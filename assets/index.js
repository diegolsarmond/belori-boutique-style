var hN = (n) => {
  throw TypeError(n);
};
var lC = (n, e, r) => e.has(n) || hN("Cannot " + r);
var W = (n, e, r) => (lC(n, e, "read from private field"), r ? r.call(n) : e.get(n)), _t = (n, e, r) => e.has(n) ? hN("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(n) : e.set(n, r), Ye = (n, e, r, o) => (lC(n, e, "write to private field"), o ? o.call(n, r) : e.set(n, r), r), qt = (n, e, r) => (lC(n, e, "access private method"), r);
var pw = (n, e, r, o) => ({
  set _(u) {
    Ye(n, e, u, r);
  },
  get _() {
    return W(n, e, o);
  }
});
function DA(n, e) {
  for (var r = 0; r < e.length; r++) {
    const o = e[r];
    if (typeof o != "string" && !Array.isArray(o)) {
      for (const u in o)
        if (u !== "default" && !(u in n)) {
          const c = Object.getOwnPropertyDescriptor(o, u);
          c && Object.defineProperty(n, u, c.get ? c : {
            enumerable: !0,
            get: () => o[u]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }));
}
function PA(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
function Iz(n) {
  if (n.__esModule) return n;
  var e = n.default;
  if (typeof e == "function") {
    var r = function o() {
      return this instanceof o ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    r.prototype = e.prototype;
  } else r = {};
  return Object.defineProperty(r, "__esModule", { value: !0 }), Object.keys(n).forEach(function (o) {
    var u = Object.getOwnPropertyDescriptor(n, o);
    Object.defineProperty(r, o, u.get ? u : {
      enumerable: !0,
      get: function () {
        return n[o];
      }
    });
  }), r;
}
var FC = { exports: {} }, Lg = {}, mw = { exports: {} }, Xt = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var pN;
function Uz() {
  if (pN) return Xt;
  pN = 1;
  var n = Symbol.for("react.element"), e = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), u = Symbol.for("react.profiler"), c = Symbol.for("react.provider"), f = Symbol.for("react.context"), m = Symbol.for("react.forward_ref"), y = Symbol.for("react.suspense"), b = Symbol.for("react.memo"), _ = Symbol.for("react.lazy"), T = Symbol.iterator;
  function k(Y) {
    return Y === null || typeof Y != "object" ? null : (Y = T && Y[T] || Y["@@iterator"], typeof Y == "function" ? Y : null);
  }
  var C = {
    isMounted: function () {
      return !1;
    }, enqueueForceUpdate: function () {
    }, enqueueReplaceState: function () {
    }, enqueueSetState: function () {
    }
  }, M = Object.assign, N = {};
  function A(Y, ae, Pe) {
    this.props = Y, this.context = ae, this.refs = N, this.updater = Pe || C;
  }
  A.prototype.isReactComponent = {}, A.prototype.setState = function (Y, ae) {
    if (typeof Y != "object" && typeof Y != "function" && Y != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, Y, ae, "setState");
  }, A.prototype.forceUpdate = function (Y) {
    this.updater.enqueueForceUpdate(this, Y, "forceUpdate");
  };
  function $() {
  }
  $.prototype = A.prototype;
  function I(Y, ae, Pe) {
    this.props = Y, this.context = ae, this.refs = N, this.updater = Pe || C;
  }
  var U = I.prototype = new $();
  U.constructor = I, M(U, A.prototype), U.isPureReactComponent = !0;
  var B = Array.isArray, K = Object.prototype.hasOwnProperty, te = { current: null }, re = { key: !0, ref: !0, __self: !0, __source: !0 };
  function ve(Y, ae, Pe) {
    var Ue, ut = {}, xt = null, et = null;
    if (ae != null) for (Ue in ae.ref !== void 0 && (et = ae.ref), ae.key !== void 0 && (xt = "" + ae.key), ae) K.call(ae, Ue) && !re.hasOwnProperty(Ue) && (ut[Ue] = ae[Ue]);
    var kt = arguments.length - 2;
    if (kt === 1) ut.children = Pe;
    else if (1 < kt) {
      for (var Et = Array(kt), an = 0; an < kt; an++) Et[an] = arguments[an + 2];
      ut.children = Et;
    }
    if (Y && Y.defaultProps) for (Ue in kt = Y.defaultProps, kt) ut[Ue] === void 0 && (ut[Ue] = kt[Ue]);
    return { $$typeof: n, type: Y, key: xt, ref: et, props: ut, _owner: te.current };
  }
  function Ce(Y, ae) {
    return { $$typeof: n, type: Y.type, key: ae, ref: Y.ref, props: Y.props, _owner: Y._owner };
  }
  function ke(Y) {
    return typeof Y == "object" && Y !== null && Y.$$typeof === n;
  }
  function Ie(Y) {
    var ae = { "=": "=0", ":": "=2" };
    return "$" + Y.replace(/[=:]/g, function (Pe) {
      return ae[Pe];
    });
  }
  var Ne = /\/+/g;
  function Re(Y, ae) {
    return typeof Y == "object" && Y !== null && Y.key != null ? Ie("" + Y.key) : ae.toString(36);
  }
  function me(Y, ae, Pe, Ue, ut) {
    var xt = typeof Y;
    (xt === "undefined" || xt === "boolean") && (Y = null);
    var et = !1;
    if (Y === null) et = !0;
    else switch (xt) {
      case "string":
      case "number":
        et = !0;
        break;
      case "object":
        switch (Y.$$typeof) {
          case n:
          case e:
            et = !0;
        }
    }
    if (et) return et = Y, ut = ut(et), Y = Ue === "" ? "." + Re(et, 0) : Ue, B(ut) ? (Pe = "", Y != null && (Pe = Y.replace(Ne, "$&/") + "/"), me(ut, ae, Pe, "", function (an) {
      return an;
    })) : ut != null && (ke(ut) && (ut = Ce(ut, Pe + (!ut.key || et && et.key === ut.key ? "" : ("" + ut.key).replace(Ne, "$&/") + "/") + Y)), ae.push(ut)), 1;
    if (et = 0, Ue = Ue === "" ? "." : Ue + ":", B(Y)) for (var kt = 0; kt < Y.length; kt++) {
      xt = Y[kt];
      var Et = Ue + Re(xt, kt);
      et += me(xt, ae, Pe, Et, ut);
    }
    else if (Et = k(Y), typeof Et == "function") for (Y = Et.call(Y), kt = 0; !(xt = Y.next()).done;) xt = xt.value, Et = Ue + Re(xt, kt++), et += me(xt, ae, Pe, Et, ut);
    else if (xt === "object") throw ae = String(Y), Error("Objects are not valid as a React child (found: " + (ae === "[object Object]" ? "object with keys {" + Object.keys(Y).join(", ") + "}" : ae) + "). If you meant to render a collection of children, use an array instead.");
    return et;
  }
  function Ge(Y, ae, Pe) {
    if (Y == null) return Y;
    var Ue = [], ut = 0;
    return me(Y, Ue, "", "", function (xt) {
      return ae.call(Pe, xt, ut++);
    }), Ue;
  }
  function Me(Y) {
    if (Y._status === -1) {
      var ae = Y._result;
      ae = ae(), ae.then(function (Pe) {
        (Y._status === 0 || Y._status === -1) && (Y._status = 1, Y._result = Pe);
      }, function (Pe) {
        (Y._status === 0 || Y._status === -1) && (Y._status = 2, Y._result = Pe);
      }), Y._status === -1 && (Y._status = 0, Y._result = ae);
    }
    if (Y._status === 1) return Y._result.default;
    throw Y._result;
  }
  var we = { current: null }, ue = { transition: null }, he = { ReactCurrentDispatcher: we, ReactCurrentBatchConfig: ue, ReactCurrentOwner: te };
  function ge() {
    throw Error("act(...) is not supported in production builds of React.");
  }
  return Xt.Children = {
    map: Ge, forEach: function (Y, ae, Pe) {
      Ge(Y, function () {
        ae.apply(this, arguments);
      }, Pe);
    }, count: function (Y) {
      var ae = 0;
      return Ge(Y, function () {
        ae++;
      }), ae;
    }, toArray: function (Y) {
      return Ge(Y, function (ae) {
        return ae;
      }) || [];
    }, only: function (Y) {
      if (!ke(Y)) throw Error("React.Children.only expected to receive a single React element child.");
      return Y;
    }
  }, Xt.Component = A, Xt.Fragment = r, Xt.Profiler = u, Xt.PureComponent = I, Xt.StrictMode = o, Xt.Suspense = y, Xt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = he, Xt.act = ge, Xt.cloneElement = function (Y, ae, Pe) {
    if (Y == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + Y + ".");
    var Ue = M({}, Y.props), ut = Y.key, xt = Y.ref, et = Y._owner;
    if (ae != null) {
      if (ae.ref !== void 0 && (xt = ae.ref, et = te.current), ae.key !== void 0 && (ut = "" + ae.key), Y.type && Y.type.defaultProps) var kt = Y.type.defaultProps;
      for (Et in ae) K.call(ae, Et) && !re.hasOwnProperty(Et) && (Ue[Et] = ae[Et] === void 0 && kt !== void 0 ? kt[Et] : ae[Et]);
    }
    var Et = arguments.length - 2;
    if (Et === 1) Ue.children = Pe;
    else if (1 < Et) {
      kt = Array(Et);
      for (var an = 0; an < Et; an++) kt[an] = arguments[an + 2];
      Ue.children = kt;
    }
    return { $$typeof: n, type: Y.type, key: ut, ref: xt, props: Ue, _owner: et };
  }, Xt.createContext = function (Y) {
    return Y = { $$typeof: f, _currentValue: Y, _currentValue2: Y, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, Y.Provider = { $$typeof: c, _context: Y }, Y.Consumer = Y;
  }, Xt.createElement = ve, Xt.createFactory = function (Y) {
    var ae = ve.bind(null, Y);
    return ae.type = Y, ae;
  }, Xt.createRef = function () {
    return { current: null };
  }, Xt.forwardRef = function (Y) {
    return { $$typeof: m, render: Y };
  }, Xt.isValidElement = ke, Xt.lazy = function (Y) {
    return { $$typeof: _, _payload: { _status: -1, _result: Y }, _init: Me };
  }, Xt.memo = function (Y, ae) {
    return { $$typeof: b, type: Y, compare: ae === void 0 ? null : ae };
  }, Xt.startTransition = function (Y) {
    var ae = ue.transition;
    ue.transition = {};
    try {
      Y();
    } finally {
      ue.transition = ae;
    }
  }, Xt.unstable_act = ge, Xt.useCallback = function (Y, ae) {
    return we.current.useCallback(Y, ae);
  }, Xt.useContext = function (Y) {
    return we.current.useContext(Y);
  }, Xt.useDebugValue = function () {
  }, Xt.useDeferredValue = function (Y) {
    return we.current.useDeferredValue(Y);
  }, Xt.useEffect = function (Y, ae) {
    return we.current.useEffect(Y, ae);
  }, Xt.useId = function () {
    return we.current.useId();
  }, Xt.useImperativeHandle = function (Y, ae, Pe) {
    return we.current.useImperativeHandle(Y, ae, Pe);
  }, Xt.useInsertionEffect = function (Y, ae) {
    return we.current.useInsertionEffect(Y, ae);
  }, Xt.useLayoutEffect = function (Y, ae) {
    return we.current.useLayoutEffect(Y, ae);
  }, Xt.useMemo = function (Y, ae) {
    return we.current.useMemo(Y, ae);
  }, Xt.useReducer = function (Y, ae, Pe) {
    return we.current.useReducer(Y, ae, Pe);
  }, Xt.useRef = function (Y) {
    return we.current.useRef(Y);
  }, Xt.useState = function (Y) {
    return we.current.useState(Y);
  }, Xt.useSyncExternalStore = function (Y, ae, Pe) {
    return we.current.useSyncExternalStore(Y, ae, Pe);
  }, Xt.useTransition = function () {
    return we.current.useTransition();
  }, Xt.version = "18.3.1", Xt;
}
var $g = { exports: {} };
/**
 * @license React
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
$g.exports;
var mN;
function Fz() {
  return mN || (mN = 1, function (n, e) {
    process.env.NODE_ENV !== "production" && function () {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var r = "18.3.1", o = Symbol.for("react.element"), u = Symbol.for("react.portal"), c = Symbol.for("react.fragment"), f = Symbol.for("react.strict_mode"), m = Symbol.for("react.profiler"), y = Symbol.for("react.provider"), b = Symbol.for("react.context"), _ = Symbol.for("react.forward_ref"), T = Symbol.for("react.suspense"), k = Symbol.for("react.suspense_list"), C = Symbol.for("react.memo"), M = Symbol.for("react.lazy"), N = Symbol.for("react.offscreen"), A = Symbol.iterator, $ = "@@iterator";
      function I(j) {
        if (j === null || typeof j != "object")
          return null;
        var V = A && j[A] || j[$];
        return typeof V == "function" ? V : null;
      }
      var U = {
        /**
         * @internal
         * @type {ReactComponent}
         */
        current: null
      }, B = {
        transition: null
      }, K = {
        current: null,
        // Used to reproduce behavior of `batchedUpdates` in legacy mode.
        isBatchingLegacy: !1,
        didScheduleLegacyUpdate: !1
      }, te = {
        /**
         * @internal
         * @type {ReactComponent}
         */
        current: null
      }, re = {}, ve = null;
      function Ce(j) {
        ve = j;
      }
      re.setExtraStackFrame = function (j) {
        ve = j;
      }, re.getCurrentStack = null, re.getStackAddendum = function () {
        var j = "";
        ve && (j += ve);
        var V = re.getCurrentStack;
        return V && (j += V() || ""), j;
      };
      var ke = !1, Ie = !1, Ne = !1, Re = !1, me = !1, Ge = {
        ReactCurrentDispatcher: U,
        ReactCurrentBatchConfig: B,
        ReactCurrentOwner: te
      };
      Ge.ReactDebugCurrentFrame = re, Ge.ReactCurrentActQueue = K;
      function Me(j) {
        {
          for (var V = arguments.length, oe = new Array(V > 1 ? V - 1 : 0), ce = 1; ce < V; ce++)
            oe[ce - 1] = arguments[ce];
          ue("warn", j, oe);
        }
      }
      function we(j) {
        {
          for (var V = arguments.length, oe = new Array(V > 1 ? V - 1 : 0), ce = 1; ce < V; ce++)
            oe[ce - 1] = arguments[ce];
          ue("error", j, oe);
        }
      }
      function ue(j, V, oe) {
        {
          var ce = Ge.ReactDebugCurrentFrame, Oe = ce.getStackAddendum();
          Oe !== "" && (V += "%s", oe = oe.concat([Oe]));
          var bt = oe.map(function (ze) {
            return String(ze);
          });
          bt.unshift("Warning: " + V), Function.prototype.apply.call(console[j], console, bt);
        }
      }
      var he = {};
      function ge(j, V) {
        {
          var oe = j.constructor, ce = oe && (oe.displayName || oe.name) || "ReactClass", Oe = ce + "." + V;
          if (he[Oe])
            return;
          we("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", V, ce), he[Oe] = !0;
        }
      }
      var Y = {
        /**
         * Checks whether or not this composite component is mounted.
         * @param {ReactClass} publicInstance The instance we want to test.
         * @return {boolean} True if mounted, false otherwise.
         * @protected
         * @final
         */
        isMounted: function (j) {
          return !1;
        },
        /**
         * Forces an update. This should only be invoked when it is known with
         * certainty that we are **not** in a DOM transaction.
         *
         * You may want to call this when you know that some deeper aspect of the
         * component's state has changed but `setState` was not called.
         *
         * This will not invoke `shouldComponentUpdate`, but it will invoke
         * `componentWillUpdate` and `componentDidUpdate`.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {?function} callback Called after component is updated.
         * @param {?string} callerName name of the calling function in the public API.
         * @internal
         */
        enqueueForceUpdate: function (j, V, oe) {
          ge(j, "forceUpdate");
        },
        /**
         * Replaces all of the state. Always use this or `setState` to mutate state.
         * You should treat `this.state` as immutable.
         *
         * There is no guarantee that `this.state` will be immediately updated, so
         * accessing `this.state` after calling this method may return the old value.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {object} completeState Next state.
         * @param {?function} callback Called after component is updated.
         * @param {?string} callerName name of the calling function in the public API.
         * @internal
         */
        enqueueReplaceState: function (j, V, oe, ce) {
          ge(j, "replaceState");
        },
        /**
         * Sets a subset of the state. This only exists because _pendingState is
         * internal. This provides a merging strategy that is not available to deep
         * properties which is confusing. TODO: Expose pendingState or don't use it
         * during the merge.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {object} partialState Next partial state to be merged with state.
         * @param {?function} callback Called after component is updated.
         * @param {?string} Name of the calling function in the public API.
         * @internal
         */
        enqueueSetState: function (j, V, oe, ce) {
          ge(j, "setState");
        }
      }, ae = Object.assign, Pe = {};
      Object.freeze(Pe);
      function Ue(j, V, oe) {
        this.props = j, this.context = V, this.refs = Pe, this.updater = oe || Y;
      }
      Ue.prototype.isReactComponent = {}, Ue.prototype.setState = function (j, V) {
        if (typeof j != "object" && typeof j != "function" && j != null)
          throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, j, V, "setState");
      }, Ue.prototype.forceUpdate = function (j) {
        this.updater.enqueueForceUpdate(this, j, "forceUpdate");
      };
      {
        var ut = {
          isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
          replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
        }, xt = function (j, V) {
          Object.defineProperty(Ue.prototype, j, {
            get: function () {
              Me("%s(...) is deprecated in plain JavaScript React classes. %s", V[0], V[1]);
            }
          });
        };
        for (var et in ut)
          ut.hasOwnProperty(et) && xt(et, ut[et]);
      }
      function kt() {
      }
      kt.prototype = Ue.prototype;
      function Et(j, V, oe) {
        this.props = j, this.context = V, this.refs = Pe, this.updater = oe || Y;
      }
      var an = Et.prototype = new kt();
      an.constructor = Et, ae(an, Ue.prototype), an.isPureReactComponent = !0;
      function zn() {
        var j = {
          current: null
        };
        return Object.seal(j), j;
      }
      var yr = Array.isArray;
      function cn(j) {
        return yr(j);
      }
      function ar(j) {
        {
          var V = typeof Symbol == "function" && Symbol.toStringTag, oe = V && j[Symbol.toStringTag] || j.constructor.name || "Object";
          return oe;
        }
      }
      function ir(j) {
        try {
          return Bn(j), !1;
        } catch {
          return !0;
        }
      }
      function Bn(j) {
        return "" + j;
      }
      function Vn(j) {
        if (ir(j))
          return we("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", ar(j)), Bn(j);
      }
      function Rr(j, V, oe) {
        var ce = j.displayName;
        if (ce)
          return ce;
        var Oe = V.displayName || V.name || "";
        return Oe !== "" ? oe + "(" + Oe + ")" : oe;
      }
      function br(j) {
        return j.displayName || "Context";
      }
      function wr(j) {
        if (j == null)
          return null;
        if (typeof j.tag == "number" && we("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof j == "function")
          return j.displayName || j.name || null;
        if (typeof j == "string")
          return j;
        switch (j) {
          case c:
            return "Fragment";
          case u:
            return "Portal";
          case m:
            return "Profiler";
          case f:
            return "StrictMode";
          case T:
            return "Suspense";
          case k:
            return "SuspenseList";
        }
        if (typeof j == "object")
          switch (j.$$typeof) {
            case b:
              var V = j;
              return br(V) + ".Consumer";
            case y:
              var oe = j;
              return br(oe._context) + ".Provider";
            case _:
              return Rr(j, j.render, "ForwardRef");
            case C:
              var ce = j.displayName || null;
              return ce !== null ? ce : wr(j.type) || "Memo";
            case M: {
              var Oe = j, bt = Oe._payload, ze = Oe._init;
              try {
                return wr(ze(bt));
              } catch {
                return null;
              }
            }
          }
        return null;
      }
      var dr = Object.prototype.hasOwnProperty, aa = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
      }, Xn, Oa, Ur;
      Ur = {};
      function An(j) {
        if (dr.call(j, "ref")) {
          var V = Object.getOwnPropertyDescriptor(j, "ref").get;
          if (V && V.isReactWarning)
            return !1;
        }
        return j.ref !== void 0;
      }
      function Sn(j) {
        if (dr.call(j, "key")) {
          var V = Object.getOwnPropertyDescriptor(j, "key").get;
          if (V && V.isReactWarning)
            return !1;
        }
        return j.key !== void 0;
      }
      function ia(j, V) {
        var oe = function () {
          Xn || (Xn = !0, we("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", V));
        };
        oe.isReactWarning = !0, Object.defineProperty(j, "key", {
          get: oe,
          configurable: !0
        });
      }
      function ji(j, V) {
        var oe = function () {
          Oa || (Oa = !0, we("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", V));
        };
        oe.isReactWarning = !0, Object.defineProperty(j, "ref", {
          get: oe,
          configurable: !0
        });
      }
      function Wr(j) {
        if (typeof j.ref == "string" && te.current && j.__self && te.current.stateNode !== j.__self) {
          var V = wr(te.current.type);
          Ur[V] || (we('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', V, j.ref), Ur[V] = !0);
        }
      }
      var Le = function (j, V, oe, ce, Oe, bt, ze) {
        var vt = {
          // This tag allows us to uniquely identify this as a React Element
          $$typeof: o,
          // Built-in properties that belong on the element
          type: j,
          key: V,
          ref: oe,
          props: ze,
          // Record the component responsible for creating this element.
          _owner: bt
        };
        return vt._store = {}, Object.defineProperty(vt._store, "validated", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: !1
        }), Object.defineProperty(vt, "_self", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: ce
        }), Object.defineProperty(vt, "_source", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: Oe
        }), Object.freeze && (Object.freeze(vt.props), Object.freeze(vt)), vt;
      };
      function nt(j, V, oe) {
        var ce, Oe = {}, bt = null, ze = null, vt = null, zt = null;
        if (V != null) {
          An(V) && (ze = V.ref, Wr(V)), Sn(V) && (Vn(V.key), bt = "" + V.key), vt = V.__self === void 0 ? null : V.__self, zt = V.__source === void 0 ? null : V.__source;
          for (ce in V)
            dr.call(V, ce) && !aa.hasOwnProperty(ce) && (Oe[ce] = V[ce]);
        }
        var sn = arguments.length - 2;
        if (sn === 1)
          Oe.children = oe;
        else if (sn > 1) {
          for (var Pn = Array(sn), Rn = 0; Rn < sn; Rn++)
            Pn[Rn] = arguments[Rn + 2];
          Object.freeze && Object.freeze(Pn), Oe.children = Pn;
        }
        if (j && j.defaultProps) {
          var Mn = j.defaultProps;
          for (ce in Mn)
            Oe[ce] === void 0 && (Oe[ce] = Mn[ce]);
        }
        if (bt || ze) {
          var Fn = typeof j == "function" ? j.displayName || j.name || "Unknown" : j;
          bt && ia(Oe, Fn), ze && ji(Oe, Fn);
        }
        return Le(j, bt, ze, vt, zt, te.current, Oe);
      }
      function At(j, V) {
        var oe = Le(j.type, V, j.ref, j._self, j._source, j._owner, j.props);
        return oe;
      }
      function Ht(j, V, oe) {
        if (j == null)
          throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + j + ".");
        var ce, Oe = ae({}, j.props), bt = j.key, ze = j.ref, vt = j._self, zt = j._source, sn = j._owner;
        if (V != null) {
          An(V) && (ze = V.ref, sn = te.current), Sn(V) && (Vn(V.key), bt = "" + V.key);
          var Pn;
          j.type && j.type.defaultProps && (Pn = j.type.defaultProps);
          for (ce in V)
            dr.call(V, ce) && !aa.hasOwnProperty(ce) && (V[ce] === void 0 && Pn !== void 0 ? Oe[ce] = Pn[ce] : Oe[ce] = V[ce]);
        }
        var Rn = arguments.length - 2;
        if (Rn === 1)
          Oe.children = oe;
        else if (Rn > 1) {
          for (var Mn = Array(Rn), Fn = 0; Fn < Rn; Fn++)
            Mn[Fn] = arguments[Fn + 2];
          Oe.children = Mn;
        }
        return Le(j.type, bt, ze, vt, zt, sn, Oe);
      }
      function ln(j) {
        return typeof j == "object" && j !== null && j.$$typeof === o;
      }
      var kn = ".", Hn = ":";
      function qr(j) {
        var V = /[=:]/g, oe = {
          "=": "=0",
          ":": "=2"
        }, ce = j.replace(V, function (Oe) {
          return oe[Oe];
        });
        return "$" + ce;
      }
      var dn = !1, Yr = /\/+/g;
      function fn(j) {
        return j.replace(Yr, "$&/");
      }
      function on(j, V) {
        return typeof j == "object" && j !== null && j.key != null ? (Vn(j.key), qr("" + j.key)) : V.toString(36);
      }
      function kr(j, V, oe, ce, Oe) {
        var bt = typeof j;
        (bt === "undefined" || bt === "boolean") && (j = null);
        var ze = !1;
        if (j === null)
          ze = !0;
        else
          switch (bt) {
            case "string":
            case "number":
              ze = !0;
              break;
            case "object":
              switch (j.$$typeof) {
                case o:
                case u:
                  ze = !0;
              }
          }
        if (ze) {
          var vt = j, zt = Oe(vt), sn = ce === "" ? kn + on(vt, 0) : ce;
          if (cn(zt)) {
            var Pn = "";
            sn != null && (Pn = fn(sn) + "/"), kr(zt, V, Pn, "", function (Mm) {
              return Mm;
            });
          } else zt != null && (ln(zt) && (zt.key && (!vt || vt.key !== zt.key) && Vn(zt.key), zt = At(
            zt,
            // Keep both the (mapped) and old keys if they differ, just as
            // traverseAllChildren used to do for objects as children
            oe + // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
            (zt.key && (!vt || vt.key !== zt.key) ? (
              // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
              // eslint-disable-next-line react-internal/safe-string-coercion
              fn("" + zt.key) + "/"
            ) : "") + sn
          )), V.push(zt));
          return 1;
        }
        var Rn, Mn, Fn = 0, Zt = ce === "" ? kn : ce + Hn;
        if (cn(j))
          for (var Zo = 0; Zo < j.length; Zo++)
            Rn = j[Zo], Mn = Zt + on(Rn, Zo), Fn += kr(Rn, V, oe, Mn, Oe);
        else {
          var Fu = I(j);
          if (typeof Fu == "function") {
            var wd = j;
            Fu === wd.entries && (dn || Me("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), dn = !0);
            for (var Pm = Fu.call(wd), so, xd = 0; !(so = Pm.next()).done;)
              Rn = so.value, Mn = Zt + on(Rn, xd++), Fn += kr(Rn, V, oe, Mn, Oe);
          } else if (bt === "object") {
            var Sd = String(j);
            throw new Error("Objects are not valid as a React child (found: " + (Sd === "[object Object]" ? "object with keys {" + Object.keys(j).join(", ") + "}" : Sd) + "). If you meant to render a collection of children, use an array instead.");
          }
        }
        return Fn;
      }
      function Wa(j, V, oe) {
        if (j == null)
          return j;
        var ce = [], Oe = 0;
        return kr(j, ce, "", "", function (bt) {
          return V.call(oe, bt, Oe++);
        }), ce;
      }
      function gt(j) {
        var V = 0;
        return Wa(j, function () {
          V++;
        }), V;
      }
      function Gt(j, V, oe) {
        Wa(j, function () {
          V.apply(this, arguments);
        }, oe);
      }
      function yn(j) {
        return Wa(j, function (V) {
          return V;
        }) || [];
      }
      function xr(j) {
        if (!ln(j))
          throw new Error("React.Children.only expected to receive a single React element child.");
        return j;
      }
      function Or(j) {
        var V = {
          $$typeof: b,
          // As a workaround to support multiple concurrent renderers, we categorize
          // some renderers as primary and others as secondary. We only expect
          // there to be two concurrent renderers at most: React Native (primary) and
          // Fabric (secondary); React DOM (primary) and React ART (secondary).
          // Secondary renderers store their context values on separate fields.
          _currentValue: j,
          _currentValue2: j,
          // Used to track how many concurrent renderers this context currently
          // supports within in a single renderer. Such as parallel server rendering.
          _threadCount: 0,
          // These are circular
          Provider: null,
          Consumer: null,
          // Add these to use same hidden class in VM as ServerContext
          _defaultValue: null,
          _globalName: null
        };
        V.Provider = {
          $$typeof: y,
          _context: V
        };
        var oe = !1, ce = !1, Oe = !1;
        {
          var bt = {
            $$typeof: b,
            _context: V
          };
          Object.defineProperties(bt, {
            Provider: {
              get: function () {
                return ce || (ce = !0, we("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?")), V.Provider;
              },
              set: function (ze) {
                V.Provider = ze;
              }
            },
            _currentValue: {
              get: function () {
                return V._currentValue;
              },
              set: function (ze) {
                V._currentValue = ze;
              }
            },
            _currentValue2: {
              get: function () {
                return V._currentValue2;
              },
              set: function (ze) {
                V._currentValue2 = ze;
              }
            },
            _threadCount: {
              get: function () {
                return V._threadCount;
              },
              set: function (ze) {
                V._threadCount = ze;
              }
            },
            Consumer: {
              get: function () {
                return oe || (oe = !0, we("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?")), V.Consumer;
              }
            },
            displayName: {
              get: function () {
                return V.displayName;
              },
              set: function (ze) {
                Oe || (Me("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", ze), Oe = !0);
              }
            }
          }), V.Consumer = bt;
        }
        return V._currentRenderer = null, V._currentRenderer2 = null, V;
      }
      var fr = -1, Kr = 0, Wn = 1, Nr = 2;
      function Na(j) {
        if (j._status === fr) {
          var V = j._result, oe = V();
          if (oe.then(function (bt) {
            if (j._status === Kr || j._status === fr) {
              var ze = j;
              ze._status = Wn, ze._result = bt;
            }
          }, function (bt) {
            if (j._status === Kr || j._status === fr) {
              var ze = j;
              ze._status = Nr, ze._result = bt;
            }
          }), j._status === fr) {
            var ce = j;
            ce._status = Kr, ce._result = oe;
          }
        }
        if (j._status === Wn) {
          var Oe = j._result;
          return Oe === void 0 && we(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))

Did you accidentally put curly braces around the import?`, Oe), "default" in Oe || we(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))`, Oe), Oe.default;
        } else
          throw j._result;
      }
      function mi(j) {
        var V = {
          // We use these fields to store the result.
          _status: fr,
          _result: j
        }, oe = {
          $$typeof: M,
          _payload: V,
          _init: Na
        };
        {
          var ce, Oe;
          Object.defineProperties(oe, {
            defaultProps: {
              configurable: !0,
              get: function () {
                return ce;
              },
              set: function (bt) {
                we("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), ce = bt, Object.defineProperty(oe, "defaultProps", {
                  enumerable: !0
                });
              }
            },
            propTypes: {
              configurable: !0,
              get: function () {
                return Oe;
              },
              set: function (bt) {
                we("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), Oe = bt, Object.defineProperty(oe, "propTypes", {
                  enumerable: !0
                });
              }
            }
          });
        }
        return oe;
      }
      function _o(j) {
        j != null && j.$$typeof === C ? we("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).") : typeof j != "function" ? we("forwardRef requires a render function but was given %s.", j === null ? "null" : typeof j) : j.length !== 0 && j.length !== 2 && we("forwardRef render functions accept exactly two parameters: props and ref. %s", j.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."), j != null && (j.defaultProps != null || j.propTypes != null) && we("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
        var V = {
          $$typeof: _,
          render: j
        };
        {
          var oe;
          Object.defineProperty(V, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function () {
              return oe;
            },
            set: function (ce) {
              oe = ce, !j.name && !j.displayName && (j.displayName = ce);
            }
          });
        }
        return V;
      }
      var Eo;
      Eo = Symbol.for("react.module.reference");
      function H(j) {
        return !!(typeof j == "string" || typeof j == "function" || j === c || j === m || me || j === f || j === T || j === k || Re || j === N || ke || Ie || Ne || typeof j == "object" && j !== null && (j.$$typeof === M || j.$$typeof === C || j.$$typeof === y || j.$$typeof === b || j.$$typeof === _ || // This needs to include all possible module reference object
          // types supported by any Flight configuration anywhere since
          // we don't know which Flight build this will end up being used
          // with.
          j.$$typeof === Eo || j.getModuleId !== void 0));
      }
      function xe(j, V) {
        H(j) || we("memo: The first argument must be a component. Instead received: %s", j === null ? "null" : typeof j);
        var oe = {
          $$typeof: C,
          type: j,
          compare: V === void 0 ? null : V
        };
        {
          var ce;
          Object.defineProperty(oe, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function () {
              return ce;
            },
            set: function (Oe) {
              ce = Oe, !j.name && !j.displayName && (j.displayName = Oe);
            }
          });
        }
        return oe;
      }
      function Te() {
        var j = U.current;
        return j === null && we(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`), j;
      }
      function ot(j) {
        var V = Te();
        if (j._context !== void 0) {
          var oe = j._context;
          oe.Consumer === j ? we("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?") : oe.Provider === j && we("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
        }
        return V.useContext(j);
      }
      function Wt(j) {
        var V = Te();
        return V.useState(j);
      }
      function Qt(j, V, oe) {
        var ce = Te();
        return ce.useReducer(j, V, oe);
      }
      function yt(j) {
        var V = Te();
        return V.useRef(j);
      }
      function Ut(j, V) {
        var oe = Te();
        return oe.useEffect(j, V);
      }
      function jr(j, V) {
        var oe = Te();
        return oe.useInsertionEffect(j, V);
      }
      function Dn(j, V) {
        var oe = Te();
        return oe.useLayoutEffect(j, V);
      }
      function qn(j, V) {
        var oe = Te();
        return oe.useCallback(j, V);
      }
      function wa(j, V) {
        var oe = Te();
        return oe.useMemo(j, V);
      }
      function Co(j, V, oe) {
        var ce = Te();
        return ce.useImperativeHandle(j, V, oe);
      }
      function hn(j, V) {
        {
          var oe = Te();
          return oe.useDebugValue(j, V);
        }
      }
      function Gr() {
        var j = Te();
        return j.useTransition();
      }
      function ja(j) {
        var V = Te();
        return V.useDeferredValue(j);
      }
      function Ft() {
        var j = Te();
        return j.useId();
      }
      function Ai(j, V, oe) {
        var ce = Te();
        return ce.useSyncExternalStore(j, V, oe);
      }
      var $s = 0, Ou, zs, qa, vd, Aa, gd, yd;
      function Gf() {
      }
      Gf.__reactDisabledLog = !0;
      function Nu() {
        {
          if ($s === 0) {
            Ou = console.log, zs = console.info, qa = console.warn, vd = console.error, Aa = console.group, gd = console.groupCollapsed, yd = console.groupEnd;
            var j = {
              configurable: !0,
              enumerable: !0,
              value: Gf,
              writable: !0
            };
            Object.defineProperties(console, {
              info: j,
              log: j,
              warn: j,
              error: j,
              group: j,
              groupCollapsed: j,
              groupEnd: j
            });
          }
          $s++;
        }
      }
      function Bs() {
        {
          if ($s--, $s === 0) {
            var j = {
              configurable: !0,
              enumerable: !0,
              writable: !0
            };
            Object.defineProperties(console, {
              log: ae({}, j, {
                value: Ou
              }),
              info: ae({}, j, {
                value: zs
              }),
              warn: ae({}, j, {
                value: qa
              }),
              error: ae({}, j, {
                value: vd
              }),
              group: ae({}, j, {
                value: Aa
              }),
              groupCollapsed: ae({}, j, {
                value: gd
              }),
              groupEnd: ae({}, j, {
                value: yd
              })
            });
          }
          $s < 0 && we("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
        }
      }
      var io = Ge.ReactCurrentDispatcher, Da;
      function Vs(j, V, oe) {
        {
          if (Da === void 0)
            try {
              throw Error();
            } catch (Oe) {
              var ce = Oe.stack.trim().match(/\n( *(at )?)/);
              Da = ce && ce[1] || "";
            }
          return `
` + Da + j;
        }
      }
      var Hs = !1, Ws;
      {
        var ju = typeof WeakMap == "function" ? WeakMap : Map;
        Ws = new ju();
      }
      function Au(j, V) {
        if (!j || Hs)
          return "";
        {
          var oe = Ws.get(j);
          if (oe !== void 0)
            return oe;
        }
        var ce;
        Hs = !0;
        var Oe = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var bt;
        bt = io.current, io.current = null, Nu();
        try {
          if (V) {
            var ze = function () {
              throw Error();
            };
            if (Object.defineProperty(ze.prototype, "props", {
              set: function () {
                throw Error();
              }
            }), typeof Reflect == "object" && Reflect.construct) {
              try {
                Reflect.construct(ze, []);
              } catch (Zt) {
                ce = Zt;
              }
              Reflect.construct(j, [], ze);
            } else {
              try {
                ze.call();
              } catch (Zt) {
                ce = Zt;
              }
              j.call(ze.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (Zt) {
              ce = Zt;
            }
            j();
          }
        } catch (Zt) {
          if (Zt && ce && typeof Zt.stack == "string") {
            for (var vt = Zt.stack.split(`
`), zt = ce.stack.split(`
`), sn = vt.length - 1, Pn = zt.length - 1; sn >= 1 && Pn >= 0 && vt[sn] !== zt[Pn];)
              Pn--;
            for (; sn >= 1 && Pn >= 0; sn--, Pn--)
              if (vt[sn] !== zt[Pn]) {
                if (sn !== 1 || Pn !== 1)
                  do
                    if (sn--, Pn--, Pn < 0 || vt[sn] !== zt[Pn]) {
                      var Rn = `
` + vt[sn].replace(" at new ", " at ");
                      return j.displayName && Rn.includes("<anonymous>") && (Rn = Rn.replace("<anonymous>", j.displayName)), typeof j == "function" && Ws.set(j, Rn), Rn;
                    }
                  while (sn >= 1 && Pn >= 0);
                break;
              }
          }
        } finally {
          Hs = !1, io.current = bt, Bs(), Error.prepareStackTrace = Oe;
        }
        var Mn = j ? j.displayName || j.name : "", Fn = Mn ? Vs(Mn) : "";
        return typeof j == "function" && Ws.set(j, Fn), Fn;
      }
      function Go(j, V, oe) {
        return Au(j, !1);
      }
      function Dm(j) {
        var V = j.prototype;
        return !!(V && V.isReactComponent);
      }
      function To(j, V, oe) {
        if (j == null)
          return "";
        if (typeof j == "function")
          return Au(j, Dm(j));
        if (typeof j == "string")
          return Vs(j);
        switch (j) {
          case T:
            return Vs("Suspense");
          case k:
            return Vs("SuspenseList");
        }
        if (typeof j == "object")
          switch (j.$$typeof) {
            case _:
              return Go(j.render);
            case C:
              return To(j.type, V, oe);
            case M: {
              var ce = j, Oe = ce._payload, bt = ce._init;
              try {
                return To(bt(Oe), V, oe);
              } catch {
              }
            }
          }
        return "";
      }
      var pn = {}, Du = Ge.ReactDebugCurrentFrame;
      function Dl(j) {
        if (j) {
          var V = j._owner, oe = To(j.type, j._source, V ? V.type : null);
          Du.setExtraStackFrame(oe);
        } else
          Du.setExtraStackFrame(null);
      }
      function Pu(j, V, oe, ce, Oe) {
        {
          var bt = Function.call.bind(dr);
          for (var ze in j)
            if (bt(j, ze)) {
              var vt = void 0;
              try {
                if (typeof j[ze] != "function") {
                  var zt = Error((ce || "React class") + ": " + oe + " type `" + ze + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof j[ze] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw zt.name = "Invariant Violation", zt;
                }
                vt = j[ze](V, ze, ce, oe, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (sn) {
                vt = sn;
              }
              vt && !(vt instanceof Error) && (Dl(Oe), we("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ce || "React class", oe, ze, typeof vt), Dl(null)), vt instanceof Error && !(vt.message in pn) && (pn[vt.message] = !0, Dl(Oe), we("Failed %s type: %s", oe, vt.message), Dl(null));
            }
        }
      }
      function Jt(j) {
        if (j) {
          var V = j._owner, oe = To(j.type, j._source, V ? V.type : null);
          Ce(oe);
        } else
          Ce(null);
      }
      var Mu;
      Mu = !1;
      function Lu() {
        if (te.current) {
          var j = wr(te.current.type);
          if (j)
            return `

Check the render method of \`` + j + "`.";
        }
        return "";
      }
      function Ot(j) {
        if (j !== void 0) {
          var V = j.fileName.replace(/^.*[\\\/]/, ""), oe = j.lineNumber;
          return `

Check your code at ` + V + ":" + oe + ".";
        }
        return "";
      }
      function Pl(j) {
        return j != null ? Ot(j.__source) : "";
      }
      var or = {};
      function Ya(j) {
        var V = Lu();
        if (!V) {
          var oe = typeof j == "string" ? j : j.displayName || j.name;
          oe && (V = `

Check the top-level render call using <` + oe + ">.");
        }
        return V;
      }
      function Pa(j, V) {
        if (!(!j._store || j._store.validated || j.key != null)) {
          j._store.validated = !0;
          var oe = Ya(V);
          if (!or[oe]) {
            or[oe] = !0;
            var ce = "";
            j && j._owner && j._owner !== te.current && (ce = " It was passed a child from " + wr(j._owner.type) + "."), Jt(j), we('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', oe, ce), Jt(null);
          }
        }
      }
      function qs(j, V) {
        if (typeof j == "object") {
          if (cn(j))
            for (var oe = 0; oe < j.length; oe++) {
              var ce = j[oe];
              ln(ce) && Pa(ce, V);
            }
          else if (ln(j))
            j._store && (j._store.validated = !0);
          else if (j) {
            var Oe = I(j);
            if (typeof Oe == "function" && Oe !== j.entries)
              for (var bt = Oe.call(j), ze; !(ze = bt.next()).done;)
                ln(ze.value) && Pa(ze.value, V);
          }
        }
      }
      function hr(j) {
        {
          var V = j.type;
          if (V == null || typeof V == "string")
            return;
          var oe;
          if (typeof V == "function")
            oe = V.propTypes;
          else if (typeof V == "object" && (V.$$typeof === _ || // Note: Memo only checks outer props here.
            // Inner props are checked in the reconciler.
            V.$$typeof === C))
            oe = V.propTypes;
          else
            return;
          if (oe) {
            var ce = wr(V);
            Pu(oe, j.props, "prop", ce, j);
          } else if (V.PropTypes !== void 0 && !Mu) {
            Mu = !0;
            var Oe = wr(V);
            we("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Oe || "Unknown");
          }
          typeof V.getDefaultProps == "function" && !V.getDefaultProps.isReactClassApproved && we("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
        }
      }
      function _n(j) {
        {
          for (var V = Object.keys(j.props), oe = 0; oe < V.length; oe++) {
            var ce = V[oe];
            if (ce !== "children" && ce !== "key") {
              Jt(j), we("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ce), Jt(null);
              break;
            }
          }
          j.ref !== null && (Jt(j), we("Invalid attribute `ref` supplied to `React.Fragment`."), Jt(null));
        }
      }
      function Qf(j, V, oe) {
        var ce = H(j);
        if (!ce) {
          var Oe = "";
          (j === void 0 || typeof j == "object" && j !== null && Object.keys(j).length === 0) && (Oe += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var bt = Pl(V);
          bt ? Oe += bt : Oe += Lu();
          var ze;
          j === null ? ze = "null" : cn(j) ? ze = "array" : j !== void 0 && j.$$typeof === o ? (ze = "<" + (wr(j.type) || "Unknown") + " />", Oe = " Did you accidentally export a JSX literal instead of a component?") : ze = typeof j, we("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", ze, Oe);
        }
        var vt = nt.apply(this, arguments);
        if (vt == null)
          return vt;
        if (ce)
          for (var zt = 2; zt < arguments.length; zt++)
            qs(arguments[zt], j);
        return j === c ? _n(vt) : hr(vt), vt;
      }
      var Ka = !1;
      function Qr(j) {
        var V = Qf.bind(null, j);
        return V.type = j, Ka || (Ka = !0, Me("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.")), Object.defineProperty(V, "type", {
          enumerable: !1,
          get: function () {
            return Me("Factory.type is deprecated. Access the class directly before passing it to createFactory."), Object.defineProperty(this, "type", {
              value: j
            }), j;
          }
        }), V;
      }
      function Ro(j, V, oe) {
        for (var ce = Ht.apply(this, arguments), Oe = 2; Oe < arguments.length; Oe++)
          qs(arguments[Oe], ce.type);
        return hr(ce), ce;
      }
      function Jf(j, V) {
        var oe = B.transition;
        B.transition = {};
        var ce = B.transition;
        B.transition._updatedFibers = /* @__PURE__ */ new Set();
        try {
          j();
        } finally {
          if (B.transition = oe, oe === null && ce._updatedFibers) {
            var Oe = ce._updatedFibers.size;
            Oe > 10 && Me("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), ce._updatedFibers.clear();
          }
        }
      }
      var Qo = !1, Ys = null;
      function Zf(j) {
        if (Ys === null)
          try {
            var V = ("require" + Math.random()).slice(0, 7), oe = n && n[V];
            Ys = oe.call(n, "timers").setImmediate;
          } catch {
            Ys = function (Oe) {
              Qo === !1 && (Qo = !0, typeof MessageChannel > "u" && we("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."));
              var bt = new MessageChannel();
              bt.port1.onmessage = Oe, bt.port2.postMessage(void 0);
            };
          }
        return Ys(j);
      }
      var Di = 0, Ks = !1;
      function Jo(j) {
        {
          var V = Di;
          Di++, K.current === null && (K.current = []);
          var oe = K.isBatchingLegacy, ce;
          try {
            if (K.isBatchingLegacy = !0, ce = j(), !oe && K.didScheduleLegacyUpdate) {
              var Oe = K.current;
              Oe !== null && (K.didScheduleLegacyUpdate = !1, Qs(Oe));
            }
          } catch (Mn) {
            throw Pi(V), Mn;
          } finally {
            K.isBatchingLegacy = oe;
          }
          if (ce !== null && typeof ce == "object" && typeof ce.then == "function") {
            var bt = ce, ze = !1, vt = {
              then: function (Mn, Fn) {
                ze = !0, bt.then(function (Zt) {
                  Pi(V), Di === 0 ? Iu(Zt, Mn, Fn) : Mn(Zt);
                }, function (Zt) {
                  Pi(V), Fn(Zt);
                });
              }
            };
            return !Ks && typeof Promise < "u" && Promise.resolve().then(function () {
            }).then(function () {
              ze || (Ks = !0, we("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"));
            }), vt;
          } else {
            var zt = ce;
            if (Pi(V), Di === 0) {
              var sn = K.current;
              sn !== null && (Qs(sn), K.current = null);
              var Pn = {
                then: function (Mn, Fn) {
                  K.current === null ? (K.current = [], Iu(zt, Mn, Fn)) : Mn(zt);
                }
              };
              return Pn;
            } else {
              var Rn = {
                then: function (Mn, Fn) {
                  Mn(zt);
                }
              };
              return Rn;
            }
          }
        }
      }
      function Pi(j) {
        j !== Di - 1 && we("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "), Di = j;
      }
      function Iu(j, V, oe) {
        {
          var ce = K.current;
          if (ce !== null)
            try {
              Qs(ce), Zf(function () {
                ce.length === 0 ? (K.current = null, V(j)) : Iu(j, V, oe);
              });
            } catch (Oe) {
              oe(Oe);
            }
          else
            V(j);
        }
      }
      var Gs = !1;
      function Qs(j) {
        if (!Gs) {
          Gs = !0;
          var V = 0;
          try {
            for (; V < j.length; V++) {
              var oe = j[V];
              do
                oe = oe(!0);
              while (oe !== null);
            }
            j.length = 0;
          } catch (ce) {
            throw j = j.slice(V + 1), ce;
          } finally {
            Gs = !1;
          }
        }
      }
      var Ml = Qf, Uu = Ro, bd = Qr, oo = {
        map: Wa,
        forEach: Gt,
        count: gt,
        toArray: yn,
        only: xr
      };
      e.Children = oo, e.Component = Ue, e.Fragment = c, e.Profiler = m, e.PureComponent = Et, e.StrictMode = f, e.Suspense = T, e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Ge, e.act = Jo, e.cloneElement = Uu, e.createContext = Or, e.createElement = Ml, e.createFactory = bd, e.createRef = zn, e.forwardRef = _o, e.isValidElement = ln, e.lazy = mi, e.memo = xe, e.startTransition = Jf, e.unstable_act = Jo, e.useCallback = qn, e.useContext = ot, e.useDebugValue = hn, e.useDeferredValue = ja, e.useEffect = Ut, e.useId = Ft, e.useImperativeHandle = Co, e.useInsertionEffect = jr, e.useLayoutEffect = Dn, e.useMemo = wa, e.useReducer = Qt, e.useRef = yt, e.useState = Wt, e.useSyncExternalStore = Ai, e.useTransition = Gr, e.version = r, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }($g, $g.exports)), $g.exports;
}
var vN;
function py() {
  return vN || (vN = 1, process.env.NODE_ENV === "production" ? mw.exports = Uz() : mw.exports = Fz()), mw.exports;
}
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var gN;
function $z() {
  if (gN) return Lg;
  gN = 1;
  var n = py(), e = Symbol.for("react.element"), r = Symbol.for("react.fragment"), o = Object.prototype.hasOwnProperty, u = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, c = { key: !0, ref: !0, __self: !0, __source: !0 };
  function f(m, y, b) {
    var _, T = {}, k = null, C = null;
    b !== void 0 && (k = "" + b), y.key !== void 0 && (k = "" + y.key), y.ref !== void 0 && (C = y.ref);
    for (_ in y) o.call(y, _) && !c.hasOwnProperty(_) && (T[_] = y[_]);
    if (m && m.defaultProps) for (_ in y = m.defaultProps, y) T[_] === void 0 && (T[_] = y[_]);
    return { $$typeof: e, type: m, key: k, ref: C, props: T, _owner: u.current };
  }
  return Lg.Fragment = r, Lg.jsx = f, Lg.jsxs = f, Lg;
}
var Ig = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var yN;
function zz() {
  return yN || (yN = 1, process.env.NODE_ENV !== "production" && function () {
    var n = py(), e = Symbol.for("react.element"), r = Symbol.for("react.portal"), o = Symbol.for("react.fragment"), u = Symbol.for("react.strict_mode"), c = Symbol.for("react.profiler"), f = Symbol.for("react.provider"), m = Symbol.for("react.context"), y = Symbol.for("react.forward_ref"), b = Symbol.for("react.suspense"), _ = Symbol.for("react.suspense_list"), T = Symbol.for("react.memo"), k = Symbol.for("react.lazy"), C = Symbol.for("react.offscreen"), M = Symbol.iterator, N = "@@iterator";
    function A(H) {
      if (H === null || typeof H != "object")
        return null;
      var xe = M && H[M] || H[N];
      return typeof xe == "function" ? xe : null;
    }
    var $ = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function I(H) {
      {
        for (var xe = arguments.length, Te = new Array(xe > 1 ? xe - 1 : 0), ot = 1; ot < xe; ot++)
          Te[ot - 1] = arguments[ot];
        U("error", H, Te);
      }
    }
    function U(H, xe, Te) {
      {
        var ot = $.ReactDebugCurrentFrame, Wt = ot.getStackAddendum();
        Wt !== "" && (xe += "%s", Te = Te.concat([Wt]));
        var Qt = Te.map(function (yt) {
          return String(yt);
        });
        Qt.unshift("Warning: " + xe), Function.prototype.apply.call(console[H], console, Qt);
      }
    }
    var B = !1, K = !1, te = !1, re = !1, ve = !1, Ce;
    Ce = Symbol.for("react.module.reference");
    function ke(H) {
      return !!(typeof H == "string" || typeof H == "function" || H === o || H === c || ve || H === u || H === b || H === _ || re || H === C || B || K || te || typeof H == "object" && H !== null && (H.$$typeof === k || H.$$typeof === T || H.$$typeof === f || H.$$typeof === m || H.$$typeof === y || // This needs to include all possible module reference object
        // types supported by any Flight configuration anywhere since
        // we don't know which Flight build this will end up being used
        // with.
        H.$$typeof === Ce || H.getModuleId !== void 0));
    }
    function Ie(H, xe, Te) {
      var ot = H.displayName;
      if (ot)
        return ot;
      var Wt = xe.displayName || xe.name || "";
      return Wt !== "" ? Te + "(" + Wt + ")" : Te;
    }
    function Ne(H) {
      return H.displayName || "Context";
    }
    function Re(H) {
      if (H == null)
        return null;
      if (typeof H.tag == "number" && I("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof H == "function")
        return H.displayName || H.name || null;
      if (typeof H == "string")
        return H;
      switch (H) {
        case o:
          return "Fragment";
        case r:
          return "Portal";
        case c:
          return "Profiler";
        case u:
          return "StrictMode";
        case b:
          return "Suspense";
        case _:
          return "SuspenseList";
      }
      if (typeof H == "object")
        switch (H.$$typeof) {
          case m:
            var xe = H;
            return Ne(xe) + ".Consumer";
          case f:
            var Te = H;
            return Ne(Te._context) + ".Provider";
          case y:
            return Ie(H, H.render, "ForwardRef");
          case T:
            var ot = H.displayName || null;
            return ot !== null ? ot : Re(H.type) || "Memo";
          case k: {
            var Wt = H, Qt = Wt._payload, yt = Wt._init;
            try {
              return Re(yt(Qt));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var me = Object.assign, Ge = 0, Me, we, ue, he, ge, Y, ae;
    function Pe() {
    }
    Pe.__reactDisabledLog = !0;
    function Ue() {
      {
        if (Ge === 0) {
          Me = console.log, we = console.info, ue = console.warn, he = console.error, ge = console.group, Y = console.groupCollapsed, ae = console.groupEnd;
          var H = {
            configurable: !0,
            enumerable: !0,
            value: Pe,
            writable: !0
          };
          Object.defineProperties(console, {
            info: H,
            log: H,
            warn: H,
            error: H,
            group: H,
            groupCollapsed: H,
            groupEnd: H
          });
        }
        Ge++;
      }
    }
    function ut() {
      {
        if (Ge--, Ge === 0) {
          var H = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: me({}, H, {
              value: Me
            }),
            info: me({}, H, {
              value: we
            }),
            warn: me({}, H, {
              value: ue
            }),
            error: me({}, H, {
              value: he
            }),
            group: me({}, H, {
              value: ge
            }),
            groupCollapsed: me({}, H, {
              value: Y
            }),
            groupEnd: me({}, H, {
              value: ae
            })
          });
        }
        Ge < 0 && I("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var xt = $.ReactCurrentDispatcher, et;
    function kt(H, xe, Te) {
      {
        if (et === void 0)
          try {
            throw Error();
          } catch (Wt) {
            var ot = Wt.stack.trim().match(/\n( *(at )?)/);
            et = ot && ot[1] || "";
          }
        return `
` + et + H;
      }
    }
    var Et = !1, an;
    {
      var zn = typeof WeakMap == "function" ? WeakMap : Map;
      an = new zn();
    }
    function yr(H, xe) {
      if (!H || Et)
        return "";
      {
        var Te = an.get(H);
        if (Te !== void 0)
          return Te;
      }
      var ot;
      Et = !0;
      var Wt = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var Qt;
      Qt = xt.current, xt.current = null, Ue();
      try {
        if (xe) {
          var yt = function () {
            throw Error();
          };
          if (Object.defineProperty(yt.prototype, "props", {
            set: function () {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(yt, []);
            } catch (Gr) {
              ot = Gr;
            }
            Reflect.construct(H, [], yt);
          } else {
            try {
              yt.call();
            } catch (Gr) {
              ot = Gr;
            }
            H.call(yt.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Gr) {
            ot = Gr;
          }
          H();
        }
      } catch (Gr) {
        if (Gr && ot && typeof Gr.stack == "string") {
          for (var Ut = Gr.stack.split(`
`), jr = ot.stack.split(`
`), Dn = Ut.length - 1, qn = jr.length - 1; Dn >= 1 && qn >= 0 && Ut[Dn] !== jr[qn];)
            qn--;
          for (; Dn >= 1 && qn >= 0; Dn--, qn--)
            if (Ut[Dn] !== jr[qn]) {
              if (Dn !== 1 || qn !== 1)
                do
                  if (Dn--, qn--, qn < 0 || Ut[Dn] !== jr[qn]) {
                    var wa = `
` + Ut[Dn].replace(" at new ", " at ");
                    return H.displayName && wa.includes("<anonymous>") && (wa = wa.replace("<anonymous>", H.displayName)), typeof H == "function" && an.set(H, wa), wa;
                  }
                while (Dn >= 1 && qn >= 0);
              break;
            }
        }
      } finally {
        Et = !1, xt.current = Qt, ut(), Error.prepareStackTrace = Wt;
      }
      var Co = H ? H.displayName || H.name : "", hn = Co ? kt(Co) : "";
      return typeof H == "function" && an.set(H, hn), hn;
    }
    function cn(H, xe, Te) {
      return yr(H, !1);
    }
    function ar(H) {
      var xe = H.prototype;
      return !!(xe && xe.isReactComponent);
    }
    function ir(H, xe, Te) {
      if (H == null)
        return "";
      if (typeof H == "function")
        return yr(H, ar(H));
      if (typeof H == "string")
        return kt(H);
      switch (H) {
        case b:
          return kt("Suspense");
        case _:
          return kt("SuspenseList");
      }
      if (typeof H == "object")
        switch (H.$$typeof) {
          case y:
            return cn(H.render);
          case T:
            return ir(H.type, xe, Te);
          case k: {
            var ot = H, Wt = ot._payload, Qt = ot._init;
            try {
              return ir(Qt(Wt), xe, Te);
            } catch {
            }
          }
        }
      return "";
    }
    var Bn = Object.prototype.hasOwnProperty, Vn = {}, Rr = $.ReactDebugCurrentFrame;
    function br(H) {
      if (H) {
        var xe = H._owner, Te = ir(H.type, H._source, xe ? xe.type : null);
        Rr.setExtraStackFrame(Te);
      } else
        Rr.setExtraStackFrame(null);
    }
    function wr(H, xe, Te, ot, Wt) {
      {
        var Qt = Function.call.bind(Bn);
        for (var yt in H)
          if (Qt(H, yt)) {
            var Ut = void 0;
            try {
              if (typeof H[yt] != "function") {
                var jr = Error((ot || "React class") + ": " + Te + " type `" + yt + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof H[yt] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw jr.name = "Invariant Violation", jr;
              }
              Ut = H[yt](xe, yt, ot, Te, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Dn) {
              Ut = Dn;
            }
            Ut && !(Ut instanceof Error) && (br(Wt), I("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ot || "React class", Te, yt, typeof Ut), br(null)), Ut instanceof Error && !(Ut.message in Vn) && (Vn[Ut.message] = !0, br(Wt), I("Failed %s type: %s", Te, Ut.message), br(null));
          }
      }
    }
    var dr = Array.isArray;
    function aa(H) {
      return dr(H);
    }
    function Xn(H) {
      {
        var xe = typeof Symbol == "function" && Symbol.toStringTag, Te = xe && H[Symbol.toStringTag] || H.constructor.name || "Object";
        return Te;
      }
    }
    function Oa(H) {
      try {
        return Ur(H), !1;
      } catch {
        return !0;
      }
    }
    function Ur(H) {
      return "" + H;
    }
    function An(H) {
      if (Oa(H))
        return I("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Xn(H)), Ur(H);
    }
    var Sn = $.ReactCurrentOwner, ia = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, ji, Wr, Le;
    Le = {};
    function nt(H) {
      if (Bn.call(H, "ref")) {
        var xe = Object.getOwnPropertyDescriptor(H, "ref").get;
        if (xe && xe.isReactWarning)
          return !1;
      }
      return H.ref !== void 0;
    }
    function At(H) {
      if (Bn.call(H, "key")) {
        var xe = Object.getOwnPropertyDescriptor(H, "key").get;
        if (xe && xe.isReactWarning)
          return !1;
      }
      return H.key !== void 0;
    }
    function Ht(H, xe) {
      if (typeof H.ref == "string" && Sn.current && xe && Sn.current.stateNode !== xe) {
        var Te = Re(Sn.current.type);
        Le[Te] || (I('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', Re(Sn.current.type), H.ref), Le[Te] = !0);
      }
    }
    function ln(H, xe) {
      {
        var Te = function () {
          ji || (ji = !0, I("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", xe));
        };
        Te.isReactWarning = !0, Object.defineProperty(H, "key", {
          get: Te,
          configurable: !0
        });
      }
    }
    function kn(H, xe) {
      {
        var Te = function () {
          Wr || (Wr = !0, I("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", xe));
        };
        Te.isReactWarning = !0, Object.defineProperty(H, "ref", {
          get: Te,
          configurable: !0
        });
      }
    }
    var Hn = function (H, xe, Te, ot, Wt, Qt, yt) {
      var Ut = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: e,
        // Built-in properties that belong on the element
        type: H,
        key: xe,
        ref: Te,
        props: yt,
        // Record the component responsible for creating this element.
        _owner: Qt
      };
      return Ut._store = {}, Object.defineProperty(Ut._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(Ut, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ot
      }), Object.defineProperty(Ut, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Wt
      }), Object.freeze && (Object.freeze(Ut.props), Object.freeze(Ut)), Ut;
    };
    function qr(H, xe, Te, ot, Wt) {
      {
        var Qt, yt = {}, Ut = null, jr = null;
        Te !== void 0 && (An(Te), Ut = "" + Te), At(xe) && (An(xe.key), Ut = "" + xe.key), nt(xe) && (jr = xe.ref, Ht(xe, Wt));
        for (Qt in xe)
          Bn.call(xe, Qt) && !ia.hasOwnProperty(Qt) && (yt[Qt] = xe[Qt]);
        if (H && H.defaultProps) {
          var Dn = H.defaultProps;
          for (Qt in Dn)
            yt[Qt] === void 0 && (yt[Qt] = Dn[Qt]);
        }
        if (Ut || jr) {
          var qn = typeof H == "function" ? H.displayName || H.name || "Unknown" : H;
          Ut && ln(yt, qn), jr && kn(yt, qn);
        }
        return Hn(H, Ut, jr, Wt, ot, Sn.current, yt);
      }
    }
    var dn = $.ReactCurrentOwner, Yr = $.ReactDebugCurrentFrame;
    function fn(H) {
      if (H) {
        var xe = H._owner, Te = ir(H.type, H._source, xe ? xe.type : null);
        Yr.setExtraStackFrame(Te);
      } else
        Yr.setExtraStackFrame(null);
    }
    var on;
    on = !1;
    function kr(H) {
      return typeof H == "object" && H !== null && H.$$typeof === e;
    }
    function Wa() {
      {
        if (dn.current) {
          var H = Re(dn.current.type);
          if (H)
            return `

Check the render method of \`` + H + "`.";
        }
        return "";
      }
    }
    function gt(H) {
      return "";
    }
    var Gt = {};
    function yn(H) {
      {
        var xe = Wa();
        if (!xe) {
          var Te = typeof H == "string" ? H : H.displayName || H.name;
          Te && (xe = `

Check the top-level render call using <` + Te + ">.");
        }
        return xe;
      }
    }
    function xr(H, xe) {
      {
        if (!H._store || H._store.validated || H.key != null)
          return;
        H._store.validated = !0;
        var Te = yn(xe);
        if (Gt[Te])
          return;
        Gt[Te] = !0;
        var ot = "";
        H && H._owner && H._owner !== dn.current && (ot = " It was passed a child from " + Re(H._owner.type) + "."), fn(H), I('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Te, ot), fn(null);
      }
    }
    function Or(H, xe) {
      {
        if (typeof H != "object")
          return;
        if (aa(H))
          for (var Te = 0; Te < H.length; Te++) {
            var ot = H[Te];
            kr(ot) && xr(ot, xe);
          }
        else if (kr(H))
          H._store && (H._store.validated = !0);
        else if (H) {
          var Wt = A(H);
          if (typeof Wt == "function" && Wt !== H.entries)
            for (var Qt = Wt.call(H), yt; !(yt = Qt.next()).done;)
              kr(yt.value) && xr(yt.value, xe);
        }
      }
    }
    function fr(H) {
      {
        var xe = H.type;
        if (xe == null || typeof xe == "string")
          return;
        var Te;
        if (typeof xe == "function")
          Te = xe.propTypes;
        else if (typeof xe == "object" && (xe.$$typeof === y || // Note: Memo only checks outer props here.
          // Inner props are checked in the reconciler.
          xe.$$typeof === T))
          Te = xe.propTypes;
        else
          return;
        if (Te) {
          var ot = Re(xe);
          wr(Te, H.props, "prop", ot, H);
        } else if (xe.PropTypes !== void 0 && !on) {
          on = !0;
          var Wt = Re(xe);
          I("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Wt || "Unknown");
        }
        typeof xe.getDefaultProps == "function" && !xe.getDefaultProps.isReactClassApproved && I("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Kr(H) {
      {
        for (var xe = Object.keys(H.props), Te = 0; Te < xe.length; Te++) {
          var ot = xe[Te];
          if (ot !== "children" && ot !== "key") {
            fn(H), I("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ot), fn(null);
            break;
          }
        }
        H.ref !== null && (fn(H), I("Invalid attribute `ref` supplied to `React.Fragment`."), fn(null));
      }
    }
    var Wn = {};
    function Nr(H, xe, Te, ot, Wt, Qt) {
      {
        var yt = ke(H);
        if (!yt) {
          var Ut = "";
          (H === void 0 || typeof H == "object" && H !== null && Object.keys(H).length === 0) && (Ut += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var jr = gt();
          jr ? Ut += jr : Ut += Wa();
          var Dn;
          H === null ? Dn = "null" : aa(H) ? Dn = "array" : H !== void 0 && H.$$typeof === e ? (Dn = "<" + (Re(H.type) || "Unknown") + " />", Ut = " Did you accidentally export a JSX literal instead of a component?") : Dn = typeof H, I("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Dn, Ut);
        }
        var qn = qr(H, xe, Te, Wt, Qt);
        if (qn == null)
          return qn;
        if (yt) {
          var wa = xe.children;
          if (wa !== void 0)
            if (ot)
              if (aa(wa)) {
                for (var Co = 0; Co < wa.length; Co++)
                  Or(wa[Co], H);
                Object.freeze && Object.freeze(wa);
              } else
                I("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Or(wa, H);
        }
        if (Bn.call(xe, "key")) {
          var hn = Re(H), Gr = Object.keys(xe).filter(function (Ai) {
            return Ai !== "key";
          }), ja = Gr.length > 0 ? "{key: someKey, " + Gr.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!Wn[hn + ja]) {
            var Ft = Gr.length > 0 ? "{" + Gr.join(": ..., ") + ": ...}" : "{}";
            I(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, ja, hn, Ft, hn), Wn[hn + ja] = !0;
          }
        }
        return H === o ? Kr(qn) : fr(qn), qn;
      }
    }
    function Na(H, xe, Te) {
      return Nr(H, xe, Te, !0);
    }
    function mi(H, xe, Te) {
      return Nr(H, xe, Te, !1);
    }
    var _o = mi, Eo = Na;
    Ig.Fragment = o, Ig.jsx = _o, Ig.jsxs = Eo;
  }()), Ig;
}
process.env.NODE_ENV === "production" ? FC.exports = $z() : FC.exports = zz();
var x = FC.exports, $C = { exports: {} }, eo = {}, vw = { exports: {} }, uC = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var bN;
function Bz() {
  return bN || (bN = 1, function (n) {
    function e(ue, he) {
      var ge = ue.length;
      ue.push(he);
      e: for (; 0 < ge;) {
        var Y = ge - 1 >>> 1, ae = ue[Y];
        if (0 < u(ae, he)) ue[Y] = he, ue[ge] = ae, ge = Y;
        else break e;
      }
    }
    function r(ue) {
      return ue.length === 0 ? null : ue[0];
    }
    function o(ue) {
      if (ue.length === 0) return null;
      var he = ue[0], ge = ue.pop();
      if (ge !== he) {
        ue[0] = ge;
        e: for (var Y = 0, ae = ue.length, Pe = ae >>> 1; Y < Pe;) {
          var Ue = 2 * (Y + 1) - 1, ut = ue[Ue], xt = Ue + 1, et = ue[xt];
          if (0 > u(ut, ge)) xt < ae && 0 > u(et, ut) ? (ue[Y] = et, ue[xt] = ge, Y = xt) : (ue[Y] = ut, ue[Ue] = ge, Y = Ue);
          else if (xt < ae && 0 > u(et, ge)) ue[Y] = et, ue[xt] = ge, Y = xt;
          else break e;
        }
      }
      return he;
    }
    function u(ue, he) {
      var ge = ue.sortIndex - he.sortIndex;
      return ge !== 0 ? ge : ue.id - he.id;
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
      var c = performance;
      n.unstable_now = function () {
        return c.now();
      };
    } else {
      var f = Date, m = f.now();
      n.unstable_now = function () {
        return f.now() - m;
      };
    }
    var y = [], b = [], _ = 1, T = null, k = 3, C = !1, M = !1, N = !1, A = typeof setTimeout == "function" ? setTimeout : null, $ = typeof clearTimeout == "function" ? clearTimeout : null, I = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function U(ue) {
      for (var he = r(b); he !== null;) {
        if (he.callback === null) o(b);
        else if (he.startTime <= ue) o(b), he.sortIndex = he.expirationTime, e(y, he);
        else break;
        he = r(b);
      }
    }
    function B(ue) {
      if (N = !1, U(ue), !M) if (r(y) !== null) M = !0, Me(K);
      else {
        var he = r(b);
        he !== null && we(B, he.startTime - ue);
      }
    }
    function K(ue, he) {
      M = !1, N && (N = !1, $(ve), ve = -1), C = !0;
      var ge = k;
      try {
        for (U(he), T = r(y); T !== null && (!(T.expirationTime > he) || ue && !Ie());) {
          var Y = T.callback;
          if (typeof Y == "function") {
            T.callback = null, k = T.priorityLevel;
            var ae = Y(T.expirationTime <= he);
            he = n.unstable_now(), typeof ae == "function" ? T.callback = ae : T === r(y) && o(y), U(he);
          } else o(y);
          T = r(y);
        }
        if (T !== null) var Pe = !0;
        else {
          var Ue = r(b);
          Ue !== null && we(B, Ue.startTime - he), Pe = !1;
        }
        return Pe;
      } finally {
        T = null, k = ge, C = !1;
      }
    }
    var te = !1, re = null, ve = -1, Ce = 5, ke = -1;
    function Ie() {
      return !(n.unstable_now() - ke < Ce);
    }
    function Ne() {
      if (re !== null) {
        var ue = n.unstable_now();
        ke = ue;
        var he = !0;
        try {
          he = re(!0, ue);
        } finally {
          he ? Re() : (te = !1, re = null);
        }
      } else te = !1;
    }
    var Re;
    if (typeof I == "function") Re = function () {
      I(Ne);
    };
    else if (typeof MessageChannel < "u") {
      var me = new MessageChannel(), Ge = me.port2;
      me.port1.onmessage = Ne, Re = function () {
        Ge.postMessage(null);
      };
    } else Re = function () {
      A(Ne, 0);
    };
    function Me(ue) {
      re = ue, te || (te = !0, Re());
    }
    function we(ue, he) {
      ve = A(function () {
        ue(n.unstable_now());
      }, he);
    }
    n.unstable_IdlePriority = 5, n.unstable_ImmediatePriority = 1, n.unstable_LowPriority = 4, n.unstable_NormalPriority = 3, n.unstable_Profiling = null, n.unstable_UserBlockingPriority = 2, n.unstable_cancelCallback = function (ue) {
      ue.callback = null;
    }, n.unstable_continueExecution = function () {
      M || C || (M = !0, Me(K));
    }, n.unstable_forceFrameRate = function (ue) {
      0 > ue || 125 < ue ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : Ce = 0 < ue ? Math.floor(1e3 / ue) : 5;
    }, n.unstable_getCurrentPriorityLevel = function () {
      return k;
    }, n.unstable_getFirstCallbackNode = function () {
      return r(y);
    }, n.unstable_next = function (ue) {
      switch (k) {
        case 1:
        case 2:
        case 3:
          var he = 3;
          break;
        default:
          he = k;
      }
      var ge = k;
      k = he;
      try {
        return ue();
      } finally {
        k = ge;
      }
    }, n.unstable_pauseExecution = function () {
    }, n.unstable_requestPaint = function () {
    }, n.unstable_runWithPriority = function (ue, he) {
      switch (ue) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          ue = 3;
      }
      var ge = k;
      k = ue;
      try {
        return he();
      } finally {
        k = ge;
      }
    }, n.unstable_scheduleCallback = function (ue, he, ge) {
      var Y = n.unstable_now();
      switch (typeof ge == "object" && ge !== null ? (ge = ge.delay, ge = typeof ge == "number" && 0 < ge ? Y + ge : Y) : ge = Y, ue) {
        case 1:
          var ae = -1;
          break;
        case 2:
          ae = 250;
          break;
        case 5:
          ae = 1073741823;
          break;
        case 4:
          ae = 1e4;
          break;
        default:
          ae = 5e3;
      }
      return ae = ge + ae, ue = { id: _++, callback: he, priorityLevel: ue, startTime: ge, expirationTime: ae, sortIndex: -1 }, ge > Y ? (ue.sortIndex = ge, e(b, ue), r(y) === null && ue === r(b) && (N ? ($(ve), ve = -1) : N = !0, we(B, ge - Y))) : (ue.sortIndex = ae, e(y, ue), M || C || (M = !0, Me(K))), ue;
    }, n.unstable_shouldYield = Ie, n.unstable_wrapCallback = function (ue) {
      var he = k;
      return function () {
        var ge = k;
        k = he;
        try {
          return ue.apply(this, arguments);
        } finally {
          k = ge;
        }
      };
    };
  }(uC)), uC;
}
var cC = {};
/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var wN;
function Vz() {
  return wN || (wN = 1, function (n) {
    process.env.NODE_ENV !== "production" && function () {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var e = !1, r = !1, o = 5;
      function u(Le, nt) {
        var At = Le.length;
        Le.push(nt), m(Le, nt, At);
      }
      function c(Le) {
        return Le.length === 0 ? null : Le[0];
      }
      function f(Le) {
        if (Le.length === 0)
          return null;
        var nt = Le[0], At = Le.pop();
        return At !== nt && (Le[0] = At, y(Le, At, 0)), nt;
      }
      function m(Le, nt, At) {
        for (var Ht = At; Ht > 0;) {
          var ln = Ht - 1 >>> 1, kn = Le[ln];
          if (b(kn, nt) > 0)
            Le[ln] = nt, Le[Ht] = kn, Ht = ln;
          else
            return;
        }
      }
      function y(Le, nt, At) {
        for (var Ht = At, ln = Le.length, kn = ln >>> 1; Ht < kn;) {
          var Hn = (Ht + 1) * 2 - 1, qr = Le[Hn], dn = Hn + 1, Yr = Le[dn];
          if (b(qr, nt) < 0)
            dn < ln && b(Yr, qr) < 0 ? (Le[Ht] = Yr, Le[dn] = nt, Ht = dn) : (Le[Ht] = qr, Le[Hn] = nt, Ht = Hn);
          else if (dn < ln && b(Yr, nt) < 0)
            Le[Ht] = Yr, Le[dn] = nt, Ht = dn;
          else
            return;
        }
      }
      function b(Le, nt) {
        var At = Le.sortIndex - nt.sortIndex;
        return At !== 0 ? At : Le.id - nt.id;
      }
      var _ = 1, T = 2, k = 3, C = 4, M = 5;
      function N(Le, nt) {
      }
      var A = typeof performance == "object" && typeof performance.now == "function";
      if (A) {
        var $ = performance;
        n.unstable_now = function () {
          return $.now();
        };
      } else {
        var I = Date, U = I.now();
        n.unstable_now = function () {
          return I.now() - U;
        };
      }
      var B = 1073741823, K = -1, te = 250, re = 5e3, ve = 1e4, Ce = B, ke = [], Ie = [], Ne = 1, Re = null, me = k, Ge = !1, Me = !1, we = !1, ue = typeof setTimeout == "function" ? setTimeout : null, he = typeof clearTimeout == "function" ? clearTimeout : null, ge = typeof setImmediate < "u" ? setImmediate : null;
      typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function Y(Le) {
        for (var nt = c(Ie); nt !== null;) {
          if (nt.callback === null)
            f(Ie);
          else if (nt.startTime <= Le)
            f(Ie), nt.sortIndex = nt.expirationTime, u(ke, nt);
          else
            return;
          nt = c(Ie);
        }
      }
      function ae(Le) {
        if (we = !1, Y(Le), !Me)
          if (c(ke) !== null)
            Me = !0, An(Pe);
          else {
            var nt = c(Ie);
            nt !== null && Sn(ae, nt.startTime - Le);
          }
      }
      function Pe(Le, nt) {
        Me = !1, we && (we = !1, ia()), Ge = !0;
        var At = me;
        try {
          var Ht;
          if (!r) return Ue(Le, nt);
        } finally {
          Re = null, me = At, Ge = !1;
        }
      }
      function Ue(Le, nt) {
        var At = nt;
        for (Y(At), Re = c(ke); Re !== null && !e && !(Re.expirationTime > At && (!Le || br()));) {
          var Ht = Re.callback;
          if (typeof Ht == "function") {
            Re.callback = null, me = Re.priorityLevel;
            var ln = Re.expirationTime <= At, kn = Ht(ln);
            At = n.unstable_now(), typeof kn == "function" ? Re.callback = kn : Re === c(ke) && f(ke), Y(At);
          } else
            f(ke);
          Re = c(ke);
        }
        if (Re !== null)
          return !0;
        var Hn = c(Ie);
        return Hn !== null && Sn(ae, Hn.startTime - At), !1;
      }
      function ut(Le, nt) {
        switch (Le) {
          case _:
          case T:
          case k:
          case C:
          case M:
            break;
          default:
            Le = k;
        }
        var At = me;
        me = Le;
        try {
          return nt();
        } finally {
          me = At;
        }
      }
      function xt(Le) {
        var nt;
        switch (me) {
          case _:
          case T:
          case k:
            nt = k;
            break;
          default:
            nt = me;
            break;
        }
        var At = me;
        me = nt;
        try {
          return Le();
        } finally {
          me = At;
        }
      }
      function et(Le) {
        var nt = me;
        return function () {
          var At = me;
          me = nt;
          try {
            return Le.apply(this, arguments);
          } finally {
            me = At;
          }
        };
      }
      function kt(Le, nt, At) {
        var Ht = n.unstable_now(), ln;
        if (typeof At == "object" && At !== null) {
          var kn = At.delay;
          typeof kn == "number" && kn > 0 ? ln = Ht + kn : ln = Ht;
        } else
          ln = Ht;
        var Hn;
        switch (Le) {
          case _:
            Hn = K;
            break;
          case T:
            Hn = te;
            break;
          case M:
            Hn = Ce;
            break;
          case C:
            Hn = ve;
            break;
          case k:
          default:
            Hn = re;
            break;
        }
        var qr = ln + Hn, dn = {
          id: Ne++,
          callback: nt,
          priorityLevel: Le,
          startTime: ln,
          expirationTime: qr,
          sortIndex: -1
        };
        return ln > Ht ? (dn.sortIndex = ln, u(Ie, dn), c(ke) === null && dn === c(Ie) && (we ? ia() : we = !0, Sn(ae, ln - Ht))) : (dn.sortIndex = qr, u(ke, dn), !Me && !Ge && (Me = !0, An(Pe))), dn;
      }
      function Et() {
      }
      function an() {
        !Me && !Ge && (Me = !0, An(Pe));
      }
      function zn() {
        return c(ke);
      }
      function yr(Le) {
        Le.callback = null;
      }
      function cn() {
        return me;
      }
      var ar = !1, ir = null, Bn = -1, Vn = o, Rr = -1;
      function br() {
        var Le = n.unstable_now() - Rr;
        return !(Le < Vn);
      }
      function wr() {
      }
      function dr(Le) {
        if (Le < 0 || Le > 125) {
          console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
          return;
        }
        Le > 0 ? Vn = Math.floor(1e3 / Le) : Vn = o;
      }
      var aa = function () {
        if (ir !== null) {
          var Le = n.unstable_now();
          Rr = Le;
          var nt = !0, At = !0;
          try {
            At = ir(nt, Le);
          } finally {
            At ? Xn() : (ar = !1, ir = null);
          }
        } else
          ar = !1;
      }, Xn;
      if (typeof ge == "function")
        Xn = function () {
          ge(aa);
        };
      else if (typeof MessageChannel < "u") {
        var Oa = new MessageChannel(), Ur = Oa.port2;
        Oa.port1.onmessage = aa, Xn = function () {
          Ur.postMessage(null);
        };
      } else
        Xn = function () {
          ue(aa, 0);
        };
      function An(Le) {
        ir = Le, ar || (ar = !0, Xn());
      }
      function Sn(Le, nt) {
        Bn = ue(function () {
          Le(n.unstable_now());
        }, nt);
      }
      function ia() {
        he(Bn), Bn = -1;
      }
      var ji = wr, Wr = null;
      n.unstable_IdlePriority = M, n.unstable_ImmediatePriority = _, n.unstable_LowPriority = C, n.unstable_NormalPriority = k, n.unstable_Profiling = Wr, n.unstable_UserBlockingPriority = T, n.unstable_cancelCallback = yr, n.unstable_continueExecution = an, n.unstable_forceFrameRate = dr, n.unstable_getCurrentPriorityLevel = cn, n.unstable_getFirstCallbackNode = zn, n.unstable_next = xt, n.unstable_pauseExecution = Et, n.unstable_requestPaint = ji, n.unstable_runWithPriority = ut, n.unstable_scheduleCallback = kt, n.unstable_shouldYield = br, n.unstable_wrapCallback = et, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(cC)), cC;
}
var xN;
function MA() {
  return xN || (xN = 1, process.env.NODE_ENV === "production" ? vw.exports = Bz() : vw.exports = Vz()), vw.exports;
}
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var SN;
function Hz() {
  if (SN) return eo;
  SN = 1;
  var n = py(), e = MA();
  function r(i) {
    for (var s = "https://reactjs.org/docs/error-decoder.html?invariant=" + i, h = 1; h < arguments.length; h++) s += "&args[]=" + encodeURIComponent(arguments[h]);
    return "Minified React error #" + i + "; visit " + s + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var o = /* @__PURE__ */ new Set(), u = {};
  function c(i, s) {
    f(i, s), f(i + "Capture", s);
  }
  function f(i, s) {
    for (u[i] = s, i = 0; i < s.length; i++) o.add(s[i]);
  }
  var m = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), y = Object.prototype.hasOwnProperty, b = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, _ = {}, T = {};
  function k(i) {
    return y.call(T, i) ? !0 : y.call(_, i) ? !1 : b.test(i) ? T[i] = !0 : (_[i] = !0, !1);
  }
  function C(i, s, h, v) {
    if (h !== null && h.type === 0) return !1;
    switch (typeof s) {
      case "function":
      case "symbol":
        return !0;
      case "boolean":
        return v ? !1 : h !== null ? !h.acceptsBooleans : (i = i.toLowerCase().slice(0, 5), i !== "data-" && i !== "aria-");
      default:
        return !1;
    }
  }
  function M(i, s, h, v) {
    if (s === null || typeof s > "u" || C(i, s, h, v)) return !0;
    if (v) return !1;
    if (h !== null) switch (h.type) {
      case 3:
        return !s;
      case 4:
        return s === !1;
      case 5:
        return isNaN(s);
      case 6:
        return isNaN(s) || 1 > s;
    }
    return !1;
  }
  function N(i, s, h, v, w, E, P) {
    this.acceptsBooleans = s === 2 || s === 3 || s === 4, this.attributeName = v, this.attributeNamespace = w, this.mustUseProperty = h, this.propertyName = i, this.type = s, this.sanitizeURL = E, this.removeEmptyString = P;
  }
  var A = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (i) {
    A[i] = new N(i, 0, !1, i, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (i) {
    var s = i[0];
    A[s] = new N(s, 1, !1, i[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function (i) {
    A[i] = new N(i, 2, !1, i.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (i) {
    A[i] = new N(i, 2, !1, i, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (i) {
    A[i] = new N(i, 3, !1, i.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function (i) {
    A[i] = new N(i, 3, !0, i, null, !1, !1);
  }), ["capture", "download"].forEach(function (i) {
    A[i] = new N(i, 4, !1, i, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function (i) {
    A[i] = new N(i, 6, !1, i, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function (i) {
    A[i] = new N(i, 5, !1, i.toLowerCase(), null, !1, !1);
  });
  var $ = /[\-:]([a-z])/g;
  function I(i) {
    return i[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (i) {
    var s = i.replace(
      $,
      I
    );
    A[s] = new N(s, 1, !1, i, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (i) {
    var s = i.replace($, I);
    A[s] = new N(s, 1, !1, i, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function (i) {
    var s = i.replace($, I);
    A[s] = new N(s, 1, !1, i, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function (i) {
    A[i] = new N(i, 1, !1, i.toLowerCase(), null, !1, !1);
  }), A.xlinkHref = new N("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function (i) {
    A[i] = new N(i, 1, !1, i.toLowerCase(), null, !0, !0);
  });
  function U(i, s, h, v) {
    var w = A.hasOwnProperty(s) ? A[s] : null;
    (w !== null ? w.type !== 0 : v || !(2 < s.length) || s[0] !== "o" && s[0] !== "O" || s[1] !== "n" && s[1] !== "N") && (M(s, h, w, v) && (h = null), v || w === null ? k(s) && (h === null ? i.removeAttribute(s) : i.setAttribute(s, "" + h)) : w.mustUseProperty ? i[w.propertyName] = h === null ? w.type === 3 ? !1 : "" : h : (s = w.attributeName, v = w.attributeNamespace, h === null ? i.removeAttribute(s) : (w = w.type, h = w === 3 || w === 4 && h === !0 ? "" : "" + h, v ? i.setAttributeNS(v, s, h) : i.setAttribute(s, h))));
  }
  var B = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, K = Symbol.for("react.element"), te = Symbol.for("react.portal"), re = Symbol.for("react.fragment"), ve = Symbol.for("react.strict_mode"), Ce = Symbol.for("react.profiler"), ke = Symbol.for("react.provider"), Ie = Symbol.for("react.context"), Ne = Symbol.for("react.forward_ref"), Re = Symbol.for("react.suspense"), me = Symbol.for("react.suspense_list"), Ge = Symbol.for("react.memo"), Me = Symbol.for("react.lazy"), we = Symbol.for("react.offscreen"), ue = Symbol.iterator;
  function he(i) {
    return i === null || typeof i != "object" ? null : (i = ue && i[ue] || i["@@iterator"], typeof i == "function" ? i : null);
  }
  var ge = Object.assign, Y;
  function ae(i) {
    if (Y === void 0) try {
      throw Error();
    } catch (h) {
      var s = h.stack.trim().match(/\n( *(at )?)/);
      Y = s && s[1] || "";
    }
    return `
` + Y + i;
  }
  var Pe = !1;
  function Ue(i, s) {
    if (!i || Pe) return "";
    Pe = !0;
    var h = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (s) if (s = function () {
        throw Error();
      }, Object.defineProperty(s.prototype, "props", {
        set: function () {
          throw Error();
        }
      }), typeof Reflect == "object" && Reflect.construct) {
        try {
          Reflect.construct(s, []);
        } catch (se) {
          var v = se;
        }
        Reflect.construct(i, [], s);
      } else {
        try {
          s.call();
        } catch (se) {
          v = se;
        }
        i.call(s.prototype);
      }
      else {
        try {
          throw Error();
        } catch (se) {
          v = se;
        }
        i();
      }
    } catch (se) {
      if (se && v && typeof se.stack == "string") {
        for (var w = se.stack.split(`
`), E = v.stack.split(`
`), P = w.length - 1, z = E.length - 1; 1 <= P && 0 <= z && w[P] !== E[z];) z--;
        for (; 1 <= P && 0 <= z; P--, z--) if (w[P] !== E[z]) {
          if (P !== 1 || z !== 1)
            do
              if (P--, z--, 0 > z || w[P] !== E[z]) {
                var q = `
` + w[P].replace(" at new ", " at ");
                return i.displayName && q.includes("<anonymous>") && (q = q.replace("<anonymous>", i.displayName)), q;
              }
            while (1 <= P && 0 <= z);
          break;
        }
      }
    } finally {
      Pe = !1, Error.prepareStackTrace = h;
    }
    return (i = i ? i.displayName || i.name : "") ? ae(i) : "";
  }
  function ut(i) {
    switch (i.tag) {
      case 5:
        return ae(i.type);
      case 16:
        return ae("Lazy");
      case 13:
        return ae("Suspense");
      case 19:
        return ae("SuspenseList");
      case 0:
      case 2:
      case 15:
        return i = Ue(i.type, !1), i;
      case 11:
        return i = Ue(i.type.render, !1), i;
      case 1:
        return i = Ue(i.type, !0), i;
      default:
        return "";
    }
  }
  function xt(i) {
    if (i == null) return null;
    if (typeof i == "function") return i.displayName || i.name || null;
    if (typeof i == "string") return i;
    switch (i) {
      case re:
        return "Fragment";
      case te:
        return "Portal";
      case Ce:
        return "Profiler";
      case ve:
        return "StrictMode";
      case Re:
        return "Suspense";
      case me:
        return "SuspenseList";
    }
    if (typeof i == "object") switch (i.$$typeof) {
      case Ie:
        return (i.displayName || "Context") + ".Consumer";
      case ke:
        return (i._context.displayName || "Context") + ".Provider";
      case Ne:
        var s = i.render;
        return i = i.displayName, i || (i = s.displayName || s.name || "", i = i !== "" ? "ForwardRef(" + i + ")" : "ForwardRef"), i;
      case Ge:
        return s = i.displayName || null, s !== null ? s : xt(i.type) || "Memo";
      case Me:
        s = i._payload, i = i._init;
        try {
          return xt(i(s));
        } catch {
        }
    }
    return null;
  }
  function et(i) {
    var s = i.type;
    switch (i.tag) {
      case 24:
        return "Cache";
      case 9:
        return (s.displayName || "Context") + ".Consumer";
      case 10:
        return (s._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return i = s.render, i = i.displayName || i.name || "", s.displayName || (i !== "" ? "ForwardRef(" + i + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return s;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return xt(s);
      case 8:
        return s === ve ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof s == "function") return s.displayName || s.name || null;
        if (typeof s == "string") return s;
    }
    return null;
  }
  function kt(i) {
    switch (typeof i) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return i;
      case "object":
        return i;
      default:
        return "";
    }
  }
  function Et(i) {
    var s = i.type;
    return (i = i.nodeName) && i.toLowerCase() === "input" && (s === "checkbox" || s === "radio");
  }
  function an(i) {
    var s = Et(i) ? "checked" : "value", h = Object.getOwnPropertyDescriptor(i.constructor.prototype, s), v = "" + i[s];
    if (!i.hasOwnProperty(s) && typeof h < "u" && typeof h.get == "function" && typeof h.set == "function") {
      var w = h.get, E = h.set;
      return Object.defineProperty(i, s, {
        configurable: !0, get: function () {
          return w.call(this);
        }, set: function (P) {
          v = "" + P, E.call(this, P);
        }
      }), Object.defineProperty(i, s, { enumerable: h.enumerable }), {
        getValue: function () {
          return v;
        }, setValue: function (P) {
          v = "" + P;
        }, stopTracking: function () {
          i._valueTracker = null, delete i[s];
        }
      };
    }
  }
  function zn(i) {
    i._valueTracker || (i._valueTracker = an(i));
  }
  function yr(i) {
    if (!i) return !1;
    var s = i._valueTracker;
    if (!s) return !0;
    var h = s.getValue(), v = "";
    return i && (v = Et(i) ? i.checked ? "true" : "false" : i.value), i = v, i !== h ? (s.setValue(i), !0) : !1;
  }
  function cn(i) {
    if (i = i || (typeof document < "u" ? document : void 0), typeof i > "u") return null;
    try {
      return i.activeElement || i.body;
    } catch {
      return i.body;
    }
  }
  function ar(i, s) {
    var h = s.checked;
    return ge({}, s, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: h ?? i._wrapperState.initialChecked });
  }
  function ir(i, s) {
    var h = s.defaultValue == null ? "" : s.defaultValue, v = s.checked != null ? s.checked : s.defaultChecked;
    h = kt(s.value != null ? s.value : h), i._wrapperState = { initialChecked: v, initialValue: h, controlled: s.type === "checkbox" || s.type === "radio" ? s.checked != null : s.value != null };
  }
  function Bn(i, s) {
    s = s.checked, s != null && U(i, "checked", s, !1);
  }
  function Vn(i, s) {
    Bn(i, s);
    var h = kt(s.value), v = s.type;
    if (h != null) v === "number" ? (h === 0 && i.value === "" || i.value != h) && (i.value = "" + h) : i.value !== "" + h && (i.value = "" + h);
    else if (v === "submit" || v === "reset") {
      i.removeAttribute("value");
      return;
    }
    s.hasOwnProperty("value") ? br(i, s.type, h) : s.hasOwnProperty("defaultValue") && br(i, s.type, kt(s.defaultValue)), s.checked == null && s.defaultChecked != null && (i.defaultChecked = !!s.defaultChecked);
  }
  function Rr(i, s, h) {
    if (s.hasOwnProperty("value") || s.hasOwnProperty("defaultValue")) {
      var v = s.type;
      if (!(v !== "submit" && v !== "reset" || s.value !== void 0 && s.value !== null)) return;
      s = "" + i._wrapperState.initialValue, h || s === i.value || (i.value = s), i.defaultValue = s;
    }
    h = i.name, h !== "" && (i.name = ""), i.defaultChecked = !!i._wrapperState.initialChecked, h !== "" && (i.name = h);
  }
  function br(i, s, h) {
    (s !== "number" || cn(i.ownerDocument) !== i) && (h == null ? i.defaultValue = "" + i._wrapperState.initialValue : i.defaultValue !== "" + h && (i.defaultValue = "" + h));
  }
  var wr = Array.isArray;
  function dr(i, s, h, v) {
    if (i = i.options, s) {
      s = {};
      for (var w = 0; w < h.length; w++) s["$" + h[w]] = !0;
      for (h = 0; h < i.length; h++) w = s.hasOwnProperty("$" + i[h].value), i[h].selected !== w && (i[h].selected = w), w && v && (i[h].defaultSelected = !0);
    } else {
      for (h = "" + kt(h), s = null, w = 0; w < i.length; w++) {
        if (i[w].value === h) {
          i[w].selected = !0, v && (i[w].defaultSelected = !0);
          return;
        }
        s !== null || i[w].disabled || (s = i[w]);
      }
      s !== null && (s.selected = !0);
    }
  }
  function aa(i, s) {
    if (s.dangerouslySetInnerHTML != null) throw Error(r(91));
    return ge({}, s, { value: void 0, defaultValue: void 0, children: "" + i._wrapperState.initialValue });
  }
  function Xn(i, s) {
    var h = s.value;
    if (h == null) {
      if (h = s.children, s = s.defaultValue, h != null) {
        if (s != null) throw Error(r(92));
        if (wr(h)) {
          if (1 < h.length) throw Error(r(93));
          h = h[0];
        }
        s = h;
      }
      s == null && (s = ""), h = s;
    }
    i._wrapperState = { initialValue: kt(h) };
  }
  function Oa(i, s) {
    var h = kt(s.value), v = kt(s.defaultValue);
    h != null && (h = "" + h, h !== i.value && (i.value = h), s.defaultValue == null && i.defaultValue !== h && (i.defaultValue = h)), v != null && (i.defaultValue = "" + v);
  }
  function Ur(i) {
    var s = i.textContent;
    s === i._wrapperState.initialValue && s !== "" && s !== null && (i.value = s);
  }
  function An(i) {
    switch (i) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function Sn(i, s) {
    return i == null || i === "http://www.w3.org/1999/xhtml" ? An(s) : i === "http://www.w3.org/2000/svg" && s === "foreignObject" ? "http://www.w3.org/1999/xhtml" : i;
  }
  var ia, ji = function (i) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function (s, h, v, w) {
      MSApp.execUnsafeLocalFunction(function () {
        return i(s, h, v, w);
      });
    } : i;
  }(function (i, s) {
    if (i.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in i) i.innerHTML = s;
    else {
      for (ia = ia || document.createElement("div"), ia.innerHTML = "<svg>" + s.valueOf().toString() + "</svg>", s = ia.firstChild; i.firstChild;) i.removeChild(i.firstChild);
      for (; s.firstChild;) i.appendChild(s.firstChild);
    }
  });
  function Wr(i, s) {
    if (s) {
      var h = i.firstChild;
      if (h && h === i.lastChild && h.nodeType === 3) {
        h.nodeValue = s;
        return;
      }
    }
    i.textContent = s;
  }
  var Le = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  }, nt = ["Webkit", "ms", "Moz", "O"];
  Object.keys(Le).forEach(function (i) {
    nt.forEach(function (s) {
      s = s + i.charAt(0).toUpperCase() + i.substring(1), Le[s] = Le[i];
    });
  });
  function At(i, s, h) {
    return s == null || typeof s == "boolean" || s === "" ? "" : h || typeof s != "number" || s === 0 || Le.hasOwnProperty(i) && Le[i] ? ("" + s).trim() : s + "px";
  }
  function Ht(i, s) {
    i = i.style;
    for (var h in s) if (s.hasOwnProperty(h)) {
      var v = h.indexOf("--") === 0, w = At(h, s[h], v);
      h === "float" && (h = "cssFloat"), v ? i.setProperty(h, w) : i[h] = w;
    }
  }
  var ln = ge({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 });
  function kn(i, s) {
    if (s) {
      if (ln[i] && (s.children != null || s.dangerouslySetInnerHTML != null)) throw Error(r(137, i));
      if (s.dangerouslySetInnerHTML != null) {
        if (s.children != null) throw Error(r(60));
        if (typeof s.dangerouslySetInnerHTML != "object" || !("__html" in s.dangerouslySetInnerHTML)) throw Error(r(61));
      }
      if (s.style != null && typeof s.style != "object") throw Error(r(62));
    }
  }
  function Hn(i, s) {
    if (i.indexOf("-") === -1) return typeof s.is == "string";
    switch (i) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var qr = null;
  function dn(i) {
    return i = i.target || i.srcElement || window, i.correspondingUseElement && (i = i.correspondingUseElement), i.nodeType === 3 ? i.parentNode : i;
  }
  var Yr = null, fn = null, on = null;
  function kr(i) {
    if (i = Dd(i)) {
      if (typeof Yr != "function") throw Error(r(280));
      var s = i.stateNode;
      s && (s = ht(s), Yr(i.stateNode, i.type, s));
    }
  }
  function Wa(i) {
    fn ? on ? on.push(i) : on = [i] : fn = i;
  }
  function gt() {
    if (fn) {
      var i = fn, s = on;
      if (on = fn = null, kr(i), s) for (i = 0; i < s.length; i++) kr(s[i]);
    }
  }
  function Gt(i, s) {
    return i(s);
  }
  function yn() {
  }
  var xr = !1;
  function Or(i, s, h) {
    if (xr) return i(s, h);
    xr = !0;
    try {
      return Gt(i, s, h);
    } finally {
      xr = !1, (fn !== null || on !== null) && (yn(), gt());
    }
  }
  function fr(i, s) {
    var h = i.stateNode;
    if (h === null) return null;
    var v = ht(h);
    if (v === null) return null;
    h = v[s];
    e: switch (s) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (v = !v.disabled) || (i = i.type, v = !(i === "button" || i === "input" || i === "select" || i === "textarea")), i = !v;
        break e;
      default:
        i = !1;
    }
    if (i) return null;
    if (h && typeof h != "function") throw Error(r(231, s, typeof h));
    return h;
  }
  var Kr = !1;
  if (m) try {
    var Wn = {};
    Object.defineProperty(Wn, "passive", {
      get: function () {
        Kr = !0;
      }
    }), window.addEventListener("test", Wn, Wn), window.removeEventListener("test", Wn, Wn);
  } catch {
    Kr = !1;
  }
  function Nr(i, s, h, v, w, E, P, z, q) {
    var se = Array.prototype.slice.call(arguments, 3);
    try {
      s.apply(h, se);
    } catch (Se) {
      this.onError(Se);
    }
  }
  var Na = !1, mi = null, _o = !1, Eo = null, H = {
    onError: function (i) {
      Na = !0, mi = i;
    }
  };
  function xe(i, s, h, v, w, E, P, z, q) {
    Na = !1, mi = null, Nr.apply(H, arguments);
  }
  function Te(i, s, h, v, w, E, P, z, q) {
    if (xe.apply(this, arguments), Na) {
      if (Na) {
        var se = mi;
        Na = !1, mi = null;
      } else throw Error(r(198));
      _o || (_o = !0, Eo = se);
    }
  }
  function ot(i) {
    var s = i, h = i;
    if (i.alternate) for (; s.return;) s = s.return;
    else {
      i = s;
      do
        s = i, s.flags & 4098 && (h = s.return), i = s.return;
      while (i);
    }
    return s.tag === 3 ? h : null;
  }
  function Wt(i) {
    if (i.tag === 13) {
      var s = i.memoizedState;
      if (s === null && (i = i.alternate, i !== null && (s = i.memoizedState)), s !== null) return s.dehydrated;
    }
    return null;
  }
  function Qt(i) {
    if (ot(i) !== i) throw Error(r(188));
  }
  function yt(i) {
    var s = i.alternate;
    if (!s) {
      if (s = ot(i), s === null) throw Error(r(188));
      return s !== i ? null : i;
    }
    for (var h = i, v = s; ;) {
      var w = h.return;
      if (w === null) break;
      var E = w.alternate;
      if (E === null) {
        if (v = w.return, v !== null) {
          h = v;
          continue;
        }
        break;
      }
      if (w.child === E.child) {
        for (E = w.child; E;) {
          if (E === h) return Qt(w), i;
          if (E === v) return Qt(w), s;
          E = E.sibling;
        }
        throw Error(r(188));
      }
      if (h.return !== v.return) h = w, v = E;
      else {
        for (var P = !1, z = w.child; z;) {
          if (z === h) {
            P = !0, h = w, v = E;
            break;
          }
          if (z === v) {
            P = !0, v = w, h = E;
            break;
          }
          z = z.sibling;
        }
        if (!P) {
          for (z = E.child; z;) {
            if (z === h) {
              P = !0, h = E, v = w;
              break;
            }
            if (z === v) {
              P = !0, v = E, h = w;
              break;
            }
            z = z.sibling;
          }
          if (!P) throw Error(r(189));
        }
      }
      if (h.alternate !== v) throw Error(r(190));
    }
    if (h.tag !== 3) throw Error(r(188));
    return h.stateNode.current === h ? i : s;
  }
  function Ut(i) {
    return i = yt(i), i !== null ? jr(i) : null;
  }
  function jr(i) {
    if (i.tag === 5 || i.tag === 6) return i;
    for (i = i.child; i !== null;) {
      var s = jr(i);
      if (s !== null) return s;
      i = i.sibling;
    }
    return null;
  }
  var Dn = e.unstable_scheduleCallback, qn = e.unstable_cancelCallback, wa = e.unstable_shouldYield, Co = e.unstable_requestPaint, hn = e.unstable_now, Gr = e.unstable_getCurrentPriorityLevel, ja = e.unstable_ImmediatePriority, Ft = e.unstable_UserBlockingPriority, Ai = e.unstable_NormalPriority, $s = e.unstable_LowPriority, Ou = e.unstable_IdlePriority, zs = null, qa = null;
  function vd(i) {
    if (qa && typeof qa.onCommitFiberRoot == "function") try {
      qa.onCommitFiberRoot(zs, i, void 0, (i.current.flags & 128) === 128);
    } catch {
    }
  }
  var Aa = Math.clz32 ? Math.clz32 : Gf, gd = Math.log, yd = Math.LN2;
  function Gf(i) {
    return i >>>= 0, i === 0 ? 32 : 31 - (gd(i) / yd | 0) | 0;
  }
  var Nu = 64, Bs = 4194304;
  function io(i) {
    switch (i & -i) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return i & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return i & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return i;
    }
  }
  function Da(i, s) {
    var h = i.pendingLanes;
    if (h === 0) return 0;
    var v = 0, w = i.suspendedLanes, E = i.pingedLanes, P = h & 268435455;
    if (P !== 0) {
      var z = P & ~w;
      z !== 0 ? v = io(z) : (E &= P, E !== 0 && (v = io(E)));
    } else P = h & ~w, P !== 0 ? v = io(P) : E !== 0 && (v = io(E));
    if (v === 0) return 0;
    if (s !== 0 && s !== v && !(s & w) && (w = v & -v, E = s & -s, w >= E || w === 16 && (E & 4194240) !== 0)) return s;
    if (v & 4 && (v |= h & 16), s = i.entangledLanes, s !== 0) for (i = i.entanglements, s &= v; 0 < s;) h = 31 - Aa(s), w = 1 << h, v |= i[h], s &= ~w;
    return v;
  }
  function Vs(i, s) {
    switch (i) {
      case 1:
      case 2:
      case 4:
        return s + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return s + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function Hs(i, s) {
    for (var h = i.suspendedLanes, v = i.pingedLanes, w = i.expirationTimes, E = i.pendingLanes; 0 < E;) {
      var P = 31 - Aa(E), z = 1 << P, q = w[P];
      q === -1 ? (!(z & h) || z & v) && (w[P] = Vs(z, s)) : q <= s && (i.expiredLanes |= z), E &= ~z;
    }
  }
  function Ws(i) {
    return i = i.pendingLanes & -1073741825, i !== 0 ? i : i & 1073741824 ? 1073741824 : 0;
  }
  function ju() {
    var i = Nu;
    return Nu <<= 1, !(Nu & 4194240) && (Nu = 64), i;
  }
  function Au(i) {
    for (var s = [], h = 0; 31 > h; h++) s.push(i);
    return s;
  }
  function Go(i, s, h) {
    i.pendingLanes |= s, s !== 536870912 && (i.suspendedLanes = 0, i.pingedLanes = 0), i = i.eventTimes, s = 31 - Aa(s), i[s] = h;
  }
  function Dm(i, s) {
    var h = i.pendingLanes & ~s;
    i.pendingLanes = s, i.suspendedLanes = 0, i.pingedLanes = 0, i.expiredLanes &= s, i.mutableReadLanes &= s, i.entangledLanes &= s, s = i.entanglements;
    var v = i.eventTimes;
    for (i = i.expirationTimes; 0 < h;) {
      var w = 31 - Aa(h), E = 1 << w;
      s[w] = 0, v[w] = -1, i[w] = -1, h &= ~E;
    }
  }
  function To(i, s) {
    var h = i.entangledLanes |= s;
    for (i = i.entanglements; h;) {
      var v = 31 - Aa(h), w = 1 << v;
      w & s | i[v] & s && (i[v] |= s), h &= ~w;
    }
  }
  var pn = 0;
  function Du(i) {
    return i &= -i, 1 < i ? 4 < i ? i & 268435455 ? 16 : 536870912 : 4 : 1;
  }
  var Dl, Pu, Jt, Mu, Lu, Ot = !1, Pl = [], or = null, Ya = null, Pa = null, qs = /* @__PURE__ */ new Map(), hr = /* @__PURE__ */ new Map(), _n = [], Qf = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function Ka(i, s) {
    switch (i) {
      case "focusin":
      case "focusout":
        or = null;
        break;
      case "dragenter":
      case "dragleave":
        Ya = null;
        break;
      case "mouseover":
      case "mouseout":
        Pa = null;
        break;
      case "pointerover":
      case "pointerout":
        qs.delete(s.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        hr.delete(s.pointerId);
    }
  }
  function Qr(i, s, h, v, w, E) {
    return i === null || i.nativeEvent !== E ? (i = { blockedOn: s, domEventName: h, eventSystemFlags: v, nativeEvent: E, targetContainers: [w] }, s !== null && (s = Dd(s), s !== null && Pu(s)), i) : (i.eventSystemFlags |= v, s = i.targetContainers, w !== null && s.indexOf(w) === -1 && s.push(w), i);
  }
  function Ro(i, s, h, v, w) {
    switch (s) {
      case "focusin":
        return or = Qr(or, i, s, h, v, w), !0;
      case "dragenter":
        return Ya = Qr(Ya, i, s, h, v, w), !0;
      case "mouseover":
        return Pa = Qr(Pa, i, s, h, v, w), !0;
      case "pointerover":
        var E = w.pointerId;
        return qs.set(E, Qr(qs.get(E) || null, i, s, h, v, w)), !0;
      case "gotpointercapture":
        return E = w.pointerId, hr.set(E, Qr(hr.get(E) || null, i, s, h, v, w)), !0;
    }
    return !1;
  }
  function Jf(i) {
    var s = Li(i.target);
    if (s !== null) {
      var h = ot(s);
      if (h !== null) {
        if (s = h.tag, s === 13) {
          if (s = Wt(h), s !== null) {
            i.blockedOn = s, Lu(i.priority, function () {
              Jt(h);
            });
            return;
          }
        } else if (s === 3 && h.stateNode.current.memoizedState.isDehydrated) {
          i.blockedOn = h.tag === 3 ? h.stateNode.containerInfo : null;
          return;
        }
      }
    }
    i.blockedOn = null;
  }
  function Qo(i) {
    if (i.blockedOn !== null) return !1;
    for (var s = i.targetContainers; 0 < s.length;) {
      var h = Uu(i.domEventName, i.eventSystemFlags, s[0], i.nativeEvent);
      if (h === null) {
        h = i.nativeEvent;
        var v = new h.constructor(h.type, h);
        qr = v, h.target.dispatchEvent(v), qr = null;
      } else return s = Dd(h), s !== null && Pu(s), i.blockedOn = h, !1;
      s.shift();
    }
    return !0;
  }
  function Ys(i, s, h) {
    Qo(i) && h.delete(s);
  }
  function Zf() {
    Ot = !1, or !== null && Qo(or) && (or = null), Ya !== null && Qo(Ya) && (Ya = null), Pa !== null && Qo(Pa) && (Pa = null), qs.forEach(Ys), hr.forEach(Ys);
  }
  function Di(i, s) {
    i.blockedOn === s && (i.blockedOn = null, Ot || (Ot = !0, e.unstable_scheduleCallback(e.unstable_NormalPriority, Zf)));
  }
  function Ks(i) {
    function s(w) {
      return Di(w, i);
    }
    if (0 < Pl.length) {
      Di(Pl[0], i);
      for (var h = 1; h < Pl.length; h++) {
        var v = Pl[h];
        v.blockedOn === i && (v.blockedOn = null);
      }
    }
    for (or !== null && Di(or, i), Ya !== null && Di(Ya, i), Pa !== null && Di(Pa, i), qs.forEach(s), hr.forEach(s), h = 0; h < _n.length; h++) v = _n[h], v.blockedOn === i && (v.blockedOn = null);
    for (; 0 < _n.length && (h = _n[0], h.blockedOn === null);) Jf(h), h.blockedOn === null && _n.shift();
  }
  var Jo = B.ReactCurrentBatchConfig, Pi = !0;
  function Iu(i, s, h, v) {
    var w = pn, E = Jo.transition;
    Jo.transition = null;
    try {
      pn = 1, Qs(i, s, h, v);
    } finally {
      pn = w, Jo.transition = E;
    }
  }
  function Gs(i, s, h, v) {
    var w = pn, E = Jo.transition;
    Jo.transition = null;
    try {
      pn = 4, Qs(i, s, h, v);
    } finally {
      pn = w, Jo.transition = E;
    }
  }
  function Qs(i, s, h, v) {
    if (Pi) {
      var w = Uu(i, s, h, v);
      if (w === null) sh(i, s, v, Ml, h), Ka(i, v);
      else if (Ro(w, i, s, h, v)) v.stopPropagation();
      else if (Ka(i, v), s & 4 && -1 < Qf.indexOf(i)) {
        for (; w !== null;) {
          var E = Dd(w);
          if (E !== null && Dl(E), E = Uu(i, s, h, v), E === null && sh(i, s, v, Ml, h), E === w) break;
          w = E;
        }
        w !== null && v.stopPropagation();
      } else sh(i, s, v, null, h);
    }
  }
  var Ml = null;
  function Uu(i, s, h, v) {
    if (Ml = null, i = dn(v), i = Li(i), i !== null) if (s = ot(i), s === null) i = null;
    else if (h = s.tag, h === 13) {
      if (i = Wt(s), i !== null) return i;
      i = null;
    } else if (h === 3) {
      if (s.stateNode.current.memoizedState.isDehydrated) return s.tag === 3 ? s.stateNode.containerInfo : null;
      i = null;
    } else s !== i && (i = null);
    return Ml = i, null;
  }
  function bd(i) {
    switch (i) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (Gr()) {
          case ja:
            return 1;
          case Ft:
            return 4;
          case Ai:
          case $s:
            return 16;
          case Ou:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var oo = null, j = null, V = null;
  function oe() {
    if (V) return V;
    var i, s = j, h = s.length, v, w = "value" in oo ? oo.value : oo.textContent, E = w.length;
    for (i = 0; i < h && s[i] === w[i]; i++);
    var P = h - i;
    for (v = 1; v <= P && s[h - v] === w[E - v]; v++);
    return V = w.slice(i, 1 < v ? 1 - v : void 0);
  }
  function ce(i) {
    var s = i.keyCode;
    return "charCode" in i ? (i = i.charCode, i === 0 && s === 13 && (i = 13)) : i = s, i === 10 && (i = 13), 32 <= i || i === 13 ? i : 0;
  }
  function Oe() {
    return !0;
  }
  function bt() {
    return !1;
  }
  function ze(i) {
    function s(h, v, w, E, P) {
      this._reactName = h, this._targetInst = w, this.type = v, this.nativeEvent = E, this.target = P, this.currentTarget = null;
      for (var z in i) i.hasOwnProperty(z) && (h = i[z], this[z] = h ? h(E) : E[z]);
      return this.isDefaultPrevented = (E.defaultPrevented != null ? E.defaultPrevented : E.returnValue === !1) ? Oe : bt, this.isPropagationStopped = bt, this;
    }
    return ge(s.prototype, {
      preventDefault: function () {
        this.defaultPrevented = !0;
        var h = this.nativeEvent;
        h && (h.preventDefault ? h.preventDefault() : typeof h.returnValue != "unknown" && (h.returnValue = !1), this.isDefaultPrevented = Oe);
      }, stopPropagation: function () {
        var h = this.nativeEvent;
        h && (h.stopPropagation ? h.stopPropagation() : typeof h.cancelBubble != "unknown" && (h.cancelBubble = !0), this.isPropagationStopped = Oe);
      }, persist: function () {
      }, isPersistent: Oe
    }), s;
  }
  var vt = {
    eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (i) {
      return i.timeStamp || Date.now();
    }, defaultPrevented: 0, isTrusted: 0
  }, zt = ze(vt), sn = ge({}, vt, { view: 0, detail: 0 }), Pn = ze(sn), Rn, Mn, Fn, Zt = ge({}, sn, {
    screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: Um, button: 0, buttons: 0, relatedTarget: function (i) {
      return i.relatedTarget === void 0 ? i.fromElement === i.srcElement ? i.toElement : i.fromElement : i.relatedTarget;
    }, movementX: function (i) {
      return "movementX" in i ? i.movementX : (i !== Fn && (Fn && i.type === "mousemove" ? (Rn = i.screenX - Fn.screenX, Mn = i.screenY - Fn.screenY) : Mn = Rn = 0, Fn = i), Rn);
    }, movementY: function (i) {
      return "movementY" in i ? i.movementY : Mn;
    }
  }), Zo = ze(Zt), Fu = ge({}, Zt, { dataTransfer: 0 }), wd = ze(Fu), Pm = ge({}, sn, { relatedTarget: 0 }), so = ze(Pm), xd = ge({}, vt, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Sd = ze(xd), Mm = ge({}, vt, {
    clipboardData: function (i) {
      return "clipboardData" in i ? i.clipboardData : window.clipboardData;
    }
  }), Fx = ze(Mm), $x = ge({}, vt, { data: 0 }), Lm = ze($x), Im = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, Cy = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, Ty = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
  function Ry(i) {
    var s = this.nativeEvent;
    return s.getModifierState ? s.getModifierState(i) : (i = Ty[i]) ? !!s[i] : !1;
  }
  function Um() {
    return Ry;
  }
  var Xo = ge({}, sn, {
    key: function (i) {
      if (i.key) {
        var s = Im[i.key] || i.key;
        if (s !== "Unidentified") return s;
      }
      return i.type === "keypress" ? (i = ce(i), i === 13 ? "Enter" : String.fromCharCode(i)) : i.type === "keydown" || i.type === "keyup" ? Cy[i.keyCode] || "Unidentified" : "";
    }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: Um, charCode: function (i) {
      return i.type === "keypress" ? ce(i) : 0;
    }, keyCode: function (i) {
      return i.type === "keydown" || i.type === "keyup" ? i.keyCode : 0;
    }, which: function (i) {
      return i.type === "keypress" ? ce(i) : i.type === "keydown" || i.type === "keyup" ? i.keyCode : 0;
    }
  }), zx = ze(Xo), Fm = ge({}, Zt, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Xf = ze(Fm), $m = ge({}, sn, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: Um }), Bx = ze($m), eh = ge({}, vt, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), ky = ze(eh), Ga = ge({}, Zt, {
    deltaX: function (i) {
      return "deltaX" in i ? i.deltaX : "wheelDeltaX" in i ? -i.wheelDeltaX : 0;
    },
    deltaY: function (i) {
      return "deltaY" in i ? i.deltaY : "wheelDeltaY" in i ? -i.wheelDeltaY : "wheelDelta" in i ? -i.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), es = ze(Ga), Ar = [9, 13, 27, 32], lo = m && "CompositionEvent" in window, Ll = null;
  m && "documentMode" in document && (Ll = document.documentMode);
  var th = m && "TextEvent" in window && !Ll, Oy = m && (!lo || Ll && 8 < Ll && 11 >= Ll), $u = " ", Ny = !1;
  function jy(i, s) {
    switch (i) {
      case "keyup":
        return Ar.indexOf(s.keyCode) !== -1;
      case "keydown":
        return s.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function nh(i) {
    return i = i.detail, typeof i == "object" && "data" in i ? i.data : null;
  }
  var zu = !1;
  function Vx(i, s) {
    switch (i) {
      case "compositionend":
        return nh(s);
      case "keypress":
        return s.which !== 32 ? null : (Ny = !0, $u);
      case "textInput":
        return i = s.data, i === $u && Ny ? null : i;
      default:
        return null;
    }
  }
  function Hx(i, s) {
    if (zu) return i === "compositionend" || !lo && jy(i, s) ? (i = oe(), V = j = oo = null, zu = !1, i) : null;
    switch (i) {
      case "paste":
        return null;
      case "keypress":
        if (!(s.ctrlKey || s.altKey || s.metaKey) || s.ctrlKey && s.altKey) {
          if (s.char && 1 < s.char.length) return s.char;
          if (s.which) return String.fromCharCode(s.which);
        }
        return null;
      case "compositionend":
        return Oy && s.locale !== "ko" ? null : s.data;
      default:
        return null;
    }
  }
  var Ay = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };
  function Dy(i) {
    var s = i && i.nodeName && i.nodeName.toLowerCase();
    return s === "input" ? !!Ay[i.type] : s === "textarea";
  }
  function Py(i, s, h, v) {
    Wa(v), s = Nd(s, "onChange"), 0 < s.length && (h = new zt("onChange", "change", null, h, v), i.push({ event: h, listeners: s }));
  }
  var _d = null, Bu = null;
  function Vu(i) {
    oh(i, 0);
  }
  function Hu(i) {
    var s = qu(i);
    if (yr(s)) return i;
  }
  function My(i, s) {
    if (i === "change") return s;
  }
  var zm = !1;
  if (m) {
    var Bm;
    if (m) {
      var Vm = "oninput" in document;
      if (!Vm) {
        var Ly = document.createElement("div");
        Ly.setAttribute("oninput", "return;"), Vm = typeof Ly.oninput == "function";
      }
      Bm = Vm;
    } else Bm = !1;
    zm = Bm && (!document.documentMode || 9 < document.documentMode);
  }
  function Iy() {
    _d && (_d.detachEvent("onpropertychange", Uy), Bu = _d = null);
  }
  function Uy(i) {
    if (i.propertyName === "value" && Hu(Bu)) {
      var s = [];
      Py(s, Bu, i, dn(i)), Or(Vu, s);
    }
  }
  function Wx(i, s, h) {
    i === "focusin" ? (Iy(), _d = s, Bu = h, _d.attachEvent("onpropertychange", Uy)) : i === "focusout" && Iy();
  }
  function qx(i) {
    if (i === "selectionchange" || i === "keyup" || i === "keydown") return Hu(Bu);
  }
  function Yx(i, s) {
    if (i === "click") return Hu(s);
  }
  function Fy(i, s) {
    if (i === "input" || i === "change") return Hu(s);
  }
  function Kx(i, s) {
    return i === s && (i !== 0 || 1 / i === 1 / s) || i !== i && s !== s;
  }
  var Mi = typeof Object.is == "function" ? Object.is : Kx;
  function Ed(i, s) {
    if (Mi(i, s)) return !0;
    if (typeof i != "object" || i === null || typeof s != "object" || s === null) return !1;
    var h = Object.keys(i), v = Object.keys(s);
    if (h.length !== v.length) return !1;
    for (v = 0; v < h.length; v++) {
      var w = h[v];
      if (!y.call(s, w) || !Mi(i[w], s[w])) return !1;
    }
    return !0;
  }
  function $y(i) {
    for (; i && i.firstChild;) i = i.firstChild;
    return i;
  }
  function zy(i, s) {
    var h = $y(i);
    i = 0;
    for (var v; h;) {
      if (h.nodeType === 3) {
        if (v = i + h.textContent.length, i <= s && v >= s) return { node: h, offset: s - i };
        i = v;
      }
      e: {
        for (; h;) {
          if (h.nextSibling) {
            h = h.nextSibling;
            break e;
          }
          h = h.parentNode;
        }
        h = void 0;
      }
      h = $y(h);
    }
  }
  function By(i, s) {
    return i && s ? i === s ? !0 : i && i.nodeType === 3 ? !1 : s && s.nodeType === 3 ? By(i, s.parentNode) : "contains" in i ? i.contains(s) : i.compareDocumentPosition ? !!(i.compareDocumentPosition(s) & 16) : !1 : !1;
  }
  function rh() {
    for (var i = window, s = cn(); s instanceof i.HTMLIFrameElement;) {
      try {
        var h = typeof s.contentWindow.location.href == "string";
      } catch {
        h = !1;
      }
      if (h) i = s.contentWindow;
      else break;
      s = cn(i.document);
    }
    return s;
  }
  function ts(i) {
    var s = i && i.nodeName && i.nodeName.toLowerCase();
    return s && (s === "input" && (i.type === "text" || i.type === "search" || i.type === "tel" || i.type === "url" || i.type === "password") || s === "textarea" || i.contentEditable === "true");
  }
  function ah(i) {
    var s = rh(), h = i.focusedElem, v = i.selectionRange;
    if (s !== h && h && h.ownerDocument && By(h.ownerDocument.documentElement, h)) {
      if (v !== null && ts(h)) {
        if (s = v.start, i = v.end, i === void 0 && (i = s), "selectionStart" in h) h.selectionStart = s, h.selectionEnd = Math.min(i, h.value.length);
        else if (i = (s = h.ownerDocument || document) && s.defaultView || window, i.getSelection) {
          i = i.getSelection();
          var w = h.textContent.length, E = Math.min(v.start, w);
          v = v.end === void 0 ? E : Math.min(v.end, w), !i.extend && E > v && (w = v, v = E, E = w), w = zy(h, E);
          var P = zy(
            h,
            v
          );
          w && P && (i.rangeCount !== 1 || i.anchorNode !== w.node || i.anchorOffset !== w.offset || i.focusNode !== P.node || i.focusOffset !== P.offset) && (s = s.createRange(), s.setStart(w.node, w.offset), i.removeAllRanges(), E > v ? (i.addRange(s), i.extend(P.node, P.offset)) : (s.setEnd(P.node, P.offset), i.addRange(s)));
        }
      }
      for (s = [], i = h; i = i.parentNode;) i.nodeType === 1 && s.push({ element: i, left: i.scrollLeft, top: i.scrollTop });
      for (typeof h.focus == "function" && h.focus(), h = 0; h < s.length; h++) i = s[h], i.element.scrollLeft = i.left, i.element.scrollTop = i.top;
    }
  }
  var Vy = m && "documentMode" in document && 11 >= document.documentMode, uo = null, Hm = null, Cd = null, Wm = !1;
  function Hy(i, s, h) {
    var v = h.window === h ? h.document : h.nodeType === 9 ? h : h.ownerDocument;
    Wm || uo == null || uo !== cn(v) || (v = uo, "selectionStart" in v && ts(v) ? v = { start: v.selectionStart, end: v.selectionEnd } : (v = (v.ownerDocument && v.ownerDocument.defaultView || window).getSelection(), v = { anchorNode: v.anchorNode, anchorOffset: v.anchorOffset, focusNode: v.focusNode, focusOffset: v.focusOffset }), Cd && Ed(Cd, v) || (Cd = v, v = Nd(Hm, "onSelect"), 0 < v.length && (s = new zt("onSelect", "select", null, s, h), i.push({ event: s, listeners: v }), s.target = uo)));
  }
  function ih(i, s) {
    var h = {};
    return h[i.toLowerCase()] = s.toLowerCase(), h["Webkit" + i] = "webkit" + s, h["Moz" + i] = "moz" + s, h;
  }
  var Il = { animationend: ih("Animation", "AnimationEnd"), animationiteration: ih("Animation", "AnimationIteration"), animationstart: ih("Animation", "AnimationStart"), transitionend: ih("Transition", "TransitionEnd") }, qm = {}, Ym = {};
  m && (Ym = document.createElement("div").style, "AnimationEvent" in window || (delete Il.animationend.animation, delete Il.animationiteration.animation, delete Il.animationstart.animation), "TransitionEvent" in window || delete Il.transitionend.transition);
  function Jr(i) {
    if (qm[i]) return qm[i];
    if (!Il[i]) return i;
    var s = Il[i], h;
    for (h in s) if (s.hasOwnProperty(h) && h in Ym) return qm[i] = s[h];
    return i;
  }
  var Km = Jr("animationend"), Wy = Jr("animationiteration"), qy = Jr("animationstart"), Yy = Jr("transitionend"), Ky = /* @__PURE__ */ new Map(), Gy = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function ns(i, s) {
    Ky.set(i, s), c(s, [i]);
  }
  for (var Td = 0; Td < Gy.length; Td++) {
    var Ul = Gy[Td], Gx = Ul.toLowerCase(), Rd = Ul[0].toUpperCase() + Ul.slice(1);
    ns(Gx, "on" + Rd);
  }
  ns(Km, "onAnimationEnd"), ns(Wy, "onAnimationIteration"), ns(qy, "onAnimationStart"), ns("dblclick", "onDoubleClick"), ns("focusin", "onFocus"), ns("focusout", "onBlur"), ns(Yy, "onTransitionEnd"), f("onMouseEnter", ["mouseout", "mouseover"]), f("onMouseLeave", ["mouseout", "mouseover"]), f("onPointerEnter", ["pointerout", "pointerover"]), f("onPointerLeave", ["pointerout", "pointerover"]), c("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), c("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), c("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), c("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), c("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), c("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var kd = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), Qx = new Set("cancel close invalid load scroll toggle".split(" ").concat(kd));
  function Qy(i, s, h) {
    var v = i.type || "unknown-event";
    i.currentTarget = h, Te(v, s, void 0, i), i.currentTarget = null;
  }
  function oh(i, s) {
    s = (s & 4) !== 0;
    for (var h = 0; h < i.length; h++) {
      var v = i[h], w = v.event;
      v = v.listeners;
      e: {
        var E = void 0;
        if (s) for (var P = v.length - 1; 0 <= P; P--) {
          var z = v[P], q = z.instance, se = z.currentTarget;
          if (z = z.listener, q !== E && w.isPropagationStopped()) break e;
          Qy(w, z, se), E = q;
        }
        else for (P = 0; P < v.length; P++) {
          if (z = v[P], q = z.instance, se = z.currentTarget, z = z.listener, q !== E && w.isPropagationStopped()) break e;
          Qy(w, z, se), E = q;
        }
      }
    }
    if (_o) throw i = Eo, _o = !1, Eo = null, i;
  }
  function Ln(i, s) {
    var h = s[tv];
    h === void 0 && (h = s[tv] = /* @__PURE__ */ new Set());
    var v = i + "__bubble";
    h.has(v) || (Jy(s, i, 2, !1), h.add(v));
  }
  function Js(i, s, h) {
    var v = 0;
    s && (v |= 4), Jy(h, i, v, s);
  }
  var rs = "_reactListening" + Math.random().toString(36).slice(2);
  function Wu(i) {
    if (!i[rs]) {
      i[rs] = !0, o.forEach(function (h) {
        h !== "selectionchange" && (Qx.has(h) || Js(h, !1, i), Js(h, !0, i));
      });
      var s = i.nodeType === 9 ? i : i.ownerDocument;
      s === null || s[rs] || (s[rs] = !0, Js("selectionchange", !1, s));
    }
  }
  function Jy(i, s, h, v) {
    switch (bd(s)) {
      case 1:
        var w = Iu;
        break;
      case 4:
        w = Gs;
        break;
      default:
        w = Qs;
    }
    h = w.bind(null, s, h, i), w = void 0, !Kr || s !== "touchstart" && s !== "touchmove" && s !== "wheel" || (w = !0), v ? w !== void 0 ? i.addEventListener(s, h, { capture: !0, passive: w }) : i.addEventListener(s, h, !0) : w !== void 0 ? i.addEventListener(s, h, { passive: w }) : i.addEventListener(s, h, !1);
  }
  function sh(i, s, h, v, w) {
    var E = v;
    if (!(s & 1) && !(s & 2) && v !== null) e: for (; ;) {
      if (v === null) return;
      var P = v.tag;
      if (P === 3 || P === 4) {
        var z = v.stateNode.containerInfo;
        if (z === w || z.nodeType === 8 && z.parentNode === w) break;
        if (P === 4) for (P = v.return; P !== null;) {
          var q = P.tag;
          if ((q === 3 || q === 4) && (q = P.stateNode.containerInfo, q === w || q.nodeType === 8 && q.parentNode === w)) return;
          P = P.return;
        }
        for (; z !== null;) {
          if (P = Li(z), P === null) return;
          if (q = P.tag, q === 5 || q === 6) {
            v = E = P;
            continue e;
          }
          z = z.parentNode;
        }
      }
      v = v.return;
    }
    Or(function () {
      var se = E, Se = dn(h), _e = [];
      e: {
        var be = Ky.get(i);
        if (be !== void 0) {
          var He = zt, Je = i;
          switch (i) {
            case "keypress":
              if (ce(h) === 0) break e;
            case "keydown":
            case "keyup":
              He = zx;
              break;
            case "focusin":
              Je = "focus", He = so;
              break;
            case "focusout":
              Je = "blur", He = so;
              break;
            case "beforeblur":
            case "afterblur":
              He = so;
              break;
            case "click":
              if (h.button === 2) break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              He = Zo;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              He = wd;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              He = Bx;
              break;
            case Km:
            case Wy:
            case qy:
              He = Sd;
              break;
            case Yy:
              He = ky;
              break;
            case "scroll":
              He = Pn;
              break;
            case "wheel":
              He = es;
              break;
            case "copy":
            case "cut":
            case "paste":
              He = Fx;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              He = Xf;
          }
          var tt = (s & 4) !== 0, Er = !tt && i === "scroll", Z = tt ? be !== null ? be + "Capture" : null : be;
          tt = [];
          for (var Q = se, ne; Q !== null;) {
            ne = Q;
            var je = ne.stateNode;
            if (ne.tag === 5 && je !== null && (ne = je, Z !== null && (je = fr(Q, Z), je != null && tt.push(Od(Q, je, ne)))), Er) break;
            Q = Q.return;
          }
          0 < tt.length && (be = new He(be, Je, null, h, Se), _e.push({ event: be, listeners: tt }));
        }
      }
      if (!(s & 7)) {
        e: {
          if (be = i === "mouseover" || i === "pointerover", He = i === "mouseout" || i === "pointerout", be && h !== qr && (Je = h.relatedTarget || h.fromElement) && (Li(Je) || Je[as])) break e;
          if ((He || be) && (be = Se.window === Se ? Se : (be = Se.ownerDocument) ? be.defaultView || be.parentWindow : window, He ? (Je = h.relatedTarget || h.toElement, He = se, Je = Je ? Li(Je) : null, Je !== null && (Er = ot(Je), Je !== Er || Je.tag !== 5 && Je.tag !== 6) && (Je = null)) : (He = null, Je = se), He !== Je)) {
            if (tt = Zo, je = "onMouseLeave", Z = "onMouseEnter", Q = "mouse", (i === "pointerout" || i === "pointerover") && (tt = Xf, je = "onPointerLeave", Z = "onPointerEnter", Q = "pointer"), Er = He == null ? be : qu(He), ne = Je == null ? be : qu(Je), be = new tt(je, Q + "leave", He, h, Se), be.target = Er, be.relatedTarget = ne, je = null, Li(Se) === se && (tt = new tt(Z, Q + "enter", Je, h, Se), tt.target = ne, tt.relatedTarget = Er, je = tt), Er = je, He && Je) t: {
              for (tt = He, Z = Je, Q = 0, ne = tt; ne; ne = Fl(ne)) Q++;
              for (ne = 0, je = Z; je; je = Fl(je)) ne++;
              for (; 0 < Q - ne;) tt = Fl(tt), Q--;
              for (; 0 < ne - Q;) Z = Fl(Z), ne--;
              for (; Q--;) {
                if (tt === Z || Z !== null && tt === Z.alternate) break t;
                tt = Fl(tt), Z = Fl(Z);
              }
              tt = null;
            }
            else tt = null;
            He !== null && Gm(_e, be, He, tt, !1), Je !== null && Er !== null && Gm(_e, Er, Je, tt, !0);
          }
        }
        e: {
          if (be = se ? qu(se) : window, He = be.nodeName && be.nodeName.toLowerCase(), He === "select" || He === "input" && be.type === "file") var at = My;
          else if (Dy(be)) if (zm) at = Fy;
          else {
            at = qx;
            var wt = Wx;
          }
          else (He = be.nodeName) && He.toLowerCase() === "input" && (be.type === "checkbox" || be.type === "radio") && (at = Yx);
          if (at && (at = at(i, se))) {
            Py(_e, at, h, Se);
            break e;
          }
          wt && wt(i, be, se), i === "focusout" && (wt = be._wrapperState) && wt.controlled && be.type === "number" && br(be, "number", be.value);
        }
        switch (wt = se ? qu(se) : window, i) {
          case "focusin":
            (Dy(wt) || wt.contentEditable === "true") && (uo = wt, Hm = se, Cd = null);
            break;
          case "focusout":
            Cd = Hm = uo = null;
            break;
          case "mousedown":
            Wm = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            Wm = !1, Hy(_e, h, Se);
            break;
          case "selectionchange":
            if (Vy) break;
          case "keydown":
          case "keyup":
            Hy(_e, h, Se);
        }
        var Ze;
        if (lo) e: {
          switch (i) {
            case "compositionstart":
              var St = "onCompositionStart";
              break e;
            case "compositionend":
              St = "onCompositionEnd";
              break e;
            case "compositionupdate":
              St = "onCompositionUpdate";
              break e;
          }
          St = void 0;
        }
        else zu ? jy(i, h) && (St = "onCompositionEnd") : i === "keydown" && h.keyCode === 229 && (St = "onCompositionStart");
        St && (Oy && h.locale !== "ko" && (zu || St !== "onCompositionStart" ? St === "onCompositionEnd" && zu && (Ze = oe()) : (oo = Se, j = "value" in oo ? oo.value : oo.textContent, zu = !0)), wt = Nd(se, St), 0 < wt.length && (St = new Lm(St, i, null, h, Se), _e.push({ event: St, listeners: wt }), Ze ? St.data = Ze : (Ze = nh(h), Ze !== null && (St.data = Ze)))), (Ze = th ? Vx(i, h) : Hx(i, h)) && (se = Nd(se, "onBeforeInput"), 0 < se.length && (Se = new Lm("onBeforeInput", "beforeinput", null, h, Se), _e.push({ event: Se, listeners: se }), Se.data = Ze));
      }
      oh(_e, s);
    });
  }
  function Od(i, s, h) {
    return { instance: i, listener: s, currentTarget: h };
  }
  function Nd(i, s) {
    for (var h = s + "Capture", v = []; i !== null;) {
      var w = i, E = w.stateNode;
      w.tag === 5 && E !== null && (w = E, E = fr(i, h), E != null && v.unshift(Od(i, E, w)), E = fr(i, s), E != null && v.push(Od(i, E, w))), i = i.return;
    }
    return v;
  }
  function Fl(i) {
    if (i === null) return null;
    do
      i = i.return;
    while (i && i.tag !== 5);
    return i || null;
  }
  function Gm(i, s, h, v, w) {
    for (var E = s._reactName, P = []; h !== null && h !== v;) {
      var z = h, q = z.alternate, se = z.stateNode;
      if (q !== null && q === v) break;
      z.tag === 5 && se !== null && (z = se, w ? (q = fr(h, E), q != null && P.unshift(Od(h, q, z))) : w || (q = fr(h, E), q != null && P.push(Od(h, q, z)))), h = h.return;
    }
    P.length !== 0 && i.push({ event: s, listeners: P });
  }
  var Qm = /\r\n?/g, Jx = /\u0000|\uFFFD/g;
  function Jm(i) {
    return (typeof i == "string" ? i : "" + i).replace(Qm, `
`).replace(Jx, "");
  }
  function lh(i, s, h) {
    if (s = Jm(s), Jm(i) !== s && h) throw Error(r(425));
  }
  function uh() {
  }
  var Zm = null, $l = null;
  function jd(i, s) {
    return i === "textarea" || i === "noscript" || typeof s.children == "string" || typeof s.children == "number" || typeof s.dangerouslySetInnerHTML == "object" && s.dangerouslySetInnerHTML !== null && s.dangerouslySetInnerHTML.__html != null;
  }
  var zl = typeof setTimeout == "function" ? setTimeout : void 0, Zy = typeof clearTimeout == "function" ? clearTimeout : void 0, Xm = typeof Promise == "function" ? Promise : void 0, ev = typeof queueMicrotask == "function" ? queueMicrotask : typeof Xm < "u" ? function (i) {
    return Xm.resolve(null).then(i).catch(Zx);
  } : zl;
  function Zx(i) {
    setTimeout(function () {
      throw i;
    });
  }
  function Zs(i, s) {
    var h = s, v = 0;
    do {
      var w = h.nextSibling;
      if (i.removeChild(h), w && w.nodeType === 8) if (h = w.data, h === "/$") {
        if (v === 0) {
          i.removeChild(w), Ks(s);
          return;
        }
        v--;
      } else h !== "$" && h !== "$?" && h !== "$!" || v++;
      h = w;
    } while (h);
    Ks(s);
  }
  function co(i) {
    for (; i != null; i = i.nextSibling) {
      var s = i.nodeType;
      if (s === 1 || s === 3) break;
      if (s === 8) {
        if (s = i.data, s === "$" || s === "$!" || s === "$?") break;
        if (s === "/$") return null;
      }
    }
    return i;
  }
  function Ad(i) {
    i = i.previousSibling;
    for (var s = 0; i;) {
      if (i.nodeType === 8) {
        var h = i.data;
        if (h === "$" || h === "$!" || h === "$?") {
          if (s === 0) return i;
          s--;
        } else h === "/$" && s++;
      }
      i = i.previousSibling;
    }
    return null;
  }
  var Xs = Math.random().toString(36).slice(2), ko = "__reactFiber$" + Xs, Bl = "__reactProps$" + Xs, as = "__reactContainer$" + Xs, tv = "__reactEvents$" + Xs, Xx = "__reactListeners$" + Xs, nv = "__reactHandles$" + Xs;
  function Li(i) {
    var s = i[ko];
    if (s) return s;
    for (var h = i.parentNode; h;) {
      if (s = h[as] || h[ko]) {
        if (h = s.alternate, s.child !== null || h !== null && h.child !== null) for (i = Ad(i); i !== null;) {
          if (h = i[ko]) return h;
          i = Ad(i);
        }
        return s;
      }
      i = h, h = i.parentNode;
    }
    return null;
  }
  function Dd(i) {
    return i = i[ko] || i[as], !i || i.tag !== 5 && i.tag !== 6 && i.tag !== 13 && i.tag !== 3 ? null : i;
  }
  function qu(i) {
    if (i.tag === 5 || i.tag === 6) return i.stateNode;
    throw Error(r(33));
  }
  function ht(i) {
    return i[Bl] || null;
  }
  var el = [], Yn = -1;
  function Mt(i) {
    return { current: i };
  }
  function bn(i) {
    0 > Yn || (i.current = el[Yn], el[Yn] = null, Yn--);
  }
  function En(i, s) {
    Yn++, el[Yn] = i.current, i.current = s;
  }
  var Oo = {}, Tt = Mt(Oo), pr = Mt(!1), Qa = Oo;
  function Ii(i, s) {
    var h = i.type.contextTypes;
    if (!h) return Oo;
    var v = i.stateNode;
    if (v && v.__reactInternalMemoizedUnmaskedChildContext === s) return v.__reactInternalMemoizedMaskedChildContext;
    var w = {}, E;
    for (E in h) w[E] = s[E];
    return v && (i = i.stateNode, i.__reactInternalMemoizedUnmaskedChildContext = s, i.__reactInternalMemoizedMaskedChildContext = w), w;
  }
  function er(i) {
    return i = i.childContextTypes, i != null;
  }
  function Ui() {
    bn(pr), bn(Tt);
  }
  function tl(i, s, h) {
    if (Tt.current !== Oo) throw Error(r(168));
    En(Tt, s), En(pr, h);
  }
  function Pd(i, s, h) {
    var v = i.stateNode;
    if (s = s.childContextTypes, typeof v.getChildContext != "function") return h;
    v = v.getChildContext();
    for (var w in v) if (!(w in s)) throw Error(r(108, et(i) || "Unknown", w));
    return ge({}, h, v);
  }
  function ch(i) {
    return i = (i = i.stateNode) && i.__reactInternalMemoizedMergedChildContext || Oo, Qa = Tt.current, En(Tt, i), En(pr, pr.current), !0;
  }
  function Xy(i, s, h) {
    var v = i.stateNode;
    if (!v) throw Error(r(169));
    h ? (i = Pd(i, s, Qa), v.__reactInternalMemoizedMergedChildContext = i, bn(pr), bn(Tt), En(Tt, i)) : bn(pr), En(pr, h);
  }
  var vi = null, Zr = !1, Md = !1;
  function rv(i) {
    vi === null ? vi = [i] : vi.push(i);
  }
  function av(i) {
    Zr = !0, rv(i);
  }
  function Ja() {
    if (!Md && vi !== null) {
      Md = !0;
      var i = 0, s = pn;
      try {
        var h = vi;
        for (pn = 1; i < h.length; i++) {
          var v = h[i];
          do
            v = v(!0);
          while (v !== null);
        }
        vi = null, Zr = !1;
      } catch (w) {
        throw vi !== null && (vi = vi.slice(i + 1)), Dn(ja, Ja), w;
      } finally {
        pn = s, Md = !1;
      }
    }
    return null;
  }
  var nl = [], Za = 0, Vl = null, Yu = 0, Xa = [], xa = 0, Fi = null, oa = 1, is = "";
  function gi(i, s) {
    nl[Za++] = Yu, nl[Za++] = Vl, Vl = i, Yu = s;
  }
  function iv(i, s, h) {
    Xa[xa++] = oa, Xa[xa++] = is, Xa[xa++] = Fi, Fi = i;
    var v = oa;
    i = is;
    var w = 32 - Aa(v) - 1;
    v &= ~(1 << w), h += 1;
    var E = 32 - Aa(s) + w;
    if (30 < E) {
      var P = w - w % 5;
      E = (v & (1 << P) - 1).toString(32), v >>= P, w -= P, oa = 1 << 32 - Aa(s) + w | h << w | v, is = E + i;
    } else oa = 1 << E | h << w | v, is = i;
  }
  function dh(i) {
    i.return !== null && (gi(i, 1), iv(i, 1, 0));
  }
  function ov(i) {
    for (; i === Vl;) Vl = nl[--Za], nl[Za] = null, Yu = nl[--Za], nl[Za] = null;
    for (; i === Fi;) Fi = Xa[--xa], Xa[xa] = null, is = Xa[--xa], Xa[xa] = null, oa = Xa[--xa], Xa[xa] = null;
  }
  var yi = null, ei = null, Kn = !1, $i = null;
  function sv(i, s) {
    var h = Ki(5, null, null, 0);
    h.elementType = "DELETED", h.stateNode = s, h.return = i, s = i.deletions, s === null ? (i.deletions = [h], i.flags |= 16) : s.push(h);
  }
  function e0(i, s) {
    switch (i.tag) {
      case 5:
        var h = i.type;
        return s = s.nodeType !== 1 || h.toLowerCase() !== s.nodeName.toLowerCase() ? null : s, s !== null ? (i.stateNode = s, yi = i, ei = co(s.firstChild), !0) : !1;
      case 6:
        return s = i.pendingProps === "" || s.nodeType !== 3 ? null : s, s !== null ? (i.stateNode = s, yi = i, ei = null, !0) : !1;
      case 13:
        return s = s.nodeType !== 8 ? null : s, s !== null ? (h = Fi !== null ? { id: oa, overflow: is } : null, i.memoizedState = { dehydrated: s, treeContext: h, retryLane: 1073741824 }, h = Ki(18, null, null, 0), h.stateNode = s, h.return = i, i.child = h, yi = i, ei = null, !0) : !1;
      default:
        return !1;
    }
  }
  function fh(i) {
    return (i.mode & 1) !== 0 && (i.flags & 128) === 0;
  }
  function hh(i) {
    if (Kn) {
      var s = ei;
      if (s) {
        var h = s;
        if (!e0(i, s)) {
          if (fh(i)) throw Error(r(418));
          s = co(h.nextSibling);
          var v = yi;
          s && e0(i, s) ? sv(v, h) : (i.flags = i.flags & -4097 | 2, Kn = !1, yi = i);
        }
      } else {
        if (fh(i)) throw Error(r(418));
        i.flags = i.flags & -4097 | 2, Kn = !1, yi = i;
      }
    }
  }
  function t0(i) {
    for (i = i.return; i !== null && i.tag !== 5 && i.tag !== 3 && i.tag !== 13;) i = i.return;
    yi = i;
  }
  function ph(i) {
    if (i !== yi) return !1;
    if (!Kn) return t0(i), Kn = !0, !1;
    var s;
    if ((s = i.tag !== 3) && !(s = i.tag !== 5) && (s = i.type, s = s !== "head" && s !== "body" && !jd(i.type, i.memoizedProps)), s && (s = ei)) {
      if (fh(i)) throw n0(), Error(r(418));
      for (; s;) sv(i, s), s = co(s.nextSibling);
    }
    if (t0(i), i.tag === 13) {
      if (i = i.memoizedState, i = i !== null ? i.dehydrated : null, !i) throw Error(r(317));
      e: {
        for (i = i.nextSibling, s = 0; i;) {
          if (i.nodeType === 8) {
            var h = i.data;
            if (h === "/$") {
              if (s === 0) {
                ei = co(i.nextSibling);
                break e;
              }
              s--;
            } else h !== "$" && h !== "$!" && h !== "$?" || s++;
          }
          i = i.nextSibling;
        }
        ei = null;
      }
    } else ei = yi ? co(i.stateNode.nextSibling) : null;
    return !0;
  }
  function n0() {
    for (var i = ei; i;) i = co(i.nextSibling);
  }
  function sr() {
    ei = yi = null, Kn = !1;
  }
  function lv(i) {
    $i === null ? $i = [i] : $i.push(i);
  }
  var mh = B.ReactCurrentBatchConfig;
  function Hl(i, s, h) {
    if (i = h.ref, i !== null && typeof i != "function" && typeof i != "object") {
      if (h._owner) {
        if (h = h._owner, h) {
          if (h.tag !== 1) throw Error(r(309));
          var v = h.stateNode;
        }
        if (!v) throw Error(r(147, i));
        var w = v, E = "" + i;
        return s !== null && s.ref !== null && typeof s.ref == "function" && s.ref._stringRef === E ? s.ref : (s = function (P) {
          var z = w.refs;
          P === null ? delete z[E] : z[E] = P;
        }, s._stringRef = E, s);
      }
      if (typeof i != "string") throw Error(r(284));
      if (!h._owner) throw Error(r(290, i));
    }
    return i;
  }
  function No(i, s) {
    throw i = Object.prototype.toString.call(s), Error(r(31, i === "[object Object]" ? "object with keys {" + Object.keys(s).join(", ") + "}" : i));
  }
  function r0(i) {
    var s = i._init;
    return s(i._payload);
  }
  function vh(i) {
    function s(Z, Q) {
      if (i) {
        var ne = Z.deletions;
        ne === null ? (Z.deletions = [Q], Z.flags |= 16) : ne.push(Q);
      }
    }
    function h(Z, Q) {
      if (!i) return null;
      for (; Q !== null;) s(Z, Q), Q = Q.sibling;
      return null;
    }
    function v(Z, Q) {
      for (Z = /* @__PURE__ */ new Map(); Q !== null;) Q.key !== null ? Z.set(Q.key, Q) : Z.set(Q.index, Q), Q = Q.sibling;
      return Z;
    }
    function w(Z, Q) {
      return Z = cl(Z, Q), Z.index = 0, Z.sibling = null, Z;
    }
    function E(Z, Q, ne) {
      return Z.index = ne, i ? (ne = Z.alternate, ne !== null ? (ne = ne.index, ne < Q ? (Z.flags |= 2, Q) : ne) : (Z.flags |= 2, Q)) : (Z.flags |= 1048576, Q);
    }
    function P(Z) {
      return i && Z.alternate === null && (Z.flags |= 2), Z;
    }
    function z(Z, Q, ne, je) {
      return Q === null || Q.tag !== 6 ? (Q = rp(ne, Z.mode, je), Q.return = Z, Q) : (Q = w(Q, ne), Q.return = Z, Q);
    }
    function q(Z, Q, ne, je) {
      var at = ne.type;
      return at === re ? Se(Z, Q, ne.props.children, je, ne.key) : Q !== null && (Q.elementType === at || typeof at == "object" && at !== null && at.$$typeof === Me && r0(at) === Q.type) ? (je = w(Q, ne.props), je.ref = Hl(Z, Q, ne), je.return = Z, je) : (je = tp(ne.type, ne.key, ne.props, null, Z.mode, je), je.ref = Hl(Z, Q, ne), je.return = Z, je);
    }
    function se(Z, Q, ne, je) {
      return Q === null || Q.tag !== 4 || Q.stateNode.containerInfo !== ne.containerInfo || Q.stateNode.implementation !== ne.implementation ? (Q = Xd(ne, Z.mode, je), Q.return = Z, Q) : (Q = w(Q, ne.children || []), Q.return = Z, Q);
    }
    function Se(Z, Q, ne, je, at) {
      return Q === null || Q.tag !== 7 ? (Q = iu(ne, Z.mode, je, at), Q.return = Z, Q) : (Q = w(Q, ne), Q.return = Z, Q);
    }
    function _e(Z, Q, ne) {
      if (typeof Q == "string" && Q !== "" || typeof Q == "number") return Q = rp("" + Q, Z.mode, ne), Q.return = Z, Q;
      if (typeof Q == "object" && Q !== null) {
        switch (Q.$$typeof) {
          case K:
            return ne = tp(Q.type, Q.key, Q.props, null, Z.mode, ne), ne.ref = Hl(Z, null, Q), ne.return = Z, ne;
          case te:
            return Q = Xd(Q, Z.mode, ne), Q.return = Z, Q;
          case Me:
            var je = Q._init;
            return _e(Z, je(Q._payload), ne);
        }
        if (wr(Q) || he(Q)) return Q = iu(Q, Z.mode, ne, null), Q.return = Z, Q;
        No(Z, Q);
      }
      return null;
    }
    function be(Z, Q, ne, je) {
      var at = Q !== null ? Q.key : null;
      if (typeof ne == "string" && ne !== "" || typeof ne == "number") return at !== null ? null : z(Z, Q, "" + ne, je);
      if (typeof ne == "object" && ne !== null) {
        switch (ne.$$typeof) {
          case K:
            return ne.key === at ? q(Z, Q, ne, je) : null;
          case te:
            return ne.key === at ? se(Z, Q, ne, je) : null;
          case Me:
            return at = ne._init, be(
              Z,
              Q,
              at(ne._payload),
              je
            );
        }
        if (wr(ne) || he(ne)) return at !== null ? null : Se(Z, Q, ne, je, null);
        No(Z, ne);
      }
      return null;
    }
    function He(Z, Q, ne, je, at) {
      if (typeof je == "string" && je !== "" || typeof je == "number") return Z = Z.get(ne) || null, z(Q, Z, "" + je, at);
      if (typeof je == "object" && je !== null) {
        switch (je.$$typeof) {
          case K:
            return Z = Z.get(je.key === null ? ne : je.key) || null, q(Q, Z, je, at);
          case te:
            return Z = Z.get(je.key === null ? ne : je.key) || null, se(Q, Z, je, at);
          case Me:
            var wt = je._init;
            return He(Z, Q, ne, wt(je._payload), at);
        }
        if (wr(je) || he(je)) return Z = Z.get(ne) || null, Se(Q, Z, je, at, null);
        No(Q, je);
      }
      return null;
    }
    function Je(Z, Q, ne, je) {
      for (var at = null, wt = null, Ze = Q, St = Q = 0, Vr = null; Ze !== null && St < ne.length; St++) {
        Ze.index > St ? (Vr = Ze, Ze = null) : Vr = Ze.sibling;
        var mn = be(Z, Ze, ne[St], je);
        if (mn === null) {
          Ze === null && (Ze = Vr);
          break;
        }
        i && Ze && mn.alternate === null && s(Z, Ze), Q = E(mn, Q, St), wt === null ? at = mn : wt.sibling = mn, wt = mn, Ze = Vr;
      }
      if (St === ne.length) return h(Z, Ze), Kn && gi(Z, St), at;
      if (Ze === null) {
        for (; St < ne.length; St++) Ze = _e(Z, ne[St], je), Ze !== null && (Q = E(Ze, Q, St), wt === null ? at = Ze : wt.sibling = Ze, wt = Ze);
        return Kn && gi(Z, St), at;
      }
      for (Ze = v(Z, Ze); St < ne.length; St++) Vr = He(Ze, Z, St, ne[St], je), Vr !== null && (i && Vr.alternate !== null && Ze.delete(Vr.key === null ? St : Vr.key), Q = E(Vr, Q, St), wt === null ? at = Vr : wt.sibling = Vr, wt = Vr);
      return i && Ze.forEach(function (fs) {
        return s(Z, fs);
      }), Kn && gi(Z, St), at;
    }
    function tt(Z, Q, ne, je) {
      var at = he(ne);
      if (typeof at != "function") throw Error(r(150));
      if (ne = at.call(ne), ne == null) throw Error(r(151));
      for (var wt = at = null, Ze = Q, St = Q = 0, Vr = null, mn = ne.next(); Ze !== null && !mn.done; St++, mn = ne.next()) {
        Ze.index > St ? (Vr = Ze, Ze = null) : Vr = Ze.sibling;
        var fs = be(Z, Ze, mn.value, je);
        if (fs === null) {
          Ze === null && (Ze = Vr);
          break;
        }
        i && Ze && fs.alternate === null && s(Z, Ze), Q = E(fs, Q, St), wt === null ? at = fs : wt.sibling = fs, wt = fs, Ze = Vr;
      }
      if (mn.done) return h(
        Z,
        Ze
      ), Kn && gi(Z, St), at;
      if (Ze === null) {
        for (; !mn.done; St++, mn = ne.next()) mn = _e(Z, mn.value, je), mn !== null && (Q = E(mn, Q, St), wt === null ? at = mn : wt.sibling = mn, wt = mn);
        return Kn && gi(Z, St), at;
      }
      for (Ze = v(Z, Ze); !mn.done; St++, mn = ne.next()) mn = He(Ze, Z, St, mn.value, je), mn !== null && (i && mn.alternate !== null && Ze.delete(mn.key === null ? St : mn.key), Q = E(mn, Q, St), wt === null ? at = mn : wt.sibling = mn, wt = mn);
      return i && Ze.forEach(function (gS) {
        return s(Z, gS);
      }), Kn && gi(Z, St), at;
    }
    function Er(Z, Q, ne, je) {
      if (typeof ne == "object" && ne !== null && ne.type === re && ne.key === null && (ne = ne.props.children), typeof ne == "object" && ne !== null) {
        switch (ne.$$typeof) {
          case K:
            e: {
              for (var at = ne.key, wt = Q; wt !== null;) {
                if (wt.key === at) {
                  if (at = ne.type, at === re) {
                    if (wt.tag === 7) {
                      h(Z, wt.sibling), Q = w(wt, ne.props.children), Q.return = Z, Z = Q;
                      break e;
                    }
                  } else if (wt.elementType === at || typeof at == "object" && at !== null && at.$$typeof === Me && r0(at) === wt.type) {
                    h(Z, wt.sibling), Q = w(wt, ne.props), Q.ref = Hl(Z, wt, ne), Q.return = Z, Z = Q;
                    break e;
                  }
                  h(Z, wt);
                  break;
                } else s(Z, wt);
                wt = wt.sibling;
              }
              ne.type === re ? (Q = iu(ne.props.children, Z.mode, je, ne.key), Q.return = Z, Z = Q) : (je = tp(ne.type, ne.key, ne.props, null, Z.mode, je), je.ref = Hl(Z, Q, ne), je.return = Z, Z = je);
            }
            return P(Z);
          case te:
            e: {
              for (wt = ne.key; Q !== null;) {
                if (Q.key === wt) if (Q.tag === 4 && Q.stateNode.containerInfo === ne.containerInfo && Q.stateNode.implementation === ne.implementation) {
                  h(Z, Q.sibling), Q = w(Q, ne.children || []), Q.return = Z, Z = Q;
                  break e;
                } else {
                  h(Z, Q);
                  break;
                }
                else s(Z, Q);
                Q = Q.sibling;
              }
              Q = Xd(ne, Z.mode, je), Q.return = Z, Z = Q;
            }
            return P(Z);
          case Me:
            return wt = ne._init, Er(Z, Q, wt(ne._payload), je);
        }
        if (wr(ne)) return Je(Z, Q, ne, je);
        if (he(ne)) return tt(Z, Q, ne, je);
        No(Z, ne);
      }
      return typeof ne == "string" && ne !== "" || typeof ne == "number" ? (ne = "" + ne, Q !== null && Q.tag === 6 ? (h(Z, Q.sibling), Q = w(Q, ne), Q.return = Z, Z = Q) : (h(Z, Q), Q = rp(ne, Z.mode, je), Q.return = Z, Z = Q), P(Z)) : h(Z, Q);
    }
    return Er;
  }
  var Ku = vh(!0), a0 = vh(!1), os = Mt(null), Fr = null, Fe = null, zi = null;
  function bi() {
    zi = Fe = Fr = null;
  }
  function uv(i) {
    var s = os.current;
    bn(os), i._currentValue = s;
  }
  function cv(i, s, h) {
    for (; i !== null;) {
      var v = i.alternate;
      if ((i.childLanes & s) !== s ? (i.childLanes |= s, v !== null && (v.childLanes |= s)) : v !== null && (v.childLanes & s) !== s && (v.childLanes |= s), i === h) break;
      i = i.return;
    }
  }
  function Gu(i, s) {
    Fr = i, zi = Fe = null, i = i.dependencies, i !== null && i.firstContext !== null && (i.lanes & s && (ri = !0), i.firstContext = null);
  }
  function Bi(i) {
    var s = i._currentValue;
    if (zi !== i) if (i = { context: i, memoizedValue: s, next: null }, Fe === null) {
      if (Fr === null) throw Error(r(308));
      Fe = i, Fr.dependencies = { lanes: 0, firstContext: i };
    } else Fe = Fe.next = i;
    return s;
  }
  var Wl = null;
  function Dr(i) {
    Wl === null ? Wl = [i] : Wl.push(i);
  }
  function i0(i, s, h, v) {
    var w = s.interleaved;
    return w === null ? (h.next = h, Dr(s)) : (h.next = w.next, w.next = h), s.interleaved = h, ss(i, v);
  }
  function ss(i, s) {
    i.lanes |= s;
    var h = i.alternate;
    for (h !== null && (h.lanes |= s), h = i, i = i.return; i !== null;) i.childLanes |= s, h = i.alternate, h !== null && (h.childLanes |= s), h = i, i = i.return;
    return h.tag === 3 ? h.stateNode : null;
  }
  var rl = !1;
  function gh(i) {
    i.updateQueue = { baseState: i.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
  }
  function Qu(i, s) {
    i = i.updateQueue, s.updateQueue === i && (s.updateQueue = { baseState: i.baseState, firstBaseUpdate: i.firstBaseUpdate, lastBaseUpdate: i.lastBaseUpdate, shared: i.shared, effects: i.effects });
  }
  function ti(i, s) {
    return { eventTime: i, lane: s, tag: 0, payload: null, callback: null, next: null };
  }
  function al(i, s, h) {
    var v = i.updateQueue;
    if (v === null) return null;
    if (v = v.shared, Yt & 2) {
      var w = v.pending;
      return w === null ? s.next = s : (s.next = w.next, w.next = s), v.pending = s, ss(i, h);
    }
    return w = v.interleaved, w === null ? (s.next = s, Dr(v)) : (s.next = w.next, w.next = s), v.interleaved = s, ss(i, h);
  }
  function yh(i, s, h) {
    if (s = s.updateQueue, s !== null && (s = s.shared, (h & 4194240) !== 0)) {
      var v = s.lanes;
      v &= i.pendingLanes, h |= v, s.lanes = h, To(i, h);
    }
  }
  function o0(i, s) {
    var h = i.updateQueue, v = i.alternate;
    if (v !== null && (v = v.updateQueue, h === v)) {
      var w = null, E = null;
      if (h = h.firstBaseUpdate, h !== null) {
        do {
          var P = { eventTime: h.eventTime, lane: h.lane, tag: h.tag, payload: h.payload, callback: h.callback, next: null };
          E === null ? w = E = P : E = E.next = P, h = h.next;
        } while (h !== null);
        E === null ? w = E = s : E = E.next = s;
      } else w = E = s;
      h = { baseState: v.baseState, firstBaseUpdate: w, lastBaseUpdate: E, shared: v.shared, effects: v.effects }, i.updateQueue = h;
      return;
    }
    i = h.lastBaseUpdate, i === null ? h.firstBaseUpdate = s : i.next = s, h.lastBaseUpdate = s;
  }
  function bh(i, s, h, v) {
    var w = i.updateQueue;
    rl = !1;
    var E = w.firstBaseUpdate, P = w.lastBaseUpdate, z = w.shared.pending;
    if (z !== null) {
      w.shared.pending = null;
      var q = z, se = q.next;
      q.next = null, P === null ? E = se : P.next = se, P = q;
      var Se = i.alternate;
      Se !== null && (Se = Se.updateQueue, z = Se.lastBaseUpdate, z !== P && (z === null ? Se.firstBaseUpdate = se : z.next = se, Se.lastBaseUpdate = q));
    }
    if (E !== null) {
      var _e = w.baseState;
      P = 0, Se = se = q = null, z = E;
      do {
        var be = z.lane, He = z.eventTime;
        if ((v & be) === be) {
          Se !== null && (Se = Se.next = {
            eventTime: He,
            lane: 0,
            tag: z.tag,
            payload: z.payload,
            callback: z.callback,
            next: null
          });
          e: {
            var Je = i, tt = z;
            switch (be = s, He = h, tt.tag) {
              case 1:
                if (Je = tt.payload, typeof Je == "function") {
                  _e = Je.call(He, _e, be);
                  break e;
                }
                _e = Je;
                break e;
              case 3:
                Je.flags = Je.flags & -65537 | 128;
              case 0:
                if (Je = tt.payload, be = typeof Je == "function" ? Je.call(He, _e, be) : Je, be == null) break e;
                _e = ge({}, _e, be);
                break e;
              case 2:
                rl = !0;
            }
          }
          z.callback !== null && z.lane !== 0 && (i.flags |= 64, be = w.effects, be === null ? w.effects = [z] : be.push(z));
        } else He = { eventTime: He, lane: be, tag: z.tag, payload: z.payload, callback: z.callback, next: null }, Se === null ? (se = Se = He, q = _e) : Se = Se.next = He, P |= be;
        if (z = z.next, z === null) {
          if (z = w.shared.pending, z === null) break;
          be = z, z = be.next, be.next = null, w.lastBaseUpdate = be, w.shared.pending = null;
        }
      } while (!0);
      if (Se === null && (q = _e), w.baseState = q, w.firstBaseUpdate = se, w.lastBaseUpdate = Se, s = w.shared.interleaved, s !== null) {
        w = s;
        do
          P |= w.lane, w = w.next;
        while (w !== s);
      } else E === null && (w.shared.lanes = 0);
      tu |= P, i.lanes = P, i.memoizedState = _e;
    }
  }
  function s0(i, s, h) {
    if (i = s.effects, s.effects = null, i !== null) for (s = 0; s < i.length; s++) {
      var v = i[s], w = v.callback;
      if (w !== null) {
        if (v.callback = null, v = h, typeof w != "function") throw Error(r(191, w));
        w.call(v);
      }
    }
  }
  var Ld = {}, fo = Mt(Ld), Ju = Mt(Ld), Id = Mt(Ld);
  function ql(i) {
    if (i === Ld) throw Error(r(174));
    return i;
  }
  function dv(i, s) {
    switch (En(Id, s), En(Ju, i), En(fo, Ld), i = s.nodeType, i) {
      case 9:
      case 11:
        s = (s = s.documentElement) ? s.namespaceURI : Sn(null, "");
        break;
      default:
        i = i === 8 ? s.parentNode : s, s = i.namespaceURI || null, i = i.tagName, s = Sn(s, i);
    }
    bn(fo), En(fo, s);
  }
  function Zu() {
    bn(fo), bn(Ju), bn(Id);
  }
  function l0(i) {
    ql(Id.current);
    var s = ql(fo.current), h = Sn(s, i.type);
    s !== h && (En(Ju, i), En(fo, h));
  }
  function fv(i) {
    Ju.current === i && (bn(fo), bn(Ju));
  }
  var tr = Mt(0);
  function wh(i) {
    for (var s = i; s !== null;) {
      if (s.tag === 13) {
        var h = s.memoizedState;
        if (h !== null && (h = h.dehydrated, h === null || h.data === "$?" || h.data === "$!")) return s;
      } else if (s.tag === 19 && s.memoizedProps.revealOrder !== void 0) {
        if (s.flags & 128) return s;
      } else if (s.child !== null) {
        s.child.return = s, s = s.child;
        continue;
      }
      if (s === i) break;
      for (; s.sibling === null;) {
        if (s.return === null || s.return === i) return null;
        s = s.return;
      }
      s.sibling.return = s.return, s = s.sibling;
    }
    return null;
  }
  var xh = [];
  function hv() {
    for (var i = 0; i < xh.length; i++) xh[i]._workInProgressVersionPrimary = null;
    xh.length = 0;
  }
  var Sh = B.ReactCurrentDispatcher, Ud = B.ReactCurrentBatchConfig, rt = 0, st = null, Rt = null, Bt = null, wi = !1, Xu = !1, Fd = 0, eS = 0;
  function Sa() {
    throw Error(r(321));
  }
  function $d(i, s) {
    if (s === null) return !1;
    for (var h = 0; h < s.length && h < i.length; h++) if (!Mi(i[h], s[h])) return !1;
    return !0;
  }
  function ye(i, s, h, v, w, E) {
    if (rt = E, st = s, s.memoizedState = null, s.updateQueue = null, s.lanes = 0, Sh.current = i === null || i.memoizedState === null ? tS : $n, i = h(v, w), Xu) {
      E = 0;
      do {
        if (Xu = !1, Fd = 0, 25 <= E) throw Error(r(301));
        E += 1, Bt = Rt = null, s.updateQueue = null, Sh.current = Ih, i = h(v, w);
      } while (Xu);
    }
    if (Sh.current = _a, s = Rt !== null && Rt.next !== null, rt = 0, Bt = Rt = st = null, wi = !1, s) throw Error(r(300));
    return i;
  }
  function Pr() {
    var i = Fd !== 0;
    return Fd = 0, i;
  }
  function ft() {
    var i = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    return Bt === null ? st.memoizedState = Bt = i : Bt = Bt.next = i, Bt;
  }
  function sa() {
    if (Rt === null) {
      var i = st.alternate;
      i = i !== null ? i.memoizedState : null;
    } else i = Rt.next;
    var s = Bt === null ? st.memoizedState : Bt.next;
    if (s !== null) Bt = s, Rt = i;
    else {
      if (i === null) throw Error(r(310));
      Rt = i, i = { memoizedState: Rt.memoizedState, baseState: Rt.baseState, baseQueue: Rt.baseQueue, queue: Rt.queue, next: null }, Bt === null ? st.memoizedState = Bt = i : Bt = Bt.next = i;
    }
    return Bt;
  }
  function xi(i, s) {
    return typeof s == "function" ? s(i) : s;
  }
  function ls(i) {
    var s = sa(), h = s.queue;
    if (h === null) throw Error(r(311));
    h.lastRenderedReducer = i;
    var v = Rt, w = v.baseQueue, E = h.pending;
    if (E !== null) {
      if (w !== null) {
        var P = w.next;
        w.next = E.next, E.next = P;
      }
      v.baseQueue = w = E, h.pending = null;
    }
    if (w !== null) {
      E = w.next, v = v.baseState;
      var z = P = null, q = null, se = E;
      do {
        var Se = se.lane;
        if ((rt & Se) === Se) q !== null && (q = q.next = { lane: 0, action: se.action, hasEagerState: se.hasEagerState, eagerState: se.eagerState, next: null }), v = se.hasEagerState ? se.eagerState : i(v, se.action);
        else {
          var _e = {
            lane: Se,
            action: se.action,
            hasEagerState: se.hasEagerState,
            eagerState: se.eagerState,
            next: null
          };
          q === null ? (z = q = _e, P = v) : q = q.next = _e, st.lanes |= Se, tu |= Se;
        }
        se = se.next;
      } while (se !== null && se !== E);
      q === null ? P = v : q.next = z, Mi(v, s.memoizedState) || (ri = !0), s.memoizedState = v, s.baseState = P, s.baseQueue = q, h.lastRenderedState = v;
    }
    if (i = h.interleaved, i !== null) {
      w = i;
      do
        E = w.lane, st.lanes |= E, tu |= E, w = w.next;
      while (w !== i);
    } else w === null && (h.lanes = 0);
    return [s.memoizedState, h.dispatch];
  }
  function Vi(i) {
    var s = sa(), h = s.queue;
    if (h === null) throw Error(r(311));
    h.lastRenderedReducer = i;
    var v = h.dispatch, w = h.pending, E = s.memoizedState;
    if (w !== null) {
      h.pending = null;
      var P = w = w.next;
      do
        E = i(E, P.action), P = P.next;
      while (P !== w);
      Mi(E, s.memoizedState) || (ri = !0), s.memoizedState = E, s.baseQueue === null && (s.baseState = E), h.lastRenderedState = E;
    }
    return [E, v];
  }
  function ec() {
  }
  function Yl(i, s) {
    var h = st, v = sa(), w = s(), E = !Mi(v.memoizedState, w);
    if (E && (v.memoizedState = w, ri = !0), v = v.queue, zd(Eh.bind(null, h, v, i), [i]), v.getSnapshot !== s || E || Bt !== null && Bt.memoizedState.tag & 1) {
      if (h.flags |= 2048, Kl(9, _h.bind(null, h, v, w, s), void 0, null), vr === null) throw Error(r(349));
      rt & 30 || tc(h, s, w);
    }
    return w;
  }
  function tc(i, s, h) {
    i.flags |= 16384, i = { getSnapshot: s, value: h }, s = st.updateQueue, s === null ? (s = { lastEffect: null, stores: null }, st.updateQueue = s, s.stores = [i]) : (h = s.stores, h === null ? s.stores = [i] : h.push(i));
  }
  function _h(i, s, h, v) {
    s.value = h, s.getSnapshot = v, Ch(s) && Th(i);
  }
  function Eh(i, s, h) {
    return h(function () {
      Ch(s) && Th(i);
    });
  }
  function Ch(i) {
    var s = i.getSnapshot;
    i = i.value;
    try {
      var h = s();
      return !Mi(i, h);
    } catch {
      return !0;
    }
  }
  function Th(i) {
    var s = ss(i, 1);
    s !== null && lr(s, i, 1, -1);
  }
  function Rh(i) {
    var s = ft();
    return typeof i == "function" && (i = i()), s.memoizedState = s.baseState = i, i = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: xi, lastRenderedState: i }, s.queue = i, i = i.dispatch = Bd.bind(null, st, i), [s.memoizedState, i];
  }
  function Kl(i, s, h, v) {
    return i = { tag: i, create: s, destroy: h, deps: v, next: null }, s = st.updateQueue, s === null ? (s = { lastEffect: null, stores: null }, st.updateQueue = s, s.lastEffect = i.next = i) : (h = s.lastEffect, h === null ? s.lastEffect = i.next = i : (v = h.next, h.next = i, i.next = v, s.lastEffect = i)), i;
  }
  function kh() {
    return sa().memoizedState;
  }
  function nc(i, s, h, v) {
    var w = ft();
    st.flags |= i, w.memoizedState = Kl(1 | s, h, void 0, v === void 0 ? null : v);
  }
  function rc(i, s, h, v) {
    var w = sa();
    v = v === void 0 ? null : v;
    var E = void 0;
    if (Rt !== null) {
      var P = Rt.memoizedState;
      if (E = P.destroy, v !== null && $d(v, P.deps)) {
        w.memoizedState = Kl(s, h, E, v);
        return;
      }
    }
    st.flags |= i, w.memoizedState = Kl(1 | s, h, E, v);
  }
  function Oh(i, s) {
    return nc(8390656, 8, i, s);
  }
  function zd(i, s) {
    return rc(2048, 8, i, s);
  }
  function Nh(i, s) {
    return rc(4, 2, i, s);
  }
  function jh(i, s) {
    return rc(4, 4, i, s);
  }
  function Ah(i, s) {
    if (typeof s == "function") return i = i(), s(i), function () {
      s(null);
    };
    if (s != null) return i = i(), s.current = i, function () {
      s.current = null;
    };
  }
  function Dh(i, s, h) {
    return h = h != null ? h.concat([i]) : null, rc(4, 4, Ah.bind(null, s, i), h);
  }
  function ac() {
  }
  function Gl(i, s) {
    var h = sa();
    s = s === void 0 ? null : s;
    var v = h.memoizedState;
    return v !== null && s !== null && $d(s, v[1]) ? v[0] : (h.memoizedState = [i, s], i);
  }
  function Ph(i, s) {
    var h = sa();
    s = s === void 0 ? null : s;
    var v = h.memoizedState;
    return v !== null && s !== null && $d(s, v[1]) ? v[0] : (i = i(), h.memoizedState = [i, s], i);
  }
  function Mh(i, s, h) {
    return rt & 21 ? (Mi(h, s) || (h = ju(), st.lanes |= h, tu |= h, i.baseState = !0), s) : (i.baseState && (i.baseState = !1, ri = !0), i.memoizedState = h);
  }
  function pv(i, s) {
    var h = pn;
    pn = h !== 0 && 4 > h ? h : 4, i(!0);
    var v = Ud.transition;
    Ud.transition = {};
    try {
      i(!1), s();
    } finally {
      pn = h, Ud.transition = v;
    }
  }
  function Lh() {
    return sa().memoizedState;
  }
  function u0(i, s, h) {
    var v = ds(i);
    if (h = { lane: v, action: h, hasEagerState: !1, eagerState: null, next: null }, mv(i)) ic(s, h);
    else if (h = i0(i, s, h, v), h !== null) {
      var w = ta();
      lr(h, i, v, w), il(h, s, v);
    }
  }
  function Bd(i, s, h) {
    var v = ds(i), w = { lane: v, action: h, hasEagerState: !1, eagerState: null, next: null };
    if (mv(i)) ic(s, w);
    else {
      var E = i.alternate;
      if (i.lanes === 0 && (E === null || E.lanes === 0) && (E = s.lastRenderedReducer, E !== null)) try {
        var P = s.lastRenderedState, z = E(P, h);
        if (w.hasEagerState = !0, w.eagerState = z, Mi(z, P)) {
          var q = s.interleaved;
          q === null ? (w.next = w, Dr(s)) : (w.next = q.next, q.next = w), s.interleaved = w;
          return;
        }
      } catch {
      } finally {
      }
      h = i0(i, s, w, v), h !== null && (w = ta(), lr(h, i, v, w), il(h, s, v));
    }
  }
  function mv(i) {
    var s = i.alternate;
    return i === st || s !== null && s === st;
  }
  function ic(i, s) {
    Xu = wi = !0;
    var h = i.pending;
    h === null ? s.next = s : (s.next = h.next, h.next = s), i.pending = s;
  }
  function il(i, s, h) {
    if (h & 4194240) {
      var v = s.lanes;
      v &= i.pendingLanes, h |= v, s.lanes = h, To(i, h);
    }
  }
  var _a = { readContext: Bi, useCallback: Sa, useContext: Sa, useEffect: Sa, useImperativeHandle: Sa, useInsertionEffect: Sa, useLayoutEffect: Sa, useMemo: Sa, useReducer: Sa, useRef: Sa, useState: Sa, useDebugValue: Sa, useDeferredValue: Sa, useTransition: Sa, useMutableSource: Sa, useSyncExternalStore: Sa, useId: Sa, unstable_isNewReconciler: !1 }, tS = {
    readContext: Bi, useCallback: function (i, s) {
      return ft().memoizedState = [i, s === void 0 ? null : s], i;
    }, useContext: Bi, useEffect: Oh, useImperativeHandle: function (i, s, h) {
      return h = h != null ? h.concat([i]) : null, nc(
        4194308,
        4,
        Ah.bind(null, s, i),
        h
      );
    }, useLayoutEffect: function (i, s) {
      return nc(4194308, 4, i, s);
    }, useInsertionEffect: function (i, s) {
      return nc(4, 2, i, s);
    }, useMemo: function (i, s) {
      var h = ft();
      return s = s === void 0 ? null : s, i = i(), h.memoizedState = [i, s], i;
    }, useReducer: function (i, s, h) {
      var v = ft();
      return s = h !== void 0 ? h(s) : s, v.memoizedState = v.baseState = s, i = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: i, lastRenderedState: s }, v.queue = i, i = i.dispatch = u0.bind(null, st, i), [v.memoizedState, i];
    }, useRef: function (i) {
      var s = ft();
      return i = { current: i }, s.memoizedState = i;
    }, useState: Rh, useDebugValue: ac, useDeferredValue: function (i) {
      return ft().memoizedState = i;
    }, useTransition: function () {
      var i = Rh(!1), s = i[0];
      return i = pv.bind(null, i[1]), ft().memoizedState = i, [s, i];
    }, useMutableSource: function () {
    }, useSyncExternalStore: function (i, s, h) {
      var v = st, w = ft();
      if (Kn) {
        if (h === void 0) throw Error(r(407));
        h = h();
      } else {
        if (h = s(), vr === null) throw Error(r(349));
        rt & 30 || tc(v, s, h);
      }
      w.memoizedState = h;
      var E = { value: h, getSnapshot: s };
      return w.queue = E, Oh(Eh.bind(
        null,
        v,
        E,
        i
      ), [i]), v.flags |= 2048, Kl(9, _h.bind(null, v, E, h, s), void 0, null), h;
    }, useId: function () {
      var i = ft(), s = vr.identifierPrefix;
      if (Kn) {
        var h = is, v = oa;
        h = (v & ~(1 << 32 - Aa(v) - 1)).toString(32) + h, s = ":" + s + "R" + h, h = Fd++, 0 < h && (s += "H" + h.toString(32)), s += ":";
      } else h = eS++, s = ":" + s + "r" + h.toString(32) + ":";
      return i.memoizedState = s;
    }, unstable_isNewReconciler: !1
  }, $n = {
    readContext: Bi,
    useCallback: Gl,
    useContext: Bi,
    useEffect: zd,
    useImperativeHandle: Dh,
    useInsertionEffect: Nh,
    useLayoutEffect: jh,
    useMemo: Ph,
    useReducer: ls,
    useRef: kh,
    useState: function () {
      return ls(xi);
    },
    useDebugValue: ac,
    useDeferredValue: function (i) {
      var s = sa();
      return Mh(s, Rt.memoizedState, i);
    },
    useTransition: function () {
      var i = ls(xi)[0], s = sa().memoizedState;
      return [i, s];
    },
    useMutableSource: ec,
    useSyncExternalStore: Yl,
    useId: Lh,
    unstable_isNewReconciler: !1
  }, Ih = {
    readContext: Bi, useCallback: Gl, useContext: Bi, useEffect: zd, useImperativeHandle: Dh, useInsertionEffect: Nh, useLayoutEffect: jh, useMemo: Ph, useReducer: Vi, useRef: kh, useState: function () {
      return Vi(xi);
    }, useDebugValue: ac, useDeferredValue: function (i) {
      var s = sa();
      return Rt === null ? s.memoizedState = i : Mh(s, Rt.memoizedState, i);
    }, useTransition: function () {
      var i = Vi(xi)[0], s = sa().memoizedState;
      return [i, s];
    }, useMutableSource: ec, useSyncExternalStore: Yl, useId: Lh, unstable_isNewReconciler: !1
  };
  function ni(i, s) {
    if (i && i.defaultProps) {
      s = ge({}, s), i = i.defaultProps;
      for (var h in i) s[h] === void 0 && (s[h] = i[h]);
      return s;
    }
    return s;
  }
  function Ql(i, s, h, v) {
    s = i.memoizedState, h = h(v, s), h = h == null ? s : ge({}, s, h), i.memoizedState = h, i.lanes === 0 && (i.updateQueue.baseState = h);
  }
  var Jl = {
    isMounted: function (i) {
      return (i = i._reactInternals) ? ot(i) === i : !1;
    }, enqueueSetState: function (i, s, h) {
      i = i._reactInternals;
      var v = ta(), w = ds(i), E = ti(v, w);
      E.payload = s, h != null && (E.callback = h), s = al(i, E, w), s !== null && (lr(s, i, w, v), yh(s, i, w));
    }, enqueueReplaceState: function (i, s, h) {
      i = i._reactInternals;
      var v = ta(), w = ds(i), E = ti(v, w);
      E.tag = 1, E.payload = s, h != null && (E.callback = h), s = al(i, E, w), s !== null && (lr(s, i, w, v), yh(s, i, w));
    }, enqueueForceUpdate: function (i, s) {
      i = i._reactInternals;
      var h = ta(), v = ds(i), w = ti(h, v);
      w.tag = 2, s != null && (w.callback = s), s = al(i, w, v), s !== null && (lr(s, i, v, h), yh(s, i, v));
    }
  };
  function c0(i, s, h, v, w, E, P) {
    return i = i.stateNode, typeof i.shouldComponentUpdate == "function" ? i.shouldComponentUpdate(v, E, P) : s.prototype && s.prototype.isPureReactComponent ? !Ed(h, v) || !Ed(w, E) : !0;
  }
  function d0(i, s, h) {
    var v = !1, w = Oo, E = s.contextType;
    return typeof E == "object" && E !== null ? E = Bi(E) : (w = er(s) ? Qa : Tt.current, v = s.contextTypes, E = (v = v != null) ? Ii(i, w) : Oo), s = new s(h, E), i.memoizedState = s.state !== null && s.state !== void 0 ? s.state : null, s.updater = Jl, i.stateNode = s, s._reactInternals = i, v && (i = i.stateNode, i.__reactInternalMemoizedUnmaskedChildContext = w, i.__reactInternalMemoizedMaskedChildContext = E), s;
  }
  function f0(i, s, h, v) {
    i = s.state, typeof s.componentWillReceiveProps == "function" && s.componentWillReceiveProps(h, v), typeof s.UNSAFE_componentWillReceiveProps == "function" && s.UNSAFE_componentWillReceiveProps(h, v), s.state !== i && Jl.enqueueReplaceState(s, s.state, null);
  }
  function vv(i, s, h, v) {
    var w = i.stateNode;
    w.props = h, w.state = i.memoizedState, w.refs = {}, gh(i);
    var E = s.contextType;
    typeof E == "object" && E !== null ? w.context = Bi(E) : (E = er(s) ? Qa : Tt.current, w.context = Ii(i, E)), w.state = i.memoizedState, E = s.getDerivedStateFromProps, typeof E == "function" && (Ql(i, s, E, h), w.state = i.memoizedState), typeof s.getDerivedStateFromProps == "function" || typeof w.getSnapshotBeforeUpdate == "function" || typeof w.UNSAFE_componentWillMount != "function" && typeof w.componentWillMount != "function" || (s = w.state, typeof w.componentWillMount == "function" && w.componentWillMount(), typeof w.UNSAFE_componentWillMount == "function" && w.UNSAFE_componentWillMount(), s !== w.state && Jl.enqueueReplaceState(w, w.state, null), bh(i, h, w, v), w.state = i.memoizedState), typeof w.componentDidMount == "function" && (i.flags |= 4194308);
  }
  function ol(i, s) {
    try {
      var h = "", v = s;
      do
        h += ut(v), v = v.return;
      while (v);
      var w = h;
    } catch (E) {
      w = `
Error generating stack: ` + E.message + `
` + E.stack;
    }
    return { value: i, source: s, stack: w, digest: null };
  }
  function gv(i, s, h) {
    return { value: i, source: null, stack: h ?? null, digest: s ?? null };
  }
  function Vd(i, s) {
    try {
      console.error(s.value);
    } catch (h) {
      setTimeout(function () {
        throw h;
      });
    }
  }
  var h0 = typeof WeakMap == "function" ? WeakMap : Map;
  function p0(i, s, h) {
    h = ti(-1, h), h.tag = 3, h.payload = { element: null };
    var v = s.value;
    return h.callback = function () {
      Gh || (Gh = !0, Tv = v), Vd(i, s);
    }, h;
  }
  function m0(i, s, h) {
    h = ti(-1, h), h.tag = 3;
    var v = i.type.getDerivedStateFromError;
    if (typeof v == "function") {
      var w = s.value;
      h.payload = function () {
        return v(w);
      }, h.callback = function () {
        Vd(i, s);
      };
    }
    var E = i.stateNode;
    return E !== null && typeof E.componentDidCatch == "function" && (h.callback = function () {
      Vd(i, s), typeof v != "function" && (qi === null ? qi = /* @__PURE__ */ new Set([this]) : qi.add(this));
      var P = s.stack;
      this.componentDidCatch(s.value, { componentStack: P !== null ? P : "" });
    }), h;
  }
  function Hd(i, s, h) {
    var v = i.pingCache;
    if (v === null) {
      v = i.pingCache = new h0();
      var w = /* @__PURE__ */ new Set();
      v.set(s, w);
    } else w = v.get(s), w === void 0 && (w = /* @__PURE__ */ new Set(), v.set(s, w));
    w.has(h) || (w.add(h), i = dS.bind(null, i, s, h), s.then(i, i));
  }
  function v0(i) {
    do {
      var s;
      if ((s = i.tag === 13) && (s = i.memoizedState, s = s !== null ? s.dehydrated !== null : !0), s) return i;
      i = i.return;
    } while (i !== null);
    return null;
  }
  function yv(i, s, h, v, w) {
    return i.mode & 1 ? (i.flags |= 65536, i.lanes = w, i) : (i === s ? i.flags |= 65536 : (i.flags |= 128, h.flags |= 131072, h.flags &= -52805, h.tag === 1 && (h.alternate === null ? h.tag = 17 : (s = ti(-1, 1), s.tag = 2, al(h, s, 1))), h.lanes |= 1), i);
  }
  var g0 = B.ReactCurrentOwner, ri = !1;
  function Sr(i, s, h, v) {
    s.child = i === null ? a0(s, null, h, v) : Ku(s, i.child, h, v);
  }
  function oc(i, s, h, v, w) {
    h = h.render;
    var E = s.ref;
    return Gu(s, w), v = ye(i, s, h, v, E, w), h = Pr(), i !== null && !ri ? (s.updateQueue = i.updateQueue, s.flags &= -2053, i.lanes &= ~w, _r(i, s, w)) : (Kn && h && dh(s), s.flags |= 1, Sr(i, s, v, w), s.child);
  }
  function sl(i, s, h, v, w) {
    if (i === null) {
      var E = h.type;
      return typeof E == "function" && !jv(E) && E.defaultProps === void 0 && h.compare === null && h.defaultProps === void 0 ? (s.tag = 15, s.type = E, Uh(i, s, E, v, w)) : (i = tp(h.type, null, v, s, s.mode, w), i.ref = s.ref, i.return = s, s.child = i);
    }
    if (E = i.child, !(i.lanes & w)) {
      var P = E.memoizedProps;
      if (h = h.compare, h = h !== null ? h : Ed, h(P, v) && i.ref === s.ref) return _r(i, s, w);
    }
    return s.flags |= 1, i = cl(E, v), i.ref = s.ref, i.return = s, s.child = i;
  }
  function Uh(i, s, h, v, w) {
    if (i !== null) {
      var E = i.memoizedProps;
      if (Ed(E, v) && i.ref === s.ref) if (ri = !1, s.pendingProps = v = E, (i.lanes & w) !== 0) i.flags & 131072 && (ri = !0);
      else return s.lanes = i.lanes, _r(i, s, w);
    }
    return Pt(i, s, h, v, w);
  }
  function ai(i, s, h) {
    var v = s.pendingProps, w = v.children, E = i !== null ? i.memoizedState : null;
    if (v.mode === "hidden") if (!(s.mode & 1)) s.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, En(vc, ii), ii |= h;
    else {
      if (!(h & 1073741824)) return i = E !== null ? E.baseLanes | h : h, s.lanes = s.childLanes = 1073741824, s.memoizedState = { baseLanes: i, cachePool: null, transitions: null }, s.updateQueue = null, En(vc, ii), ii |= i, null;
      s.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, v = E !== null ? E.baseLanes : h, En(vc, ii), ii |= v;
    }
    else E !== null ? (v = E.baseLanes | h, s.memoizedState = null) : v = h, En(vc, ii), ii |= v;
    return Sr(i, s, w, h), s.child;
  }
  function Zl(i, s) {
    var h = s.ref;
    (i === null && h !== null || i !== null && i.ref !== h) && (s.flags |= 512, s.flags |= 2097152);
  }
  function Pt(i, s, h, v, w) {
    var E = er(h) ? Qa : Tt.current;
    return E = Ii(s, E), Gu(s, w), h = ye(i, s, h, v, E, w), v = Pr(), i !== null && !ri ? (s.updateQueue = i.updateQueue, s.flags &= -2053, i.lanes &= ~w, _r(i, s, w)) : (Kn && v && dh(s), s.flags |= 1, Sr(i, s, h, w), s.child);
  }
  function Wd(i, s, h, v, w) {
    if (er(h)) {
      var E = !0;
      ch(s);
    } else E = !1;
    if (Gu(s, w), s.stateNode === null) Yd(i, s), d0(s, h, v), vv(s, h, v, w), v = !0;
    else if (i === null) {
      var P = s.stateNode, z = s.memoizedProps;
      P.props = z;
      var q = P.context, se = h.contextType;
      typeof se == "object" && se !== null ? se = Bi(se) : (se = er(h) ? Qa : Tt.current, se = Ii(s, se));
      var Se = h.getDerivedStateFromProps, _e = typeof Se == "function" || typeof P.getSnapshotBeforeUpdate == "function";
      _e || typeof P.UNSAFE_componentWillReceiveProps != "function" && typeof P.componentWillReceiveProps != "function" || (z !== v || q !== se) && f0(s, P, v, se), rl = !1;
      var be = s.memoizedState;
      P.state = be, bh(s, v, P, w), q = s.memoizedState, z !== v || be !== q || pr.current || rl ? (typeof Se == "function" && (Ql(s, h, Se, v), q = s.memoizedState), (z = rl || c0(s, h, z, v, be, q, se)) ? (_e || typeof P.UNSAFE_componentWillMount != "function" && typeof P.componentWillMount != "function" || (typeof P.componentWillMount == "function" && P.componentWillMount(), typeof P.UNSAFE_componentWillMount == "function" && P.UNSAFE_componentWillMount()), typeof P.componentDidMount == "function" && (s.flags |= 4194308)) : (typeof P.componentDidMount == "function" && (s.flags |= 4194308), s.memoizedProps = v, s.memoizedState = q), P.props = v, P.state = q, P.context = se, v = z) : (typeof P.componentDidMount == "function" && (s.flags |= 4194308), v = !1);
    } else {
      P = s.stateNode, Qu(i, s), z = s.memoizedProps, se = s.type === s.elementType ? z : ni(s.type, z), P.props = se, _e = s.pendingProps, be = P.context, q = h.contextType, typeof q == "object" && q !== null ? q = Bi(q) : (q = er(h) ? Qa : Tt.current, q = Ii(s, q));
      var He = h.getDerivedStateFromProps;
      (Se = typeof He == "function" || typeof P.getSnapshotBeforeUpdate == "function") || typeof P.UNSAFE_componentWillReceiveProps != "function" && typeof P.componentWillReceiveProps != "function" || (z !== _e || be !== q) && f0(s, P, v, q), rl = !1, be = s.memoizedState, P.state = be, bh(s, v, P, w);
      var Je = s.memoizedState;
      z !== _e || be !== Je || pr.current || rl ? (typeof He == "function" && (Ql(s, h, He, v), Je = s.memoizedState), (se = rl || c0(s, h, se, v, be, Je, q) || !1) ? (Se || typeof P.UNSAFE_componentWillUpdate != "function" && typeof P.componentWillUpdate != "function" || (typeof P.componentWillUpdate == "function" && P.componentWillUpdate(v, Je, q), typeof P.UNSAFE_componentWillUpdate == "function" && P.UNSAFE_componentWillUpdate(v, Je, q)), typeof P.componentDidUpdate == "function" && (s.flags |= 4), typeof P.getSnapshotBeforeUpdate == "function" && (s.flags |= 1024)) : (typeof P.componentDidUpdate != "function" || z === i.memoizedProps && be === i.memoizedState || (s.flags |= 4), typeof P.getSnapshotBeforeUpdate != "function" || z === i.memoizedProps && be === i.memoizedState || (s.flags |= 1024), s.memoizedProps = v, s.memoizedState = Je), P.props = v, P.state = Je, P.context = q, v = se) : (typeof P.componentDidUpdate != "function" || z === i.memoizedProps && be === i.memoizedState || (s.flags |= 4), typeof P.getSnapshotBeforeUpdate != "function" || z === i.memoizedProps && be === i.memoizedState || (s.flags |= 1024), v = !1);
    }
    return Fh(i, s, h, v, E, w);
  }
  function Fh(i, s, h, v, w, E) {
    Zl(i, s);
    var P = (s.flags & 128) !== 0;
    if (!v && !P) return w && Xy(s, h, !1), _r(i, s, E);
    v = s.stateNode, g0.current = s;
    var z = P && typeof h.getDerivedStateFromError != "function" ? null : v.render();
    return s.flags |= 1, i !== null && P ? (s.child = Ku(s, i.child, null, E), s.child = Ku(s, null, z, E)) : Sr(i, s, z, E), s.memoizedState = v.state, w && Xy(s, h, !0), s.child;
  }
  function nS(i) {
    var s = i.stateNode;
    s.pendingContext ? tl(i, s.pendingContext, s.pendingContext !== s.context) : s.context && tl(i, s.context, !1), dv(i, s.containerInfo);
  }
  function y0(i, s, h, v, w) {
    return sr(), lv(w), s.flags |= 256, Sr(i, s, h, v), s.child;
  }
  var qd = { dehydrated: null, treeContext: null, retryLane: 0 };
  function Xl(i) {
    return { baseLanes: i, cachePool: null, transitions: null };
  }
  function b0(i, s, h) {
    var v = s.pendingProps, w = tr.current, E = !1, P = (s.flags & 128) !== 0, z;
    if ((z = P) || (z = i !== null && i.memoizedState === null ? !1 : (w & 2) !== 0), z ? (E = !0, s.flags &= -129) : (i === null || i.memoizedState !== null) && (w |= 1), En(tr, w & 1), i === null)
      return hh(s), i = s.memoizedState, i !== null && (i = i.dehydrated, i !== null) ? (s.mode & 1 ? i.data === "$!" ? s.lanes = 8 : s.lanes = 1073741824 : s.lanes = 1, null) : (P = v.children, i = v.fallback, E ? (v = s.mode, E = s.child, P = { mode: "hidden", children: P }, !(v & 1) && E !== null ? (E.childLanes = 0, E.pendingProps = P) : E = np(P, v, 0, null), i = iu(i, v, h, null), E.return = s, i.return = s, E.sibling = i, s.child = E, s.child.memoizedState = Xl(h), s.memoizedState = qd, i) : $h(s, P));
    if (w = i.memoizedState, w !== null && (z = w.dehydrated, z !== null)) return bv(i, s, P, v, z, w, h);
    if (E) {
      E = v.fallback, P = s.mode, w = i.child, z = w.sibling;
      var q = { mode: "hidden", children: v.children };
      return !(P & 1) && s.child !== w ? (v = s.child, v.childLanes = 0, v.pendingProps = q, s.deletions = null) : (v = cl(w, q), v.subtreeFlags = w.subtreeFlags & 14680064), z !== null ? E = cl(z, E) : (E = iu(E, P, h, null), E.flags |= 2), E.return = s, v.return = s, v.sibling = E, s.child = v, v = E, E = s.child, P = i.child.memoizedState, P = P === null ? Xl(h) : { baseLanes: P.baseLanes | h, cachePool: null, transitions: P.transitions }, E.memoizedState = P, E.childLanes = i.childLanes & ~h, s.memoizedState = qd, v;
    }
    return E = i.child, i = E.sibling, v = cl(E, { mode: "visible", children: v.children }), !(s.mode & 1) && (v.lanes = h), v.return = s, v.sibling = null, i !== null && (h = s.deletions, h === null ? (s.deletions = [i], s.flags |= 16) : h.push(i)), s.child = v, s.memoizedState = null, v;
  }
  function $h(i, s) {
    return s = np({ mode: "visible", children: s }, i.mode, 0, null), s.return = i, i.child = s;
  }
  function zh(i, s, h, v) {
    return v !== null && lv(v), Ku(s, i.child, null, h), i = $h(s, s.pendingProps.children), i.flags |= 2, s.memoizedState = null, i;
  }
  function bv(i, s, h, v, w, E, P) {
    if (h)
      return s.flags & 256 ? (s.flags &= -257, v = gv(Error(r(422))), zh(i, s, P, v)) : s.memoizedState !== null ? (s.child = i.child, s.flags |= 128, null) : (E = v.fallback, w = s.mode, v = np({ mode: "visible", children: v.children }, w, 0, null), E = iu(E, w, P, null), E.flags |= 2, v.return = s, E.return = s, v.sibling = E, s.child = v, s.mode & 1 && Ku(s, i.child, null, P), s.child.memoizedState = Xl(P), s.memoizedState = qd, E);
    if (!(s.mode & 1)) return zh(i, s, P, null);
    if (w.data === "$!") {
      if (v = w.nextSibling && w.nextSibling.dataset, v) var z = v.dgst;
      return v = z, E = Error(r(419)), v = gv(E, v, void 0), zh(i, s, P, v);
    }
    if (z = (P & i.childLanes) !== 0, ri || z) {
      if (v = vr, v !== null) {
        switch (P & -P) {
          case 4:
            w = 2;
            break;
          case 16:
            w = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            w = 32;
            break;
          case 536870912:
            w = 268435456;
            break;
          default:
            w = 0;
        }
        w = w & (v.suspendedLanes | P) ? 0 : w, w !== 0 && w !== E.retryLane && (E.retryLane = w, ss(i, w), lr(v, i, w, -1));
      }
      return Zd(), v = gv(Error(r(421))), zh(i, s, P, v);
    }
    return w.data === "$?" ? (s.flags |= 128, s.child = i.child, s = Nv.bind(null, i), w._reactRetry = s, null) : (i = E.treeContext, ei = co(w.nextSibling), yi = s, Kn = !0, $i = null, i !== null && (Xa[xa++] = oa, Xa[xa++] = is, Xa[xa++] = Fi, oa = i.id, is = i.overflow, Fi = s), s = $h(s, v.children), s.flags |= 4096, s);
  }
  function w0(i, s, h) {
    i.lanes |= s;
    var v = i.alternate;
    v !== null && (v.lanes |= s), cv(i.return, s, h);
  }
  function Bh(i, s, h, v, w) {
    var E = i.memoizedState;
    E === null ? i.memoizedState = { isBackwards: s, rendering: null, renderingStartTime: 0, last: v, tail: h, tailMode: w } : (E.isBackwards = s, E.rendering = null, E.renderingStartTime = 0, E.last = v, E.tail = h, E.tailMode = w);
  }
  function wv(i, s, h) {
    var v = s.pendingProps, w = v.revealOrder, E = v.tail;
    if (Sr(i, s, v.children, h), v = tr.current, v & 2) v = v & 1 | 2, s.flags |= 128;
    else {
      if (i !== null && i.flags & 128) e: for (i = s.child; i !== null;) {
        if (i.tag === 13) i.memoizedState !== null && w0(i, h, s);
        else if (i.tag === 19) w0(i, h, s);
        else if (i.child !== null) {
          i.child.return = i, i = i.child;
          continue;
        }
        if (i === s) break e;
        for (; i.sibling === null;) {
          if (i.return === null || i.return === s) break e;
          i = i.return;
        }
        i.sibling.return = i.return, i = i.sibling;
      }
      v &= 1;
    }
    if (En(tr, v), !(s.mode & 1)) s.memoizedState = null;
    else switch (w) {
      case "forwards":
        for (h = s.child, w = null; h !== null;) i = h.alternate, i !== null && wh(i) === null && (w = h), h = h.sibling;
        h = w, h === null ? (w = s.child, s.child = null) : (w = h.sibling, h.sibling = null), Bh(s, !1, w, h, E);
        break;
      case "backwards":
        for (h = null, w = s.child, s.child = null; w !== null;) {
          if (i = w.alternate, i !== null && wh(i) === null) {
            s.child = w;
            break;
          }
          i = w.sibling, w.sibling = h, h = w, w = i;
        }
        Bh(s, !0, h, null, E);
        break;
      case "together":
        Bh(s, !1, null, null, void 0);
        break;
      default:
        s.memoizedState = null;
    }
    return s.child;
  }
  function Yd(i, s) {
    !(s.mode & 1) && i !== null && (i.alternate = null, s.alternate = null, s.flags |= 2);
  }
  function _r(i, s, h) {
    if (i !== null && (s.dependencies = i.dependencies), tu |= s.lanes, !(h & s.childLanes)) return null;
    if (i !== null && s.child !== i.child) throw Error(r(153));
    if (s.child !== null) {
      for (i = s.child, h = cl(i, i.pendingProps), s.child = h, h.return = s; i.sibling !== null;) i = i.sibling, h = h.sibling = cl(i, i.pendingProps), h.return = s;
      h.sibling = null;
    }
    return s.child;
  }
  function us(i, s, h) {
    switch (s.tag) {
      case 3:
        nS(s), sr();
        break;
      case 5:
        l0(s);
        break;
      case 1:
        er(s.type) && ch(s);
        break;
      case 4:
        dv(s, s.stateNode.containerInfo);
        break;
      case 10:
        var v = s.type._context, w = s.memoizedProps.value;
        En(os, v._currentValue), v._currentValue = w;
        break;
      case 13:
        if (v = s.memoizedState, v !== null)
          return v.dehydrated !== null ? (En(tr, tr.current & 1), s.flags |= 128, null) : h & s.child.childLanes ? b0(i, s, h) : (En(tr, tr.current & 1), i = _r(i, s, h), i !== null ? i.sibling : null);
        En(tr, tr.current & 1);
        break;
      case 19:
        if (v = (h & s.childLanes) !== 0, i.flags & 128) {
          if (v) return wv(i, s, h);
          s.flags |= 128;
        }
        if (w = s.memoizedState, w !== null && (w.rendering = null, w.tail = null, w.lastEffect = null), En(tr, tr.current), v) break;
        return null;
      case 22:
      case 23:
        return s.lanes = 0, ai(i, s, h);
    }
    return _r(i, s, h);
  }
  var jo, sc, lc, Hi;
  jo = function (i, s) {
    for (var h = s.child; h !== null;) {
      if (h.tag === 5 || h.tag === 6) i.appendChild(h.stateNode);
      else if (h.tag !== 4 && h.child !== null) {
        h.child.return = h, h = h.child;
        continue;
      }
      if (h === s) break;
      for (; h.sibling === null;) {
        if (h.return === null || h.return === s) return;
        h = h.return;
      }
      h.sibling.return = h.return, h = h.sibling;
    }
  }, sc = function () {
  }, lc = function (i, s, h, v) {
    var w = i.memoizedProps;
    if (w !== v) {
      i = s.stateNode, ql(fo.current);
      var E = null;
      switch (h) {
        case "input":
          w = ar(i, w), v = ar(i, v), E = [];
          break;
        case "select":
          w = ge({}, w, { value: void 0 }), v = ge({}, v, { value: void 0 }), E = [];
          break;
        case "textarea":
          w = aa(i, w), v = aa(i, v), E = [];
          break;
        default:
          typeof w.onClick != "function" && typeof v.onClick == "function" && (i.onclick = uh);
      }
      kn(h, v);
      var P;
      h = null;
      for (se in w) if (!v.hasOwnProperty(se) && w.hasOwnProperty(se) && w[se] != null) if (se === "style") {
        var z = w[se];
        for (P in z) z.hasOwnProperty(P) && (h || (h = {}), h[P] = "");
      } else se !== "dangerouslySetInnerHTML" && se !== "children" && se !== "suppressContentEditableWarning" && se !== "suppressHydrationWarning" && se !== "autoFocus" && (u.hasOwnProperty(se) ? E || (E = []) : (E = E || []).push(se, null));
      for (se in v) {
        var q = v[se];
        if (z = w != null ? w[se] : void 0, v.hasOwnProperty(se) && q !== z && (q != null || z != null)) if (se === "style") if (z) {
          for (P in z) !z.hasOwnProperty(P) || q && q.hasOwnProperty(P) || (h || (h = {}), h[P] = "");
          for (P in q) q.hasOwnProperty(P) && z[P] !== q[P] && (h || (h = {}), h[P] = q[P]);
        } else h || (E || (E = []), E.push(
          se,
          h
        )), h = q;
        else se === "dangerouslySetInnerHTML" ? (q = q ? q.__html : void 0, z = z ? z.__html : void 0, q != null && z !== q && (E = E || []).push(se, q)) : se === "children" ? typeof q != "string" && typeof q != "number" || (E = E || []).push(se, "" + q) : se !== "suppressContentEditableWarning" && se !== "suppressHydrationWarning" && (u.hasOwnProperty(se) ? (q != null && se === "onScroll" && Ln("scroll", i), E || z === q || (E = [])) : (E = E || []).push(se, q));
      }
      h && (E = E || []).push("style", h);
      var se = E;
      (s.updateQueue = se) && (s.flags |= 4);
    }
  }, Hi = function (i, s, h, v) {
    h !== v && (s.flags |= 4);
  };
  function mr(i, s) {
    if (!Kn) switch (i.tailMode) {
      case "hidden":
        s = i.tail;
        for (var h = null; s !== null;) s.alternate !== null && (h = s), s = s.sibling;
        h === null ? i.tail = null : h.sibling = null;
        break;
      case "collapsed":
        h = i.tail;
        for (var v = null; h !== null;) h.alternate !== null && (v = h), h = h.sibling;
        v === null ? s || i.tail === null ? i.tail = null : i.tail.sibling = null : v.sibling = null;
    }
  }
  function Ea(i) {
    var s = i.alternate !== null && i.alternate.child === i.child, h = 0, v = 0;
    if (s) for (var w = i.child; w !== null;) h |= w.lanes | w.childLanes, v |= w.subtreeFlags & 14680064, v |= w.flags & 14680064, w.return = i, w = w.sibling;
    else for (w = i.child; w !== null;) h |= w.lanes | w.childLanes, v |= w.subtreeFlags, v |= w.flags, w.return = i, w = w.sibling;
    return i.subtreeFlags |= v, i.childLanes = h, s;
  }
  function rS(i, s, h) {
    var v = s.pendingProps;
    switch (ov(s), s.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return Ea(s), null;
      case 1:
        return er(s.type) && Ui(), Ea(s), null;
      case 3:
        return v = s.stateNode, Zu(), bn(pr), bn(Tt), hv(), v.pendingContext && (v.context = v.pendingContext, v.pendingContext = null), (i === null || i.child === null) && (ph(s) ? s.flags |= 4 : i === null || i.memoizedState.isDehydrated && !(s.flags & 256) || (s.flags |= 1024, $i !== null && (Rv($i), $i = null))), sc(i, s), Ea(s), null;
      case 5:
        fv(s);
        var w = ql(Id.current);
        if (h = s.type, i !== null && s.stateNode != null) lc(i, s, h, v, w), i.ref !== s.ref && (s.flags |= 512, s.flags |= 2097152);
        else {
          if (!v) {
            if (s.stateNode === null) throw Error(r(166));
            return Ea(s), null;
          }
          if (i = ql(fo.current), ph(s)) {
            v = s.stateNode, h = s.type;
            var E = s.memoizedProps;
            switch (v[ko] = s, v[Bl] = E, i = (s.mode & 1) !== 0, h) {
              case "dialog":
                Ln("cancel", v), Ln("close", v);
                break;
              case "iframe":
              case "object":
              case "embed":
                Ln("load", v);
                break;
              case "video":
              case "audio":
                for (w = 0; w < kd.length; w++) Ln(kd[w], v);
                break;
              case "source":
                Ln("error", v);
                break;
              case "img":
              case "image":
              case "link":
                Ln(
                  "error",
                  v
                ), Ln("load", v);
                break;
              case "details":
                Ln("toggle", v);
                break;
              case "input":
                ir(v, E), Ln("invalid", v);
                break;
              case "select":
                v._wrapperState = { wasMultiple: !!E.multiple }, Ln("invalid", v);
                break;
              case "textarea":
                Xn(v, E), Ln("invalid", v);
            }
            kn(h, E), w = null;
            for (var P in E) if (E.hasOwnProperty(P)) {
              var z = E[P];
              P === "children" ? typeof z == "string" ? v.textContent !== z && (E.suppressHydrationWarning !== !0 && lh(v.textContent, z, i), w = ["children", z]) : typeof z == "number" && v.textContent !== "" + z && (E.suppressHydrationWarning !== !0 && lh(
                v.textContent,
                z,
                i
              ), w = ["children", "" + z]) : u.hasOwnProperty(P) && z != null && P === "onScroll" && Ln("scroll", v);
            }
            switch (h) {
              case "input":
                zn(v), Rr(v, E, !0);
                break;
              case "textarea":
                zn(v), Ur(v);
                break;
              case "select":
              case "option":
                break;
              default:
                typeof E.onClick == "function" && (v.onclick = uh);
            }
            v = w, s.updateQueue = v, v !== null && (s.flags |= 4);
          } else {
            P = w.nodeType === 9 ? w : w.ownerDocument, i === "http://www.w3.org/1999/xhtml" && (i = An(h)), i === "http://www.w3.org/1999/xhtml" ? h === "script" ? (i = P.createElement("div"), i.innerHTML = "<script><\/script>", i = i.removeChild(i.firstChild)) : typeof v.is == "string" ? i = P.createElement(h, { is: v.is }) : (i = P.createElement(h), h === "select" && (P = i, v.multiple ? P.multiple = !0 : v.size && (P.size = v.size))) : i = P.createElementNS(i, h), i[ko] = s, i[Bl] = v, jo(i, s, !1, !1), s.stateNode = i;
            e: {
              switch (P = Hn(h, v), h) {
                case "dialog":
                  Ln("cancel", i), Ln("close", i), w = v;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  Ln("load", i), w = v;
                  break;
                case "video":
                case "audio":
                  for (w = 0; w < kd.length; w++) Ln(kd[w], i);
                  w = v;
                  break;
                case "source":
                  Ln("error", i), w = v;
                  break;
                case "img":
                case "image":
                case "link":
                  Ln(
                    "error",
                    i
                  ), Ln("load", i), w = v;
                  break;
                case "details":
                  Ln("toggle", i), w = v;
                  break;
                case "input":
                  ir(i, v), w = ar(i, v), Ln("invalid", i);
                  break;
                case "option":
                  w = v;
                  break;
                case "select":
                  i._wrapperState = { wasMultiple: !!v.multiple }, w = ge({}, v, { value: void 0 }), Ln("invalid", i);
                  break;
                case "textarea":
                  Xn(i, v), w = aa(i, v), Ln("invalid", i);
                  break;
                default:
                  w = v;
              }
              kn(h, w), z = w;
              for (E in z) if (z.hasOwnProperty(E)) {
                var q = z[E];
                E === "style" ? Ht(i, q) : E === "dangerouslySetInnerHTML" ? (q = q ? q.__html : void 0, q != null && ji(i, q)) : E === "children" ? typeof q == "string" ? (h !== "textarea" || q !== "") && Wr(i, q) : typeof q == "number" && Wr(i, "" + q) : E !== "suppressContentEditableWarning" && E !== "suppressHydrationWarning" && E !== "autoFocus" && (u.hasOwnProperty(E) ? q != null && E === "onScroll" && Ln("scroll", i) : q != null && U(i, E, q, P));
              }
              switch (h) {
                case "input":
                  zn(i), Rr(i, v, !1);
                  break;
                case "textarea":
                  zn(i), Ur(i);
                  break;
                case "option":
                  v.value != null && i.setAttribute("value", "" + kt(v.value));
                  break;
                case "select":
                  i.multiple = !!v.multiple, E = v.value, E != null ? dr(i, !!v.multiple, E, !1) : v.defaultValue != null && dr(
                    i,
                    !!v.multiple,
                    v.defaultValue,
                    !0
                  );
                  break;
                default:
                  typeof w.onClick == "function" && (i.onclick = uh);
              }
              switch (h) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  v = !!v.autoFocus;
                  break e;
                case "img":
                  v = !0;
                  break e;
                default:
                  v = !1;
              }
            }
            v && (s.flags |= 4);
          }
          s.ref !== null && (s.flags |= 512, s.flags |= 2097152);
        }
        return Ea(s), null;
      case 6:
        if (i && s.stateNode != null) Hi(i, s, i.memoizedProps, v);
        else {
          if (typeof v != "string" && s.stateNode === null) throw Error(r(166));
          if (h = ql(Id.current), ql(fo.current), ph(s)) {
            if (v = s.stateNode, h = s.memoizedProps, v[ko] = s, (E = v.nodeValue !== h) && (i = yi, i !== null)) switch (i.tag) {
              case 3:
                lh(v.nodeValue, h, (i.mode & 1) !== 0);
                break;
              case 5:
                i.memoizedProps.suppressHydrationWarning !== !0 && lh(v.nodeValue, h, (i.mode & 1) !== 0);
            }
            E && (s.flags |= 4);
          } else v = (h.nodeType === 9 ? h : h.ownerDocument).createTextNode(v), v[ko] = s, s.stateNode = v;
        }
        return Ea(s), null;
      case 13:
        if (bn(tr), v = s.memoizedState, i === null || i.memoizedState !== null && i.memoizedState.dehydrated !== null) {
          if (Kn && ei !== null && s.mode & 1 && !(s.flags & 128)) n0(), sr(), s.flags |= 98560, E = !1;
          else if (E = ph(s), v !== null && v.dehydrated !== null) {
            if (i === null) {
              if (!E) throw Error(r(318));
              if (E = s.memoizedState, E = E !== null ? E.dehydrated : null, !E) throw Error(r(317));
              E[ko] = s;
            } else sr(), !(s.flags & 128) && (s.memoizedState = null), s.flags |= 4;
            Ea(s), E = !1;
          } else $i !== null && (Rv($i), $i = null), E = !0;
          if (!E) return s.flags & 65536 ? s : null;
        }
        return s.flags & 128 ? (s.lanes = h, s) : (v = v !== null, v !== (i !== null && i.memoizedState !== null) && v && (s.child.flags |= 8192, s.mode & 1 && (i === null || tr.current & 1 ? zr === 0 && (zr = 3) : Zd())), s.updateQueue !== null && (s.flags |= 4), Ea(s), null);
      case 4:
        return Zu(), sc(i, s), i === null && Wu(s.stateNode.containerInfo), Ea(s), null;
      case 10:
        return uv(s.type._context), Ea(s), null;
      case 17:
        return er(s.type) && Ui(), Ea(s), null;
      case 19:
        if (bn(tr), E = s.memoizedState, E === null) return Ea(s), null;
        if (v = (s.flags & 128) !== 0, P = E.rendering, P === null) if (v) mr(E, !1);
        else {
          if (zr !== 0 || i !== null && i.flags & 128) for (i = s.child; i !== null;) {
            if (P = wh(i), P !== null) {
              for (s.flags |= 128, mr(E, !1), v = P.updateQueue, v !== null && (s.updateQueue = v, s.flags |= 4), s.subtreeFlags = 0, v = h, h = s.child; h !== null;) E = h, i = v, E.flags &= 14680066, P = E.alternate, P === null ? (E.childLanes = 0, E.lanes = i, E.child = null, E.subtreeFlags = 0, E.memoizedProps = null, E.memoizedState = null, E.updateQueue = null, E.dependencies = null, E.stateNode = null) : (E.childLanes = P.childLanes, E.lanes = P.lanes, E.child = P.child, E.subtreeFlags = 0, E.deletions = null, E.memoizedProps = P.memoizedProps, E.memoizedState = P.memoizedState, E.updateQueue = P.updateQueue, E.type = P.type, i = P.dependencies, E.dependencies = i === null ? null : { lanes: i.lanes, firstContext: i.firstContext }), h = h.sibling;
              return En(tr, tr.current & 1 | 2), s.child;
            }
            i = i.sibling;
          }
          E.tail !== null && hn() > yc && (s.flags |= 128, v = !0, mr(E, !1), s.lanes = 4194304);
        }
        else {
          if (!v) if (i = wh(P), i !== null) {
            if (s.flags |= 128, v = !0, h = i.updateQueue, h !== null && (s.updateQueue = h, s.flags |= 4), mr(E, !0), E.tail === null && E.tailMode === "hidden" && !P.alternate && !Kn) return Ea(s), null;
          } else 2 * hn() - E.renderingStartTime > yc && h !== 1073741824 && (s.flags |= 128, v = !0, mr(E, !1), s.lanes = 4194304);
          E.isBackwards ? (P.sibling = s.child, s.child = P) : (h = E.last, h !== null ? h.sibling = P : s.child = P, E.last = P);
        }
        return E.tail !== null ? (s = E.tail, E.rendering = s, E.tail = s.sibling, E.renderingStartTime = hn(), s.sibling = null, h = tr.current, En(tr, v ? h & 1 | 2 : h & 1), s) : (Ea(s), null);
      case 22:
      case 23:
        return Xh(), v = s.memoizedState !== null, i !== null && i.memoizedState !== null !== v && (s.flags |= 8192), v && s.mode & 1 ? ii & 1073741824 && (Ea(s), s.subtreeFlags & 6 && (s.flags |= 8192)) : Ea(s), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(r(156, s.tag));
  }
  function aS(i, s) {
    switch (ov(s), s.tag) {
      case 1:
        return er(s.type) && Ui(), i = s.flags, i & 65536 ? (s.flags = i & -65537 | 128, s) : null;
      case 3:
        return Zu(), bn(pr), bn(Tt), hv(), i = s.flags, i & 65536 && !(i & 128) ? (s.flags = i & -65537 | 128, s) : null;
      case 5:
        return fv(s), null;
      case 13:
        if (bn(tr), i = s.memoizedState, i !== null && i.dehydrated !== null) {
          if (s.alternate === null) throw Error(r(340));
          sr();
        }
        return i = s.flags, i & 65536 ? (s.flags = i & -65537 | 128, s) : null;
      case 19:
        return bn(tr), null;
      case 4:
        return Zu(), null;
      case 10:
        return uv(s.type._context), null;
      case 22:
      case 23:
        return Xh(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var uc = !1, la = !1, Vh = typeof WeakSet == "function" ? WeakSet : Set, Qe = null;
  function cc(i, s) {
    var h = i.ref;
    if (h !== null) if (typeof h == "function") try {
      h(null);
    } catch (v) {
      gr(i, s, v);
    }
    else h.current = null;
  }
  function xv(i, s, h) {
    try {
      h();
    } catch (v) {
      gr(i, s, v);
    }
  }
  var Hh = !1;
  function iS(i, s) {
    if (Zm = Pi, i = rh(), ts(i)) {
      if ("selectionStart" in i) var h = { start: i.selectionStart, end: i.selectionEnd };
      else e: {
        h = (h = i.ownerDocument) && h.defaultView || window;
        var v = h.getSelection && h.getSelection();
        if (v && v.rangeCount !== 0) {
          h = v.anchorNode;
          var w = v.anchorOffset, E = v.focusNode;
          v = v.focusOffset;
          try {
            h.nodeType, E.nodeType;
          } catch {
            h = null;
            break e;
          }
          var P = 0, z = -1, q = -1, se = 0, Se = 0, _e = i, be = null;
          t: for (; ;) {
            for (var He; _e !== h || w !== 0 && _e.nodeType !== 3 || (z = P + w), _e !== E || v !== 0 && _e.nodeType !== 3 || (q = P + v), _e.nodeType === 3 && (P += _e.nodeValue.length), (He = _e.firstChild) !== null;)
              be = _e, _e = He;
            for (; ;) {
              if (_e === i) break t;
              if (be === h && ++se === w && (z = P), be === E && ++Se === v && (q = P), (He = _e.nextSibling) !== null) break;
              _e = be, be = _e.parentNode;
            }
            _e = He;
          }
          h = z === -1 || q === -1 ? null : { start: z, end: q };
        } else h = null;
      }
      h = h || { start: 0, end: 0 };
    } else h = null;
    for ($l = { focusedElem: i, selectionRange: h }, Pi = !1, Qe = s; Qe !== null;) if (s = Qe, i = s.child, (s.subtreeFlags & 1028) !== 0 && i !== null) i.return = s, Qe = i;
    else for (; Qe !== null;) {
      s = Qe;
      try {
        var Je = s.alternate;
        if (s.flags & 1024) switch (s.tag) {
          case 0:
          case 11:
          case 15:
            break;
          case 1:
            if (Je !== null) {
              var tt = Je.memoizedProps, Er = Je.memoizedState, Z = s.stateNode, Q = Z.getSnapshotBeforeUpdate(s.elementType === s.type ? tt : ni(s.type, tt), Er);
              Z.__reactInternalSnapshotBeforeUpdate = Q;
            }
            break;
          case 3:
            var ne = s.stateNode.containerInfo;
            ne.nodeType === 1 ? ne.textContent = "" : ne.nodeType === 9 && ne.documentElement && ne.removeChild(ne.documentElement);
            break;
          case 5:
          case 6:
          case 4:
          case 17:
            break;
          default:
            throw Error(r(163));
        }
      } catch (je) {
        gr(s, s.return, je);
      }
      if (i = s.sibling, i !== null) {
        i.return = s.return, Qe = i;
        break;
      }
      Qe = s.return;
    }
    return Je = Hh, Hh = !1, Je;
  }
  function dc(i, s, h) {
    var v = s.updateQueue;
    if (v = v !== null ? v.lastEffect : null, v !== null) {
      var w = v = v.next;
      do {
        if ((w.tag & i) === i) {
          var E = w.destroy;
          w.destroy = void 0, E !== void 0 && xv(s, h, E);
        }
        w = w.next;
      } while (w !== v);
    }
  }
  function Wh(i, s) {
    if (s = s.updateQueue, s = s !== null ? s.lastEffect : null, s !== null) {
      var h = s = s.next;
      do {
        if ((h.tag & i) === i) {
          var v = h.create;
          h.destroy = v();
        }
        h = h.next;
      } while (h !== s);
    }
  }
  function qh(i) {
    var s = i.ref;
    if (s !== null) {
      var h = i.stateNode;
      switch (i.tag) {
        case 5:
          i = h;
          break;
        default:
          i = h;
      }
      typeof s == "function" ? s(i) : s.current = i;
    }
  }
  function x0(i) {
    var s = i.alternate;
    s !== null && (i.alternate = null, x0(s)), i.child = null, i.deletions = null, i.sibling = null, i.tag === 5 && (s = i.stateNode, s !== null && (delete s[ko], delete s[Bl], delete s[tv], delete s[Xx], delete s[nv])), i.stateNode = null, i.return = null, i.dependencies = null, i.memoizedProps = null, i.memoizedState = null, i.pendingProps = null, i.stateNode = null, i.updateQueue = null;
  }
  function Sv(i) {
    return i.tag === 5 || i.tag === 3 || i.tag === 4;
  }
  function S0(i) {
    e: for (; ;) {
      for (; i.sibling === null;) {
        if (i.return === null || Sv(i.return)) return null;
        i = i.return;
      }
      for (i.sibling.return = i.return, i = i.sibling; i.tag !== 5 && i.tag !== 6 && i.tag !== 18;) {
        if (i.flags & 2 || i.child === null || i.tag === 4) continue e;
        i.child.return = i, i = i.child;
      }
      if (!(i.flags & 2)) return i.stateNode;
    }
  }
  function Kd(i, s, h) {
    var v = i.tag;
    if (v === 5 || v === 6) i = i.stateNode, s ? h.nodeType === 8 ? h.parentNode.insertBefore(i, s) : h.insertBefore(i, s) : (h.nodeType === 8 ? (s = h.parentNode, s.insertBefore(i, h)) : (s = h, s.appendChild(i)), h = h._reactRootContainer, h != null || s.onclick !== null || (s.onclick = uh));
    else if (v !== 4 && (i = i.child, i !== null)) for (Kd(i, s, h), i = i.sibling; i !== null;) Kd(i, s, h), i = i.sibling;
  }
  function fc(i, s, h) {
    var v = i.tag;
    if (v === 5 || v === 6) i = i.stateNode, s ? h.insertBefore(i, s) : h.appendChild(i);
    else if (v !== 4 && (i = i.child, i !== null)) for (fc(i, s, h), i = i.sibling; i !== null;) fc(i, s, h), i = i.sibling;
  }
  var nr = null, Xr = !1;
  function Ma(i, s, h) {
    for (h = h.child; h !== null;) hc(i, s, h), h = h.sibling;
  }
  function hc(i, s, h) {
    if (qa && typeof qa.onCommitFiberUnmount == "function") try {
      qa.onCommitFiberUnmount(zs, h);
    } catch {
    }
    switch (h.tag) {
      case 5:
        la || cc(h, s);
      case 6:
        var v = nr, w = Xr;
        nr = null, Ma(i, s, h), nr = v, Xr = w, nr !== null && (Xr ? (i = nr, h = h.stateNode, i.nodeType === 8 ? i.parentNode.removeChild(h) : i.removeChild(h)) : nr.removeChild(h.stateNode));
        break;
      case 18:
        nr !== null && (Xr ? (i = nr, h = h.stateNode, i.nodeType === 8 ? Zs(i.parentNode, h) : i.nodeType === 1 && Zs(i, h), Ks(i)) : Zs(nr, h.stateNode));
        break;
      case 4:
        v = nr, w = Xr, nr = h.stateNode.containerInfo, Xr = !0, Ma(i, s, h), nr = v, Xr = w;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!la && (v = h.updateQueue, v !== null && (v = v.lastEffect, v !== null))) {
          w = v = v.next;
          do {
            var E = w, P = E.destroy;
            E = E.tag, P !== void 0 && (E & 2 || E & 4) && xv(h, s, P), w = w.next;
          } while (w !== v);
        }
        Ma(i, s, h);
        break;
      case 1:
        if (!la && (cc(h, s), v = h.stateNode, typeof v.componentWillUnmount == "function")) try {
          v.props = h.memoizedProps, v.state = h.memoizedState, v.componentWillUnmount();
        } catch (z) {
          gr(h, s, z);
        }
        Ma(i, s, h);
        break;
      case 21:
        Ma(i, s, h);
        break;
      case 22:
        h.mode & 1 ? (la = (v = la) || h.memoizedState !== null, Ma(i, s, h), la = v) : Ma(i, s, h);
        break;
      default:
        Ma(i, s, h);
    }
  }
  function pc(i) {
    var s = i.updateQueue;
    if (s !== null) {
      i.updateQueue = null;
      var h = i.stateNode;
      h === null && (h = i.stateNode = new Vh()), s.forEach(function (v) {
        var w = fS.bind(null, i, v);
        h.has(v) || (h.add(v), v.then(w, w));
      });
    }
  }
  function ea(i, s) {
    var h = s.deletions;
    if (h !== null) for (var v = 0; v < h.length; v++) {
      var w = h[v];
      try {
        var E = i, P = s, z = P;
        e: for (; z !== null;) {
          switch (z.tag) {
            case 5:
              nr = z.stateNode, Xr = !1;
              break e;
            case 3:
              nr = z.stateNode.containerInfo, Xr = !0;
              break e;
            case 4:
              nr = z.stateNode.containerInfo, Xr = !0;
              break e;
          }
          z = z.return;
        }
        if (nr === null) throw Error(r(160));
        hc(E, P, w), nr = null, Xr = !1;
        var q = w.alternate;
        q !== null && (q.return = null), w.return = null;
      } catch (se) {
        gr(w, s, se);
      }
    }
    if (s.subtreeFlags & 12854) for (s = s.child; s !== null;) _0(s, i), s = s.sibling;
  }
  function _0(i, s) {
    var h = i.alternate, v = i.flags;
    switch (i.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (ea(s, i), Ao(i), v & 4) {
          try {
            dc(3, i, i.return), Wh(3, i);
          } catch (tt) {
            gr(i, i.return, tt);
          }
          try {
            dc(5, i, i.return);
          } catch (tt) {
            gr(i, i.return, tt);
          }
        }
        break;
      case 1:
        ea(s, i), Ao(i), v & 512 && h !== null && cc(h, h.return);
        break;
      case 5:
        if (ea(s, i), Ao(i), v & 512 && h !== null && cc(h, h.return), i.flags & 32) {
          var w = i.stateNode;
          try {
            Wr(w, "");
          } catch (tt) {
            gr(i, i.return, tt);
          }
        }
        if (v & 4 && (w = i.stateNode, w != null)) {
          var E = i.memoizedProps, P = h !== null ? h.memoizedProps : E, z = i.type, q = i.updateQueue;
          if (i.updateQueue = null, q !== null) try {
            z === "input" && E.type === "radio" && E.name != null && Bn(w, E), Hn(z, P);
            var se = Hn(z, E);
            for (P = 0; P < q.length; P += 2) {
              var Se = q[P], _e = q[P + 1];
              Se === "style" ? Ht(w, _e) : Se === "dangerouslySetInnerHTML" ? ji(w, _e) : Se === "children" ? Wr(w, _e) : U(w, Se, _e, se);
            }
            switch (z) {
              case "input":
                Vn(w, E);
                break;
              case "textarea":
                Oa(w, E);
                break;
              case "select":
                var be = w._wrapperState.wasMultiple;
                w._wrapperState.wasMultiple = !!E.multiple;
                var He = E.value;
                He != null ? dr(w, !!E.multiple, He, !1) : be !== !!E.multiple && (E.defaultValue != null ? dr(
                  w,
                  !!E.multiple,
                  E.defaultValue,
                  !0
                ) : dr(w, !!E.multiple, E.multiple ? [] : "", !1));
            }
            w[Bl] = E;
          } catch (tt) {
            gr(i, i.return, tt);
          }
        }
        break;
      case 6:
        if (ea(s, i), Ao(i), v & 4) {
          if (i.stateNode === null) throw Error(r(162));
          w = i.stateNode, E = i.memoizedProps;
          try {
            w.nodeValue = E;
          } catch (tt) {
            gr(i, i.return, tt);
          }
        }
        break;
      case 3:
        if (ea(s, i), Ao(i), v & 4 && h !== null && h.memoizedState.isDehydrated) try {
          Ks(s.containerInfo);
        } catch (tt) {
          gr(i, i.return, tt);
        }
        break;
      case 4:
        ea(s, i), Ao(i);
        break;
      case 13:
        ea(s, i), Ao(i), w = i.child, w.flags & 8192 && (E = w.memoizedState !== null, w.stateNode.isHidden = E, !E || w.alternate !== null && w.alternate.memoizedState !== null || (Kh = hn())), v & 4 && pc(i);
        break;
      case 22:
        if (Se = h !== null && h.memoizedState !== null, i.mode & 1 ? (la = (se = la) || Se, ea(s, i), la = se) : ea(s, i), Ao(i), v & 8192) {
          if (se = i.memoizedState !== null, (i.stateNode.isHidden = se) && !Se && i.mode & 1) for (Qe = i, Se = i.child; Se !== null;) {
            for (_e = Qe = Se; Qe !== null;) {
              switch (be = Qe, He = be.child, be.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  dc(4, be, be.return);
                  break;
                case 1:
                  cc(be, be.return);
                  var Je = be.stateNode;
                  if (typeof Je.componentWillUnmount == "function") {
                    v = be, h = be.return;
                    try {
                      s = v, Je.props = s.memoizedProps, Je.state = s.memoizedState, Je.componentWillUnmount();
                    } catch (tt) {
                      gr(v, h, tt);
                    }
                  }
                  break;
                case 5:
                  cc(be, be.return);
                  break;
                case 22:
                  if (be.memoizedState !== null) {
                    E0(_e);
                    continue;
                  }
              }
              He !== null ? (He.return = be, Qe = He) : E0(_e);
            }
            Se = Se.sibling;
          }
          e: for (Se = null, _e = i; ;) {
            if (_e.tag === 5) {
              if (Se === null) {
                Se = _e;
                try {
                  w = _e.stateNode, se ? (E = w.style, typeof E.setProperty == "function" ? E.setProperty("display", "none", "important") : E.display = "none") : (z = _e.stateNode, q = _e.memoizedProps.style, P = q != null && q.hasOwnProperty("display") ? q.display : null, z.style.display = At("display", P));
                } catch (tt) {
                  gr(i, i.return, tt);
                }
              }
            } else if (_e.tag === 6) {
              if (Se === null) try {
                _e.stateNode.nodeValue = se ? "" : _e.memoizedProps;
              } catch (tt) {
                gr(i, i.return, tt);
              }
            } else if ((_e.tag !== 22 && _e.tag !== 23 || _e.memoizedState === null || _e === i) && _e.child !== null) {
              _e.child.return = _e, _e = _e.child;
              continue;
            }
            if (_e === i) break e;
            for (; _e.sibling === null;) {
              if (_e.return === null || _e.return === i) break e;
              Se === _e && (Se = null), _e = _e.return;
            }
            Se === _e && (Se = null), _e.sibling.return = _e.return, _e = _e.sibling;
          }
        }
        break;
      case 19:
        ea(s, i), Ao(i), v & 4 && pc(i);
        break;
      case 21:
        break;
      default:
        ea(
          s,
          i
        ), Ao(i);
    }
  }
  function Ao(i) {
    var s = i.flags;
    if (s & 2) {
      try {
        e: {
          for (var h = i.return; h !== null;) {
            if (Sv(h)) {
              var v = h;
              break e;
            }
            h = h.return;
          }
          throw Error(r(160));
        }
        switch (v.tag) {
          case 5:
            var w = v.stateNode;
            v.flags & 32 && (Wr(w, ""), v.flags &= -33);
            var E = S0(i);
            fc(i, E, w);
            break;
          case 3:
          case 4:
            var P = v.stateNode.containerInfo, z = S0(i);
            Kd(i, z, P);
            break;
          default:
            throw Error(r(161));
        }
      } catch (q) {
        gr(i, i.return, q);
      }
      i.flags &= -3;
    }
    s & 4096 && (i.flags &= -4097);
  }
  function oS(i, s, h) {
    Qe = i, _v(i);
  }
  function _v(i, s, h) {
    for (var v = (i.mode & 1) !== 0; Qe !== null;) {
      var w = Qe, E = w.child;
      if (w.tag === 22 && v) {
        var P = w.memoizedState !== null || uc;
        if (!P) {
          var z = w.alternate, q = z !== null && z.memoizedState !== null || la;
          z = uc;
          var se = la;
          if (uc = P, (la = q) && !se) for (Qe = w; Qe !== null;) P = Qe, q = P.child, P.tag === 22 && P.memoizedState !== null ? Ev(w) : q !== null ? (q.return = P, Qe = q) : Ev(w);
          for (; E !== null;) Qe = E, _v(E), E = E.sibling;
          Qe = w, uc = z, la = se;
        }
        mc(i);
      } else w.subtreeFlags & 8772 && E !== null ? (E.return = w, Qe = E) : mc(i);
    }
  }
  function mc(i) {
    for (; Qe !== null;) {
      var s = Qe;
      if (s.flags & 8772) {
        var h = s.alternate;
        try {
          if (s.flags & 8772) switch (s.tag) {
            case 0:
            case 11:
            case 15:
              la || Wh(5, s);
              break;
            case 1:
              var v = s.stateNode;
              if (s.flags & 4 && !la) if (h === null) v.componentDidMount();
              else {
                var w = s.elementType === s.type ? h.memoizedProps : ni(s.type, h.memoizedProps);
                v.componentDidUpdate(w, h.memoizedState, v.__reactInternalSnapshotBeforeUpdate);
              }
              var E = s.updateQueue;
              E !== null && s0(s, E, v);
              break;
            case 3:
              var P = s.updateQueue;
              if (P !== null) {
                if (h = null, s.child !== null) switch (s.child.tag) {
                  case 5:
                    h = s.child.stateNode;
                    break;
                  case 1:
                    h = s.child.stateNode;
                }
                s0(s, P, h);
              }
              break;
            case 5:
              var z = s.stateNode;
              if (h === null && s.flags & 4) {
                h = z;
                var q = s.memoizedProps;
                switch (s.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    q.autoFocus && h.focus();
                    break;
                  case "img":
                    q.src && (h.src = q.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (s.memoizedState === null) {
                var se = s.alternate;
                if (se !== null) {
                  var Se = se.memoizedState;
                  if (Se !== null) {
                    var _e = Se.dehydrated;
                    _e !== null && Ks(_e);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(r(163));
          }
          la || s.flags & 512 && qh(s);
        } catch (be) {
          gr(s, s.return, be);
        }
      }
      if (s === i) {
        Qe = null;
        break;
      }
      if (h = s.sibling, h !== null) {
        h.return = s.return, Qe = h;
        break;
      }
      Qe = s.return;
    }
  }
  function E0(i) {
    for (; Qe !== null;) {
      var s = Qe;
      if (s === i) {
        Qe = null;
        break;
      }
      var h = s.sibling;
      if (h !== null) {
        h.return = s.return, Qe = h;
        break;
      }
      Qe = s.return;
    }
  }
  function Ev(i) {
    for (; Qe !== null;) {
      var s = Qe;
      try {
        switch (s.tag) {
          case 0:
          case 11:
          case 15:
            var h = s.return;
            try {
              Wh(4, s);
            } catch (q) {
              gr(s, h, q);
            }
            break;
          case 1:
            var v = s.stateNode;
            if (typeof v.componentDidMount == "function") {
              var w = s.return;
              try {
                v.componentDidMount();
              } catch (q) {
                gr(s, w, q);
              }
            }
            var E = s.return;
            try {
              qh(s);
            } catch (q) {
              gr(s, E, q);
            }
            break;
          case 5:
            var P = s.return;
            try {
              qh(s);
            } catch (q) {
              gr(s, P, q);
            }
        }
      } catch (q) {
        gr(s, s.return, q);
      }
      if (s === i) {
        Qe = null;
        break;
      }
      var z = s.sibling;
      if (z !== null) {
        z.return = s.return, Qe = z;
        break;
      }
      Qe = s.return;
    }
  }
  var sS = Math.ceil, eu = B.ReactCurrentDispatcher, Yh = B.ReactCurrentOwner, Wi = B.ReactCurrentBatchConfig, Yt = 0, vr = null, Gn = null, $r = 0, ii = 0, vc = Mt(0), zr = 0, Gd = null, tu = 0, gc = 0, Cv = 0, ll = null, Ca = null, Kh = 0, yc = 1 / 0, cs = null, Gh = !1, Tv = null, qi = null, bc = !1, Yi = null, Qh = 0, Qd = 0, Jh = null, Jd = -1, nu = 0;
  function ta() {
    return Yt & 6 ? hn() : Jd !== -1 ? Jd : Jd = hn();
  }
  function ds(i) {
    return i.mode & 1 ? Yt & 2 && $r !== 0 ? $r & -$r : mh.transition !== null ? (nu === 0 && (nu = ju()), nu) : (i = pn, i !== 0 || (i = window.event, i = i === void 0 ? 16 : bd(i.type)), i) : 1;
  }
  function lr(i, s, h, v) {
    if (50 < Qd) throw Qd = 0, Jh = null, Error(r(185));
    Go(i, h, v), (!(Yt & 2) || i !== vr) && (i === vr && (!(Yt & 2) && (gc |= h), zr === 4 && Do(i, $r)), Br(i, v), h === 1 && Yt === 0 && !(s.mode & 1) && (yc = hn() + 500, Zr && Ja()));
  }
  function Br(i, s) {
    var h = i.callbackNode;
    Hs(i, s);
    var v = Da(i, i === vr ? $r : 0);
    if (v === 0) h !== null && qn(h), i.callbackNode = null, i.callbackPriority = 0;
    else if (s = v & -v, i.callbackPriority !== s) {
      if (h != null && qn(h), s === 1) i.tag === 0 ? av(wc.bind(null, i)) : rv(wc.bind(null, i)), ev(function () {
        !(Yt & 6) && Ja();
      }), h = null;
      else {
        switch (Du(v)) {
          case 1:
            h = ja;
            break;
          case 4:
            h = Ft;
            break;
          case 16:
            h = Ai;
            break;
          case 536870912:
            h = Ou;
            break;
          default:
            h = Ai;
        }
        h = A0(h, Zh.bind(null, i));
      }
      i.callbackPriority = s, i.callbackNode = h;
    }
  }
  function Zh(i, s) {
    if (Jd = -1, nu = 0, Yt & 6) throw Error(r(327));
    var h = i.callbackNode;
    if (xc() && i.callbackNode !== h) return null;
    var v = Da(i, i === vr ? $r : 0);
    if (v === 0) return null;
    if (v & 30 || v & i.expiredLanes || s) s = ep(i, v);
    else {
      s = v;
      var w = Yt;
      Yt |= 2;
      var E = T0();
      (vr !== i || $r !== s) && (cs = null, yc = hn() + 500, au(i, s));
      do
        try {
          uS();
          break;
        } catch (z) {
          C0(i, z);
        }
      while (!0);
      bi(), eu.current = E, Yt = w, Gn !== null ? s = 0 : (vr = null, $r = 0, s = zr);
    }
    if (s !== 0) {
      if (s === 2 && (w = Ws(i), w !== 0 && (v = w, s = ru(i, w))), s === 1) throw h = Gd, au(i, 0), Do(i, v), Br(i, hn()), h;
      if (s === 6) Do(i, v);
      else {
        if (w = i.current.alternate, !(v & 30) && !kv(w) && (s = ep(i, v), s === 2 && (E = Ws(i), E !== 0 && (v = E, s = ru(i, E))), s === 1)) throw h = Gd, au(i, 0), Do(i, v), Br(i, hn()), h;
        switch (i.finishedWork = w, i.finishedLanes = v, s) {
          case 0:
          case 1:
            throw Error(r(345));
          case 2:
            ul(i, Ca, cs);
            break;
          case 3:
            if (Do(i, v), (v & 130023424) === v && (s = Kh + 500 - hn(), 10 < s)) {
              if (Da(i, 0) !== 0) break;
              if (w = i.suspendedLanes, (w & v) !== v) {
                ta(), i.pingedLanes |= i.suspendedLanes & w;
                break;
              }
              i.timeoutHandle = zl(ul.bind(null, i, Ca, cs), s);
              break;
            }
            ul(i, Ca, cs);
            break;
          case 4:
            if (Do(i, v), (v & 4194240) === v) break;
            for (s = i.eventTimes, w = -1; 0 < v;) {
              var P = 31 - Aa(v);
              E = 1 << P, P = s[P], P > w && (w = P), v &= ~E;
            }
            if (v = w, v = hn() - v, v = (120 > v ? 120 : 480 > v ? 480 : 1080 > v ? 1080 : 1920 > v ? 1920 : 3e3 > v ? 3e3 : 4320 > v ? 4320 : 1960 * sS(v / 1960)) - v, 10 < v) {
              i.timeoutHandle = zl(ul.bind(null, i, Ca, cs), v);
              break;
            }
            ul(i, Ca, cs);
            break;
          case 5:
            ul(i, Ca, cs);
            break;
          default:
            throw Error(r(329));
        }
      }
    }
    return Br(i, hn()), i.callbackNode === h ? Zh.bind(null, i) : null;
  }
  function ru(i, s) {
    var h = ll;
    return i.current.memoizedState.isDehydrated && (au(i, s).flags |= 256), i = ep(i, s), i !== 2 && (s = Ca, Ca = h, s !== null && Rv(s)), i;
  }
  function Rv(i) {
    Ca === null ? Ca = i : Ca.push.apply(Ca, i);
  }
  function kv(i) {
    for (var s = i; ;) {
      if (s.flags & 16384) {
        var h = s.updateQueue;
        if (h !== null && (h = h.stores, h !== null)) for (var v = 0; v < h.length; v++) {
          var w = h[v], E = w.getSnapshot;
          w = w.value;
          try {
            if (!Mi(E(), w)) return !1;
          } catch {
            return !1;
          }
        }
      }
      if (h = s.child, s.subtreeFlags & 16384 && h !== null) h.return = s, s = h;
      else {
        if (s === i) break;
        for (; s.sibling === null;) {
          if (s.return === null || s.return === i) return !0;
          s = s.return;
        }
        s.sibling.return = s.return, s = s.sibling;
      }
    }
    return !0;
  }
  function Do(i, s) {
    for (s &= ~Cv, s &= ~gc, i.suspendedLanes |= s, i.pingedLanes &= ~s, i = i.expirationTimes; 0 < s;) {
      var h = 31 - Aa(s), v = 1 << h;
      i[h] = -1, s &= ~v;
    }
  }
  function wc(i) {
    if (Yt & 6) throw Error(r(327));
    xc();
    var s = Da(i, 0);
    if (!(s & 1)) return Br(i, hn()), null;
    var h = ep(i, s);
    if (i.tag !== 0 && h === 2) {
      var v = Ws(i);
      v !== 0 && (s = v, h = ru(i, v));
    }
    if (h === 1) throw h = Gd, au(i, 0), Do(i, s), Br(i, hn()), h;
    if (h === 6) throw Error(r(345));
    return i.finishedWork = i.current.alternate, i.finishedLanes = s, ul(i, Ca, cs), Br(i, hn()), null;
  }
  function Ov(i, s) {
    var h = Yt;
    Yt |= 1;
    try {
      return i(s);
    } finally {
      Yt = h, Yt === 0 && (yc = hn() + 500, Zr && Ja());
    }
  }
  function Po(i) {
    Yi !== null && Yi.tag === 0 && !(Yt & 6) && xc();
    var s = Yt;
    Yt |= 1;
    var h = Wi.transition, v = pn;
    try {
      if (Wi.transition = null, pn = 1, i) return i();
    } finally {
      pn = v, Wi.transition = h, Yt = s, !(Yt & 6) && Ja();
    }
  }
  function Xh() {
    ii = vc.current, bn(vc);
  }
  function au(i, s) {
    i.finishedWork = null, i.finishedLanes = 0;
    var h = i.timeoutHandle;
    if (h !== -1 && (i.timeoutHandle = -1, Zy(h)), Gn !== null) for (h = Gn.return; h !== null;) {
      var v = h;
      switch (ov(v), v.tag) {
        case 1:
          v = v.type.childContextTypes, v != null && Ui();
          break;
        case 3:
          Zu(), bn(pr), bn(Tt), hv();
          break;
        case 5:
          fv(v);
          break;
        case 4:
          Zu();
          break;
        case 13:
          bn(tr);
          break;
        case 19:
          bn(tr);
          break;
        case 10:
          uv(v.type._context);
          break;
        case 22:
        case 23:
          Xh();
      }
      h = h.return;
    }
    if (vr = i, Gn = i = cl(i.current, null), $r = ii = s, zr = 0, Gd = null, Cv = gc = tu = 0, Ca = ll = null, Wl !== null) {
      for (s = 0; s < Wl.length; s++) if (h = Wl[s], v = h.interleaved, v !== null) {
        h.interleaved = null;
        var w = v.next, E = h.pending;
        if (E !== null) {
          var P = E.next;
          E.next = w, v.next = P;
        }
        h.pending = v;
      }
      Wl = null;
    }
    return i;
  }
  function C0(i, s) {
    do {
      var h = Gn;
      try {
        if (bi(), Sh.current = _a, wi) {
          for (var v = st.memoizedState; v !== null;) {
            var w = v.queue;
            w !== null && (w.pending = null), v = v.next;
          }
          wi = !1;
        }
        if (rt = 0, Bt = Rt = st = null, Xu = !1, Fd = 0, Yh.current = null, h === null || h.return === null) {
          zr = 1, Gd = s, Gn = null;
          break;
        }
        e: {
          var E = i, P = h.return, z = h, q = s;
          if (s = $r, z.flags |= 32768, q !== null && typeof q == "object" && typeof q.then == "function") {
            var se = q, Se = z, _e = Se.tag;
            if (!(Se.mode & 1) && (_e === 0 || _e === 11 || _e === 15)) {
              var be = Se.alternate;
              be ? (Se.updateQueue = be.updateQueue, Se.memoizedState = be.memoizedState, Se.lanes = be.lanes) : (Se.updateQueue = null, Se.memoizedState = null);
            }
            var He = v0(P);
            if (He !== null) {
              He.flags &= -257, yv(He, P, z, E, s), He.mode & 1 && Hd(E, se, s), s = He, q = se;
              var Je = s.updateQueue;
              if (Je === null) {
                var tt = /* @__PURE__ */ new Set();
                tt.add(q), s.updateQueue = tt;
              } else Je.add(q);
              break e;
            } else {
              if (!(s & 1)) {
                Hd(E, se, s), Zd();
                break e;
              }
              q = Error(r(426));
            }
          } else if (Kn && z.mode & 1) {
            var Er = v0(P);
            if (Er !== null) {
              !(Er.flags & 65536) && (Er.flags |= 256), yv(Er, P, z, E, s), lv(ol(q, z));
              break e;
            }
          }
          E = q = ol(q, z), zr !== 4 && (zr = 2), ll === null ? ll = [E] : ll.push(E), E = P;
          do {
            switch (E.tag) {
              case 3:
                E.flags |= 65536, s &= -s, E.lanes |= s;
                var Z = p0(E, q, s);
                o0(E, Z);
                break e;
              case 1:
                z = q;
                var Q = E.type, ne = E.stateNode;
                if (!(E.flags & 128) && (typeof Q.getDerivedStateFromError == "function" || ne !== null && typeof ne.componentDidCatch == "function" && (qi === null || !qi.has(ne)))) {
                  E.flags |= 65536, s &= -s, E.lanes |= s;
                  var je = m0(E, z, s);
                  o0(E, je);
                  break e;
                }
            }
            E = E.return;
          } while (E !== null);
        }
        k0(h);
      } catch (at) {
        s = at, Gn === h && h !== null && (Gn = h = h.return);
        continue;
      }
      break;
    } while (!0);
  }
  function T0() {
    var i = eu.current;
    return eu.current = _a, i === null ? _a : i;
  }
  function Zd() {
    (zr === 0 || zr === 3 || zr === 2) && (zr = 4), vr === null || !(tu & 268435455) && !(gc & 268435455) || Do(vr, $r);
  }
  function ep(i, s) {
    var h = Yt;
    Yt |= 2;
    var v = T0();
    (vr !== i || $r !== s) && (cs = null, au(i, s));
    do
      try {
        lS();
        break;
      } catch (w) {
        C0(i, w);
      }
    while (!0);
    if (bi(), Yt = h, eu.current = v, Gn !== null) throw Error(r(261));
    return vr = null, $r = 0, zr;
  }
  function lS() {
    for (; Gn !== null;) R0(Gn);
  }
  function uS() {
    for (; Gn !== null && !wa();) R0(Gn);
  }
  function R0(i) {
    var s = j0(i.alternate, i, ii);
    i.memoizedProps = i.pendingProps, s === null ? k0(i) : Gn = s, Yh.current = null;
  }
  function k0(i) {
    var s = i;
    do {
      var h = s.alternate;
      if (i = s.return, s.flags & 32768) {
        if (h = aS(h, s), h !== null) {
          h.flags &= 32767, Gn = h;
          return;
        }
        if (i !== null) i.flags |= 32768, i.subtreeFlags = 0, i.deletions = null;
        else {
          zr = 6, Gn = null;
          return;
        }
      } else if (h = rS(h, s, ii), h !== null) {
        Gn = h;
        return;
      }
      if (s = s.sibling, s !== null) {
        Gn = s;
        return;
      }
      Gn = s = i;
    } while (s !== null);
    zr === 0 && (zr = 5);
  }
  function ul(i, s, h) {
    var v = pn, w = Wi.transition;
    try {
      Wi.transition = null, pn = 1, cS(i, s, h, v);
    } finally {
      Wi.transition = w, pn = v;
    }
    return null;
  }
  function cS(i, s, h, v) {
    do
      xc();
    while (Yi !== null);
    if (Yt & 6) throw Error(r(327));
    h = i.finishedWork;
    var w = i.finishedLanes;
    if (h === null) return null;
    if (i.finishedWork = null, i.finishedLanes = 0, h === i.current) throw Error(r(177));
    i.callbackNode = null, i.callbackPriority = 0;
    var E = h.lanes | h.childLanes;
    if (Dm(i, E), i === vr && (Gn = vr = null, $r = 0), !(h.subtreeFlags & 2064) && !(h.flags & 2064) || bc || (bc = !0, A0(Ai, function () {
      return xc(), null;
    })), E = (h.flags & 15990) !== 0, h.subtreeFlags & 15990 || E) {
      E = Wi.transition, Wi.transition = null;
      var P = pn;
      pn = 1;
      var z = Yt;
      Yt |= 4, Yh.current = null, iS(i, h), _0(h, i), ah($l), Pi = !!Zm, $l = Zm = null, i.current = h, oS(h), Co(), Yt = z, pn = P, Wi.transition = E;
    } else i.current = h;
    if (bc && (bc = !1, Yi = i, Qh = w), E = i.pendingLanes, E === 0 && (qi = null), vd(h.stateNode), Br(i, hn()), s !== null) for (v = i.onRecoverableError, h = 0; h < s.length; h++) w = s[h], v(w.value, { componentStack: w.stack, digest: w.digest });
    if (Gh) throw Gh = !1, i = Tv, Tv = null, i;
    return Qh & 1 && i.tag !== 0 && xc(), E = i.pendingLanes, E & 1 ? i === Jh ? Qd++ : (Qd = 0, Jh = i) : Qd = 0, Ja(), null;
  }
  function xc() {
    if (Yi !== null) {
      var i = Du(Qh), s = Wi.transition, h = pn;
      try {
        if (Wi.transition = null, pn = 16 > i ? 16 : i, Yi === null) var v = !1;
        else {
          if (i = Yi, Yi = null, Qh = 0, Yt & 6) throw Error(r(331));
          var w = Yt;
          for (Yt |= 4, Qe = i.current; Qe !== null;) {
            var E = Qe, P = E.child;
            if (Qe.flags & 16) {
              var z = E.deletions;
              if (z !== null) {
                for (var q = 0; q < z.length; q++) {
                  var se = z[q];
                  for (Qe = se; Qe !== null;) {
                    var Se = Qe;
                    switch (Se.tag) {
                      case 0:
                      case 11:
                      case 15:
                        dc(8, Se, E);
                    }
                    var _e = Se.child;
                    if (_e !== null) _e.return = Se, Qe = _e;
                    else for (; Qe !== null;) {
                      Se = Qe;
                      var be = Se.sibling, He = Se.return;
                      if (x0(Se), Se === se) {
                        Qe = null;
                        break;
                      }
                      if (be !== null) {
                        be.return = He, Qe = be;
                        break;
                      }
                      Qe = He;
                    }
                  }
                }
                var Je = E.alternate;
                if (Je !== null) {
                  var tt = Je.child;
                  if (tt !== null) {
                    Je.child = null;
                    do {
                      var Er = tt.sibling;
                      tt.sibling = null, tt = Er;
                    } while (tt !== null);
                  }
                }
                Qe = E;
              }
            }
            if (E.subtreeFlags & 2064 && P !== null) P.return = E, Qe = P;
            else e: for (; Qe !== null;) {
              if (E = Qe, E.flags & 2048) switch (E.tag) {
                case 0:
                case 11:
                case 15:
                  dc(9, E, E.return);
              }
              var Z = E.sibling;
              if (Z !== null) {
                Z.return = E.return, Qe = Z;
                break e;
              }
              Qe = E.return;
            }
          }
          var Q = i.current;
          for (Qe = Q; Qe !== null;) {
            P = Qe;
            var ne = P.child;
            if (P.subtreeFlags & 2064 && ne !== null) ne.return = P, Qe = ne;
            else e: for (P = Q; Qe !== null;) {
              if (z = Qe, z.flags & 2048) try {
                switch (z.tag) {
                  case 0:
                  case 11:
                  case 15:
                    Wh(9, z);
                }
              } catch (at) {
                gr(z, z.return, at);
              }
              if (z === P) {
                Qe = null;
                break e;
              }
              var je = z.sibling;
              if (je !== null) {
                je.return = z.return, Qe = je;
                break e;
              }
              Qe = z.return;
            }
          }
          if (Yt = w, Ja(), qa && typeof qa.onPostCommitFiberRoot == "function") try {
            qa.onPostCommitFiberRoot(zs, i);
          } catch {
          }
          v = !0;
        }
        return v;
      } finally {
        pn = h, Wi.transition = s;
      }
    }
    return !1;
  }
  function O0(i, s, h) {
    s = ol(h, s), s = p0(i, s, 1), i = al(i, s, 1), s = ta(), i !== null && (Go(i, 1, s), Br(i, s));
  }
  function gr(i, s, h) {
    if (i.tag === 3) O0(i, i, h);
    else for (; s !== null;) {
      if (s.tag === 3) {
        O0(s, i, h);
        break;
      } else if (s.tag === 1) {
        var v = s.stateNode;
        if (typeof s.type.getDerivedStateFromError == "function" || typeof v.componentDidCatch == "function" && (qi === null || !qi.has(v))) {
          i = ol(h, i), i = m0(s, i, 1), s = al(s, i, 1), i = ta(), s !== null && (Go(s, 1, i), Br(s, i));
          break;
        }
      }
      s = s.return;
    }
  }
  function dS(i, s, h) {
    var v = i.pingCache;
    v !== null && v.delete(s), s = ta(), i.pingedLanes |= i.suspendedLanes & h, vr === i && ($r & h) === h && (zr === 4 || zr === 3 && ($r & 130023424) === $r && 500 > hn() - Kh ? au(i, 0) : Cv |= h), Br(i, s);
  }
  function N0(i, s) {
    s === 0 && (i.mode & 1 ? (s = Bs, Bs <<= 1, !(Bs & 130023424) && (Bs = 4194304)) : s = 1);
    var h = ta();
    i = ss(i, s), i !== null && (Go(i, s, h), Br(i, h));
  }
  function Nv(i) {
    var s = i.memoizedState, h = 0;
    s !== null && (h = s.retryLane), N0(i, h);
  }
  function fS(i, s) {
    var h = 0;
    switch (i.tag) {
      case 13:
        var v = i.stateNode, w = i.memoizedState;
        w !== null && (h = w.retryLane);
        break;
      case 19:
        v = i.stateNode;
        break;
      default:
        throw Error(r(314));
    }
    v !== null && v.delete(s), N0(i, h);
  }
  var j0;
  j0 = function (i, s, h) {
    if (i !== null) if (i.memoizedProps !== s.pendingProps || pr.current) ri = !0;
    else {
      if (!(i.lanes & h) && !(s.flags & 128)) return ri = !1, us(i, s, h);
      ri = !!(i.flags & 131072);
    }
    else ri = !1, Kn && s.flags & 1048576 && iv(s, Yu, s.index);
    switch (s.lanes = 0, s.tag) {
      case 2:
        var v = s.type;
        Yd(i, s), i = s.pendingProps;
        var w = Ii(s, Tt.current);
        Gu(s, h), w = ye(null, s, v, i, w, h);
        var E = Pr();
        return s.flags |= 1, typeof w == "object" && w !== null && typeof w.render == "function" && w.$$typeof === void 0 ? (s.tag = 1, s.memoizedState = null, s.updateQueue = null, er(v) ? (E = !0, ch(s)) : E = !1, s.memoizedState = w.state !== null && w.state !== void 0 ? w.state : null, gh(s), w.updater = Jl, s.stateNode = w, w._reactInternals = s, vv(s, v, i, h), s = Fh(null, s, v, !0, E, h)) : (s.tag = 0, Kn && E && dh(s), Sr(null, s, w, h), s = s.child), s;
      case 16:
        v = s.elementType;
        e: {
          switch (Yd(i, s), i = s.pendingProps, w = v._init, v = w(v._payload), s.type = v, w = s.tag = hS(v), i = ni(v, i), w) {
            case 0:
              s = Pt(null, s, v, i, h);
              break e;
            case 1:
              s = Wd(null, s, v, i, h);
              break e;
            case 11:
              s = oc(null, s, v, i, h);
              break e;
            case 14:
              s = sl(null, s, v, ni(v.type, i), h);
              break e;
          }
          throw Error(r(
            306,
            v,
            ""
          ));
        }
        return s;
      case 0:
        return v = s.type, w = s.pendingProps, w = s.elementType === v ? w : ni(v, w), Pt(i, s, v, w, h);
      case 1:
        return v = s.type, w = s.pendingProps, w = s.elementType === v ? w : ni(v, w), Wd(i, s, v, w, h);
      case 3:
        e: {
          if (nS(s), i === null) throw Error(r(387));
          v = s.pendingProps, E = s.memoizedState, w = E.element, Qu(i, s), bh(s, v, null, h);
          var P = s.memoizedState;
          if (v = P.element, E.isDehydrated) if (E = { element: v, isDehydrated: !1, cache: P.cache, pendingSuspenseBoundaries: P.pendingSuspenseBoundaries, transitions: P.transitions }, s.updateQueue.baseState = E, s.memoizedState = E, s.flags & 256) {
            w = ol(Error(r(423)), s), s = y0(i, s, v, h, w);
            break e;
          } else if (v !== w) {
            w = ol(Error(r(424)), s), s = y0(i, s, v, h, w);
            break e;
          } else for (ei = co(s.stateNode.containerInfo.firstChild), yi = s, Kn = !0, $i = null, h = a0(s, null, v, h), s.child = h; h;) h.flags = h.flags & -3 | 4096, h = h.sibling;
          else {
            if (sr(), v === w) {
              s = _r(i, s, h);
              break e;
            }
            Sr(i, s, v, h);
          }
          s = s.child;
        }
        return s;
      case 5:
        return l0(s), i === null && hh(s), v = s.type, w = s.pendingProps, E = i !== null ? i.memoizedProps : null, P = w.children, jd(v, w) ? P = null : E !== null && jd(v, E) && (s.flags |= 32), Zl(i, s), Sr(i, s, P, h), s.child;
      case 6:
        return i === null && hh(s), null;
      case 13:
        return b0(i, s, h);
      case 4:
        return dv(s, s.stateNode.containerInfo), v = s.pendingProps, i === null ? s.child = Ku(s, null, v, h) : Sr(i, s, v, h), s.child;
      case 11:
        return v = s.type, w = s.pendingProps, w = s.elementType === v ? w : ni(v, w), oc(i, s, v, w, h);
      case 7:
        return Sr(i, s, s.pendingProps, h), s.child;
      case 8:
        return Sr(i, s, s.pendingProps.children, h), s.child;
      case 12:
        return Sr(i, s, s.pendingProps.children, h), s.child;
      case 10:
        e: {
          if (v = s.type._context, w = s.pendingProps, E = s.memoizedProps, P = w.value, En(os, v._currentValue), v._currentValue = P, E !== null) if (Mi(E.value, P)) {
            if (E.children === w.children && !pr.current) {
              s = _r(i, s, h);
              break e;
            }
          } else for (E = s.child, E !== null && (E.return = s); E !== null;) {
            var z = E.dependencies;
            if (z !== null) {
              P = E.child;
              for (var q = z.firstContext; q !== null;) {
                if (q.context === v) {
                  if (E.tag === 1) {
                    q = ti(-1, h & -h), q.tag = 2;
                    var se = E.updateQueue;
                    if (se !== null) {
                      se = se.shared;
                      var Se = se.pending;
                      Se === null ? q.next = q : (q.next = Se.next, Se.next = q), se.pending = q;
                    }
                  }
                  E.lanes |= h, q = E.alternate, q !== null && (q.lanes |= h), cv(
                    E.return,
                    h,
                    s
                  ), z.lanes |= h;
                  break;
                }
                q = q.next;
              }
            } else if (E.tag === 10) P = E.type === s.type ? null : E.child;
            else if (E.tag === 18) {
              if (P = E.return, P === null) throw Error(r(341));
              P.lanes |= h, z = P.alternate, z !== null && (z.lanes |= h), cv(P, h, s), P = E.sibling;
            } else P = E.child;
            if (P !== null) P.return = E;
            else for (P = E; P !== null;) {
              if (P === s) {
                P = null;
                break;
              }
              if (E = P.sibling, E !== null) {
                E.return = P.return, P = E;
                break;
              }
              P = P.return;
            }
            E = P;
          }
          Sr(i, s, w.children, h), s = s.child;
        }
        return s;
      case 9:
        return w = s.type, v = s.pendingProps.children, Gu(s, h), w = Bi(w), v = v(w), s.flags |= 1, Sr(i, s, v, h), s.child;
      case 14:
        return v = s.type, w = ni(v, s.pendingProps), w = ni(v.type, w), sl(i, s, v, w, h);
      case 15:
        return Uh(i, s, s.type, s.pendingProps, h);
      case 17:
        return v = s.type, w = s.pendingProps, w = s.elementType === v ? w : ni(v, w), Yd(i, s), s.tag = 1, er(v) ? (i = !0, ch(s)) : i = !1, Gu(s, h), d0(s, v, w), vv(s, v, w, h), Fh(null, s, v, !0, i, h);
      case 19:
        return wv(i, s, h);
      case 22:
        return ai(i, s, h);
    }
    throw Error(r(156, s.tag));
  };
  function A0(i, s) {
    return Dn(i, s);
  }
  function D0(i, s, h, v) {
    this.tag = i, this.key = h, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = s, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = v, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function Ki(i, s, h, v) {
    return new D0(i, s, h, v);
  }
  function jv(i) {
    return i = i.prototype, !(!i || !i.isReactComponent);
  }
  function hS(i) {
    if (typeof i == "function") return jv(i) ? 1 : 0;
    if (i != null) {
      if (i = i.$$typeof, i === Ne) return 11;
      if (i === Ge) return 14;
    }
    return 2;
  }
  function cl(i, s) {
    var h = i.alternate;
    return h === null ? (h = Ki(i.tag, s, i.key, i.mode), h.elementType = i.elementType, h.type = i.type, h.stateNode = i.stateNode, h.alternate = i, i.alternate = h) : (h.pendingProps = s, h.type = i.type, h.flags = 0, h.subtreeFlags = 0, h.deletions = null), h.flags = i.flags & 14680064, h.childLanes = i.childLanes, h.lanes = i.lanes, h.child = i.child, h.memoizedProps = i.memoizedProps, h.memoizedState = i.memoizedState, h.updateQueue = i.updateQueue, s = i.dependencies, h.dependencies = s === null ? null : { lanes: s.lanes, firstContext: s.firstContext }, h.sibling = i.sibling, h.index = i.index, h.ref = i.ref, h;
  }
  function tp(i, s, h, v, w, E) {
    var P = 2;
    if (v = i, typeof i == "function") jv(i) && (P = 1);
    else if (typeof i == "string") P = 5;
    else e: switch (i) {
      case re:
        return iu(h.children, w, E, s);
      case ve:
        P = 8, w |= 8;
        break;
      case Ce:
        return i = Ki(12, h, s, w | 2), i.elementType = Ce, i.lanes = E, i;
      case Re:
        return i = Ki(13, h, s, w), i.elementType = Re, i.lanes = E, i;
      case me:
        return i = Ki(19, h, s, w), i.elementType = me, i.lanes = E, i;
      case we:
        return np(h, w, E, s);
      default:
        if (typeof i == "object" && i !== null) switch (i.$$typeof) {
          case ke:
            P = 10;
            break e;
          case Ie:
            P = 9;
            break e;
          case Ne:
            P = 11;
            break e;
          case Ge:
            P = 14;
            break e;
          case Me:
            P = 16, v = null;
            break e;
        }
        throw Error(r(130, i == null ? i : typeof i, ""));
    }
    return s = Ki(P, h, s, w), s.elementType = i, s.type = v, s.lanes = E, s;
  }
  function iu(i, s, h, v) {
    return i = Ki(7, i, v, s), i.lanes = h, i;
  }
  function np(i, s, h, v) {
    return i = Ki(22, i, v, s), i.elementType = we, i.lanes = h, i.stateNode = { isHidden: !1 }, i;
  }
  function rp(i, s, h) {
    return i = Ki(6, i, null, s), i.lanes = h, i;
  }
  function Xd(i, s, h) {
    return s = Ki(4, i.children !== null ? i.children : [], i.key, s), s.lanes = h, s.stateNode = { containerInfo: i.containerInfo, pendingChildren: null, implementation: i.implementation }, s;
  }
  function ef(i, s, h, v, w) {
    this.tag = s, this.containerInfo = i, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = Au(0), this.expirationTimes = Au(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Au(0), this.identifierPrefix = v, this.onRecoverableError = w, this.mutableSourceEagerHydrationData = null;
  }
  function Av(i, s, h, v, w, E, P, z, q) {
    return i = new ef(i, s, h, z, q), s === 1 ? (s = 1, E === !0 && (s |= 8)) : s = 0, E = Ki(3, null, null, s), i.current = E, E.stateNode = i, E.memoizedState = { element: v, isDehydrated: h, cache: null, transitions: null, pendingSuspenseBoundaries: null }, gh(E), i;
  }
  function P0(i, s, h) {
    var v = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return { $$typeof: te, key: v == null ? null : "" + v, children: i, containerInfo: s, implementation: h };
  }
  function Dv(i) {
    if (!i) return Oo;
    i = i._reactInternals;
    e: {
      if (ot(i) !== i || i.tag !== 1) throw Error(r(170));
      var s = i;
      do {
        switch (s.tag) {
          case 3:
            s = s.stateNode.context;
            break e;
          case 1:
            if (er(s.type)) {
              s = s.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        s = s.return;
      } while (s !== null);
      throw Error(r(171));
    }
    if (i.tag === 1) {
      var h = i.type;
      if (er(h)) return Pd(i, h, s);
    }
    return s;
  }
  function Pv(i, s, h, v, w, E, P, z, q) {
    return i = Av(h, v, !0, i, w, E, P, z, q), i.context = Dv(null), h = i.current, v = ta(), w = ds(h), E = ti(v, w), E.callback = s ?? null, al(h, E, w), i.current.lanes = w, Go(i, w, v), Br(i, v), i;
  }
  function ap(i, s, h, v) {
    var w = s.current, E = ta(), P = ds(w);
    return h = Dv(h), s.context === null ? s.context = h : s.pendingContext = h, s = ti(E, P), s.payload = { element: i }, v = v === void 0 ? null : v, v !== null && (s.callback = v), i = al(w, s, P), i !== null && (lr(i, w, P, E), yh(i, w, P)), P;
  }
  function tf(i) {
    if (i = i.current, !i.child) return null;
    switch (i.child.tag) {
      case 5:
        return i.child.stateNode;
      default:
        return i.child.stateNode;
    }
  }
  function M0(i, s) {
    if (i = i.memoizedState, i !== null && i.dehydrated !== null) {
      var h = i.retryLane;
      i.retryLane = h !== 0 && h < s ? h : s;
    }
  }
  function Mv(i, s) {
    M0(i, s), (i = i.alternate) && M0(i, s);
  }
  function pS() {
    return null;
  }
  var Lv = typeof reportError == "function" ? reportError : function (i) {
    console.error(i);
  };
  function ip(i) {
    this._internalRoot = i;
  }
  nf.prototype.render = ip.prototype.render = function (i) {
    var s = this._internalRoot;
    if (s === null) throw Error(r(409));
    ap(i, s, null, null);
  }, nf.prototype.unmount = ip.prototype.unmount = function () {
    var i = this._internalRoot;
    if (i !== null) {
      this._internalRoot = null;
      var s = i.containerInfo;
      Po(function () {
        ap(null, i, null, null);
      }), s[as] = null;
    }
  };
  function nf(i) {
    this._internalRoot = i;
  }
  nf.prototype.unstable_scheduleHydration = function (i) {
    if (i) {
      var s = Mu();
      i = { blockedOn: null, target: i, priority: s };
      for (var h = 0; h < _n.length && s !== 0 && s < _n[h].priority; h++);
      _n.splice(h, 0, i), h === 0 && Jf(i);
    }
  };
  function dl(i) {
    return !(!i || i.nodeType !== 1 && i.nodeType !== 9 && i.nodeType !== 11);
  }
  function op(i) {
    return !(!i || i.nodeType !== 1 && i.nodeType !== 9 && i.nodeType !== 11 && (i.nodeType !== 8 || i.nodeValue !== " react-mount-point-unstable "));
  }
  function L0() {
  }
  function mS(i, s, h, v, w) {
    if (w) {
      if (typeof v == "function") {
        var E = v;
        v = function () {
          var se = tf(P);
          E.call(se);
        };
      }
      var P = Pv(s, v, i, 0, null, !1, !1, "", L0);
      return i._reactRootContainer = P, i[as] = P.current, Wu(i.nodeType === 8 ? i.parentNode : i), Po(), P;
    }
    for (; w = i.lastChild;) i.removeChild(w);
    if (typeof v == "function") {
      var z = v;
      v = function () {
        var se = tf(q);
        z.call(se);
      };
    }
    var q = Av(i, 0, !1, null, null, !1, !1, "", L0);
    return i._reactRootContainer = q, i[as] = q.current, Wu(i.nodeType === 8 ? i.parentNode : i), Po(function () {
      ap(s, q, h, v);
    }), q;
  }
  function sp(i, s, h, v, w) {
    var E = h._reactRootContainer;
    if (E) {
      var P = E;
      if (typeof w == "function") {
        var z = w;
        w = function () {
          var q = tf(P);
          z.call(q);
        };
      }
      ap(s, P, i, w);
    } else P = mS(h, s, i, w, v);
    return tf(P);
  }
  Dl = function (i) {
    switch (i.tag) {
      case 3:
        var s = i.stateNode;
        if (s.current.memoizedState.isDehydrated) {
          var h = io(s.pendingLanes);
          h !== 0 && (To(s, h | 1), Br(s, hn()), !(Yt & 6) && (yc = hn() + 500, Ja()));
        }
        break;
      case 13:
        Po(function () {
          var v = ss(i, 1);
          if (v !== null) {
            var w = ta();
            lr(v, i, 1, w);
          }
        }), Mv(i, 1);
    }
  }, Pu = function (i) {
    if (i.tag === 13) {
      var s = ss(i, 134217728);
      if (s !== null) {
        var h = ta();
        lr(s, i, 134217728, h);
      }
      Mv(i, 134217728);
    }
  }, Jt = function (i) {
    if (i.tag === 13) {
      var s = ds(i), h = ss(i, s);
      if (h !== null) {
        var v = ta();
        lr(h, i, s, v);
      }
      Mv(i, s);
    }
  }, Mu = function () {
    return pn;
  }, Lu = function (i, s) {
    var h = pn;
    try {
      return pn = i, s();
    } finally {
      pn = h;
    }
  }, Yr = function (i, s, h) {
    switch (s) {
      case "input":
        if (Vn(i, h), s = h.name, h.type === "radio" && s != null) {
          for (h = i; h.parentNode;) h = h.parentNode;
          for (h = h.querySelectorAll("input[name=" + JSON.stringify("" + s) + '][type="radio"]'), s = 0; s < h.length; s++) {
            var v = h[s];
            if (v !== i && v.form === i.form) {
              var w = ht(v);
              if (!w) throw Error(r(90));
              yr(v), Vn(v, w);
            }
          }
        }
        break;
      case "textarea":
        Oa(i, h);
        break;
      case "select":
        s = h.value, s != null && dr(i, !!h.multiple, s, !1);
    }
  }, Gt = Ov, yn = Po;
  var vS = { usingClientEntryPoint: !1, Events: [Dd, qu, ht, Wa, gt, Ov] }, rf = { findFiberByHostInstance: Li, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" }, I0 = {
    bundleType: rf.bundleType, version: rf.version, rendererPackageName: rf.rendererPackageName, rendererConfig: rf.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: B.ReactCurrentDispatcher, findHostInstanceByFiber: function (i) {
      return i = Ut(i), i === null ? null : i.stateNode;
    }, findFiberByHostInstance: rf.findFiberByHostInstance || pS, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426"
  };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var lp = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!lp.isDisabled && lp.supportsFiber) try {
      zs = lp.inject(I0), qa = lp;
    } catch {
    }
  }
  return eo.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = vS, eo.createPortal = function (i, s) {
    var h = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!dl(s)) throw Error(r(200));
    return P0(i, s, null, h);
  }, eo.createRoot = function (i, s) {
    if (!dl(i)) throw Error(r(299));
    var h = !1, v = "", w = Lv;
    return s != null && (s.unstable_strictMode === !0 && (h = !0), s.identifierPrefix !== void 0 && (v = s.identifierPrefix), s.onRecoverableError !== void 0 && (w = s.onRecoverableError)), s = Av(i, 1, !1, null, null, h, !1, v, w), i[as] = s.current, Wu(i.nodeType === 8 ? i.parentNode : i), new ip(s);
  }, eo.findDOMNode = function (i) {
    if (i == null) return null;
    if (i.nodeType === 1) return i;
    var s = i._reactInternals;
    if (s === void 0)
      throw typeof i.render == "function" ? Error(r(188)) : (i = Object.keys(i).join(","), Error(r(268, i)));
    return i = Ut(s), i = i === null ? null : i.stateNode, i;
  }, eo.flushSync = function (i) {
    return Po(i);
  }, eo.hydrate = function (i, s, h) {
    if (!op(s)) throw Error(r(200));
    return sp(null, i, s, !0, h);
  }, eo.hydrateRoot = function (i, s, h) {
    if (!dl(i)) throw Error(r(405));
    var v = h != null && h.hydratedSources || null, w = !1, E = "", P = Lv;
    if (h != null && (h.unstable_strictMode === !0 && (w = !0), h.identifierPrefix !== void 0 && (E = h.identifierPrefix), h.onRecoverableError !== void 0 && (P = h.onRecoverableError)), s = Pv(s, null, i, 1, h ?? null, w, !1, E, P), i[as] = s.current, Wu(i), v) for (i = 0; i < v.length; i++) h = v[i], w = h._getVersion, w = w(h._source), s.mutableSourceEagerHydrationData == null ? s.mutableSourceEagerHydrationData = [h, w] : s.mutableSourceEagerHydrationData.push(
      h,
      w
    );
    return new nf(s);
  }, eo.render = function (i, s, h) {
    if (!op(s)) throw Error(r(200));
    return sp(null, i, s, !1, h);
  }, eo.unmountComponentAtNode = function (i) {
    if (!op(i)) throw Error(r(40));
    return i._reactRootContainer ? (Po(function () {
      sp(null, null, i, !1, function () {
        i._reactRootContainer = null, i[as] = null;
      });
    }), !0) : !1;
  }, eo.unstable_batchedUpdates = Ov, eo.unstable_renderSubtreeIntoContainer = function (i, s, h, v) {
    if (!op(h)) throw Error(r(200));
    if (i == null || i._reactInternals === void 0) throw Error(r(38));
    return sp(i, s, h, !1, v);
  }, eo.version = "18.3.1-next-f1338f8080-20240426", eo;
}
var to = {};
/**
 * @license React
 * react-dom.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var _N;
function Wz() {
  return _N || (_N = 1, process.env.NODE_ENV !== "production" && function () {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var n = py(), e = MA(), r = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, o = !1;
    function u(t) {
      o = t;
    }
    function c(t) {
      if (!o) {
        for (var a = arguments.length, l = new Array(a > 1 ? a - 1 : 0), d = 1; d < a; d++)
          l[d - 1] = arguments[d];
        m("warn", t, l);
      }
    }
    function f(t) {
      if (!o) {
        for (var a = arguments.length, l = new Array(a > 1 ? a - 1 : 0), d = 1; d < a; d++)
          l[d - 1] = arguments[d];
        m("error", t, l);
      }
    }
    function m(t, a, l) {
      {
        var d = r.ReactDebugCurrentFrame, p = d.getStackAddendum();
        p !== "" && (a += "%s", l = l.concat([p]));
        var g = l.map(function (S) {
          return String(S);
        });
        g.unshift("Warning: " + a), Function.prototype.apply.call(console[t], console, g);
      }
    }
    var y = 0, b = 1, _ = 2, T = 3, k = 4, C = 5, M = 6, N = 7, A = 8, $ = 9, I = 10, U = 11, B = 12, K = 13, te = 14, re = 15, ve = 16, Ce = 17, ke = 18, Ie = 19, Ne = 21, Re = 22, me = 23, Ge = 24, Me = 25, we = !0, ue = !1, he = !1, ge = !1, Y = !1, ae = !0, Pe = !1, Ue = !0, ut = !0, xt = !0, et = !0, kt = /* @__PURE__ */ new Set(), Et = {}, an = {};
    function zn(t, a) {
      yr(t, a), yr(t + "Capture", a);
    }
    function yr(t, a) {
      Et[t] && f("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", t), Et[t] = a;
      {
        var l = t.toLowerCase();
        an[l] = t, t === "onDoubleClick" && (an.ondblclick = t);
      }
      for (var d = 0; d < a.length; d++)
        kt.add(a[d]);
    }
    var cn = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", ar = Object.prototype.hasOwnProperty;
    function ir(t) {
      {
        var a = typeof Symbol == "function" && Symbol.toStringTag, l = a && t[Symbol.toStringTag] || t.constructor.name || "Object";
        return l;
      }
    }
    function Bn(t) {
      try {
        return Vn(t), !1;
      } catch {
        return !0;
      }
    }
    function Vn(t) {
      return "" + t;
    }
    function Rr(t, a) {
      if (Bn(t))
        return f("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", a, ir(t)), Vn(t);
    }
    function br(t) {
      if (Bn(t))
        return f("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", ir(t)), Vn(t);
    }
    function wr(t, a) {
      if (Bn(t))
        return f("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", a, ir(t)), Vn(t);
    }
    function dr(t, a) {
      if (Bn(t))
        return f("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", a, ir(t)), Vn(t);
    }
    function aa(t) {
      if (Bn(t))
        return f("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", ir(t)), Vn(t);
    }
    function Xn(t) {
      if (Bn(t))
        return f("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before before using it here.", ir(t)), Vn(t);
    }
    var Oa = 0, Ur = 1, An = 2, Sn = 3, ia = 4, ji = 5, Wr = 6, Le = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", nt = Le + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", At = new RegExp("^[" + Le + "][" + nt + "]*$"), Ht = {}, ln = {};
    function kn(t) {
      return ar.call(ln, t) ? !0 : ar.call(Ht, t) ? !1 : At.test(t) ? (ln[t] = !0, !0) : (Ht[t] = !0, f("Invalid attribute name: `%s`", t), !1);
    }
    function Hn(t, a, l) {
      return a !== null ? a.type === Oa : l ? !1 : t.length > 2 && (t[0] === "o" || t[0] === "O") && (t[1] === "n" || t[1] === "N");
    }
    function qr(t, a, l, d) {
      if (l !== null && l.type === Oa)
        return !1;
      switch (typeof a) {
        case "function":
        case "symbol":
          return !0;
        case "boolean": {
          if (d)
            return !1;
          if (l !== null)
            return !l.acceptsBooleans;
          var p = t.toLowerCase().slice(0, 5);
          return p !== "data-" && p !== "aria-";
        }
        default:
          return !1;
      }
    }
    function dn(t, a, l, d) {
      if (a === null || typeof a > "u" || qr(t, a, l, d))
        return !0;
      if (d)
        return !1;
      if (l !== null)
        switch (l.type) {
          case Sn:
            return !a;
          case ia:
            return a === !1;
          case ji:
            return isNaN(a);
          case Wr:
            return isNaN(a) || a < 1;
        }
      return !1;
    }
    function Yr(t) {
      return on.hasOwnProperty(t) ? on[t] : null;
    }
    function fn(t, a, l, d, p, g, S) {
      this.acceptsBooleans = a === An || a === Sn || a === ia, this.attributeName = d, this.attributeNamespace = p, this.mustUseProperty = l, this.propertyName = t, this.type = a, this.sanitizeURL = g, this.removeEmptyString = S;
    }
    var on = {}, kr = [
      "children",
      "dangerouslySetInnerHTML",
      // TODO: This prevents the assignment of defaultValue to regular
      // elements (not just inputs). Now that ReactDOMInput assigns to the
      // defaultValue property -- do we need this?
      "defaultValue",
      "defaultChecked",
      "innerHTML",
      "suppressContentEditableWarning",
      "suppressHydrationWarning",
      "style"
    ];
    kr.forEach(function (t) {
      on[t] = new fn(
        t,
        Oa,
        !1,
        // mustUseProperty
        t,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (t) {
      var a = t[0], l = t[1];
      on[a] = new fn(
        a,
        Ur,
        !1,
        // mustUseProperty
        l,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function (t) {
      on[t] = new fn(
        t,
        An,
        !1,
        // mustUseProperty
        t.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (t) {
      on[t] = new fn(
        t,
        An,
        !1,
        // mustUseProperty
        t,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "allowFullScreen",
      "async",
      // Note: there is a special case that prevents it from being written to the DOM
      // on the client side because the browsers are inconsistent. Instead we call focus().
      "autoFocus",
      "autoPlay",
      "controls",
      "default",
      "defer",
      "disabled",
      "disablePictureInPicture",
      "disableRemotePlayback",
      "formNoValidate",
      "hidden",
      "loop",
      "noModule",
      "noValidate",
      "open",
      "playsInline",
      "readOnly",
      "required",
      "reversed",
      "scoped",
      "seamless",
      // Microdata
      "itemScope"
    ].forEach(function (t) {
      on[t] = new fn(
        t,
        Sn,
        !1,
        // mustUseProperty
        t.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "checked",
      // Note: `option.selected` is not updated if `select.multiple` is
      // disabled with `removeAttribute`. We have special logic for handling this.
      "multiple",
      "muted",
      "selected"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function (t) {
      on[t] = new fn(
        t,
        Sn,
        !0,
        // mustUseProperty
        t,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "capture",
      "download"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function (t) {
      on[t] = new fn(
        t,
        ia,
        !1,
        // mustUseProperty
        t,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "cols",
      "rows",
      "size",
      "span"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function (t) {
      on[t] = new fn(
        t,
        Wr,
        !1,
        // mustUseProperty
        t,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["rowSpan", "start"].forEach(function (t) {
      on[t] = new fn(
        t,
        ji,
        !1,
        // mustUseProperty
        t.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var Wa = /[\-\:]([a-z])/g, gt = function (t) {
      return t[1].toUpperCase();
    };
    [
      "accent-height",
      "alignment-baseline",
      "arabic-form",
      "baseline-shift",
      "cap-height",
      "clip-path",
      "clip-rule",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "dominant-baseline",
      "enable-background",
      "fill-opacity",
      "fill-rule",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "horiz-adv-x",
      "horiz-origin-x",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "overline-position",
      "overline-thickness",
      "paint-order",
      "panose-1",
      "pointer-events",
      "rendering-intent",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "underline-position",
      "underline-thickness",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "vector-effect",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "word-spacing",
      "writing-mode",
      "xmlns:xlink",
      "x-height"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function (t) {
      var a = t.replace(Wa, gt);
      on[a] = new fn(
        a,
        Ur,
        !1,
        // mustUseProperty
        t,
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xlink:actuate",
      "xlink:arcrole",
      "xlink:role",
      "xlink:show",
      "xlink:title",
      "xlink:type"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function (t) {
      var a = t.replace(Wa, gt);
      on[a] = new fn(
        a,
        Ur,
        !1,
        // mustUseProperty
        t,
        "http://www.w3.org/1999/xlink",
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xml:base",
      "xml:lang",
      "xml:space"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function (t) {
      var a = t.replace(Wa, gt);
      on[a] = new fn(
        a,
        Ur,
        !1,
        // mustUseProperty
        t,
        "http://www.w3.org/XML/1998/namespace",
        !1,
        // sanitizeURL
        !1
      );
    }), ["tabIndex", "crossOrigin"].forEach(function (t) {
      on[t] = new fn(
        t,
        Ur,
        !1,
        // mustUseProperty
        t.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var Gt = "xlinkHref";
    on[Gt] = new fn(
      "xlinkHref",
      Ur,
      !1,
      // mustUseProperty
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      // sanitizeURL
      !1
    ), ["src", "href", "action", "formAction"].forEach(function (t) {
      on[t] = new fn(
        t,
        Ur,
        !1,
        // mustUseProperty
        t.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !0,
        // sanitizeURL
        !0
      );
    });
    var yn = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, xr = !1;
    function Or(t) {
      !xr && yn.test(t) && (xr = !0, f("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(t)));
    }
    function fr(t, a, l, d) {
      if (d.mustUseProperty) {
        var p = d.propertyName;
        return t[p];
      } else {
        Rr(l, a), d.sanitizeURL && Or("" + l);
        var g = d.attributeName, S = null;
        if (d.type === ia) {
          if (t.hasAttribute(g)) {
            var R = t.getAttribute(g);
            return R === "" ? !0 : dn(a, l, d, !1) ? R : R === "" + l ? l : R;
          }
        } else if (t.hasAttribute(g)) {
          if (dn(a, l, d, !1))
            return t.getAttribute(g);
          if (d.type === Sn)
            return l;
          S = t.getAttribute(g);
        }
        return dn(a, l, d, !1) ? S === null ? l : S : S === "" + l ? l : S;
      }
    }
    function Kr(t, a, l, d) {
      {
        if (!kn(a))
          return;
        if (!t.hasAttribute(a))
          return l === void 0 ? void 0 : null;
        var p = t.getAttribute(a);
        return Rr(l, a), p === "" + l ? l : p;
      }
    }
    function Wn(t, a, l, d) {
      var p = Yr(a);
      if (!Hn(a, p, d)) {
        if (dn(a, l, p, d) && (l = null), d || p === null) {
          if (kn(a)) {
            var g = a;
            l === null ? t.removeAttribute(g) : (Rr(l, a), t.setAttribute(g, "" + l));
          }
          return;
        }
        var S = p.mustUseProperty;
        if (S) {
          var R = p.propertyName;
          if (l === null) {
            var O = p.type;
            t[R] = O === Sn ? !1 : "";
          } else
            t[R] = l;
          return;
        }
        var L = p.attributeName, F = p.attributeNamespace;
        if (l === null)
          t.removeAttribute(L);
        else {
          var J = p.type, G;
          J === Sn || J === ia && l === !0 ? G = "" : (Rr(l, L), G = "" + l, p.sanitizeURL && Or(G.toString())), F ? t.setAttributeNS(F, L, G) : t.setAttribute(L, G);
        }
      }
    }
    var Nr = Symbol.for("react.element"), Na = Symbol.for("react.portal"), mi = Symbol.for("react.fragment"), _o = Symbol.for("react.strict_mode"), Eo = Symbol.for("react.profiler"), H = Symbol.for("react.provider"), xe = Symbol.for("react.context"), Te = Symbol.for("react.forward_ref"), ot = Symbol.for("react.suspense"), Wt = Symbol.for("react.suspense_list"), Qt = Symbol.for("react.memo"), yt = Symbol.for("react.lazy"), Ut = Symbol.for("react.scope"), jr = Symbol.for("react.debug_trace_mode"), Dn = Symbol.for("react.offscreen"), qn = Symbol.for("react.legacy_hidden"), wa = Symbol.for("react.cache"), Co = Symbol.for("react.tracing_marker"), hn = Symbol.iterator, Gr = "@@iterator";
    function ja(t) {
      if (t === null || typeof t != "object")
        return null;
      var a = hn && t[hn] || t[Gr];
      return typeof a == "function" ? a : null;
    }
    var Ft = Object.assign, Ai = 0, $s, Ou, zs, qa, vd, Aa, gd;
    function yd() {
    }
    yd.__reactDisabledLog = !0;
    function Gf() {
      {
        if (Ai === 0) {
          $s = console.log, Ou = console.info, zs = console.warn, qa = console.error, vd = console.group, Aa = console.groupCollapsed, gd = console.groupEnd;
          var t = {
            configurable: !0,
            enumerable: !0,
            value: yd,
            writable: !0
          };
          Object.defineProperties(console, {
            info: t,
            log: t,
            warn: t,
            error: t,
            group: t,
            groupCollapsed: t,
            groupEnd: t
          });
        }
        Ai++;
      }
    }
    function Nu() {
      {
        if (Ai--, Ai === 0) {
          var t = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: Ft({}, t, {
              value: $s
            }),
            info: Ft({}, t, {
              value: Ou
            }),
            warn: Ft({}, t, {
              value: zs
            }),
            error: Ft({}, t, {
              value: qa
            }),
            group: Ft({}, t, {
              value: vd
            }),
            groupCollapsed: Ft({}, t, {
              value: Aa
            }),
            groupEnd: Ft({}, t, {
              value: gd
            })
          });
        }
        Ai < 0 && f("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Bs = r.ReactCurrentDispatcher, io;
    function Da(t, a, l) {
      {
        if (io === void 0)
          try {
            throw Error();
          } catch (p) {
            var d = p.stack.trim().match(/\n( *(at )?)/);
            io = d && d[1] || "";
          }
        return `
` + io + t;
      }
    }
    var Vs = !1, Hs;
    {
      var Ws = typeof WeakMap == "function" ? WeakMap : Map;
      Hs = new Ws();
    }
    function ju(t, a) {
      if (!t || Vs)
        return "";
      {
        var l = Hs.get(t);
        if (l !== void 0)
          return l;
      }
      var d;
      Vs = !0;
      var p = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var g;
      g = Bs.current, Bs.current = null, Gf();
      try {
        if (a) {
          var S = function () {
            throw Error();
          };
          if (Object.defineProperty(S.prototype, "props", {
            set: function () {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(S, []);
            } catch (le) {
              d = le;
            }
            Reflect.construct(t, [], S);
          } else {
            try {
              S.call();
            } catch (le) {
              d = le;
            }
            t.call(S.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (le) {
            d = le;
          }
          t();
        }
      } catch (le) {
        if (le && d && typeof le.stack == "string") {
          for (var R = le.stack.split(`
`), O = d.stack.split(`
`), L = R.length - 1, F = O.length - 1; L >= 1 && F >= 0 && R[L] !== O[F];)
            F--;
          for (; L >= 1 && F >= 0; L--, F--)
            if (R[L] !== O[F]) {
              if (L !== 1 || F !== 1)
                do
                  if (L--, F--, F < 0 || R[L] !== O[F]) {
                    var J = `
` + R[L].replace(" at new ", " at ");
                    return t.displayName && J.includes("<anonymous>") && (J = J.replace("<anonymous>", t.displayName)), typeof t == "function" && Hs.set(t, J), J;
                  }
                while (L >= 1 && F >= 0);
              break;
            }
        }
      } finally {
        Vs = !1, Bs.current = g, Nu(), Error.prepareStackTrace = p;
      }
      var G = t ? t.displayName || t.name : "", ie = G ? Da(G) : "";
      return typeof t == "function" && Hs.set(t, ie), ie;
    }
    function Au(t, a, l) {
      return ju(t, !0);
    }
    function Go(t, a, l) {
      return ju(t, !1);
    }
    function Dm(t) {
      var a = t.prototype;
      return !!(a && a.isReactComponent);
    }
    function To(t, a, l) {
      if (t == null)
        return "";
      if (typeof t == "function")
        return ju(t, Dm(t));
      if (typeof t == "string")
        return Da(t);
      switch (t) {
        case ot:
          return Da("Suspense");
        case Wt:
          return Da("SuspenseList");
      }
      if (typeof t == "object")
        switch (t.$$typeof) {
          case Te:
            return Go(t.render);
          case Qt:
            return To(t.type, a, l);
          case yt: {
            var d = t, p = d._payload, g = d._init;
            try {
              return To(g(p), a, l);
            } catch {
            }
          }
        }
      return "";
    }
    function pn(t) {
      switch (t._debugOwner && t._debugOwner.type, t._debugSource, t.tag) {
        case C:
          return Da(t.type);
        case ve:
          return Da("Lazy");
        case K:
          return Da("Suspense");
        case Ie:
          return Da("SuspenseList");
        case y:
        case _:
        case re:
          return Go(t.type);
        case U:
          return Go(t.type.render);
        case b:
          return Au(t.type);
        default:
          return "";
      }
    }
    function Du(t) {
      try {
        var a = "", l = t;
        do
          a += pn(l), l = l.return;
        while (l);
        return a;
      } catch (d) {
        return `
Error generating stack: ` + d.message + `
` + d.stack;
      }
    }
    function Dl(t, a, l) {
      var d = t.displayName;
      if (d)
        return d;
      var p = a.displayName || a.name || "";
      return p !== "" ? l + "(" + p + ")" : l;
    }
    function Pu(t) {
      return t.displayName || "Context";
    }
    function Jt(t) {
      if (t == null)
        return null;
      if (typeof t.tag == "number" && f("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof t == "function")
        return t.displayName || t.name || null;
      if (typeof t == "string")
        return t;
      switch (t) {
        case mi:
          return "Fragment";
        case Na:
          return "Portal";
        case Eo:
          return "Profiler";
        case _o:
          return "StrictMode";
        case ot:
          return "Suspense";
        case Wt:
          return "SuspenseList";
      }
      if (typeof t == "object")
        switch (t.$$typeof) {
          case xe:
            var a = t;
            return Pu(a) + ".Consumer";
          case H:
            var l = t;
            return Pu(l._context) + ".Provider";
          case Te:
            return Dl(t, t.render, "ForwardRef");
          case Qt:
            var d = t.displayName || null;
            return d !== null ? d : Jt(t.type) || "Memo";
          case yt: {
            var p = t, g = p._payload, S = p._init;
            try {
              return Jt(S(g));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    function Mu(t, a, l) {
      var d = a.displayName || a.name || "";
      return t.displayName || (d !== "" ? l + "(" + d + ")" : l);
    }
    function Lu(t) {
      return t.displayName || "Context";
    }
    function Ot(t) {
      var a = t.tag, l = t.type;
      switch (a) {
        case Ge:
          return "Cache";
        case $:
          var d = l;
          return Lu(d) + ".Consumer";
        case I:
          var p = l;
          return Lu(p._context) + ".Provider";
        case ke:
          return "DehydratedFragment";
        case U:
          return Mu(l, l.render, "ForwardRef");
        case N:
          return "Fragment";
        case C:
          return l;
        case k:
          return "Portal";
        case T:
          return "Root";
        case M:
          return "Text";
        case ve:
          return Jt(l);
        case A:
          return l === _o ? "StrictMode" : "Mode";
        case Re:
          return "Offscreen";
        case B:
          return "Profiler";
        case Ne:
          return "Scope";
        case K:
          return "Suspense";
        case Ie:
          return "SuspenseList";
        case Me:
          return "TracingMarker";
        case b:
        case y:
        case Ce:
        case _:
        case te:
        case re:
          if (typeof l == "function")
            return l.displayName || l.name || null;
          if (typeof l == "string")
            return l;
          break;
      }
      return null;
    }
    var Pl = r.ReactDebugCurrentFrame, or = null, Ya = !1;
    function Pa() {
      {
        if (or === null)
          return null;
        var t = or._debugOwner;
        if (t !== null && typeof t < "u")
          return Ot(t);
      }
      return null;
    }
    function qs() {
      return or === null ? "" : Du(or);
    }
    function hr() {
      Pl.getCurrentStack = null, or = null, Ya = !1;
    }
    function _n(t) {
      Pl.getCurrentStack = t === null ? null : qs, or = t, Ya = !1;
    }
    function Qf() {
      return or;
    }
    function Ka(t) {
      Ya = t;
    }
    function Qr(t) {
      return "" + t;
    }
    function Ro(t) {
      switch (typeof t) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return t;
        case "object":
          return Xn(t), t;
        default:
          return "";
      }
    }
    var Jf = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    };
    function Qo(t, a) {
      Jf[a.type] || a.onChange || a.onInput || a.readOnly || a.disabled || a.value == null || f("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), a.onChange || a.readOnly || a.disabled || a.checked == null || f("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function Ys(t) {
      var a = t.type, l = t.nodeName;
      return l && l.toLowerCase() === "input" && (a === "checkbox" || a === "radio");
    }
    function Zf(t) {
      return t._valueTracker;
    }
    function Di(t) {
      t._valueTracker = null;
    }
    function Ks(t) {
      var a = "";
      return t && (Ys(t) ? a = t.checked ? "true" : "false" : a = t.value), a;
    }
    function Jo(t) {
      var a = Ys(t) ? "checked" : "value", l = Object.getOwnPropertyDescriptor(t.constructor.prototype, a);
      Xn(t[a]);
      var d = "" + t[a];
      if (!(t.hasOwnProperty(a) || typeof l > "u" || typeof l.get != "function" || typeof l.set != "function")) {
        var p = l.get, g = l.set;
        Object.defineProperty(t, a, {
          configurable: !0,
          get: function () {
            return p.call(this);
          },
          set: function (R) {
            Xn(R), d = "" + R, g.call(this, R);
          }
        }), Object.defineProperty(t, a, {
          enumerable: l.enumerable
        });
        var S = {
          getValue: function () {
            return d;
          },
          setValue: function (R) {
            Xn(R), d = "" + R;
          },
          stopTracking: function () {
            Di(t), delete t[a];
          }
        };
        return S;
      }
    }
    function Pi(t) {
      Zf(t) || (t._valueTracker = Jo(t));
    }
    function Iu(t) {
      if (!t)
        return !1;
      var a = Zf(t);
      if (!a)
        return !0;
      var l = a.getValue(), d = Ks(t);
      return d !== l ? (a.setValue(d), !0) : !1;
    }
    function Gs(t) {
      if (t = t || (typeof document < "u" ? document : void 0), typeof t > "u")
        return null;
      try {
        return t.activeElement || t.body;
      } catch {
        return t.body;
      }
    }
    var Qs = !1, Ml = !1, Uu = !1, bd = !1;
    function oo(t) {
      var a = t.type === "checkbox" || t.type === "radio";
      return a ? t.checked != null : t.value != null;
    }
    function j(t, a) {
      var l = t, d = a.checked, p = Ft({}, a, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: d ?? l._wrapperState.initialChecked
      });
      return p;
    }
    function V(t, a) {
      Qo("input", a), a.checked !== void 0 && a.defaultChecked !== void 0 && !Ml && (f("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", Pa() || "A component", a.type), Ml = !0), a.value !== void 0 && a.defaultValue !== void 0 && !Qs && (f("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", Pa() || "A component", a.type), Qs = !0);
      var l = t, d = a.defaultValue == null ? "" : a.defaultValue;
      l._wrapperState = {
        initialChecked: a.checked != null ? a.checked : a.defaultChecked,
        initialValue: Ro(a.value != null ? a.value : d),
        controlled: oo(a)
      };
    }
    function oe(t, a) {
      var l = t, d = a.checked;
      d != null && Wn(l, "checked", d, !1);
    }
    function ce(t, a) {
      var l = t;
      {
        var d = oo(a);
        !l._wrapperState.controlled && d && !bd && (f("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), bd = !0), l._wrapperState.controlled && !d && !Uu && (f("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), Uu = !0);
      }
      oe(t, a);
      var p = Ro(a.value), g = a.type;
      if (p != null)
        g === "number" ? (p === 0 && l.value === "" || // We explicitly want to coerce to number here if possible.
          // eslint-disable-next-line
          l.value != p) && (l.value = Qr(p)) : l.value !== Qr(p) && (l.value = Qr(p));
      else if (g === "submit" || g === "reset") {
        l.removeAttribute("value");
        return;
      }
      a.hasOwnProperty("value") ? vt(l, a.type, p) : a.hasOwnProperty("defaultValue") && vt(l, a.type, Ro(a.defaultValue)), a.checked == null && a.defaultChecked != null && (l.defaultChecked = !!a.defaultChecked);
    }
    function Oe(t, a, l) {
      var d = t;
      if (a.hasOwnProperty("value") || a.hasOwnProperty("defaultValue")) {
        var p = a.type, g = p === "submit" || p === "reset";
        if (g && (a.value === void 0 || a.value === null))
          return;
        var S = Qr(d._wrapperState.initialValue);
        l || S !== d.value && (d.value = S), d.defaultValue = S;
      }
      var R = d.name;
      R !== "" && (d.name = ""), d.defaultChecked = !d.defaultChecked, d.defaultChecked = !!d._wrapperState.initialChecked, R !== "" && (d.name = R);
    }
    function bt(t, a) {
      var l = t;
      ce(l, a), ze(l, a);
    }
    function ze(t, a) {
      var l = a.name;
      if (a.type === "radio" && l != null) {
        for (var d = t; d.parentNode;)
          d = d.parentNode;
        Rr(l, "name");
        for (var p = d.querySelectorAll("input[name=" + JSON.stringify("" + l) + '][type="radio"]'), g = 0; g < p.length; g++) {
          var S = p[g];
          if (!(S === t || S.form !== t.form)) {
            var R = eb(S);
            if (!R)
              throw new Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
            Iu(S), ce(S, R);
          }
        }
      }
    }
    function vt(t, a, l) {
      // Focused number inputs synchronize on blur. See ChangeEventPlugin.js
      (a !== "number" || Gs(t.ownerDocument) !== t) && (l == null ? t.defaultValue = Qr(t._wrapperState.initialValue) : t.defaultValue !== Qr(l) && (t.defaultValue = Qr(l)));
    }
    var zt = !1, sn = !1, Pn = !1;
    function Rn(t, a) {
      a.value == null && (typeof a.children == "object" && a.children !== null ? n.Children.forEach(a.children, function (l) {
        l != null && (typeof l == "string" || typeof l == "number" || sn || (sn = !0, f("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      }) : a.dangerouslySetInnerHTML != null && (Pn || (Pn = !0, f("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.")))), a.selected != null && !zt && (f("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), zt = !0);
    }
    function Mn(t, a) {
      a.value != null && t.setAttribute("value", Qr(Ro(a.value)));
    }
    var Fn = Array.isArray;
    function Zt(t) {
      return Fn(t);
    }
    var Zo;
    Zo = !1;
    function Fu() {
      var t = Pa();
      return t ? `

Check the render method of \`` + t + "`." : "";
    }
    var wd = ["value", "defaultValue"];
    function Pm(t) {
      {
        Qo("select", t);
        for (var a = 0; a < wd.length; a++) {
          var l = wd[a];
          if (t[l] != null) {
            var d = Zt(t[l]);
            t.multiple && !d ? f("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", l, Fu()) : !t.multiple && d && f("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", l, Fu());
          }
        }
      }
    }
    function so(t, a, l, d) {
      var p = t.options;
      if (a) {
        for (var g = l, S = {}, R = 0; R < g.length; R++)
          S["$" + g[R]] = !0;
        for (var O = 0; O < p.length; O++) {
          var L = S.hasOwnProperty("$" + p[O].value);
          p[O].selected !== L && (p[O].selected = L), L && d && (p[O].defaultSelected = !0);
        }
      } else {
        for (var F = Qr(Ro(l)), J = null, G = 0; G < p.length; G++) {
          if (p[G].value === F) {
            p[G].selected = !0, d && (p[G].defaultSelected = !0);
            return;
          }
          J === null && !p[G].disabled && (J = p[G]);
        }
        J !== null && (J.selected = !0);
      }
    }
    function xd(t, a) {
      return Ft({}, a, {
        value: void 0
      });
    }
    function Sd(t, a) {
      var l = t;
      Pm(a), l._wrapperState = {
        wasMultiple: !!a.multiple
      }, a.value !== void 0 && a.defaultValue !== void 0 && !Zo && (f("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), Zo = !0);
    }
    function Mm(t, a) {
      var l = t;
      l.multiple = !!a.multiple;
      var d = a.value;
      d != null ? so(l, !!a.multiple, d, !1) : a.defaultValue != null && so(l, !!a.multiple, a.defaultValue, !0);
    }
    function Fx(t, a) {
      var l = t, d = l._wrapperState.wasMultiple;
      l._wrapperState.wasMultiple = !!a.multiple;
      var p = a.value;
      p != null ? so(l, !!a.multiple, p, !1) : d !== !!a.multiple && (a.defaultValue != null ? so(l, !!a.multiple, a.defaultValue, !0) : so(l, !!a.multiple, a.multiple ? [] : "", !1));
    }
    function $x(t, a) {
      var l = t, d = a.value;
      d != null && so(l, !!a.multiple, d, !1);
    }
    var Lm = !1;
    function Im(t, a) {
      var l = t;
      if (a.dangerouslySetInnerHTML != null)
        throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
      var d = Ft({}, a, {
        value: void 0,
        defaultValue: void 0,
        children: Qr(l._wrapperState.initialValue)
      });
      return d;
    }
    function Cy(t, a) {
      var l = t;
      Qo("textarea", a), a.value !== void 0 && a.defaultValue !== void 0 && !Lm && (f("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components", Pa() || "A component"), Lm = !0);
      var d = a.value;
      if (d == null) {
        var p = a.children, g = a.defaultValue;
        if (p != null) {
          f("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
          {
            if (g != null)
              throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
            if (Zt(p)) {
              if (p.length > 1)
                throw new Error("<textarea> can only have at most one child.");
              p = p[0];
            }
            g = p;
          }
        }
        g == null && (g = ""), d = g;
      }
      l._wrapperState = {
        initialValue: Ro(d)
      };
    }
    function Ty(t, a) {
      var l = t, d = Ro(a.value), p = Ro(a.defaultValue);
      if (d != null) {
        var g = Qr(d);
        g !== l.value && (l.value = g), a.defaultValue == null && l.defaultValue !== g && (l.defaultValue = g);
      }
      p != null && (l.defaultValue = Qr(p));
    }
    function Ry(t, a) {
      var l = t, d = l.textContent;
      d === l._wrapperState.initialValue && d !== "" && d !== null && (l.value = d);
    }
    function Um(t, a) {
      Ty(t, a);
    }
    var Xo = "http://www.w3.org/1999/xhtml", zx = "http://www.w3.org/1998/Math/MathML", Fm = "http://www.w3.org/2000/svg";
    function Xf(t) {
      switch (t) {
        case "svg":
          return Fm;
        case "math":
          return zx;
        default:
          return Xo;
      }
    }
    function $m(t, a) {
      return t == null || t === Xo ? Xf(a) : t === Fm && a === "foreignObject" ? Xo : t;
    }
    var Bx = function (t) {
      return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function (a, l, d, p) {
        MSApp.execUnsafeLocalFunction(function () {
          return t(a, l, d, p);
        });
      } : t;
    }, eh, ky = Bx(function (t, a) {
      if (t.namespaceURI === Fm && !("innerHTML" in t)) {
        eh = eh || document.createElement("div"), eh.innerHTML = "<svg>" + a.valueOf().toString() + "</svg>";
        for (var l = eh.firstChild; t.firstChild;)
          t.removeChild(t.firstChild);
        for (; l.firstChild;)
          t.appendChild(l.firstChild);
        return;
      }
      t.innerHTML = a;
    }), Ga = 1, es = 3, Ar = 8, lo = 9, Ll = 11, th = function (t, a) {
      if (a) {
        var l = t.firstChild;
        if (l && l === t.lastChild && l.nodeType === es) {
          l.nodeValue = a;
          return;
        }
      }
      t.textContent = a;
    }, Oy = {
      animation: ["animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction"],
      background: ["backgroundAttachment", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize"],
      backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
      border: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"],
      borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"],
      borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"],
      borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"],
      borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"],
      borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"],
      borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"],
      borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
      borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"],
      borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"],
      borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"],
      borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"],
      columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
      columns: ["columnCount", "columnWidth"],
      flex: ["flexBasis", "flexGrow", "flexShrink"],
      flexFlow: ["flexDirection", "flexWrap"],
      font: ["fontFamily", "fontFeatureSettings", "fontKerning", "fontLanguageOverride", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition", "fontWeight", "lineHeight"],
      fontVariant: ["fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition"],
      gap: ["columnGap", "rowGap"],
      grid: ["gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"],
      gridColumn: ["gridColumnEnd", "gridColumnStart"],
      gridColumnGap: ["columnGap"],
      gridGap: ["columnGap", "rowGap"],
      gridRow: ["gridRowEnd", "gridRowStart"],
      gridRowGap: ["rowGap"],
      gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
      margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
      marker: ["markerEnd", "markerMid", "markerStart"],
      mask: ["maskClip", "maskComposite", "maskImage", "maskMode", "maskOrigin", "maskPositionX", "maskPositionY", "maskRepeat", "maskSize"],
      maskPosition: ["maskPositionX", "maskPositionY"],
      outline: ["outlineColor", "outlineStyle", "outlineWidth"],
      overflow: ["overflowX", "overflowY"],
      padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
      placeContent: ["alignContent", "justifyContent"],
      placeItems: ["alignItems", "justifyItems"],
      placeSelf: ["alignSelf", "justifySelf"],
      textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"],
      textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
      transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"],
      wordWrap: ["overflowWrap"]
    }, $u = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      // SVG-related properties
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    };
    function Ny(t, a) {
      return t + a.charAt(0).toUpperCase() + a.substring(1);
    }
    var jy = ["Webkit", "ms", "Moz", "O"];
    Object.keys($u).forEach(function (t) {
      jy.forEach(function (a) {
        $u[Ny(a, t)] = $u[t];
      });
    });
    function nh(t, a, l) {
      var d = a == null || typeof a == "boolean" || a === "";
      return d ? "" : !l && typeof a == "number" && a !== 0 && !($u.hasOwnProperty(t) && $u[t]) ? a + "px" : (dr(a, t), ("" + a).trim());
    }
    var zu = /([A-Z])/g, Vx = /^ms-/;
    function Hx(t) {
      return t.replace(zu, "-$1").toLowerCase().replace(Vx, "-ms-");
    }
    var Ay = function () {
    };
    {
      var Dy = /^(?:webkit|moz|o)[A-Z]/, Py = /^-ms-/, _d = /-(.)/g, Bu = /;\s*$/, Vu = {}, Hu = {}, My = !1, zm = !1, Bm = function (t) {
        return t.replace(_d, function (a, l) {
          return l.toUpperCase();
        });
      }, Vm = function (t) {
        Vu.hasOwnProperty(t) && Vu[t] || (Vu[t] = !0, f(
          "Unsupported style property %s. Did you mean %s?",
          t,
          // As Andi Smith suggests
          // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
          // is converted to lowercase `ms`.
          Bm(t.replace(Py, "ms-"))
        ));
      }, Ly = function (t) {
        Vu.hasOwnProperty(t) && Vu[t] || (Vu[t] = !0, f("Unsupported vendor-prefixed style property %s. Did you mean %s?", t, t.charAt(0).toUpperCase() + t.slice(1)));
      }, Iy = function (t, a) {
        Hu.hasOwnProperty(a) && Hu[a] || (Hu[a] = !0, f(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, t, a.replace(Bu, "")));
      }, Uy = function (t, a) {
        My || (My = !0, f("`NaN` is an invalid value for the `%s` css style property.", t));
      }, Wx = function (t, a) {
        zm || (zm = !0, f("`Infinity` is an invalid value for the `%s` css style property.", t));
      };
      Ay = function (t, a) {
        t.indexOf("-") > -1 ? Vm(t) : Dy.test(t) ? Ly(t) : Bu.test(a) && Iy(t, a), typeof a == "number" && (isNaN(a) ? Uy(t, a) : isFinite(a) || Wx(t, a));
      };
    }
    var qx = Ay;
    function Yx(t) {
      {
        var a = "", l = "";
        for (var d in t)
          if (t.hasOwnProperty(d)) {
            var p = t[d];
            if (p != null) {
              var g = d.indexOf("--") === 0;
              a += l + (g ? d : Hx(d)) + ":", a += nh(d, p, g), l = ";";
            }
          }
        return a || null;
      }
    }
    function Fy(t, a) {
      var l = t.style;
      for (var d in a)
        if (a.hasOwnProperty(d)) {
          var p = d.indexOf("--") === 0;
          p || qx(d, a[d]);
          var g = nh(d, a[d], p);
          d === "float" && (d = "cssFloat"), p ? l.setProperty(d, g) : l[d] = g;
        }
    }
    function Kx(t) {
      return t == null || typeof t == "boolean" || t === "";
    }
    function Mi(t) {
      var a = {};
      for (var l in t)
        for (var d = Oy[l] || [l], p = 0; p < d.length; p++)
          a[d[p]] = l;
      return a;
    }
    function Ed(t, a) {
      {
        if (!a)
          return;
        var l = Mi(t), d = Mi(a), p = {};
        for (var g in l) {
          var S = l[g], R = d[g];
          if (R && S !== R) {
            var O = S + "," + R;
            if (p[O])
              continue;
            p[O] = !0, f("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", Kx(t[S]) ? "Removing" : "Updating", S, R);
          }
        }
      }
    }
    var $y = {
      area: !0,
      base: !0,
      br: !0,
      col: !0,
      embed: !0,
      hr: !0,
      img: !0,
      input: !0,
      keygen: !0,
      link: !0,
      meta: !0,
      param: !0,
      source: !0,
      track: !0,
      wbr: !0
      // NOTE: menuitem's close tag should be omitted, but that causes problems.
    }, zy = Ft({
      menuitem: !0
    }, $y), By = "__html";
    function rh(t, a) {
      if (a) {
        if (zy[t] && (a.children != null || a.dangerouslySetInnerHTML != null))
          throw new Error(t + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
        if (a.dangerouslySetInnerHTML != null) {
          if (a.children != null)
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          if (typeof a.dangerouslySetInnerHTML != "object" || !(By in a.dangerouslySetInnerHTML))
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        }
        if (!a.suppressContentEditableWarning && a.contentEditable && a.children != null && f("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), a.style != null && typeof a.style != "object")
          throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      }
    }
    function ts(t, a) {
      if (t.indexOf("-") === -1)
        return typeof a.is == "string";
      switch (t) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var ah = {
      // HTML
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      // SVG
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, Vy = {
      "aria-current": 0,
      // state
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      // state
      "aria-hidden": 0,
      // state
      "aria-invalid": 0,
      // state
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      // Widget Attributes
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      // Live Region Attributes
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      // Drag-and-Drop Attributes
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      // Relationship Attributes
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, uo = {}, Hm = new RegExp("^(aria)-[" + nt + "]*$"), Cd = new RegExp("^(aria)[A-Z][" + nt + "]*$");
    function Wm(t, a) {
      {
        if (ar.call(uo, a) && uo[a])
          return !0;
        if (Cd.test(a)) {
          var l = "aria-" + a.slice(4).toLowerCase(), d = Vy.hasOwnProperty(l) ? l : null;
          if (d == null)
            return f("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", a), uo[a] = !0, !0;
          if (a !== d)
            return f("Invalid ARIA attribute `%s`. Did you mean `%s`?", a, d), uo[a] = !0, !0;
        }
        if (Hm.test(a)) {
          var p = a.toLowerCase(), g = Vy.hasOwnProperty(p) ? p : null;
          if (g == null)
            return uo[a] = !0, !1;
          if (a !== g)
            return f("Unknown ARIA attribute `%s`. Did you mean `%s`?", a, g), uo[a] = !0, !0;
        }
      }
      return !0;
    }
    function Hy(t, a) {
      {
        var l = [];
        for (var d in a) {
          var p = Wm(t, d);
          p || l.push(d);
        }
        var g = l.map(function (S) {
          return "`" + S + "`";
        }).join(", ");
        l.length === 1 ? f("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", g, t) : l.length > 1 && f("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", g, t);
      }
    }
    function ih(t, a) {
      ts(t, a) || Hy(t, a);
    }
    var Il = !1;
    function qm(t, a) {
      {
        if (t !== "input" && t !== "textarea" && t !== "select")
          return;
        a != null && a.value === null && !Il && (Il = !0, t === "select" && a.multiple ? f("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", t) : f("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", t));
      }
    }
    var Ym = function () {
    };
    {
      var Jr = {}, Km = /^on./, Wy = /^on[^A-Z]/, qy = new RegExp("^(aria)-[" + nt + "]*$"), Yy = new RegExp("^(aria)[A-Z][" + nt + "]*$");
      Ym = function (t, a, l, d) {
        if (ar.call(Jr, a) && Jr[a])
          return !0;
        var p = a.toLowerCase();
        if (p === "onfocusin" || p === "onfocusout")
          return f("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), Jr[a] = !0, !0;
        if (d != null) {
          var g = d.registrationNameDependencies, S = d.possibleRegistrationNames;
          if (g.hasOwnProperty(a))
            return !0;
          var R = S.hasOwnProperty(p) ? S[p] : null;
          if (R != null)
            return f("Invalid event handler property `%s`. Did you mean `%s`?", a, R), Jr[a] = !0, !0;
          if (Km.test(a))
            return f("Unknown event handler property `%s`. It will be ignored.", a), Jr[a] = !0, !0;
        } else if (Km.test(a))
          return Wy.test(a) && f("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", a), Jr[a] = !0, !0;
        if (qy.test(a) || Yy.test(a))
          return !0;
        if (p === "innerhtml")
          return f("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), Jr[a] = !0, !0;
        if (p === "aria")
          return f("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), Jr[a] = !0, !0;
        if (p === "is" && l !== null && l !== void 0 && typeof l != "string")
          return f("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof l), Jr[a] = !0, !0;
        if (typeof l == "number" && isNaN(l))
          return f("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", a), Jr[a] = !0, !0;
        var O = Yr(a), L = O !== null && O.type === Oa;
        if (ah.hasOwnProperty(p)) {
          var F = ah[p];
          if (F !== a)
            return f("Invalid DOM property `%s`. Did you mean `%s`?", a, F), Jr[a] = !0, !0;
        } else if (!L && a !== p)
          return f("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", a, p), Jr[a] = !0, !0;
        return typeof l == "boolean" && qr(a, l, O, !1) ? (l ? f('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', l, a, a, l, a) : f('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', l, a, a, l, a, a, a), Jr[a] = !0, !0) : L ? !0 : qr(a, l, O, !1) ? (Jr[a] = !0, !1) : ((l === "false" || l === "true") && O !== null && O.type === Sn && (f("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", l, a, l === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', a, l), Jr[a] = !0), !0);
      };
    }
    var Ky = function (t, a, l) {
      {
        var d = [];
        for (var p in a) {
          var g = Ym(t, p, a[p], l);
          g || d.push(p);
        }
        var S = d.map(function (R) {
          return "`" + R + "`";
        }).join(", ");
        d.length === 1 ? f("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", S, t) : d.length > 1 && f("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", S, t);
      }
    };
    function Gy(t, a, l) {
      ts(t, a) || Ky(t, a, l);
    }
    var ns = 1, Td = 2, Ul = 4, Gx = ns | Td | Ul, Rd = null;
    function kd(t) {
      Rd !== null && f("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue."), Rd = t;
    }
    function Qx() {
      Rd === null && f("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue."), Rd = null;
    }
    function Qy(t) {
      return t === Rd;
    }
    function oh(t) {
      var a = t.target || t.srcElement || window;
      return a.correspondingUseElement && (a = a.correspondingUseElement), a.nodeType === es ? a.parentNode : a;
    }
    var Ln = null, Js = null, rs = null;
    function Wu(t) {
      var a = Ec(t);
      if (a) {
        if (typeof Ln != "function")
          throw new Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
        var l = a.stateNode;
        if (l) {
          var d = eb(l);
          Ln(a.stateNode, a.type, d);
        }
      }
    }
    function Jy(t) {
      Ln = t;
    }
    function sh(t) {
      Js ? rs ? rs.push(t) : rs = [t] : Js = t;
    }
    function Od() {
      return Js !== null || rs !== null;
    }
    function Nd() {
      if (Js) {
        var t = Js, a = rs;
        if (Js = null, rs = null, Wu(t), a)
          for (var l = 0; l < a.length; l++)
            Wu(a[l]);
      }
    }
    var Fl = function (t, a) {
      return t(a);
    }, Gm = function () {
    }, Qm = !1;
    function Jx() {
      var t = Od();
      t && (Gm(), Nd());
    }
    function Jm(t, a, l) {
      if (Qm)
        return t(a, l);
      Qm = !0;
      try {
        return Fl(t, a, l);
      } finally {
        Qm = !1, Jx();
      }
    }
    function lh(t, a, l) {
      Fl = t, Gm = l;
    }
    function uh(t) {
      return t === "button" || t === "input" || t === "select" || t === "textarea";
    }
    function Zm(t, a, l) {
      switch (t) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          return !!(l.disabled && uh(a));
        default:
          return !1;
      }
    }
    function $l(t, a) {
      var l = t.stateNode;
      if (l === null)
        return null;
      var d = eb(l);
      if (d === null)
        return null;
      var p = d[a];
      if (Zm(a, t.type, d))
        return null;
      if (p && typeof p != "function")
        throw new Error("Expected `" + a + "` listener to be a function, instead got a value of `" + typeof p + "` type.");
      return p;
    }
    var jd = !1;
    if (cn)
      try {
        var zl = {};
        Object.defineProperty(zl, "passive", {
          get: function () {
            jd = !0;
          }
        }), window.addEventListener("test", zl, zl), window.removeEventListener("test", zl, zl);
      } catch {
        jd = !1;
      }
    function Zy(t, a, l, d, p, g, S, R, O) {
      var L = Array.prototype.slice.call(arguments, 3);
      try {
        a.apply(l, L);
      } catch (F) {
        this.onError(F);
      }
    }
    var Xm = Zy;
    if (typeof window < "u" && typeof window.dispatchEvent == "function" && typeof document < "u" && typeof document.createEvent == "function") {
      var ev = document.createElement("react");
      Xm = function (a, l, d, p, g, S, R, O, L) {
        if (typeof document > "u" || document === null)
          throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
        var F = document.createEvent("Event"), J = !1, G = !0, ie = window.event, le = Object.getOwnPropertyDescriptor(window, "event");
        function de() {
          ev.removeEventListener(fe, pt, !1), typeof window.event < "u" && window.hasOwnProperty("event") && (window.event = ie);
        }
        var Be = Array.prototype.slice.call(arguments, 3);
        function pt() {
          J = !0, de(), l.apply(d, Be), G = !1;
        }
        var lt, rn = !1, Kt = !1;
        function X(ee) {
          if (lt = ee.error, rn = !0, lt === null && ee.colno === 0 && ee.lineno === 0 && (Kt = !0), ee.defaultPrevented && lt != null && typeof lt == "object")
            try {
              lt._suppressLogging = !0;
            } catch {
            }
        }
        var fe = "react-" + (a || "invokeguardedcallback");
        if (window.addEventListener("error", X), ev.addEventListener(fe, pt, !1), F.initEvent(fe, !1, !1), ev.dispatchEvent(F), le && Object.defineProperty(window, "event", le), J && G && (rn ? Kt && (lt = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.")) : lt = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`), this.onError(lt)), window.removeEventListener("error", X), !J)
          return de(), Zy.apply(this, arguments);
      };
    }
    var Zx = Xm, Zs = !1, co = null, Ad = !1, Xs = null, ko = {
      onError: function (t) {
        Zs = !0, co = t;
      }
    };
    function Bl(t, a, l, d, p, g, S, R, O) {
      Zs = !1, co = null, Zx.apply(ko, arguments);
    }
    function as(t, a, l, d, p, g, S, R, O) {
      if (Bl.apply(this, arguments), Zs) {
        var L = nv();
        Ad || (Ad = !0, Xs = L);
      }
    }
    function tv() {
      if (Ad) {
        var t = Xs;
        throw Ad = !1, Xs = null, t;
      }
    }
    function Xx() {
      return Zs;
    }
    function nv() {
      if (Zs) {
        var t = co;
        return Zs = !1, co = null, t;
      } else
        throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
    }
    function Li(t) {
      return t._reactInternals;
    }
    function Dd(t) {
      return t._reactInternals !== void 0;
    }
    function qu(t, a) {
      t._reactInternals = a;
    }
    var ht = (
      /*                      */
      0
    ), el = (
      /*                */
      1
    ), Yn = (
      /*                    */
      2
    ), Mt = (
      /*                       */
      4
    ), bn = (
      /*                */
      16
    ), En = (
      /*                 */
      32
    ), Oo = (
      /*                     */
      64
    ), Tt = (
      /*                   */
      128
    ), pr = (
      /*            */
      256
    ), Qa = (
      /*                          */
      512
    ), Ii = (
      /*                     */
      1024
    ), er = (
      /*                      */
      2048
    ), Ui = (
      /*                    */
      4096
    ), tl = (
      /*                   */
      8192
    ), Pd = (
      /*             */
      16384
    ), ch = er | Mt | Oo | Qa | Ii | Pd, Xy = (
      /*               */
      32767
    ), vi = (
      /*                   */
      32768
    ), Zr = (
      /*                */
      65536
    ), Md = (
      /* */
      131072
    ), rv = (
      /*                       */
      1048576
    ), av = (
      /*                    */
      2097152
    ), Ja = (
      /*                 */
      4194304
    ), nl = (
      /*                */
      8388608
    ), Za = (
      /*               */
      16777216
    ), Vl = (
      /*              */
      33554432
    ), Yu = (
      // TODO: Remove Update flag from before mutation phase by re-landing Visibility
      // flag logic (see #20043)
      Mt | Ii | 0
    ), Xa = Yn | Mt | bn | En | Qa | Ui | tl, xa = Mt | Oo | Qa | tl, Fi = er | bn, oa = Ja | nl | av, is = r.ReactCurrentOwner;
    function gi(t) {
      var a = t, l = t;
      if (t.alternate)
        for (; a.return;)
          a = a.return;
      else {
        var d = a;
        do
          a = d, (a.flags & (Yn | Ui)) !== ht && (l = a.return), d = a.return;
        while (d);
      }
      return a.tag === T ? l : null;
    }
    function iv(t) {
      if (t.tag === K) {
        var a = t.memoizedState;
        if (a === null) {
          var l = t.alternate;
          l !== null && (a = l.memoizedState);
        }
        if (a !== null)
          return a.dehydrated;
      }
      return null;
    }
    function dh(t) {
      return t.tag === T ? t.stateNode.containerInfo : null;
    }
    function ov(t) {
      return gi(t) === t;
    }
    function yi(t) {
      {
        var a = is.current;
        if (a !== null && a.tag === b) {
          var l = a, d = l.stateNode;
          d._warnedAboutRefsInRender || f("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", Ot(l) || "A component"), d._warnedAboutRefsInRender = !0;
        }
      }
      var p = Li(t);
      return p ? gi(p) === p : !1;
    }
    function ei(t) {
      if (gi(t) !== t)
        throw new Error("Unable to find node on an unmounted component.");
    }
    function Kn(t) {
      var a = t.alternate;
      if (!a) {
        var l = gi(t);
        if (l === null)
          throw new Error("Unable to find node on an unmounted component.");
        return l !== t ? null : t;
      }
      for (var d = t, p = a; ;) {
        var g = d.return;
        if (g === null)
          break;
        var S = g.alternate;
        if (S === null) {
          var R = g.return;
          if (R !== null) {
            d = p = R;
            continue;
          }
          break;
        }
        if (g.child === S.child) {
          for (var O = g.child; O;) {
            if (O === d)
              return ei(g), t;
            if (O === p)
              return ei(g), a;
            O = O.sibling;
          }
          throw new Error("Unable to find node on an unmounted component.");
        }
        if (d.return !== p.return)
          d = g, p = S;
        else {
          for (var L = !1, F = g.child; F;) {
            if (F === d) {
              L = !0, d = g, p = S;
              break;
            }
            if (F === p) {
              L = !0, p = g, d = S;
              break;
            }
            F = F.sibling;
          }
          if (!L) {
            for (F = S.child; F;) {
              if (F === d) {
                L = !0, d = S, p = g;
                break;
              }
              if (F === p) {
                L = !0, p = S, d = g;
                break;
              }
              F = F.sibling;
            }
            if (!L)
              throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
          }
        }
        if (d.alternate !== p)
          throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
      }
      if (d.tag !== T)
        throw new Error("Unable to find node on an unmounted component.");
      return d.stateNode.current === d ? t : a;
    }
    function $i(t) {
      var a = Kn(t);
      return a !== null ? sv(a) : null;
    }
    function sv(t) {
      if (t.tag === C || t.tag === M)
        return t;
      for (var a = t.child; a !== null;) {
        var l = sv(a);
        if (l !== null)
          return l;
        a = a.sibling;
      }
      return null;
    }
    function e0(t) {
      var a = Kn(t);
      return a !== null ? fh(a) : null;
    }
    function fh(t) {
      if (t.tag === C || t.tag === M)
        return t;
      for (var a = t.child; a !== null;) {
        if (a.tag !== k) {
          var l = fh(a);
          if (l !== null)
            return l;
        }
        a = a.sibling;
      }
      return null;
    }
    var hh = e.unstable_scheduleCallback, t0 = e.unstable_cancelCallback, ph = e.unstable_shouldYield, n0 = e.unstable_requestPaint, sr = e.unstable_now, lv = e.unstable_getCurrentPriorityLevel, mh = e.unstable_ImmediatePriority, Hl = e.unstable_UserBlockingPriority, No = e.unstable_NormalPriority, r0 = e.unstable_LowPriority, vh = e.unstable_IdlePriority, Ku = e.unstable_yieldValue, a0 = e.unstable_setDisableYieldValue, os = null, Fr = null, Fe = null, zi = !1, bi = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u";
    function uv(t) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
        return !1;
      var a = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (a.isDisabled)
        return !0;
      if (!a.supportsFiber)
        return f("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools"), !0;
      try {
        ut && (t = Ft({}, t, {
          getLaneLabelMap: ss,
          injectProfilingHooks: i0
        })), os = a.inject(t), Fr = a;
      } catch (l) {
        f("React instrumentation encountered an error: %s.", l);
      }
      return !!a.checkDCE;
    }
    function cv(t, a) {
      if (Fr && typeof Fr.onScheduleFiberRoot == "function")
        try {
          Fr.onScheduleFiberRoot(os, t, a);
        } catch (l) {
          zi || (zi = !0, f("React instrumentation encountered an error: %s", l));
        }
    }
    function Gu(t, a) {
      if (Fr && typeof Fr.onCommitFiberRoot == "function")
        try {
          var l = (t.current.flags & Tt) === Tt;
          if (xt) {
            var d;
            switch (a) {
              case _r:
                d = mh;
                break;
              case us:
                d = Hl;
                break;
              case jo:
                d = No;
                break;
              case sc:
                d = vh;
                break;
              default:
                d = No;
                break;
            }
            Fr.onCommitFiberRoot(os, t, d, l);
          }
        } catch (p) {
          zi || (zi = !0, f("React instrumentation encountered an error: %s", p));
        }
    }
    function Bi(t) {
      if (Fr && typeof Fr.onPostCommitFiberRoot == "function")
        try {
          Fr.onPostCommitFiberRoot(os, t);
        } catch (a) {
          zi || (zi = !0, f("React instrumentation encountered an error: %s", a));
        }
    }
    function Wl(t) {
      if (Fr && typeof Fr.onCommitFiberUnmount == "function")
        try {
          Fr.onCommitFiberUnmount(os, t);
        } catch (a) {
          zi || (zi = !0, f("React instrumentation encountered an error: %s", a));
        }
    }
    function Dr(t) {
      if (typeof Ku == "function" && (a0(t), u(t)), Fr && typeof Fr.setStrictMode == "function")
        try {
          Fr.setStrictMode(os, t);
        } catch (a) {
          zi || (zi = !0, f("React instrumentation encountered an error: %s", a));
        }
    }
    function i0(t) {
      Fe = t;
    }
    function ss() {
      {
        for (var t = /* @__PURE__ */ new Map(), a = 1, l = 0; l < $d; l++) {
          var d = tS(a);
          t.set(a, d), a *= 2;
        }
        return t;
      }
    }
    function rl(t) {
      Fe !== null && typeof Fe.markCommitStarted == "function" && Fe.markCommitStarted(t);
    }
    function gh() {
      Fe !== null && typeof Fe.markCommitStopped == "function" && Fe.markCommitStopped();
    }
    function Qu(t) {
      Fe !== null && typeof Fe.markComponentRenderStarted == "function" && Fe.markComponentRenderStarted(t);
    }
    function ti() {
      Fe !== null && typeof Fe.markComponentRenderStopped == "function" && Fe.markComponentRenderStopped();
    }
    function al(t) {
      Fe !== null && typeof Fe.markComponentPassiveEffectMountStarted == "function" && Fe.markComponentPassiveEffectMountStarted(t);
    }
    function yh() {
      Fe !== null && typeof Fe.markComponentPassiveEffectMountStopped == "function" && Fe.markComponentPassiveEffectMountStopped();
    }
    function o0(t) {
      Fe !== null && typeof Fe.markComponentPassiveEffectUnmountStarted == "function" && Fe.markComponentPassiveEffectUnmountStarted(t);
    }
    function bh() {
      Fe !== null && typeof Fe.markComponentPassiveEffectUnmountStopped == "function" && Fe.markComponentPassiveEffectUnmountStopped();
    }
    function s0(t) {
      Fe !== null && typeof Fe.markComponentLayoutEffectMountStarted == "function" && Fe.markComponentLayoutEffectMountStarted(t);
    }
    function Ld() {
      Fe !== null && typeof Fe.markComponentLayoutEffectMountStopped == "function" && Fe.markComponentLayoutEffectMountStopped();
    }
    function fo(t) {
      Fe !== null && typeof Fe.markComponentLayoutEffectUnmountStarted == "function" && Fe.markComponentLayoutEffectUnmountStarted(t);
    }
    function Ju() {
      Fe !== null && typeof Fe.markComponentLayoutEffectUnmountStopped == "function" && Fe.markComponentLayoutEffectUnmountStopped();
    }
    function Id(t, a, l) {
      Fe !== null && typeof Fe.markComponentErrored == "function" && Fe.markComponentErrored(t, a, l);
    }
    function ql(t, a, l) {
      Fe !== null && typeof Fe.markComponentSuspended == "function" && Fe.markComponentSuspended(t, a, l);
    }
    function dv(t) {
      Fe !== null && typeof Fe.markLayoutEffectsStarted == "function" && Fe.markLayoutEffectsStarted(t);
    }
    function Zu() {
      Fe !== null && typeof Fe.markLayoutEffectsStopped == "function" && Fe.markLayoutEffectsStopped();
    }
    function l0(t) {
      Fe !== null && typeof Fe.markPassiveEffectsStarted == "function" && Fe.markPassiveEffectsStarted(t);
    }
    function fv() {
      Fe !== null && typeof Fe.markPassiveEffectsStopped == "function" && Fe.markPassiveEffectsStopped();
    }
    function tr(t) {
      Fe !== null && typeof Fe.markRenderStarted == "function" && Fe.markRenderStarted(t);
    }
    function wh() {
      Fe !== null && typeof Fe.markRenderYielded == "function" && Fe.markRenderYielded();
    }
    function xh() {
      Fe !== null && typeof Fe.markRenderStopped == "function" && Fe.markRenderStopped();
    }
    function hv(t) {
      Fe !== null && typeof Fe.markRenderScheduled == "function" && Fe.markRenderScheduled(t);
    }
    function Sh(t, a) {
      Fe !== null && typeof Fe.markForceUpdateScheduled == "function" && Fe.markForceUpdateScheduled(t, a);
    }
    function Ud(t, a) {
      Fe !== null && typeof Fe.markStateUpdateScheduled == "function" && Fe.markStateUpdateScheduled(t, a);
    }
    var rt = (
      /*                         */
      0
    ), st = (
      /*                 */
      1
    ), Rt = (
      /*                    */
      2
    ), Bt = (
      /*               */
      8
    ), wi = (
      /*              */
      16
    ), Xu = Math.clz32 ? Math.clz32 : Sa, Fd = Math.log, eS = Math.LN2;
    function Sa(t) {
      var a = t >>> 0;
      return a === 0 ? 32 : 31 - (Fd(a) / eS | 0) | 0;
    }
    var $d = 31, ye = (
      /*                        */
      0
    ), Pr = (
      /*                          */
      0
    ), ft = (
      /*                        */
      1
    ), sa = (
      /*    */
      2
    ), xi = (
      /*             */
      4
    ), ls = (
      /*            */
      8
    ), Vi = (
      /*                     */
      16
    ), ec = (
      /*                */
      32
    ), Yl = (
      /*                       */
      4194240
    ), tc = (
      /*                        */
      64
    ), _h = (
      /*                        */
      128
    ), Eh = (
      /*                        */
      256
    ), Ch = (
      /*                        */
      512
    ), Th = (
      /*                        */
      1024
    ), Rh = (
      /*                        */
      2048
    ), Kl = (
      /*                        */
      4096
    ), kh = (
      /*                        */
      8192
    ), nc = (
      /*                        */
      16384
    ), rc = (
      /*                       */
      32768
    ), Oh = (
      /*                       */
      65536
    ), zd = (
      /*                       */
      131072
    ), Nh = (
      /*                       */
      262144
    ), jh = (
      /*                       */
      524288
    ), Ah = (
      /*                       */
      1048576
    ), Dh = (
      /*                       */
      2097152
    ), ac = (
      /*                            */
      130023424
    ), Gl = (
      /*                             */
      4194304
    ), Ph = (
      /*                             */
      8388608
    ), Mh = (
      /*                             */
      16777216
    ), pv = (
      /*                             */
      33554432
    ), Lh = (
      /*                             */
      67108864
    ), u0 = Gl, Bd = (
      /*          */
      134217728
    ), mv = (
      /*                          */
      268435455
    ), ic = (
      /*               */
      268435456
    ), il = (
      /*                        */
      536870912
    ), _a = (
      /*                   */
      1073741824
    );
    function tS(t) {
      {
        if (t & ft)
          return "Sync";
        if (t & sa)
          return "InputContinuousHydration";
        if (t & xi)
          return "InputContinuous";
        if (t & ls)
          return "DefaultHydration";
        if (t & Vi)
          return "Default";
        if (t & ec)
          return "TransitionHydration";
        if (t & Yl)
          return "Transition";
        if (t & ac)
          return "Retry";
        if (t & Bd)
          return "SelectiveHydration";
        if (t & ic)
          return "IdleHydration";
        if (t & il)
          return "Idle";
        if (t & _a)
          return "Offscreen";
      }
    }
    var $n = -1, Ih = tc, ni = Gl;
    function Ql(t) {
      switch (Sr(t)) {
        case ft:
          return ft;
        case sa:
          return sa;
        case xi:
          return xi;
        case ls:
          return ls;
        case Vi:
          return Vi;
        case ec:
          return ec;
        case tc:
        case _h:
        case Eh:
        case Ch:
        case Th:
        case Rh:
        case Kl:
        case kh:
        case nc:
        case rc:
        case Oh:
        case zd:
        case Nh:
        case jh:
        case Ah:
        case Dh:
          return t & Yl;
        case Gl:
        case Ph:
        case Mh:
        case pv:
        case Lh:
          return t & ac;
        case Bd:
          return Bd;
        case ic:
          return ic;
        case il:
          return il;
        case _a:
          return _a;
        default:
          return f("Should have found matching lanes. This is a bug in React."), t;
      }
    }
    function Jl(t, a) {
      var l = t.pendingLanes;
      if (l === ye)
        return ye;
      var d = ye, p = t.suspendedLanes, g = t.pingedLanes, S = l & mv;
      if (S !== ye) {
        var R = S & ~p;
        if (R !== ye)
          d = Ql(R);
        else {
          var O = S & g;
          O !== ye && (d = Ql(O));
        }
      } else {
        var L = l & ~p;
        L !== ye ? d = Ql(L) : g !== ye && (d = Ql(g));
      }
      if (d === ye)
        return ye;
      if (a !== ye && a !== d && // If we already suspended with a delay, then interrupting is fine. Don't
        // bother waiting until the root is complete.
        (a & p) === ye) {
        var F = Sr(d), J = Sr(a);
        if (
          // Tests whether the next lane is equal or lower priority than the wip
          // one. This works because the bits decrease in priority as you go left.
          F >= J || // Default priority updates should not interrupt transition updates. The
          // only difference between default updates and transition updates is that
          // default updates do not support refresh transitions.
          F === Vi && (J & Yl) !== ye
        )
          return a;
      }
      (d & xi) !== ye && (d |= l & Vi);
      var G = t.entangledLanes;
      if (G !== ye)
        for (var ie = t.entanglements, le = d & G; le > 0;) {
          var de = sl(le), Be = 1 << de;
          d |= ie[de], le &= ~Be;
        }
      return d;
    }
    function c0(t, a) {
      for (var l = t.eventTimes, d = $n; a > 0;) {
        var p = sl(a), g = 1 << p, S = l[p];
        S > d && (d = S), a &= ~g;
      }
      return d;
    }
    function d0(t, a) {
      switch (t) {
        case ft:
        case sa:
        case xi:
          return a + 250;
        case ls:
        case Vi:
        case ec:
        case tc:
        case _h:
        case Eh:
        case Ch:
        case Th:
        case Rh:
        case Kl:
        case kh:
        case nc:
        case rc:
        case Oh:
        case zd:
        case Nh:
        case jh:
        case Ah:
        case Dh:
          return a + 5e3;
        case Gl:
        case Ph:
        case Mh:
        case pv:
        case Lh:
          return $n;
        case Bd:
        case ic:
        case il:
        case _a:
          return $n;
        default:
          return f("Should have found matching lanes. This is a bug in React."), $n;
      }
    }
    function f0(t, a) {
      for (var l = t.pendingLanes, d = t.suspendedLanes, p = t.pingedLanes, g = t.expirationTimes, S = l; S > 0;) {
        var R = sl(S), O = 1 << R, L = g[R];
        L === $n ? ((O & d) === ye || (O & p) !== ye) && (g[R] = d0(O, a)) : L <= a && (t.expiredLanes |= O), S &= ~O;
      }
    }
    function vv(t) {
      return Ql(t.pendingLanes);
    }
    function ol(t) {
      var a = t.pendingLanes & ~_a;
      return a !== ye ? a : a & _a ? _a : ye;
    }
    function gv(t) {
      return (t & ft) !== ye;
    }
    function Vd(t) {
      return (t & mv) !== ye;
    }
    function h0(t) {
      return (t & ac) === t;
    }
    function p0(t) {
      var a = ft | xi | Vi;
      return (t & a) === ye;
    }
    function m0(t) {
      return (t & Yl) === t;
    }
    function Hd(t, a) {
      var l = sa | xi | ls | Vi;
      return (a & l) !== ye;
    }
    function v0(t, a) {
      return (a & t.expiredLanes) !== ye;
    }
    function yv(t) {
      return (t & Yl) !== ye;
    }
    function g0() {
      var t = Ih;
      return Ih <<= 1, (Ih & Yl) === ye && (Ih = tc), t;
    }
    function ri() {
      var t = ni;
      return ni <<= 1, (ni & ac) === ye && (ni = Gl), t;
    }
    function Sr(t) {
      return t & -t;
    }
    function oc(t) {
      return Sr(t);
    }
    function sl(t) {
      return 31 - Xu(t);
    }
    function Uh(t) {
      return sl(t);
    }
    function ai(t, a) {
      return (t & a) !== ye;
    }
    function Zl(t, a) {
      return (t & a) === a;
    }
    function Pt(t, a) {
      return t | a;
    }
    function Wd(t, a) {
      return t & ~a;
    }
    function Fh(t, a) {
      return t & a;
    }
    function nS(t) {
      return t;
    }
    function y0(t, a) {
      return t !== Pr && t < a ? t : a;
    }
    function qd(t) {
      for (var a = [], l = 0; l < $d; l++)
        a.push(t);
      return a;
    }
    function Xl(t, a, l) {
      t.pendingLanes |= a, a !== il && (t.suspendedLanes = ye, t.pingedLanes = ye);
      var d = t.eventTimes, p = Uh(a);
      d[p] = l;
    }
    function b0(t, a) {
      t.suspendedLanes |= a, t.pingedLanes &= ~a;
      for (var l = t.expirationTimes, d = a; d > 0;) {
        var p = sl(d), g = 1 << p;
        l[p] = $n, d &= ~g;
      }
    }
    function $h(t, a, l) {
      t.pingedLanes |= t.suspendedLanes & a;
    }
    function zh(t, a) {
      var l = t.pendingLanes & ~a;
      t.pendingLanes = a, t.suspendedLanes = ye, t.pingedLanes = ye, t.expiredLanes &= a, t.mutableReadLanes &= a, t.entangledLanes &= a;
      for (var d = t.entanglements, p = t.eventTimes, g = t.expirationTimes, S = l; S > 0;) {
        var R = sl(S), O = 1 << R;
        d[R] = ye, p[R] = $n, g[R] = $n, S &= ~O;
      }
    }
    function bv(t, a) {
      for (var l = t.entangledLanes |= a, d = t.entanglements, p = l; p;) {
        var g = sl(p), S = 1 << g;
        // Is this one of the newly entangled lanes?
        S & a | // Is this lane transitively entangled with the newly entangled lanes?
          d[g] & a && (d[g] |= a), p &= ~S;
      }
    }
    function w0(t, a) {
      var l = Sr(a), d;
      switch (l) {
        case xi:
          d = sa;
          break;
        case Vi:
          d = ls;
          break;
        case tc:
        case _h:
        case Eh:
        case Ch:
        case Th:
        case Rh:
        case Kl:
        case kh:
        case nc:
        case rc:
        case Oh:
        case zd:
        case Nh:
        case jh:
        case Ah:
        case Dh:
        case Gl:
        case Ph:
        case Mh:
        case pv:
        case Lh:
          d = ec;
          break;
        case il:
          d = ic;
          break;
        default:
          d = Pr;
          break;
      }
      return (d & (t.suspendedLanes | a)) !== Pr ? Pr : d;
    }
    function Bh(t, a, l) {
      if (bi)
        for (var d = t.pendingUpdatersLaneMap; l > 0;) {
          var p = Uh(l), g = 1 << p, S = d[p];
          S.add(a), l &= ~g;
        }
    }
    function wv(t, a) {
      if (bi)
        for (var l = t.pendingUpdatersLaneMap, d = t.memoizedUpdaters; a > 0;) {
          var p = Uh(a), g = 1 << p, S = l[p];
          S.size > 0 && (S.forEach(function (R) {
            var O = R.alternate;
            (O === null || !d.has(O)) && d.add(R);
          }), S.clear()), a &= ~g;
        }
    }
    function Yd(t, a) {
      return null;
    }
    var _r = ft, us = xi, jo = Vi, sc = il, lc = Pr;
    function Hi() {
      return lc;
    }
    function mr(t) {
      lc = t;
    }
    function Ea(t, a) {
      var l = lc;
      try {
        return lc = t, a();
      } finally {
        lc = l;
      }
    }
    function rS(t, a) {
      return t !== 0 && t < a ? t : a;
    }
    function aS(t, a) {
      return t > a ? t : a;
    }
    function uc(t, a) {
      return t !== 0 && t < a;
    }
    function la(t) {
      var a = Sr(t);
      return uc(_r, a) ? uc(us, a) ? Vd(a) ? jo : sc : us : _r;
    }
    function Vh(t) {
      var a = t.current.memoizedState;
      return a.isDehydrated;
    }
    var Qe;
    function cc(t) {
      Qe = t;
    }
    function xv(t) {
      Qe(t);
    }
    var Hh;
    function iS(t) {
      Hh = t;
    }
    var dc;
    function Wh(t) {
      dc = t;
    }
    var qh;
    function x0(t) {
      qh = t;
    }
    var Sv;
    function S0(t) {
      Sv = t;
    }
    var Kd = !1, fc = [], nr = null, Xr = null, Ma = null, hc = /* @__PURE__ */ new Map(), pc = /* @__PURE__ */ new Map(), ea = [], _0 = [
      "mousedown",
      "mouseup",
      "touchcancel",
      "touchend",
      "touchstart",
      "auxclick",
      "dblclick",
      "pointercancel",
      "pointerdown",
      "pointerup",
      "dragend",
      "dragstart",
      "drop",
      "compositionend",
      "compositionstart",
      "keydown",
      "keypress",
      "keyup",
      "input",
      "textInput",
      // Intentionally camelCase
      "copy",
      "cut",
      "paste",
      "click",
      "change",
      "contextmenu",
      "reset",
      "submit"
    ];
    function Ao(t) {
      return _0.indexOf(t) > -1;
    }
    function oS(t, a, l, d, p) {
      return {
        blockedOn: t,
        domEventName: a,
        eventSystemFlags: l,
        nativeEvent: p,
        targetContainers: [d]
      };
    }
    function _v(t, a) {
      switch (t) {
        case "focusin":
        case "focusout":
          nr = null;
          break;
        case "dragenter":
        case "dragleave":
          Xr = null;
          break;
        case "mouseover":
        case "mouseout":
          Ma = null;
          break;
        case "pointerover":
        case "pointerout": {
          var l = a.pointerId;
          hc.delete(l);
          break;
        }
        case "gotpointercapture":
        case "lostpointercapture": {
          var d = a.pointerId;
          pc.delete(d);
          break;
        }
      }
    }
    function mc(t, a, l, d, p, g) {
      if (t === null || t.nativeEvent !== g) {
        var S = oS(a, l, d, p, g);
        if (a !== null) {
          var R = Ec(a);
          R !== null && Hh(R);
        }
        return S;
      }
      t.eventSystemFlags |= d;
      var O = t.targetContainers;
      return p !== null && O.indexOf(p) === -1 && O.push(p), t;
    }
    function E0(t, a, l, d, p) {
      switch (a) {
        case "focusin": {
          var g = p;
          return nr = mc(nr, t, a, l, d, g), !0;
        }
        case "dragenter": {
          var S = p;
          return Xr = mc(Xr, t, a, l, d, S), !0;
        }
        case "mouseover": {
          var R = p;
          return Ma = mc(Ma, t, a, l, d, R), !0;
        }
        case "pointerover": {
          var O = p, L = O.pointerId;
          return hc.set(L, mc(hc.get(L) || null, t, a, l, d, O)), !0;
        }
        case "gotpointercapture": {
          var F = p, J = F.pointerId;
          return pc.set(J, mc(pc.get(J) || null, t, a, l, d, F)), !0;
        }
      }
      return !1;
    }
    function Ev(t) {
      var a = sf(t.target);
      if (a !== null) {
        var l = gi(a);
        if (l !== null) {
          var d = l.tag;
          if (d === K) {
            var p = iv(l);
            if (p !== null) {
              t.blockedOn = p, Sv(t.priority, function () {
                dc(l);
              });
              return;
            }
          } else if (d === T) {
            var g = l.stateNode;
            if (Vh(g)) {
              t.blockedOn = dh(l);
              return;
            }
          }
        }
      }
      t.blockedOn = null;
    }
    function sS(t) {
      for (var a = qh(), l = {
        blockedOn: null,
        target: t,
        priority: a
      }, d = 0; d < ea.length && uc(a, ea[d].priority); d++)
        ;
      ea.splice(d, 0, l), d === 0 && Ev(l);
    }
    function eu(t) {
      if (t.blockedOn !== null)
        return !1;
      for (var a = t.targetContainers; a.length > 0;) {
        var l = a[0], d = Ca(t.domEventName, t.eventSystemFlags, l, t.nativeEvent);
        if (d === null) {
          var p = t.nativeEvent, g = new p.constructor(p.type, p);
          kd(g), p.target.dispatchEvent(g), Qx();
        } else {
          var S = Ec(d);
          return S !== null && Hh(S), t.blockedOn = d, !1;
        }
        a.shift();
      }
      return !0;
    }
    function Yh(t, a, l) {
      eu(t) && l.delete(a);
    }
    function Wi() {
      Kd = !1, nr !== null && eu(nr) && (nr = null), Xr !== null && eu(Xr) && (Xr = null), Ma !== null && eu(Ma) && (Ma = null), hc.forEach(Yh), pc.forEach(Yh);
    }
    function Yt(t, a) {
      t.blockedOn === a && (t.blockedOn = null, Kd || (Kd = !0, e.unstable_scheduleCallback(e.unstable_NormalPriority, Wi)));
    }
    function vr(t) {
      if (fc.length > 0) {
        Yt(fc[0], t);
        for (var a = 1; a < fc.length; a++) {
          var l = fc[a];
          l.blockedOn === t && (l.blockedOn = null);
        }
      }
      nr !== null && Yt(nr, t), Xr !== null && Yt(Xr, t), Ma !== null && Yt(Ma, t);
      var d = function (R) {
        return Yt(R, t);
      };
      hc.forEach(d), pc.forEach(d);
      for (var p = 0; p < ea.length; p++) {
        var g = ea[p];
        g.blockedOn === t && (g.blockedOn = null);
      }
      for (; ea.length > 0;) {
        var S = ea[0];
        if (S.blockedOn !== null)
          break;
        Ev(S), S.blockedOn === null && ea.shift();
      }
    }
    var Gn = r.ReactCurrentBatchConfig, $r = !0;
    function ii(t) {
      $r = !!t;
    }
    function vc() {
      return $r;
    }
    function zr(t, a, l) {
      var d = Kh(a), p;
      switch (d) {
        case _r:
          p = Gd;
          break;
        case us:
          p = tu;
          break;
        case jo:
        default:
          p = gc;
          break;
      }
      return p.bind(null, a, l, t);
    }
    function Gd(t, a, l, d) {
      var p = Hi(), g = Gn.transition;
      Gn.transition = null;
      try {
        mr(_r), gc(t, a, l, d);
      } finally {
        mr(p), Gn.transition = g;
      }
    }
    function tu(t, a, l, d) {
      var p = Hi(), g = Gn.transition;
      Gn.transition = null;
      try {
        mr(us), gc(t, a, l, d);
      } finally {
        mr(p), Gn.transition = g;
      }
    }
    function gc(t, a, l, d) {
      $r && Cv(t, a, l, d);
    }
    function Cv(t, a, l, d) {
      var p = Ca(t, a, l, d);
      if (p === null) {
        ES(t, a, d, ll, l), _v(t, d);
        return;
      }
      if (E0(p, t, a, l, d)) {
        d.stopPropagation();
        return;
      }
      if (_v(t, d), a & Ul && Ao(t)) {
        for (; p !== null;) {
          var g = Ec(p);
          g !== null && xv(g);
          var S = Ca(t, a, l, d);
          if (S === null && ES(t, a, d, ll, l), S === p)
            break;
          p = S;
        }
        p !== null && d.stopPropagation();
        return;
      }
      ES(t, a, d, null, l);
    }
    var ll = null;
    function Ca(t, a, l, d) {
      ll = null;
      var p = oh(d), g = sf(p);
      if (g !== null) {
        var S = gi(g);
        if (S === null)
          g = null;
        else {
          var R = S.tag;
          if (R === K) {
            var O = iv(S);
            if (O !== null)
              return O;
            g = null;
          } else if (R === T) {
            var L = S.stateNode;
            if (Vh(L))
              return dh(S);
            g = null;
          } else S !== g && (g = null);
        }
      }
      return ll = g, null;
    }
    function Kh(t) {
      switch (t) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return _r;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return us;
        case "message": {
          var a = lv();
          switch (a) {
            case mh:
              return _r;
            case Hl:
              return us;
            case No:
            case r0:
              return jo;
            case vh:
              return sc;
            default:
              return jo;
          }
        }
        default:
          return jo;
      }
    }
    function yc(t, a, l) {
      return t.addEventListener(a, l, !1), l;
    }
    function cs(t, a, l) {
      return t.addEventListener(a, l, !0), l;
    }
    function Gh(t, a, l, d) {
      return t.addEventListener(a, l, {
        capture: !0,
        passive: d
      }), l;
    }
    function Tv(t, a, l, d) {
      return t.addEventListener(a, l, {
        passive: d
      }), l;
    }
    var qi = null, bc = null, Yi = null;
    function Qh(t) {
      return qi = t, bc = Jd(), !0;
    }
    function Qd() {
      qi = null, bc = null, Yi = null;
    }
    function Jh() {
      if (Yi)
        return Yi;
      var t, a = bc, l = a.length, d, p = Jd(), g = p.length;
      for (t = 0; t < l && a[t] === p[t]; t++)
        ;
      var S = l - t;
      for (d = 1; d <= S && a[l - d] === p[g - d]; d++)
        ;
      var R = d > 1 ? 1 - d : void 0;
      return Yi = p.slice(t, R), Yi;
    }
    function Jd() {
      return "value" in qi ? qi.value : qi.textContent;
    }
    function nu(t) {
      var a, l = t.keyCode;
      return "charCode" in t ? (a = t.charCode, a === 0 && l === 13 && (a = 13)) : a = l, a === 10 && (a = 13), a >= 32 || a === 13 ? a : 0;
    }
    function ta() {
      return !0;
    }
    function ds() {
      return !1;
    }
    function lr(t) {
      function a(l, d, p, g, S) {
        this._reactName = l, this._targetInst = p, this.type = d, this.nativeEvent = g, this.target = S, this.currentTarget = null;
        for (var R in t)
          if (t.hasOwnProperty(R)) {
            var O = t[R];
            O ? this[R] = O(g) : this[R] = g[R];
          }
        var L = g.defaultPrevented != null ? g.defaultPrevented : g.returnValue === !1;
        return L ? this.isDefaultPrevented = ta : this.isDefaultPrevented = ds, this.isPropagationStopped = ds, this;
      }
      return Ft(a.prototype, {
        preventDefault: function () {
          this.defaultPrevented = !0;
          var l = this.nativeEvent;
          l && (l.preventDefault ? l.preventDefault() : typeof l.returnValue != "unknown" && (l.returnValue = !1), this.isDefaultPrevented = ta);
        },
        stopPropagation: function () {
          var l = this.nativeEvent;
          l && (l.stopPropagation ? l.stopPropagation() : typeof l.cancelBubble != "unknown" && (l.cancelBubble = !0), this.isPropagationStopped = ta);
        },
        /**
         * We release all dispatched `SyntheticEvent`s after each event loop, adding
         * them back into the pool. This allows a way to hold onto a reference that
         * won't be added back into the pool.
         */
        persist: function () {
        },
        /**
         * Checks if this event should be released back into the pool.
         *
         * @return {boolean} True if this should not be released, false otherwise.
         */
        isPersistent: ta
      }), a;
    }
    var Br = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function (t) {
        return t.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0
    }, Zh = lr(Br), ru = Ft({}, Br, {
      view: 0,
      detail: 0
    }), Rv = lr(ru), kv, Do, wc;
    function Ov(t) {
      t !== wc && (wc && t.type === "mousemove" ? (kv = t.screenX - wc.screenX, Do = t.screenY - wc.screenY) : (kv = 0, Do = 0), wc = t);
    }
    var Po = Ft({}, ru, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: Nv,
      button: 0,
      buttons: 0,
      relatedTarget: function (t) {
        return t.relatedTarget === void 0 ? t.fromElement === t.srcElement ? t.toElement : t.fromElement : t.relatedTarget;
      },
      movementX: function (t) {
        return "movementX" in t ? t.movementX : (Ov(t), kv);
      },
      movementY: function (t) {
        return "movementY" in t ? t.movementY : Do;
      }
    }), Xh = lr(Po), au = Ft({}, Po, {
      dataTransfer: 0
    }), C0 = lr(au), T0 = Ft({}, ru, {
      relatedTarget: 0
    }), Zd = lr(T0), ep = Ft({}, Br, {
      animationName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), lS = lr(ep), uS = Ft({}, Br, {
      clipboardData: function (t) {
        return "clipboardData" in t ? t.clipboardData : window.clipboardData;
      }
    }), R0 = lr(uS), k0 = Ft({}, Br, {
      data: 0
    }), ul = lr(k0), cS = ul, xc = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, O0 = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    };
    function gr(t) {
      if (t.key) {
        var a = xc[t.key] || t.key;
        if (a !== "Unidentified")
          return a;
      }
      if (t.type === "keypress") {
        var l = nu(t);
        return l === 13 ? "Enter" : String.fromCharCode(l);
      }
      return t.type === "keydown" || t.type === "keyup" ? O0[t.keyCode] || "Unidentified" : "";
    }
    var dS = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey"
    };
    function N0(t) {
      var a = this, l = a.nativeEvent;
      if (l.getModifierState)
        return l.getModifierState(t);
      var d = dS[t];
      return d ? !!l[d] : !1;
    }
    function Nv(t) {
      return N0;
    }
    var fS = Ft({}, ru, {
      key: gr,
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: Nv,
      // Legacy Interface
      charCode: function (t) {
        return t.type === "keypress" ? nu(t) : 0;
      },
      keyCode: function (t) {
        return t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0;
      },
      which: function (t) {
        return t.type === "keypress" ? nu(t) : t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0;
      }
    }), j0 = lr(fS), A0 = Ft({}, Po, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0
    }), D0 = lr(A0), Ki = Ft({}, ru, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: Nv
    }), jv = lr(Ki), hS = Ft({}, Br, {
      propertyName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), cl = lr(hS), tp = Ft({}, Po, {
      deltaX: function (t) {
        return "deltaX" in t ? t.deltaX : (
          // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
          "wheelDeltaX" in t ? -t.wheelDeltaX : 0
        );
      },
      deltaY: function (t) {
        return "deltaY" in t ? t.deltaY : (
          // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
          "wheelDeltaY" in t ? -t.wheelDeltaY : (
            // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
            "wheelDelta" in t ? -t.wheelDelta : 0
          )
        );
      },
      deltaZ: 0,
      // Browsers without "deltaMode" is reporting in raw wheel delta where one
      // notch on the scroll is always +/- 120, roughly equivalent to pixels.
      // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
      // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
      deltaMode: 0
    }), iu = lr(tp), np = [9, 13, 27, 32], rp = 229, Xd = cn && "CompositionEvent" in window, ef = null;
    cn && "documentMode" in document && (ef = document.documentMode);
    var Av = cn && "TextEvent" in window && !ef, P0 = cn && (!Xd || ef && ef > 8 && ef <= 11), Dv = 32, Pv = String.fromCharCode(Dv);
    function ap() {
      zn("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), zn("onCompositionEnd", ["compositionend", "focusout", "keydown", "keypress", "keyup", "mousedown"]), zn("onCompositionStart", ["compositionstart", "focusout", "keydown", "keypress", "keyup", "mousedown"]), zn("onCompositionUpdate", ["compositionupdate", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
    }
    var tf = !1;
    function M0(t) {
      return (t.ctrlKey || t.altKey || t.metaKey) && // ctrlKey && altKey is equivalent to AltGr, and is not a command.
        !(t.ctrlKey && t.altKey);
    }
    function Mv(t) {
      switch (t) {
        case "compositionstart":
          return "onCompositionStart";
        case "compositionend":
          return "onCompositionEnd";
        case "compositionupdate":
          return "onCompositionUpdate";
      }
    }
    function pS(t, a) {
      return t === "keydown" && a.keyCode === rp;
    }
    function Lv(t, a) {
      switch (t) {
        case "keyup":
          return np.indexOf(a.keyCode) !== -1;
        case "keydown":
          return a.keyCode !== rp;
        case "keypress":
        case "mousedown":
        case "focusout":
          return !0;
        default:
          return !1;
      }
    }
    function ip(t) {
      var a = t.detail;
      return typeof a == "object" && "data" in a ? a.data : null;
    }
    function nf(t) {
      return t.locale === "ko";
    }
    var dl = !1;
    function op(t, a, l, d, p) {
      var g, S;
      if (Xd ? g = Mv(a) : dl ? Lv(a, d) && (g = "onCompositionEnd") : pS(a, d) && (g = "onCompositionStart"), !g)
        return null;
      P0 && !nf(d) && (!dl && g === "onCompositionStart" ? dl = Qh(p) : g === "onCompositionEnd" && dl && (S = Jh()));
      var R = z0(l, g);
      if (R.length > 0) {
        var O = new ul(g, a, null, d, p);
        if (t.push({
          event: O,
          listeners: R
        }), S)
          O.data = S;
        else {
          var L = ip(d);
          L !== null && (O.data = L);
        }
      }
    }
    function L0(t, a) {
      switch (t) {
        case "compositionend":
          return ip(a);
        case "keypress":
          var l = a.which;
          return l !== Dv ? null : (tf = !0, Pv);
        case "textInput":
          var d = a.data;
          return d === Pv && tf ? null : d;
        default:
          return null;
      }
    }
    function mS(t, a) {
      if (dl) {
        if (t === "compositionend" || !Xd && Lv(t, a)) {
          var l = Jh();
          return Qd(), dl = !1, l;
        }
        return null;
      }
      switch (t) {
        case "paste":
          return null;
        case "keypress":
          if (!M0(a)) {
            if (a.char && a.char.length > 1)
              return a.char;
            if (a.which)
              return String.fromCharCode(a.which);
          }
          return null;
        case "compositionend":
          return P0 && !nf(a) ? null : a.data;
        default:
          return null;
      }
    }
    function sp(t, a, l, d, p) {
      var g;
      if (Av ? g = L0(a, d) : g = mS(a, d), !g)
        return null;
      var S = z0(l, "onBeforeInput");
      if (S.length > 0) {
        var R = new cS("onBeforeInput", "beforeinput", null, d, p);
        t.push({
          event: R,
          listeners: S
        }), R.data = g;
      }
    }
    function vS(t, a, l, d, p, g, S) {
      op(t, a, l, d, p), sp(t, a, l, d, p);
    }
    var rf = {
      color: !0,
      date: !0,
      datetime: !0,
      "datetime-local": !0,
      email: !0,
      month: !0,
      number: !0,
      password: !0,
      range: !0,
      search: !0,
      tel: !0,
      text: !0,
      time: !0,
      url: !0,
      week: !0
    };
    function I0(t) {
      var a = t && t.nodeName && t.nodeName.toLowerCase();
      return a === "input" ? !!rf[t.type] : a === "textarea";
    }
    /**
     * Checks if an event is supported in the current execution environment.
     *
     * NOTE: This will not work correctly for non-generic events such as `change`,
     * `reset`, `load`, `error`, and `select`.
     *
     * Borrows from Modernizr.
     *
     * @param {string} eventNameSuffix Event name, e.g. "click".
     * @return {boolean} True if the event is supported.
     * @internal
     * @license Modernizr 3.0.0pre (Custom Build) | MIT
     */
    function lp(t) {
      if (!cn)
        return !1;
      var a = "on" + t, l = a in document;
      if (!l) {
        var d = document.createElement("div");
        d.setAttribute(a, "return;"), l = typeof d[a] == "function";
      }
      return l;
    }
    function i() {
      zn("onChange", ["change", "click", "focusin", "focusout", "input", "keydown", "keyup", "selectionchange"]);
    }
    function s(t, a, l, d) {
      sh(d);
      var p = z0(a, "onChange");
      if (p.length > 0) {
        var g = new Zh("onChange", "change", null, l, d);
        t.push({
          event: g,
          listeners: p
        });
      }
    }
    var h = null, v = null;
    function w(t) {
      var a = t.nodeName && t.nodeName.toLowerCase();
      return a === "select" || a === "input" && t.type === "file";
    }
    function E(t) {
      var a = [];
      s(a, v, t, oh(t)), Jm(P, a);
    }
    function P(t) {
      HT(t, 0);
    }
    function z(t) {
      var a = pp(t);
      if (Iu(a))
        return t;
    }
    function q(t, a) {
      if (t === "change")
        return a;
    }
    var se = !1;
    cn && (se = lp("input") && (!document.documentMode || document.documentMode > 9));
    function Se(t, a) {
      h = t, v = a, h.attachEvent("onpropertychange", be);
    }
    function _e() {
      h && (h.detachEvent("onpropertychange", be), h = null, v = null);
    }
    function be(t) {
      t.propertyName === "value" && z(v) && E(t);
    }
    function He(t, a, l) {
      t === "focusin" ? (_e(), Se(a, l)) : t === "focusout" && _e();
    }
    function Je(t, a) {
      if (t === "selectionchange" || t === "keyup" || t === "keydown")
        return z(v);
    }
    function tt(t) {
      var a = t.nodeName;
      return a && a.toLowerCase() === "input" && (t.type === "checkbox" || t.type === "radio");
    }
    function Er(t, a) {
      if (t === "click")
        return z(a);
    }
    function Z(t, a) {
      if (t === "input" || t === "change")
        return z(a);
    }
    function Q(t) {
      var a = t._wrapperState;
      !a || !a.controlled || t.type !== "number" || vt(t, "number", t.value);
    }
    function ne(t, a, l, d, p, g, S) {
      var R = l ? pp(l) : window, O, L;
      if (w(R) ? O = q : I0(R) ? se ? O = Z : (O = Je, L = He) : tt(R) && (O = Er), O) {
        var F = O(a, l);
        if (F) {
          s(t, F, d, p);
          return;
        }
      }
      L && L(a, R, l), a === "focusout" && Q(R);
    }
    function je() {
      yr("onMouseEnter", ["mouseout", "mouseover"]), yr("onMouseLeave", ["mouseout", "mouseover"]), yr("onPointerEnter", ["pointerout", "pointerover"]), yr("onPointerLeave", ["pointerout", "pointerover"]);
    }
    function at(t, a, l, d, p, g, S) {
      var R = a === "mouseover" || a === "pointerover", O = a === "mouseout" || a === "pointerout";
      if (R && !Qy(d)) {
        var L = d.relatedTarget || d.fromElement;
        if (L && (sf(L) || Qv(L)))
          return;
      }
      if (!(!O && !R)) {
        var F;
        if (p.window === p)
          F = p;
        else {
          var J = p.ownerDocument;
          J ? F = J.defaultView || J.parentWindow : F = window;
        }
        var G, ie;
        if (O) {
          var le = d.relatedTarget || d.toElement;
          if (G = l, ie = le ? sf(le) : null, ie !== null) {
            var de = gi(ie);
            (ie !== de || ie.tag !== C && ie.tag !== M) && (ie = null);
          }
        } else
          G = null, ie = l;
        if (G !== ie) {
          var Be = Xh, pt = "onMouseLeave", lt = "onMouseEnter", rn = "mouse";
          (a === "pointerout" || a === "pointerover") && (Be = D0, pt = "onPointerLeave", lt = "onPointerEnter", rn = "pointer");
          var Kt = G == null ? F : pp(G), X = ie == null ? F : pp(ie), fe = new Be(pt, rn + "leave", G, d, p);
          fe.target = Kt, fe.relatedTarget = X;
          var ee = null, Ee = sf(p);
          if (Ee === l) {
            var qe = new Be(lt, rn + "enter", ie, d, p);
            qe.target = X, qe.relatedTarget = Kt, ee = qe;
          }
          mL(t, fe, ee, G, ie);
        }
      }
    }
    function wt(t, a) {
      return t === a && (t !== 0 || 1 / t === 1 / a) || t !== t && a !== a;
    }
    var Ze = typeof Object.is == "function" ? Object.is : wt;
    function St(t, a) {
      if (Ze(t, a))
        return !0;
      if (typeof t != "object" || t === null || typeof a != "object" || a === null)
        return !1;
      var l = Object.keys(t), d = Object.keys(a);
      if (l.length !== d.length)
        return !1;
      for (var p = 0; p < l.length; p++) {
        var g = l[p];
        if (!ar.call(a, g) || !Ze(t[g], a[g]))
          return !1;
      }
      return !0;
    }
    function Vr(t) {
      for (; t && t.firstChild;)
        t = t.firstChild;
      return t;
    }
    function mn(t) {
      for (; t;) {
        if (t.nextSibling)
          return t.nextSibling;
        t = t.parentNode;
      }
    }
    function fs(t, a) {
      for (var l = Vr(t), d = 0, p = 0; l;) {
        if (l.nodeType === es) {
          if (p = d + l.textContent.length, d <= a && p >= a)
            return {
              node: l,
              offset: a - d
            };
          d = p;
        }
        l = Vr(mn(l));
      }
    }
    function gS(t) {
      var a = t.ownerDocument, l = a && a.defaultView || window, d = l.getSelection && l.getSelection();
      if (!d || d.rangeCount === 0)
        return null;
      var p = d.anchorNode, g = d.anchorOffset, S = d.focusNode, R = d.focusOffset;
      try {
        p.nodeType, S.nodeType;
      } catch {
        return null;
      }
      return G2(t, p, g, S, R);
    }
    function G2(t, a, l, d, p) {
      var g = 0, S = -1, R = -1, O = 0, L = 0, F = t, J = null;
      e: for (; ;) {
        for (var G = null; F === a && (l === 0 || F.nodeType === es) && (S = g + l), F === d && (p === 0 || F.nodeType === es) && (R = g + p), F.nodeType === es && (g += F.nodeValue.length), (G = F.firstChild) !== null;)
          J = F, F = G;
        for (; ;) {
          if (F === t)
            break e;
          if (J === a && ++O === l && (S = g), J === d && ++L === p && (R = g), (G = F.nextSibling) !== null)
            break;
          F = J, J = F.parentNode;
        }
        F = G;
      }
      return S === -1 || R === -1 ? null : {
        start: S,
        end: R
      };
    }
    function Q2(t, a) {
      var l = t.ownerDocument || document, d = l && l.defaultView || window;
      if (d.getSelection) {
        var p = d.getSelection(), g = t.textContent.length, S = Math.min(a.start, g), R = a.end === void 0 ? S : Math.min(a.end, g);
        if (!p.extend && S > R) {
          var O = R;
          R = S, S = O;
        }
        var L = fs(t, S), F = fs(t, R);
        if (L && F) {
          if (p.rangeCount === 1 && p.anchorNode === L.node && p.anchorOffset === L.offset && p.focusNode === F.node && p.focusOffset === F.offset)
            return;
          var J = l.createRange();
          J.setStart(L.node, L.offset), p.removeAllRanges(), S > R ? (p.addRange(J), p.extend(F.node, F.offset)) : (J.setEnd(F.node, F.offset), p.addRange(J));
        }
      }
    }
    function AT(t) {
      return t && t.nodeType === es;
    }
    function DT(t, a) {
      return !t || !a ? !1 : t === a ? !0 : AT(t) ? !1 : AT(a) ? DT(t, a.parentNode) : "contains" in t ? t.contains(a) : t.compareDocumentPosition ? !!(t.compareDocumentPosition(a) & 16) : !1;
    }
    function J2(t) {
      return t && t.ownerDocument && DT(t.ownerDocument.documentElement, t);
    }
    function Z2(t) {
      try {
        return typeof t.contentWindow.location.href == "string";
      } catch {
        return !1;
      }
    }
    function PT() {
      for (var t = window, a = Gs(); a instanceof t.HTMLIFrameElement;) {
        if (Z2(a))
          t = a.contentWindow;
        else
          return a;
        a = Gs(t.document);
      }
      return a;
    }
    function yS(t) {
      var a = t && t.nodeName && t.nodeName.toLowerCase();
      return a && (a === "input" && (t.type === "text" || t.type === "search" || t.type === "tel" || t.type === "url" || t.type === "password") || a === "textarea" || t.contentEditable === "true");
    }
    function X2() {
      var t = PT();
      return {
        focusedElem: t,
        selectionRange: yS(t) ? tL(t) : null
      };
    }
    function eL(t) {
      var a = PT(), l = t.focusedElem, d = t.selectionRange;
      if (a !== l && J2(l)) {
        d !== null && yS(l) && nL(l, d);
        for (var p = [], g = l; g = g.parentNode;)
          g.nodeType === Ga && p.push({
            element: g,
            left: g.scrollLeft,
            top: g.scrollTop
          });
        typeof l.focus == "function" && l.focus();
        for (var S = 0; S < p.length; S++) {
          var R = p[S];
          R.element.scrollLeft = R.left, R.element.scrollTop = R.top;
        }
      }
    }
    function tL(t) {
      var a;
      return "selectionStart" in t ? a = {
        start: t.selectionStart,
        end: t.selectionEnd
      } : a = gS(t), a || {
        start: 0,
        end: 0
      };
    }
    function nL(t, a) {
      var l = a.start, d = a.end;
      d === void 0 && (d = l), "selectionStart" in t ? (t.selectionStart = l, t.selectionEnd = Math.min(d, t.value.length)) : Q2(t, a);
    }
    var rL = cn && "documentMode" in document && document.documentMode <= 11;
    function aL() {
      zn("onSelect", ["focusout", "contextmenu", "dragend", "focusin", "keydown", "keyup", "mousedown", "mouseup", "selectionchange"]);
    }
    var up = null, bS = null, Iv = null, wS = !1;
    function iL(t) {
      if ("selectionStart" in t && yS(t))
        return {
          start: t.selectionStart,
          end: t.selectionEnd
        };
      var a = t.ownerDocument && t.ownerDocument.defaultView || window, l = a.getSelection();
      return {
        anchorNode: l.anchorNode,
        anchorOffset: l.anchorOffset,
        focusNode: l.focusNode,
        focusOffset: l.focusOffset
      };
    }
    function oL(t) {
      return t.window === t ? t.document : t.nodeType === lo ? t : t.ownerDocument;
    }
    function MT(t, a, l) {
      var d = oL(l);
      if (!(wS || up == null || up !== Gs(d))) {
        var p = iL(up);
        if (!Iv || !St(Iv, p)) {
          Iv = p;
          var g = z0(bS, "onSelect");
          if (g.length > 0) {
            var S = new Zh("onSelect", "select", null, a, l);
            t.push({
              event: S,
              listeners: g
            }), S.target = up;
          }
        }
      }
    }
    function sL(t, a, l, d, p, g, S) {
      var R = l ? pp(l) : window;
      switch (a) {
        case "focusin":
          (I0(R) || R.contentEditable === "true") && (up = R, bS = l, Iv = null);
          break;
        case "focusout":
          up = null, bS = null, Iv = null;
          break;
        case "mousedown":
          wS = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          wS = !1, MT(t, d, p);
          break;
        case "selectionchange":
          if (rL)
            break;
        case "keydown":
        case "keyup":
          MT(t, d, p);
      }
    }
    function U0(t, a) {
      var l = {};
      return l[t.toLowerCase()] = a.toLowerCase(), l["Webkit" + t] = "webkit" + a, l["Moz" + t] = "moz" + a, l;
    }
    var cp = {
      animationend: U0("Animation", "AnimationEnd"),
      animationiteration: U0("Animation", "AnimationIteration"),
      animationstart: U0("Animation", "AnimationStart"),
      transitionend: U0("Transition", "TransitionEnd")
    }, xS = {}, LT = {};
    cn && (LT = document.createElement("div").style, "AnimationEvent" in window || (delete cp.animationend.animation, delete cp.animationiteration.animation, delete cp.animationstart.animation), "TransitionEvent" in window || delete cp.transitionend.transition);
    function F0(t) {
      if (xS[t])
        return xS[t];
      if (!cp[t])
        return t;
      var a = cp[t];
      for (var l in a)
        if (a.hasOwnProperty(l) && l in LT)
          return xS[t] = a[l];
      return t;
    }
    var IT = F0("animationend"), UT = F0("animationiteration"), FT = F0("animationstart"), $T = F0("transitionend"), zT = /* @__PURE__ */ new Map(), BT = ["abort", "auxClick", "cancel", "canPlay", "canPlayThrough", "click", "close", "contextMenu", "copy", "cut", "drag", "dragEnd", "dragEnter", "dragExit", "dragLeave", "dragOver", "dragStart", "drop", "durationChange", "emptied", "encrypted", "ended", "error", "gotPointerCapture", "input", "invalid", "keyDown", "keyPress", "keyUp", "load", "loadedData", "loadedMetadata", "loadStart", "lostPointerCapture", "mouseDown", "mouseMove", "mouseOut", "mouseOver", "mouseUp", "paste", "pause", "play", "playing", "pointerCancel", "pointerDown", "pointerMove", "pointerOut", "pointerOver", "pointerUp", "progress", "rateChange", "reset", "resize", "seeked", "seeking", "stalled", "submit", "suspend", "timeUpdate", "touchCancel", "touchEnd", "touchStart", "volumeChange", "scroll", "toggle", "touchMove", "waiting", "wheel"];
    function Sc(t, a) {
      zT.set(t, a), zn(a, [t]);
    }
    function lL() {
      for (var t = 0; t < BT.length; t++) {
        var a = BT[t], l = a.toLowerCase(), d = a[0].toUpperCase() + a.slice(1);
        Sc(l, "on" + d);
      }
      Sc(IT, "onAnimationEnd"), Sc(UT, "onAnimationIteration"), Sc(FT, "onAnimationStart"), Sc("dblclick", "onDoubleClick"), Sc("focusin", "onFocus"), Sc("focusout", "onBlur"), Sc($T, "onTransitionEnd");
    }
    function uL(t, a, l, d, p, g, S) {
      var R = zT.get(a);
      if (R !== void 0) {
        var O = Zh, L = a;
        switch (a) {
          case "keypress":
            if (nu(d) === 0)
              return;
          case "keydown":
          case "keyup":
            O = j0;
            break;
          case "focusin":
            L = "focus", O = Zd;
            break;
          case "focusout":
            L = "blur", O = Zd;
            break;
          case "beforeblur":
          case "afterblur":
            O = Zd;
            break;
          case "click":
            if (d.button === 2)
              return;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            O = Xh;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            O = C0;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            O = jv;
            break;
          case IT:
          case UT:
          case FT:
            O = lS;
            break;
          case $T:
            O = cl;
            break;
          case "scroll":
            O = Rv;
            break;
          case "wheel":
            O = iu;
            break;
          case "copy":
          case "cut":
          case "paste":
            O = R0;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            O = D0;
            break;
        }
        var F = (g & Ul) !== 0;
        {
          var J = !F && // TODO: ideally, we'd eventually add all events from
            // nonDelegatedEvents list in DOMPluginEventSystem.
            // Then we can remove this special list.
            // This is a breaking change that can wait until React 18.
            a === "scroll", G = hL(l, R, d.type, F, J);
          if (G.length > 0) {
            var ie = new O(R, L, null, d, p);
            t.push({
              event: ie,
              listeners: G
            });
          }
        }
      }
    }
    lL(), je(), i(), aL(), ap();
    function cL(t, a, l, d, p, g, S) {
      uL(t, a, l, d, p, g);
      var R = (g & Gx) === 0;
      R && (at(t, a, l, d, p), ne(t, a, l, d, p), sL(t, a, l, d, p), vS(t, a, l, d, p));
    }
    var Uv = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "resize", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"], SS = new Set(["cancel", "close", "invalid", "load", "scroll", "toggle"].concat(Uv));
    function VT(t, a, l) {
      var d = t.type || "unknown-event";
      t.currentTarget = l, as(d, a, void 0, t), t.currentTarget = null;
    }
    function dL(t, a, l) {
      var d;
      if (l)
        for (var p = a.length - 1; p >= 0; p--) {
          var g = a[p], S = g.instance, R = g.currentTarget, O = g.listener;
          if (S !== d && t.isPropagationStopped())
            return;
          VT(t, O, R), d = S;
        }
      else
        for (var L = 0; L < a.length; L++) {
          var F = a[L], J = F.instance, G = F.currentTarget, ie = F.listener;
          if (J !== d && t.isPropagationStopped())
            return;
          VT(t, ie, G), d = J;
        }
    }
    function HT(t, a) {
      for (var l = (a & Ul) !== 0, d = 0; d < t.length; d++) {
        var p = t[d], g = p.event, S = p.listeners;
        dL(g, S, l);
      }
      tv();
    }
    function fL(t, a, l, d, p) {
      var g = oh(l), S = [];
      cL(S, t, d, l, g, a), HT(S, a);
    }
    function ur(t, a) {
      SS.has(t) || f('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.', t);
      var l = !1, d = BI(a), p = vL(t);
      d.has(p) || (WT(a, t, Td, l), d.add(p));
    }
    function _S(t, a, l) {
      SS.has(t) && !a && f('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.', t);
      var d = 0;
      a && (d |= Ul), WT(l, t, d, a);
    }
    var $0 = "_reactListening" + Math.random().toString(36).slice(2);
    function Fv(t) {
      if (!t[$0]) {
        t[$0] = !0, kt.forEach(function (l) {
          l !== "selectionchange" && (SS.has(l) || _S(l, !1, t), _S(l, !0, t));
        });
        var a = t.nodeType === lo ? t : t.ownerDocument;
        a !== null && (a[$0] || (a[$0] = !0, _S("selectionchange", !1, a)));
      }
    }
    function WT(t, a, l, d, p) {
      var g = zr(t, a, l), S = void 0;
      jd && (a === "touchstart" || a === "touchmove" || a === "wheel") && (S = !0), t = t, d ? S !== void 0 ? Gh(t, a, g, S) : cs(t, a, g) : S !== void 0 ? Tv(t, a, g, S) : yc(t, a, g);
    }
    function qT(t, a) {
      return t === a || t.nodeType === Ar && t.parentNode === a;
    }
    function ES(t, a, l, d, p) {
      var g = d;
      if (!(a & ns) && !(a & Td)) {
        var S = p;
        if (d !== null) {
          var R = d;
          e: for (; ;) {
            if (R === null)
              return;
            var O = R.tag;
            if (O === T || O === k) {
              var L = R.stateNode.containerInfo;
              if (qT(L, S))
                break;
              if (O === k)
                for (var F = R.return; F !== null;) {
                  var J = F.tag;
                  if (J === T || J === k) {
                    var G = F.stateNode.containerInfo;
                    if (qT(G, S))
                      return;
                  }
                  F = F.return;
                }
              for (; L !== null;) {
                var ie = sf(L);
                if (ie === null)
                  return;
                var le = ie.tag;
                if (le === C || le === M) {
                  R = g = ie;
                  continue e;
                }
                L = L.parentNode;
              }
            }
            R = R.return;
          }
        }
      }
      Jm(function () {
        return fL(t, a, l, g);
      });
    }
    function $v(t, a, l) {
      return {
        instance: t,
        listener: a,
        currentTarget: l
      };
    }
    function hL(t, a, l, d, p, g) {
      for (var S = a !== null ? a + "Capture" : null, R = d ? S : a, O = [], L = t, F = null; L !== null;) {
        var J = L, G = J.stateNode, ie = J.tag;
        if (ie === C && G !== null && (F = G, R !== null)) {
          var le = $l(L, R);
          le != null && O.push($v(L, le, F));
        }
        if (p)
          break;
        L = L.return;
      }
      return O;
    }
    function z0(t, a) {
      for (var l = a + "Capture", d = [], p = t; p !== null;) {
        var g = p, S = g.stateNode, R = g.tag;
        if (R === C && S !== null) {
          var O = S, L = $l(p, l);
          L != null && d.unshift($v(p, L, O));
          var F = $l(p, a);
          F != null && d.push($v(p, F, O));
        }
        p = p.return;
      }
      return d;
    }
    function dp(t) {
      if (t === null)
        return null;
      do
        t = t.return;
      while (t && t.tag !== C);
      return t || null;
    }
    function pL(t, a) {
      for (var l = t, d = a, p = 0, g = l; g; g = dp(g))
        p++;
      for (var S = 0, R = d; R; R = dp(R))
        S++;
      for (; p - S > 0;)
        l = dp(l), p--;
      for (; S - p > 0;)
        d = dp(d), S--;
      for (var O = p; O--;) {
        if (l === d || d !== null && l === d.alternate)
          return l;
        l = dp(l), d = dp(d);
      }
      return null;
    }
    function YT(t, a, l, d, p) {
      for (var g = a._reactName, S = [], R = l; R !== null && R !== d;) {
        var O = R, L = O.alternate, F = O.stateNode, J = O.tag;
        if (L !== null && L === d)
          break;
        if (J === C && F !== null) {
          var G = F;
          if (p) {
            var ie = $l(R, g);
            ie != null && S.unshift($v(R, ie, G));
          } else if (!p) {
            var le = $l(R, g);
            le != null && S.push($v(R, le, G));
          }
        }
        R = R.return;
      }
      S.length !== 0 && t.push({
        event: a,
        listeners: S
      });
    }
    function mL(t, a, l, d, p) {
      var g = d && p ? pL(d, p) : null;
      d !== null && YT(t, a, d, g, !1), p !== null && l !== null && YT(t, l, p, g, !0);
    }
    function vL(t, a) {
      return t + "__bubble";
    }
    var Gi = !1, zv = "dangerouslySetInnerHTML", B0 = "suppressContentEditableWarning", _c = "suppressHydrationWarning", KT = "autoFocus", af = "children", of = "style", V0 = "__html", CS, H0, Bv, GT, W0, QT, JT;
    CS = {
      // There are working polyfills for <dialog>. Let people use it.
      dialog: !0,
      // Electron ships a custom <webview> tag to display external web content in
      // an isolated frame and process.
      // This tag is not present in non Electron environments such as JSDom which
      // is often used for testing purposes.
      // @see https://electronjs.org/docs/api/webview-tag
      webview: !0
    }, H0 = function (t, a) {
      ih(t, a), qm(t, a), Gy(t, a, {
        registrationNameDependencies: Et,
        possibleRegistrationNames: an
      });
    }, QT = cn && !document.documentMode, Bv = function (t, a, l) {
      if (!Gi) {
        var d = q0(l), p = q0(a);
        p !== d && (Gi = !0, f("Prop `%s` did not match. Server: %s Client: %s", t, JSON.stringify(p), JSON.stringify(d)));
      }
    }, GT = function (t) {
      if (!Gi) {
        Gi = !0;
        var a = [];
        t.forEach(function (l) {
          a.push(l);
        }), f("Extra attributes from the server: %s", a);
      }
    }, W0 = function (t, a) {
      a === !1 ? f("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", t, t, t) : f("Expected `%s` listener to be a function, instead got a value of `%s` type.", t, typeof a);
    }, JT = function (t, a) {
      var l = t.namespaceURI === Xo ? t.ownerDocument.createElement(t.tagName) : t.ownerDocument.createElementNS(t.namespaceURI, t.tagName);
      return l.innerHTML = a, l.innerHTML;
    };
    var gL = /\r\n?/g, yL = /\u0000|\uFFFD/g;
    function q0(t) {
      aa(t);
      var a = typeof t == "string" ? t : "" + t;
      return a.replace(gL, `
`).replace(yL, "");
    }
    function Y0(t, a, l, d) {
      var p = q0(a), g = q0(t);
      if (g !== p && (d && (Gi || (Gi = !0, f('Text content did not match. Server: "%s" Client: "%s"', g, p))), l && we))
        throw new Error("Text content does not match server-rendered HTML.");
    }
    function ZT(t) {
      return t.nodeType === lo ? t : t.ownerDocument;
    }
    function bL() {
    }
    function K0(t) {
      t.onclick = bL;
    }
    function wL(t, a, l, d, p) {
      for (var g in d)
        if (d.hasOwnProperty(g)) {
          var S = d[g];
          if (g === of)
            S && Object.freeze(S), Fy(a, S);
          else if (g === zv) {
            var R = S ? S[V0] : void 0;
            R != null && ky(a, R);
          } else if (g === af)
            if (typeof S == "string") {
              var O = t !== "textarea" || S !== "";
              O && th(a, S);
            } else typeof S == "number" && th(a, "" + S);
          else g === B0 || g === _c || g === KT || (Et.hasOwnProperty(g) ? S != null && (typeof S != "function" && W0(g, S), g === "onScroll" && ur("scroll", a)) : S != null && Wn(a, g, S, p));
        }
    }
    function xL(t, a, l, d) {
      for (var p = 0; p < a.length; p += 2) {
        var g = a[p], S = a[p + 1];
        g === of ? Fy(t, S) : g === zv ? ky(t, S) : g === af ? th(t, S) : Wn(t, g, S, d);
      }
    }
    function SL(t, a, l, d) {
      var p, g = ZT(l), S, R = d;
      if (R === Xo && (R = Xf(t)), R === Xo) {
        if (p = ts(t, a), !p && t !== t.toLowerCase() && f("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", t), t === "script") {
          var O = g.createElement("div");
          O.innerHTML = "<script><\/script>";
          var L = O.firstChild;
          S = O.removeChild(L);
        } else if (typeof a.is == "string")
          S = g.createElement(t, {
            is: a.is
          });
        else if (S = g.createElement(t), t === "select") {
          var F = S;
          a.multiple ? F.multiple = !0 : a.size && (F.size = a.size);
        }
      } else
        S = g.createElementNS(R, t);
      return R === Xo && !p && Object.prototype.toString.call(S) === "[object HTMLUnknownElement]" && !ar.call(CS, t) && (CS[t] = !0, f("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", t)), S;
    }
    function _L(t, a) {
      return ZT(a).createTextNode(t);
    }
    function EL(t, a, l, d) {
      var p = ts(a, l);
      H0(a, l);
      var g;
      switch (a) {
        case "dialog":
          ur("cancel", t), ur("close", t), g = l;
          break;
        case "iframe":
        case "object":
        case "embed":
          ur("load", t), g = l;
          break;
        case "video":
        case "audio":
          for (var S = 0; S < Uv.length; S++)
            ur(Uv[S], t);
          g = l;
          break;
        case "source":
          ur("error", t), g = l;
          break;
        case "img":
        case "image":
        case "link":
          ur("error", t), ur("load", t), g = l;
          break;
        case "details":
          ur("toggle", t), g = l;
          break;
        case "input":
          V(t, l), g = j(t, l), ur("invalid", t);
          break;
        case "option":
          Rn(t, l), g = l;
          break;
        case "select":
          Sd(t, l), g = xd(t, l), ur("invalid", t);
          break;
        case "textarea":
          Cy(t, l), g = Im(t, l), ur("invalid", t);
          break;
        default:
          g = l;
      }
      switch (rh(a, g), wL(a, t, d, g, p), a) {
        case "input":
          Pi(t), Oe(t, l, !1);
          break;
        case "textarea":
          Pi(t), Ry(t);
          break;
        case "option":
          Mn(t, l);
          break;
        case "select":
          Mm(t, l);
          break;
        default:
          typeof g.onClick == "function" && K0(t);
          break;
      }
    }
    function CL(t, a, l, d, p) {
      H0(a, d);
      var g = null, S, R;
      switch (a) {
        case "input":
          S = j(t, l), R = j(t, d), g = [];
          break;
        case "select":
          S = xd(t, l), R = xd(t, d), g = [];
          break;
        case "textarea":
          S = Im(t, l), R = Im(t, d), g = [];
          break;
        default:
          S = l, R = d, typeof S.onClick != "function" && typeof R.onClick == "function" && K0(t);
          break;
      }
      rh(a, R);
      var O, L, F = null;
      for (O in S)
        if (!(R.hasOwnProperty(O) || !S.hasOwnProperty(O) || S[O] == null))
          if (O === of) {
            var J = S[O];
            for (L in J)
              J.hasOwnProperty(L) && (F || (F = {}), F[L] = "");
          } else O === zv || O === af || O === B0 || O === _c || O === KT || (Et.hasOwnProperty(O) ? g || (g = []) : (g = g || []).push(O, null));
      for (O in R) {
        var G = R[O], ie = S != null ? S[O] : void 0;
        if (!(!R.hasOwnProperty(O) || G === ie || G == null && ie == null))
          if (O === of)
            if (G && Object.freeze(G), ie) {
              for (L in ie)
                ie.hasOwnProperty(L) && (!G || !G.hasOwnProperty(L)) && (F || (F = {}), F[L] = "");
              for (L in G)
                G.hasOwnProperty(L) && ie[L] !== G[L] && (F || (F = {}), F[L] = G[L]);
            } else
              F || (g || (g = []), g.push(O, F)), F = G;
          else if (O === zv) {
            var le = G ? G[V0] : void 0, de = ie ? ie[V0] : void 0;
            le != null && de !== le && (g = g || []).push(O, le);
          } else O === af ? (typeof G == "string" || typeof G == "number") && (g = g || []).push(O, "" + G) : O === B0 || O === _c || (Et.hasOwnProperty(O) ? (G != null && (typeof G != "function" && W0(O, G), O === "onScroll" && ur("scroll", t)), !g && ie !== G && (g = [])) : (g = g || []).push(O, G));
      }
      return F && (Ed(F, R[of]), (g = g || []).push(of, F)), g;
    }
    function TL(t, a, l, d, p) {
      l === "input" && p.type === "radio" && p.name != null && oe(t, p);
      var g = ts(l, d), S = ts(l, p);
      switch (xL(t, a, g, S), l) {
        case "input":
          ce(t, p);
          break;
        case "textarea":
          Ty(t, p);
          break;
        case "select":
          Fx(t, p);
          break;
      }
    }
    function RL(t) {
      {
        var a = t.toLowerCase();
        return ah.hasOwnProperty(a) && ah[a] || null;
      }
    }
    function kL(t, a, l, d, p, g, S) {
      var R, O;
      switch (R = ts(a, l), H0(a, l), a) {
        case "dialog":
          ur("cancel", t), ur("close", t);
          break;
        case "iframe":
        case "object":
        case "embed":
          ur("load", t);
          break;
        case "video":
        case "audio":
          for (var L = 0; L < Uv.length; L++)
            ur(Uv[L], t);
          break;
        case "source":
          ur("error", t);
          break;
        case "img":
        case "image":
        case "link":
          ur("error", t), ur("load", t);
          break;
        case "details":
          ur("toggle", t);
          break;
        case "input":
          V(t, l), ur("invalid", t);
          break;
        case "option":
          Rn(t, l);
          break;
        case "select":
          Sd(t, l), ur("invalid", t);
          break;
        case "textarea":
          Cy(t, l), ur("invalid", t);
          break;
      }
      rh(a, l);
      {
        O = /* @__PURE__ */ new Set();
        for (var F = t.attributes, J = 0; J < F.length; J++) {
          var G = F[J].name.toLowerCase();
          switch (G) {
            case "value":
              break;
            case "checked":
              break;
            case "selected":
              break;
            default:
              O.add(F[J].name);
          }
        }
      }
      var ie = null;
      for (var le in l)
        if (l.hasOwnProperty(le)) {
          var de = l[le];
          if (le === af)
            typeof de == "string" ? t.textContent !== de && (l[_c] !== !0 && Y0(t.textContent, de, g, S), ie = [af, de]) : typeof de == "number" && t.textContent !== "" + de && (l[_c] !== !0 && Y0(t.textContent, de, g, S), ie = [af, "" + de]);
          else if (Et.hasOwnProperty(le))
            de != null && (typeof de != "function" && W0(le, de), le === "onScroll" && ur("scroll", t));
          else if (S && // Convince Flow we've calculated it (it's DEV-only in this method.)
            typeof R == "boolean") {
            var Be = void 0, pt = R && Pe ? null : Yr(le);
            if (l[_c] !== !0) {
              if (!(le === B0 || le === _c || // Controlled attributes are not validated
                // TODO: Only ignore them on controlled tags.
                le === "value" || le === "checked" || le === "selected")) {
                if (le === zv) {
                  var lt = t.innerHTML, rn = de ? de[V0] : void 0;
                  if (rn != null) {
                    var Kt = JT(t, rn);
                    Kt !== lt && Bv(le, lt, Kt);
                  }
                } else if (le === of) {
                  if (O.delete(le), QT) {
                    var X = Yx(de);
                    Be = t.getAttribute("style"), X !== Be && Bv(le, Be, X);
                  }
                } else if (R && !Pe)
                  O.delete(le.toLowerCase()), Be = Kr(t, le, de), de !== Be && Bv(le, Be, de);
                else if (!Hn(le, pt, R) && !dn(le, de, pt, R)) {
                  var fe = !1;
                  if (pt !== null)
                    O.delete(pt.attributeName), Be = fr(t, le, de, pt);
                  else {
                    var ee = d;
                    if (ee === Xo && (ee = Xf(a)), ee === Xo)
                      O.delete(le.toLowerCase());
                    else {
                      var Ee = RL(le);
                      Ee !== null && Ee !== le && (fe = !0, O.delete(Ee)), O.delete(le);
                    }
                    Be = Kr(t, le, de);
                  }
                  var qe = Pe;
                  !qe && de !== Be && !fe && Bv(le, Be, de);
                }
              }
            }
          }
        }
      switch (S && // $FlowFixMe - Should be inferred as not undefined.
      O.size > 0 && l[_c] !== !0 && GT(O), a) {
        case "input":
          Pi(t), Oe(t, l, !0);
          break;
        case "textarea":
          Pi(t), Ry(t);
          break;
        case "select":
        case "option":
          break;
        default:
          typeof l.onClick == "function" && K0(t);
          break;
      }
      return ie;
    }
    function OL(t, a, l) {
      var d = t.nodeValue !== a;
      return d;
    }
    function TS(t, a) {
      {
        if (Gi)
          return;
        Gi = !0, f("Did not expect server HTML to contain a <%s> in <%s>.", a.nodeName.toLowerCase(), t.nodeName.toLowerCase());
      }
    }
    function RS(t, a) {
      {
        if (Gi)
          return;
        Gi = !0, f('Did not expect server HTML to contain the text node "%s" in <%s>.', a.nodeValue, t.nodeName.toLowerCase());
      }
    }
    function kS(t, a, l) {
      {
        if (Gi)
          return;
        Gi = !0, f("Expected server HTML to contain a matching <%s> in <%s>.", a, t.nodeName.toLowerCase());
      }
    }
    function OS(t, a) {
      {
        if (a === "" || Gi)
          return;
        Gi = !0, f('Expected server HTML to contain a matching text node for "%s" in <%s>.', a, t.nodeName.toLowerCase());
      }
    }
    function NL(t, a, l) {
      switch (a) {
        case "input":
          bt(t, l);
          return;
        case "textarea":
          Um(t, l);
          return;
        case "select":
          $x(t, l);
          return;
      }
    }
    var Vv = function () {
    }, Hv = function () {
    };
    {
      var jL = ["address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp"], XT = [
        "applet",
        "caption",
        "html",
        "table",
        "td",
        "th",
        "marquee",
        "object",
        "template",
        // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
        // TODO: Distinguish by namespace here -- for <title>, including it here
        // errs on the side of fewer warnings
        "foreignObject",
        "desc",
        "title"
      ], AL = XT.concat(["button"]), DL = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"], eR = {
        current: null,
        formTag: null,
        aTagInScope: null,
        buttonTagInScope: null,
        nobrTagInScope: null,
        pTagInButtonScope: null,
        listItemTagAutoclosing: null,
        dlItemTagAutoclosing: null
      };
      Hv = function (t, a) {
        var l = Ft({}, t || eR), d = {
          tag: a
        };
        return XT.indexOf(a) !== -1 && (l.aTagInScope = null, l.buttonTagInScope = null, l.nobrTagInScope = null), AL.indexOf(a) !== -1 && (l.pTagInButtonScope = null), jL.indexOf(a) !== -1 && a !== "address" && a !== "div" && a !== "p" && (l.listItemTagAutoclosing = null, l.dlItemTagAutoclosing = null), l.current = d, a === "form" && (l.formTag = d), a === "a" && (l.aTagInScope = d), a === "button" && (l.buttonTagInScope = d), a === "nobr" && (l.nobrTagInScope = d), a === "p" && (l.pTagInButtonScope = d), a === "li" && (l.listItemTagAutoclosing = d), (a === "dd" || a === "dt") && (l.dlItemTagAutoclosing = d), l;
      };
      var PL = function (t, a) {
        switch (a) {
          case "select":
            return t === "option" || t === "optgroup" || t === "#text";
          case "optgroup":
            return t === "option" || t === "#text";
          case "option":
            return t === "#text";
          case "tr":
            return t === "th" || t === "td" || t === "style" || t === "script" || t === "template";
          case "tbody":
          case "thead":
          case "tfoot":
            return t === "tr" || t === "style" || t === "script" || t === "template";
          case "colgroup":
            return t === "col" || t === "template";
          case "table":
            return t === "caption" || t === "colgroup" || t === "tbody" || t === "tfoot" || t === "thead" || t === "style" || t === "script" || t === "template";
          case "head":
            return t === "base" || t === "basefont" || t === "bgsound" || t === "link" || t === "meta" || t === "title" || t === "noscript" || t === "noframes" || t === "style" || t === "script" || t === "template";
          case "html":
            return t === "head" || t === "body" || t === "frameset";
          case "frameset":
            return t === "frame";
          case "#document":
            return t === "html";
        }
        switch (t) {
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return a !== "h1" && a !== "h2" && a !== "h3" && a !== "h4" && a !== "h5" && a !== "h6";
          case "rp":
          case "rt":
            return DL.indexOf(a) === -1;
          case "body":
          case "caption":
          case "col":
          case "colgroup":
          case "frameset":
          case "frame":
          case "head":
          case "html":
          case "tbody":
          case "td":
          case "tfoot":
          case "th":
          case "thead":
          case "tr":
            return a == null;
        }
        return !0;
      }, ML = function (t, a) {
        switch (t) {
          case "address":
          case "article":
          case "aside":
          case "blockquote":
          case "center":
          case "details":
          case "dialog":
          case "dir":
          case "div":
          case "dl":
          case "fieldset":
          case "figcaption":
          case "figure":
          case "footer":
          case "header":
          case "hgroup":
          case "main":
          case "menu":
          case "nav":
          case "ol":
          case "p":
          case "section":
          case "summary":
          case "ul":
          case "pre":
          case "listing":
          case "table":
          case "hr":
          case "xmp":
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return a.pTagInButtonScope;
          case "form":
            return a.formTag || a.pTagInButtonScope;
          case "li":
            return a.listItemTagAutoclosing;
          case "dd":
          case "dt":
            return a.dlItemTagAutoclosing;
          case "button":
            return a.buttonTagInScope;
          case "a":
            return a.aTagInScope;
          case "nobr":
            return a.nobrTagInScope;
        }
        return null;
      }, tR = {};
      Vv = function (t, a, l) {
        l = l || eR;
        var d = l.current, p = d && d.tag;
        a != null && (t != null && f("validateDOMNesting: when childText is passed, childTag should be null"), t = "#text");
        var g = PL(t, p) ? null : d, S = g ? null : ML(t, l), R = g || S;
        if (R) {
          var O = R.tag, L = !!g + "|" + t + "|" + O;
          if (!tR[L]) {
            tR[L] = !0;
            var F = t, J = "";
            if (t === "#text" ? /\S/.test(a) ? F = "Text nodes" : (F = "Whitespace text nodes", J = " Make sure you don't have any extra whitespace between tags on each line of your source code.") : F = "<" + t + ">", g) {
              var G = "";
              O === "table" && t === "tr" && (G += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), f("validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s", F, O, J, G);
            } else
              f("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.", F, O);
          }
        }
      };
    }
    var G0 = "suppressHydrationWarning", Q0 = "$", J0 = "/$", Wv = "$?", qv = "$!", LL = "style", NS = null, jS = null;
    function IL(t) {
      var a, l, d = t.nodeType;
      switch (d) {
        case lo:
        case Ll: {
          a = d === lo ? "#document" : "#fragment";
          var p = t.documentElement;
          l = p ? p.namespaceURI : $m(null, "");
          break;
        }
        default: {
          var g = d === Ar ? t.parentNode : t, S = g.namespaceURI || null;
          a = g.tagName, l = $m(S, a);
          break;
        }
      }
      {
        var R = a.toLowerCase(), O = Hv(null, R);
        return {
          namespace: l,
          ancestorInfo: O
        };
      }
    }
    function UL(t, a, l) {
      {
        var d = t, p = $m(d.namespace, a), g = Hv(d.ancestorInfo, a);
        return {
          namespace: p,
          ancestorInfo: g
        };
      }
    }
    function GY(t) {
      return t;
    }
    function FL(t) {
      NS = vc(), jS = X2();
      var a = null;
      return ii(!1), a;
    }
    function $L(t) {
      eL(jS), ii(NS), NS = null, jS = null;
    }
    function zL(t, a, l, d, p) {
      var g;
      {
        var S = d;
        if (Vv(t, null, S.ancestorInfo), typeof a.children == "string" || typeof a.children == "number") {
          var R = "" + a.children, O = Hv(S.ancestorInfo, t);
          Vv(null, R, O);
        }
        g = S.namespace;
      }
      var L = SL(t, a, l, g);
      return Gv(p, L), FS(L, a), L;
    }
    function BL(t, a) {
      t.appendChild(a);
    }
    function VL(t, a, l, d, p) {
      switch (EL(t, a, l, d), a) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          return !!l.autoFocus;
        case "img":
          return !0;
        default:
          return !1;
      }
    }
    function HL(t, a, l, d, p, g) {
      {
        var S = g;
        if (typeof d.children != typeof l.children && (typeof d.children == "string" || typeof d.children == "number")) {
          var R = "" + d.children, O = Hv(S.ancestorInfo, a);
          Vv(null, R, O);
        }
      }
      return CL(t, a, l, d);
    }
    function AS(t, a) {
      return t === "textarea" || t === "noscript" || typeof a.children == "string" || typeof a.children == "number" || typeof a.dangerouslySetInnerHTML == "object" && a.dangerouslySetInnerHTML !== null && a.dangerouslySetInnerHTML.__html != null;
    }
    function WL(t, a, l, d) {
      {
        var p = l;
        Vv(null, t, p.ancestorInfo);
      }
      var g = _L(t, a);
      return Gv(d, g), g;
    }
    function qL() {
      var t = window.event;
      return t === void 0 ? jo : Kh(t.type);
    }
    var DS = typeof setTimeout == "function" ? setTimeout : void 0, YL = typeof clearTimeout == "function" ? clearTimeout : void 0, PS = -1, nR = typeof Promise == "function" ? Promise : void 0, KL = typeof queueMicrotask == "function" ? queueMicrotask : typeof nR < "u" ? function (t) {
      return nR.resolve(null).then(t).catch(GL);
    } : DS;
    function GL(t) {
      setTimeout(function () {
        throw t;
      });
    }
    function QL(t, a, l, d) {
      switch (a) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          l.autoFocus && t.focus();
          return;
        case "img": {
          l.src && (t.src = l.src);
          return;
        }
      }
    }
    function JL(t, a, l, d, p, g) {
      TL(t, a, l, d, p), FS(t, p);
    }
    function rR(t) {
      th(t, "");
    }
    function ZL(t, a, l) {
      t.nodeValue = l;
    }
    function XL(t, a) {
      t.appendChild(a);
    }
    function eI(t, a) {
      var l;
      t.nodeType === Ar ? (l = t.parentNode, l.insertBefore(a, t)) : (l = t, l.appendChild(a));
      var d = t._reactRootContainer;
      d == null && l.onclick === null && K0(l);
    }
    function tI(t, a, l) {
      t.insertBefore(a, l);
    }
    function nI(t, a, l) {
      t.nodeType === Ar ? t.parentNode.insertBefore(a, l) : t.insertBefore(a, l);
    }
    function rI(t, a) {
      t.removeChild(a);
    }
    function aI(t, a) {
      t.nodeType === Ar ? t.parentNode.removeChild(a) : t.removeChild(a);
    }
    function MS(t, a) {
      var l = a, d = 0;
      do {
        var p = l.nextSibling;
        if (t.removeChild(l), p && p.nodeType === Ar) {
          var g = p.data;
          if (g === J0)
            if (d === 0) {
              t.removeChild(p), vr(a);
              return;
            } else
              d--;
          else (g === Q0 || g === Wv || g === qv) && d++;
        }
        l = p;
      } while (l);
      vr(a);
    }
    function iI(t, a) {
      t.nodeType === Ar ? MS(t.parentNode, a) : t.nodeType === Ga && MS(t, a), vr(t);
    }
    function oI(t) {
      t = t;
      var a = t.style;
      typeof a.setProperty == "function" ? a.setProperty("display", "none", "important") : a.display = "none";
    }
    function sI(t) {
      t.nodeValue = "";
    }
    function lI(t, a) {
      t = t;
      var l = a[LL], d = l != null && l.hasOwnProperty("display") ? l.display : null;
      t.style.display = nh("display", d);
    }
    function uI(t, a) {
      t.nodeValue = a;
    }
    function cI(t) {
      t.nodeType === Ga ? t.textContent = "" : t.nodeType === lo && t.documentElement && t.removeChild(t.documentElement);
    }
    function dI(t, a, l) {
      return t.nodeType !== Ga || a.toLowerCase() !== t.nodeName.toLowerCase() ? null : t;
    }
    function fI(t, a) {
      return a === "" || t.nodeType !== es ? null : t;
    }
    function hI(t) {
      return t.nodeType !== Ar ? null : t;
    }
    function aR(t) {
      return t.data === Wv;
    }
    function LS(t) {
      return t.data === qv;
    }
    function pI(t) {
      var a = t.nextSibling && t.nextSibling.dataset, l, d, p;
      return a && (l = a.dgst, d = a.msg, p = a.stck), {
        message: d,
        digest: l,
        stack: p
      };
    }
    function mI(t, a) {
      t._reactRetry = a;
    }
    function Z0(t) {
      for (; t != null; t = t.nextSibling) {
        var a = t.nodeType;
        if (a === Ga || a === es)
          break;
        if (a === Ar) {
          var l = t.data;
          if (l === Q0 || l === qv || l === Wv)
            break;
          if (l === J0)
            return null;
        }
      }
      return t;
    }
    function Yv(t) {
      return Z0(t.nextSibling);
    }
    function vI(t) {
      return Z0(t.firstChild);
    }
    function gI(t) {
      return Z0(t.firstChild);
    }
    function yI(t) {
      return Z0(t.nextSibling);
    }
    function bI(t, a, l, d, p, g, S) {
      Gv(g, t), FS(t, l);
      var R;
      {
        var O = p;
        R = O.namespace;
      }
      var L = (g.mode & st) !== rt;
      return kL(t, a, l, R, d, L, S);
    }
    function wI(t, a, l, d) {
      return Gv(l, t), l.mode & st, OL(t, a);
    }
    function xI(t, a) {
      Gv(a, t);
    }
    function SI(t) {
      for (var a = t.nextSibling, l = 0; a;) {
        if (a.nodeType === Ar) {
          var d = a.data;
          if (d === J0) {
            if (l === 0)
              return Yv(a);
            l--;
          } else (d === Q0 || d === qv || d === Wv) && l++;
        }
        a = a.nextSibling;
      }
      return null;
    }
    function iR(t) {
      for (var a = t.previousSibling, l = 0; a;) {
        if (a.nodeType === Ar) {
          var d = a.data;
          if (d === Q0 || d === qv || d === Wv) {
            if (l === 0)
              return a;
            l--;
          } else d === J0 && l++;
        }
        a = a.previousSibling;
      }
      return null;
    }
    function _I(t) {
      vr(t);
    }
    function EI(t) {
      vr(t);
    }
    function CI(t) {
      return t !== "head" && t !== "body";
    }
    function TI(t, a, l, d) {
      var p = !0;
      Y0(a.nodeValue, l, d, p);
    }
    function RI(t, a, l, d, p, g) {
      if (a[G0] !== !0) {
        var S = !0;
        Y0(d.nodeValue, p, g, S);
      }
    }
    function kI(t, a) {
      a.nodeType === Ga ? TS(t, a) : a.nodeType === Ar || RS(t, a);
    }
    function OI(t, a) {
      {
        var l = t.parentNode;
        l !== null && (a.nodeType === Ga ? TS(l, a) : a.nodeType === Ar || RS(l, a));
      }
    }
    function NI(t, a, l, d, p) {
      (p || a[G0] !== !0) && (d.nodeType === Ga ? TS(l, d) : d.nodeType === Ar || RS(l, d));
    }
    function jI(t, a, l) {
      kS(t, a);
    }
    function AI(t, a) {
      OS(t, a);
    }
    function DI(t, a, l) {
      {
        var d = t.parentNode;
        d !== null && kS(d, a);
      }
    }
    function PI(t, a) {
      {
        var l = t.parentNode;
        l !== null && OS(l, a);
      }
    }
    function MI(t, a, l, d, p, g) {
      (g || a[G0] !== !0) && kS(l, d);
    }
    function LI(t, a, l, d, p) {
      (p || a[G0] !== !0) && OS(l, d);
    }
    function II(t) {
      f("An error occurred during hydration. The server HTML was replaced with client content in <%s>.", t.nodeName.toLowerCase());
    }
    function UI(t) {
      Fv(t);
    }
    var fp = Math.random().toString(36).slice(2), hp = "__reactFiber$" + fp, IS = "__reactProps$" + fp, Kv = "__reactContainer$" + fp, US = "__reactEvents$" + fp, FI = "__reactListeners$" + fp, $I = "__reactHandles$" + fp;
    function zI(t) {
      delete t[hp], delete t[IS], delete t[US], delete t[FI], delete t[$I];
    }
    function Gv(t, a) {
      a[hp] = t;
    }
    function X0(t, a) {
      a[Kv] = t;
    }
    function oR(t) {
      t[Kv] = null;
    }
    function Qv(t) {
      return !!t[Kv];
    }
    function sf(t) {
      var a = t[hp];
      if (a)
        return a;
      for (var l = t.parentNode; l;) {
        if (a = l[Kv] || l[hp], a) {
          var d = a.alternate;
          if (a.child !== null || d !== null && d.child !== null)
            for (var p = iR(t); p !== null;) {
              var g = p[hp];
              if (g)
                return g;
              p = iR(p);
            }
          return a;
        }
        t = l, l = t.parentNode;
      }
      return null;
    }
    function Ec(t) {
      var a = t[hp] || t[Kv];
      return a && (a.tag === C || a.tag === M || a.tag === K || a.tag === T) ? a : null;
    }
    function pp(t) {
      if (t.tag === C || t.tag === M)
        return t.stateNode;
      throw new Error("getNodeFromInstance: Invalid argument.");
    }
    function eb(t) {
      return t[IS] || null;
    }
    function FS(t, a) {
      t[IS] = a;
    }
    function BI(t) {
      var a = t[US];
      return a === void 0 && (a = t[US] = /* @__PURE__ */ new Set()), a;
    }
    var sR = {}, lR = r.ReactDebugCurrentFrame;
    function tb(t) {
      if (t) {
        var a = t._owner, l = To(t.type, t._source, a ? a.type : null);
        lR.setExtraStackFrame(l);
      } else
        lR.setExtraStackFrame(null);
    }
    function hs(t, a, l, d, p) {
      {
        var g = Function.call.bind(ar);
        for (var S in t)
          if (g(t, S)) {
            var R = void 0;
            try {
              if (typeof t[S] != "function") {
                var O = Error((d || "React class") + ": " + l + " type `" + S + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof t[S] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw O.name = "Invariant Violation", O;
              }
              R = t[S](a, S, d, l, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (L) {
              R = L;
            }
            R && !(R instanceof Error) && (tb(p), f("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", d || "React class", l, S, typeof R), tb(null)), R instanceof Error && !(R.message in sR) && (sR[R.message] = !0, tb(p), f("Failed %s type: %s", l, R.message), tb(null));
          }
      }
    }
    var $S = [], nb;
    nb = [];
    var ou = -1;
    function Cc(t) {
      return {
        current: t
      };
    }
    function oi(t, a) {
      if (ou < 0) {
        f("Unexpected pop.");
        return;
      }
      a !== nb[ou] && f("Unexpected Fiber popped."), t.current = $S[ou], $S[ou] = null, nb[ou] = null, ou--;
    }
    function si(t, a, l) {
      ou++, $S[ou] = t.current, nb[ou] = l, t.current = a;
    }
    var zS;
    zS = {};
    var ho = {};
    Object.freeze(ho);
    var su = Cc(ho), fl = Cc(!1), BS = ho;
    function mp(t, a, l) {
      return l && hl(a) ? BS : su.current;
    }
    function uR(t, a, l) {
      {
        var d = t.stateNode;
        d.__reactInternalMemoizedUnmaskedChildContext = a, d.__reactInternalMemoizedMaskedChildContext = l;
      }
    }
    function vp(t, a) {
      {
        var l = t.type, d = l.contextTypes;
        if (!d)
          return ho;
        var p = t.stateNode;
        if (p && p.__reactInternalMemoizedUnmaskedChildContext === a)
          return p.__reactInternalMemoizedMaskedChildContext;
        var g = {};
        for (var S in d)
          g[S] = a[S];
        {
          var R = Ot(t) || "Unknown";
          hs(d, g, "context", R);
        }
        return p && uR(t, a, g), g;
      }
    }
    function rb() {
      return fl.current;
    }
    function hl(t) {
      {
        var a = t.childContextTypes;
        return a != null;
      }
    }
    function ab(t) {
      oi(fl, t), oi(su, t);
    }
    function VS(t) {
      oi(fl, t), oi(su, t);
    }
    function cR(t, a, l) {
      {
        if (su.current !== ho)
          throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
        si(su, a, t), si(fl, l, t);
      }
    }
    function dR(t, a, l) {
      {
        var d = t.stateNode, p = a.childContextTypes;
        if (typeof d.getChildContext != "function") {
          {
            var g = Ot(t) || "Unknown";
            zS[g] || (zS[g] = !0, f("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", g, g));
          }
          return l;
        }
        var S = d.getChildContext();
        for (var R in S)
          if (!(R in p))
            throw new Error((Ot(t) || "Unknown") + '.getChildContext(): key "' + R + '" is not defined in childContextTypes.');
        {
          var O = Ot(t) || "Unknown";
          hs(p, S, "child context", O);
        }
        return Ft({}, l, S);
      }
    }
    function ib(t) {
      {
        var a = t.stateNode, l = a && a.__reactInternalMemoizedMergedChildContext || ho;
        return BS = su.current, si(su, l, t), si(fl, fl.current, t), !0;
      }
    }
    function fR(t, a, l) {
      {
        var d = t.stateNode;
        if (!d)
          throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
        if (l) {
          var p = dR(t, a, BS);
          d.__reactInternalMemoizedMergedChildContext = p, oi(fl, t), oi(su, t), si(su, p, t), si(fl, l, t);
        } else
          oi(fl, t), si(fl, l, t);
      }
    }
    function VI(t) {
      {
        if (!ov(t) || t.tag !== b)
          throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
        var a = t;
        do {
          switch (a.tag) {
            case T:
              return a.stateNode.context;
            case b: {
              var l = a.type;
              if (hl(l))
                return a.stateNode.__reactInternalMemoizedMergedChildContext;
              break;
            }
          }
          a = a.return;
        } while (a !== null);
        throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    var Tc = 0, ob = 1, lu = null, HS = !1, WS = !1;
    function hR(t) {
      lu === null ? lu = [t] : lu.push(t);
    }
    function HI(t) {
      HS = !0, hR(t);
    }
    function pR() {
      HS && Rc();
    }
    function Rc() {
      if (!WS && lu !== null) {
        WS = !0;
        var t = 0, a = Hi();
        try {
          var l = !0, d = lu;
          for (mr(_r); t < d.length; t++) {
            var p = d[t];
            do
              p = p(l);
            while (p !== null);
          }
          lu = null, HS = !1;
        } catch (g) {
          throw lu !== null && (lu = lu.slice(t + 1)), hh(mh, Rc), g;
        } finally {
          mr(a), WS = !1;
        }
      }
      return null;
    }
    var gp = [], yp = 0, sb = null, lb = 0, Mo = [], Lo = 0, lf = null, uu = 1, cu = "";
    function WI(t) {
      return cf(), (t.flags & rv) !== ht;
    }
    function qI(t) {
      return cf(), lb;
    }
    function YI() {
      var t = cu, a = uu, l = a & ~KI(a);
      return l.toString(32) + t;
    }
    function uf(t, a) {
      cf(), gp[yp++] = lb, gp[yp++] = sb, sb = t, lb = a;
    }
    function mR(t, a, l) {
      cf(), Mo[Lo++] = uu, Mo[Lo++] = cu, Mo[Lo++] = lf, lf = t;
      var d = uu, p = cu, g = ub(d) - 1, S = d & ~(1 << g), R = l + 1, O = ub(a) + g;
      if (O > 30) {
        var L = g - g % 5, F = (1 << L) - 1, J = (S & F).toString(32), G = S >> L, ie = g - L, le = ub(a) + ie, de = R << ie, Be = de | G, pt = J + p;
        uu = 1 << le | Be, cu = pt;
      } else {
        var lt = R << g, rn = lt | S, Kt = p;
        uu = 1 << O | rn, cu = Kt;
      }
    }
    function qS(t) {
      cf();
      var a = t.return;
      if (a !== null) {
        var l = 1, d = 0;
        uf(t, l), mR(t, l, d);
      }
    }
    function ub(t) {
      return 32 - Xu(t);
    }
    function KI(t) {
      return 1 << ub(t) - 1;
    }
    function YS(t) {
      for (; t === sb;)
        sb = gp[--yp], gp[yp] = null, lb = gp[--yp], gp[yp] = null;
      for (; t === lf;)
        lf = Mo[--Lo], Mo[Lo] = null, cu = Mo[--Lo], Mo[Lo] = null, uu = Mo[--Lo], Mo[Lo] = null;
    }
    function GI() {
      return cf(), lf !== null ? {
        id: uu,
        overflow: cu
      } : null;
    }
    function QI(t, a) {
      cf(), Mo[Lo++] = uu, Mo[Lo++] = cu, Mo[Lo++] = lf, uu = a.id, cu = a.overflow, lf = t;
    }
    function cf() {
      Ia() || f("Expected to be hydrating. This is a bug in React. Please file an issue.");
    }
    var La = null, Io = null, ps = !1, df = !1, kc = null;
    function JI() {
      ps && f("We should not be hydrating here. This is a bug in React. Please file a bug.");
    }
    function vR() {
      df = !0;
    }
    function ZI() {
      return df;
    }
    function XI(t) {
      var a = t.stateNode.containerInfo;
      return Io = gI(a), La = t, ps = !0, kc = null, df = !1, !0;
    }
    function eU(t, a, l) {
      return Io = yI(a), La = t, ps = !0, kc = null, df = !1, l !== null && QI(t, l), !0;
    }
    function gR(t, a) {
      switch (t.tag) {
        case T: {
          kI(t.stateNode.containerInfo, a);
          break;
        }
        case C: {
          var l = (t.mode & st) !== rt;
          NI(
            t.type,
            t.memoizedProps,
            t.stateNode,
            a,
            // TODO: Delete this argument when we remove the legacy root API.
            l
          );
          break;
        }
        case K: {
          var d = t.memoizedState;
          d.dehydrated !== null && OI(d.dehydrated, a);
          break;
        }
      }
    }
    function yR(t, a) {
      gR(t, a);
      var l = az();
      l.stateNode = a, l.return = t;
      var d = t.deletions;
      d === null ? (t.deletions = [l], t.flags |= bn) : d.push(l);
    }
    function KS(t, a) {
      {
        if (df)
          return;
        switch (t.tag) {
          case T: {
            var l = t.stateNode.containerInfo;
            switch (a.tag) {
              case C:
                var d = a.type;
                a.pendingProps, jI(l, d);
                break;
              case M:
                var p = a.pendingProps;
                AI(l, p);
                break;
            }
            break;
          }
          case C: {
            var g = t.type, S = t.memoizedProps, R = t.stateNode;
            switch (a.tag) {
              case C: {
                var O = a.type, L = a.pendingProps, F = (t.mode & st) !== rt;
                MI(
                  g,
                  S,
                  R,
                  O,
                  L,
                  // TODO: Delete this argument when we remove the legacy root API.
                  F
                );
                break;
              }
              case M: {
                var J = a.pendingProps, G = (t.mode & st) !== rt;
                LI(
                  g,
                  S,
                  R,
                  J,
                  // TODO: Delete this argument when we remove the legacy root API.
                  G
                );
                break;
              }
            }
            break;
          }
          case K: {
            var ie = t.memoizedState, le = ie.dehydrated;
            if (le !== null) switch (a.tag) {
              case C:
                var de = a.type;
                a.pendingProps, DI(le, de);
                break;
              case M:
                var Be = a.pendingProps;
                PI(le, Be);
                break;
            }
            break;
          }
          default:
            return;
        }
      }
    }
    function bR(t, a) {
      a.flags = a.flags & ~Ui | Yn, KS(t, a);
    }
    function wR(t, a) {
      switch (t.tag) {
        case C: {
          var l = t.type;
          t.pendingProps;
          var d = dI(a, l);
          return d !== null ? (t.stateNode = d, La = t, Io = vI(d), !0) : !1;
        }
        case M: {
          var p = t.pendingProps, g = fI(a, p);
          return g !== null ? (t.stateNode = g, La = t, Io = null, !0) : !1;
        }
        case K: {
          var S = hI(a);
          if (S !== null) {
            var R = {
              dehydrated: S,
              treeContext: GI(),
              retryLane: _a
            };
            t.memoizedState = R;
            var O = iz(S);
            return O.return = t, t.child = O, La = t, Io = null, !0;
          }
          return !1;
        }
        default:
          return !1;
      }
    }
    function GS(t) {
      return (t.mode & st) !== rt && (t.flags & Tt) === ht;
    }
    function QS(t) {
      throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
    }
    function JS(t) {
      if (ps) {
        var a = Io;
        if (!a) {
          GS(t) && (KS(La, t), QS()), bR(La, t), ps = !1, La = t;
          return;
        }
        var l = a;
        if (!wR(t, a)) {
          GS(t) && (KS(La, t), QS()), a = Yv(l);
          var d = La;
          if (!a || !wR(t, a)) {
            bR(La, t), ps = !1, La = t;
            return;
          }
          yR(d, l);
        }
      }
    }
    function tU(t, a, l) {
      var d = t.stateNode, p = !df, g = bI(d, t.type, t.memoizedProps, a, l, t, p);
      return t.updateQueue = g, g !== null;
    }
    function nU(t) {
      var a = t.stateNode, l = t.memoizedProps, d = wI(a, l, t);
      if (d) {
        var p = La;
        if (p !== null)
          switch (p.tag) {
            case T: {
              var g = p.stateNode.containerInfo, S = (p.mode & st) !== rt;
              TI(
                g,
                a,
                l,
                // TODO: Delete this argument when we remove the legacy root API.
                S
              );
              break;
            }
            case C: {
              var R = p.type, O = p.memoizedProps, L = p.stateNode, F = (p.mode & st) !== rt;
              RI(
                R,
                O,
                L,
                a,
                l,
                // TODO: Delete this argument when we remove the legacy root API.
                F
              );
              break;
            }
          }
      }
      return d;
    }
    function rU(t) {
      var a = t.memoizedState, l = a !== null ? a.dehydrated : null;
      if (!l)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      xI(l, t);
    }
    function aU(t) {
      var a = t.memoizedState, l = a !== null ? a.dehydrated : null;
      if (!l)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      return SI(l);
    }
    function xR(t) {
      for (var a = t.return; a !== null && a.tag !== C && a.tag !== T && a.tag !== K;)
        a = a.return;
      La = a;
    }
    function cb(t) {
      if (t !== La)
        return !1;
      if (!ps)
        return xR(t), ps = !0, !1;
      if (t.tag !== T && (t.tag !== C || CI(t.type) && !AS(t.type, t.memoizedProps))) {
        var a = Io;
        if (a)
          if (GS(t))
            SR(t), QS();
          else
            for (; a;)
              yR(t, a), a = Yv(a);
      }
      return xR(t), t.tag === K ? Io = aU(t) : Io = La ? Yv(t.stateNode) : null, !0;
    }
    function iU() {
      return ps && Io !== null;
    }
    function SR(t) {
      for (var a = Io; a;)
        gR(t, a), a = Yv(a);
    }
    function bp() {
      La = null, Io = null, ps = !1, df = !1;
    }
    function _R() {
      kc !== null && (vO(kc), kc = null);
    }
    function Ia() {
      return ps;
    }
    function ZS(t) {
      kc === null ? kc = [t] : kc.push(t);
    }
    var oU = r.ReactCurrentBatchConfig, sU = null;
    function lU() {
      return oU.transition;
    }
    var ms = {
      recordUnsafeLifecycleWarnings: function (t, a) {
      },
      flushPendingUnsafeLifecycleWarnings: function () {
      },
      recordLegacyContextWarning: function (t, a) {
      },
      flushLegacyContextWarning: function () {
      },
      discardPendingWarnings: function () {
      }
    };
    {
      var uU = function (t) {
        for (var a = null, l = t; l !== null;)
          l.mode & Bt && (a = l), l = l.return;
        return a;
      }, ff = function (t) {
        var a = [];
        return t.forEach(function (l) {
          a.push(l);
        }), a.sort().join(", ");
      }, Jv = [], Zv = [], Xv = [], eg = [], tg = [], ng = [], hf = /* @__PURE__ */ new Set();
      ms.recordUnsafeLifecycleWarnings = function (t, a) {
        hf.has(t.type) || (typeof a.componentWillMount == "function" && // Don't warn about react-lifecycles-compat polyfilled components.
          a.componentWillMount.__suppressDeprecationWarning !== !0 && Jv.push(t), t.mode & Bt && typeof a.UNSAFE_componentWillMount == "function" && Zv.push(t), typeof a.componentWillReceiveProps == "function" && a.componentWillReceiveProps.__suppressDeprecationWarning !== !0 && Xv.push(t), t.mode & Bt && typeof a.UNSAFE_componentWillReceiveProps == "function" && eg.push(t), typeof a.componentWillUpdate == "function" && a.componentWillUpdate.__suppressDeprecationWarning !== !0 && tg.push(t), t.mode & Bt && typeof a.UNSAFE_componentWillUpdate == "function" && ng.push(t));
      }, ms.flushPendingUnsafeLifecycleWarnings = function () {
        var t = /* @__PURE__ */ new Set();
        Jv.length > 0 && (Jv.forEach(function (G) {
          t.add(Ot(G) || "Component"), hf.add(G.type);
        }), Jv = []);
        var a = /* @__PURE__ */ new Set();
        Zv.length > 0 && (Zv.forEach(function (G) {
          a.add(Ot(G) || "Component"), hf.add(G.type);
        }), Zv = []);
        var l = /* @__PURE__ */ new Set();
        Xv.length > 0 && (Xv.forEach(function (G) {
          l.add(Ot(G) || "Component"), hf.add(G.type);
        }), Xv = []);
        var d = /* @__PURE__ */ new Set();
        eg.length > 0 && (eg.forEach(function (G) {
          d.add(Ot(G) || "Component"), hf.add(G.type);
        }), eg = []);
        var p = /* @__PURE__ */ new Set();
        tg.length > 0 && (tg.forEach(function (G) {
          p.add(Ot(G) || "Component"), hf.add(G.type);
        }), tg = []);
        var g = /* @__PURE__ */ new Set();
        if (ng.length > 0 && (ng.forEach(function (G) {
          g.add(Ot(G) || "Component"), hf.add(G.type);
        }), ng = []), a.size > 0) {
          var S = ff(a);
          f(`Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`, S);
        }
        if (d.size > 0) {
          var R = ff(d);
          f(`Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state

Please update the following components: %s`, R);
        }
        if (g.size > 0) {
          var O = ff(g);
          f(`Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`, O);
        }
        if (t.size > 0) {
          var L = ff(t);
          c(`componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, L);
        }
        if (l.size > 0) {
          var F = ff(l);
          c(`componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, F);
        }
        if (p.size > 0) {
          var J = ff(p);
          c(`componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, J);
        }
      };
      var db = /* @__PURE__ */ new Map(), ER = /* @__PURE__ */ new Set();
      ms.recordLegacyContextWarning = function (t, a) {
        var l = uU(t);
        if (l === null) {
          f("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
          return;
        }
        if (!ER.has(t.type)) {
          var d = db.get(l);
          (t.type.contextTypes != null || t.type.childContextTypes != null || a !== null && typeof a.getChildContext == "function") && (d === void 0 && (d = [], db.set(l, d)), d.push(t));
        }
      }, ms.flushLegacyContextWarning = function () {
        db.forEach(function (t, a) {
          if (t.length !== 0) {
            var l = t[0], d = /* @__PURE__ */ new Set();
            t.forEach(function (g) {
              d.add(Ot(g) || "Component"), ER.add(g.type);
            });
            var p = ff(d);
            try {
              _n(l), f(`Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://reactjs.org/link/legacy-context`, p);
            } finally {
              hr();
            }
          }
        });
      }, ms.discardPendingWarnings = function () {
        Jv = [], Zv = [], Xv = [], eg = [], tg = [], ng = [], db = /* @__PURE__ */ new Map();
      };
    }
    var XS, e_, t_, n_, r_, CR = function (t, a) {
    };
    XS = !1, e_ = !1, t_ = {}, n_ = {}, r_ = {}, CR = function (t, a) {
      if (!(t === null || typeof t != "object") && !(!t._store || t._store.validated || t.key != null)) {
        if (typeof t._store != "object")
          throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
        t._store.validated = !0;
        var l = Ot(a) || "Component";
        n_[l] || (n_[l] = !0, f('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.'));
      }
    };
    function cU(t) {
      return t.prototype && t.prototype.isReactComponent;
    }
    function rg(t, a, l) {
      var d = l.ref;
      if (d !== null && typeof d != "function" && typeof d != "object") {
        if ((t.mode & Bt || Ue) && // We warn in ReactElement.js if owner and self are equal for string refs
          // because these cannot be automatically converted to an arrow function
          // using a codemod. Therefore, we don't have to warn about string refs again.
          !(l._owner && l._self && l._owner.stateNode !== l._self) && // Will already throw with "Function components cannot have string refs"
          !(l._owner && l._owner.tag !== b) && // Will already warn with "Function components cannot be given refs"
          !(typeof l.type == "function" && !cU(l.type)) && // Will already throw with "Element ref was specified as a string (someStringRef) but no owner was set"
          l._owner) {
          var p = Ot(t) || "Component";
          t_[p] || (f('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', p, d), t_[p] = !0);
        }
        if (l._owner) {
          var g = l._owner, S;
          if (g) {
            var R = g;
            if (R.tag !== b)
              throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
            S = R.stateNode;
          }
          if (!S)
            throw new Error("Missing owner for string ref " + d + ". This error is likely caused by a bug in React. Please file an issue.");
          var O = S;
          wr(d, "ref");
          var L = "" + d;
          if (a !== null && a.ref !== null && typeof a.ref == "function" && a.ref._stringRef === L)
            return a.ref;
          var F = function (J) {
            var G = O.refs;
            J === null ? delete G[L] : G[L] = J;
          };
          return F._stringRef = L, F;
        } else {
          if (typeof d != "string")
            throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
          if (!l._owner)
            throw new Error("Element ref was specified as a string (" + d + `) but no owner was set. This could happen for one of the following reasons:
1. You may be adding a ref to a function component
2. You may be adding a ref to a component that was not created inside a component's render method
3. You have multiple copies of React loaded
See https://reactjs.org/link/refs-must-have-owner for more information.`);
        }
      }
      return d;
    }
    function fb(t, a) {
      var l = Object.prototype.toString.call(a);
      throw new Error("Objects are not valid as a React child (found: " + (l === "[object Object]" ? "object with keys {" + Object.keys(a).join(", ") + "}" : l) + "). If you meant to render a collection of children, use an array instead.");
    }
    function hb(t) {
      {
        var a = Ot(t) || "Component";
        if (r_[a])
          return;
        r_[a] = !0, f("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
      }
    }
    function TR(t) {
      var a = t._payload, l = t._init;
      return l(a);
    }
    function RR(t) {
      function a(X, fe) {
        if (t) {
          var ee = X.deletions;
          ee === null ? (X.deletions = [fe], X.flags |= bn) : ee.push(fe);
        }
      }
      function l(X, fe) {
        if (!t)
          return null;
        for (var ee = fe; ee !== null;)
          a(X, ee), ee = ee.sibling;
        return null;
      }
      function d(X, fe) {
        for (var ee = /* @__PURE__ */ new Map(), Ee = fe; Ee !== null;)
          Ee.key !== null ? ee.set(Ee.key, Ee) : ee.set(Ee.index, Ee), Ee = Ee.sibling;
        return ee;
      }
      function p(X, fe) {
        var ee = Sf(X, fe);
        return ee.index = 0, ee.sibling = null, ee;
      }
      function g(X, fe, ee) {
        if (X.index = ee, !t)
          return X.flags |= rv, fe;
        var Ee = X.alternate;
        if (Ee !== null) {
          var qe = Ee.index;
          return qe < fe ? (X.flags |= Yn, fe) : qe;
        } else
          return X.flags |= Yn, fe;
      }
      function S(X) {
        return t && X.alternate === null && (X.flags |= Yn), X;
      }
      function R(X, fe, ee, Ee) {
        if (fe === null || fe.tag !== M) {
          var qe = ZE(ee, X.mode, Ee);
          return qe.return = X, qe;
        } else {
          var Ve = p(fe, ee);
          return Ve.return = X, Ve;
        }
      }
      function O(X, fe, ee, Ee) {
        var qe = ee.type;
        if (qe === mi)
          return F(X, fe, ee.props.children, Ee, ee.key);
        if (fe !== null && (fe.elementType === qe || // Keep this check inline so it only runs on the false path:
          AO(fe, ee) || // Lazy types should reconcile their resolved type.
          // We need to do this after the Hot Reloading check above,
          // because hot reloading has different semantics than prod because
          // it doesn't resuspend. So we can't let the call below suspend.
          typeof qe == "object" && qe !== null && qe.$$typeof === yt && TR(qe) === fe.type)) {
          var Ve = p(fe, ee.props);
          return Ve.ref = rg(X, fe, ee), Ve.return = X, Ve._debugSource = ee._source, Ve._debugOwner = ee._owner, Ve;
        }
        var Ct = JE(ee, X.mode, Ee);
        return Ct.ref = rg(X, fe, ee), Ct.return = X, Ct;
      }
      function L(X, fe, ee, Ee) {
        if (fe === null || fe.tag !== k || fe.stateNode.containerInfo !== ee.containerInfo || fe.stateNode.implementation !== ee.implementation) {
          var qe = XE(ee, X.mode, Ee);
          return qe.return = X, qe;
        } else {
          var Ve = p(fe, ee.children || []);
          return Ve.return = X, Ve;
        }
      }
      function F(X, fe, ee, Ee, qe) {
        if (fe === null || fe.tag !== N) {
          var Ve = Fc(ee, X.mode, Ee, qe);
          return Ve.return = X, Ve;
        } else {
          var Ct = p(fe, ee);
          return Ct.return = X, Ct;
        }
      }
      function J(X, fe, ee) {
        if (typeof fe == "string" && fe !== "" || typeof fe == "number") {
          var Ee = ZE("" + fe, X.mode, ee);
          return Ee.return = X, Ee;
        }
        if (typeof fe == "object" && fe !== null) {
          switch (fe.$$typeof) {
            case Nr: {
              var qe = JE(fe, X.mode, ee);
              return qe.ref = rg(X, null, fe), qe.return = X, qe;
            }
            case Na: {
              var Ve = XE(fe, X.mode, ee);
              return Ve.return = X, Ve;
            }
            case yt: {
              var Ct = fe._payload, Dt = fe._init;
              return J(X, Dt(Ct), ee);
            }
          }
          if (Zt(fe) || ja(fe)) {
            var Nn = Fc(fe, X.mode, ee, null);
            return Nn.return = X, Nn;
          }
          fb(X, fe);
        }
        return typeof fe == "function" && hb(X), null;
      }
      function G(X, fe, ee, Ee) {
        var qe = fe !== null ? fe.key : null;
        if (typeof ee == "string" && ee !== "" || typeof ee == "number")
          return qe !== null ? null : R(X, fe, "" + ee, Ee);
        if (typeof ee == "object" && ee !== null) {
          switch (ee.$$typeof) {
            case Nr:
              return ee.key === qe ? O(X, fe, ee, Ee) : null;
            case Na:
              return ee.key === qe ? L(X, fe, ee, Ee) : null;
            case yt: {
              var Ve = ee._payload, Ct = ee._init;
              return G(X, fe, Ct(Ve), Ee);
            }
          }
          if (Zt(ee) || ja(ee))
            return qe !== null ? null : F(X, fe, ee, Ee, null);
          fb(X, ee);
        }
        return typeof ee == "function" && hb(X), null;
      }
      function ie(X, fe, ee, Ee, qe) {
        if (typeof Ee == "string" && Ee !== "" || typeof Ee == "number") {
          var Ve = X.get(ee) || null;
          return R(fe, Ve, "" + Ee, qe);
        }
        if (typeof Ee == "object" && Ee !== null) {
          switch (Ee.$$typeof) {
            case Nr: {
              var Ct = X.get(Ee.key === null ? ee : Ee.key) || null;
              return O(fe, Ct, Ee, qe);
            }
            case Na: {
              var Dt = X.get(Ee.key === null ? ee : Ee.key) || null;
              return L(fe, Dt, Ee, qe);
            }
            case yt:
              var Nn = Ee._payload, vn = Ee._init;
              return ie(X, fe, ee, vn(Nn), qe);
          }
          if (Zt(Ee) || ja(Ee)) {
            var Hr = X.get(ee) || null;
            return F(fe, Hr, Ee, qe, null);
          }
          fb(fe, Ee);
        }
        return typeof Ee == "function" && hb(fe), null;
      }
      function le(X, fe, ee) {
        {
          if (typeof X != "object" || X === null)
            return fe;
          switch (X.$$typeof) {
            case Nr:
            case Na:
              CR(X, ee);
              var Ee = X.key;
              if (typeof Ee != "string")
                break;
              if (fe === null) {
                fe = /* @__PURE__ */ new Set(), fe.add(Ee);
                break;
              }
              if (!fe.has(Ee)) {
                fe.add(Ee);
                break;
              }
              f("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted  the behavior is unsupported and could change in a future version.", Ee);
              break;
            case yt:
              var qe = X._payload, Ve = X._init;
              le(Ve(qe), fe, ee);
              break;
          }
        }
        return fe;
      }
      function de(X, fe, ee, Ee) {
        for (var qe = null, Ve = 0; Ve < ee.length; Ve++) {
          var Ct = ee[Ve];
          qe = le(Ct, qe, X);
        }
        for (var Dt = null, Nn = null, vn = fe, Hr = 0, gn = 0, Mr = null; vn !== null && gn < ee.length; gn++) {
          vn.index > gn ? (Mr = vn, vn = null) : Mr = vn.sibling;
          var ui = G(X, vn, ee[gn], Ee);
          if (ui === null) {
            vn === null && (vn = Mr);
            break;
          }
          t && vn && ui.alternate === null && a(X, vn), Hr = g(ui, Hr, gn), Nn === null ? Dt = ui : Nn.sibling = ui, Nn = ui, vn = Mr;
        }
        if (gn === ee.length) {
          if (l(X, vn), Ia()) {
            var Ha = gn;
            uf(X, Ha);
          }
          return Dt;
        }
        if (vn === null) {
          for (; gn < ee.length; gn++) {
            var mo = J(X, ee[gn], Ee);
            mo !== null && (Hr = g(mo, Hr, gn), Nn === null ? Dt = mo : Nn.sibling = mo, Nn = mo);
          }
          if (Ia()) {
            var Ci = gn;
            uf(X, Ci);
          }
          return Dt;
        }
        for (var Ti = d(X, vn); gn < ee.length; gn++) {
          var ci = ie(Ti, X, gn, ee[gn], Ee);
          ci !== null && (t && ci.alternate !== null && Ti.delete(ci.key === null ? gn : ci.key), Hr = g(ci, Hr, gn), Nn === null ? Dt = ci : Nn.sibling = ci, Nn = ci);
        }
        if (t && Ti.forEach(function (Up) {
          return a(X, Up);
        }), Ia()) {
          var gu = gn;
          uf(X, gu);
        }
        return Dt;
      }
      function Be(X, fe, ee, Ee) {
        var qe = ja(ee);
        if (typeof qe != "function")
          throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
        {
          typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
            ee[Symbol.toStringTag] === "Generator" && (e_ || f("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), e_ = !0), ee.entries === qe && (XS || f("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), XS = !0);
          var Ve = qe.call(ee);
          if (Ve)
            for (var Ct = null, Dt = Ve.next(); !Dt.done; Dt = Ve.next()) {
              var Nn = Dt.value;
              Ct = le(Nn, Ct, X);
            }
        }
        var vn = qe.call(ee);
        if (vn == null)
          throw new Error("An iterable object provided no iterator.");
        for (var Hr = null, gn = null, Mr = fe, ui = 0, Ha = 0, mo = null, Ci = vn.next(); Mr !== null && !Ci.done; Ha++, Ci = vn.next()) {
          Mr.index > Ha ? (mo = Mr, Mr = null) : mo = Mr.sibling;
          var Ti = G(X, Mr, Ci.value, Ee);
          if (Ti === null) {
            Mr === null && (Mr = mo);
            break;
          }
          t && Mr && Ti.alternate === null && a(X, Mr), ui = g(Ti, ui, Ha), gn === null ? Hr = Ti : gn.sibling = Ti, gn = Ti, Mr = mo;
        }
        if (Ci.done) {
          if (l(X, Mr), Ia()) {
            var ci = Ha;
            uf(X, ci);
          }
          return Hr;
        }
        if (Mr === null) {
          for (; !Ci.done; Ha++, Ci = vn.next()) {
            var gu = J(X, Ci.value, Ee);
            gu !== null && (ui = g(gu, ui, Ha), gn === null ? Hr = gu : gn.sibling = gu, gn = gu);
          }
          if (Ia()) {
            var Up = Ha;
            uf(X, Up);
          }
          return Hr;
        }
        for (var Mg = d(X, Mr); !Ci.done; Ha++, Ci = vn.next()) {
          var xl = ie(Mg, X, Ha, Ci.value, Ee);
          xl !== null && (t && xl.alternate !== null && Mg.delete(xl.key === null ? Ha : xl.key), ui = g(xl, ui, Ha), gn === null ? Hr = xl : gn.sibling = xl, gn = xl);
        }
        if (t && Mg.forEach(function (Lz) {
          return a(X, Lz);
        }), Ia()) {
          var Mz = Ha;
          uf(X, Mz);
        }
        return Hr;
      }
      function pt(X, fe, ee, Ee) {
        if (fe !== null && fe.tag === M) {
          l(X, fe.sibling);
          var qe = p(fe, ee);
          return qe.return = X, qe;
        }
        l(X, fe);
        var Ve = ZE(ee, X.mode, Ee);
        return Ve.return = X, Ve;
      }
      function lt(X, fe, ee, Ee) {
        for (var qe = ee.key, Ve = fe; Ve !== null;) {
          if (Ve.key === qe) {
            var Ct = ee.type;
            if (Ct === mi) {
              if (Ve.tag === N) {
                l(X, Ve.sibling);
                var Dt = p(Ve, ee.props.children);
                return Dt.return = X, Dt._debugSource = ee._source, Dt._debugOwner = ee._owner, Dt;
              }
            } else if (Ve.elementType === Ct || // Keep this check inline so it only runs on the false path:
              AO(Ve, ee) || // Lazy types should reconcile their resolved type.
              // We need to do this after the Hot Reloading check above,
              // because hot reloading has different semantics than prod because
              // it doesn't resuspend. So we can't let the call below suspend.
              typeof Ct == "object" && Ct !== null && Ct.$$typeof === yt && TR(Ct) === Ve.type) {
              l(X, Ve.sibling);
              var Nn = p(Ve, ee.props);
              return Nn.ref = rg(X, Ve, ee), Nn.return = X, Nn._debugSource = ee._source, Nn._debugOwner = ee._owner, Nn;
            }
            l(X, Ve);
            break;
          } else
            a(X, Ve);
          Ve = Ve.sibling;
        }
        if (ee.type === mi) {
          var vn = Fc(ee.props.children, X.mode, Ee, ee.key);
          return vn.return = X, vn;
        } else {
          var Hr = JE(ee, X.mode, Ee);
          return Hr.ref = rg(X, fe, ee), Hr.return = X, Hr;
        }
      }
      function rn(X, fe, ee, Ee) {
        for (var qe = ee.key, Ve = fe; Ve !== null;) {
          if (Ve.key === qe)
            if (Ve.tag === k && Ve.stateNode.containerInfo === ee.containerInfo && Ve.stateNode.implementation === ee.implementation) {
              l(X, Ve.sibling);
              var Ct = p(Ve, ee.children || []);
              return Ct.return = X, Ct;
            } else {
              l(X, Ve);
              break;
            }
          else
            a(X, Ve);
          Ve = Ve.sibling;
        }
        var Dt = XE(ee, X.mode, Ee);
        return Dt.return = X, Dt;
      }
      function Kt(X, fe, ee, Ee) {
        var qe = typeof ee == "object" && ee !== null && ee.type === mi && ee.key === null;
        if (qe && (ee = ee.props.children), typeof ee == "object" && ee !== null) {
          switch (ee.$$typeof) {
            case Nr:
              return S(lt(X, fe, ee, Ee));
            case Na:
              return S(rn(X, fe, ee, Ee));
            case yt:
              var Ve = ee._payload, Ct = ee._init;
              return Kt(X, fe, Ct(Ve), Ee);
          }
          if (Zt(ee))
            return de(X, fe, ee, Ee);
          if (ja(ee))
            return Be(X, fe, ee, Ee);
          fb(X, ee);
        }
        return typeof ee == "string" && ee !== "" || typeof ee == "number" ? S(pt(X, fe, "" + ee, Ee)) : (typeof ee == "function" && hb(X), l(X, fe));
      }
      return Kt;
    }
    var wp = RR(!0), kR = RR(!1);
    function dU(t, a) {
      if (t !== null && a.child !== t.child)
        throw new Error("Resuming work not yet implemented.");
      if (a.child !== null) {
        var l = a.child, d = Sf(l, l.pendingProps);
        for (a.child = d, d.return = a; l.sibling !== null;)
          l = l.sibling, d = d.sibling = Sf(l, l.pendingProps), d.return = a;
        d.sibling = null;
      }
    }
    function fU(t, a) {
      for (var l = t.child; l !== null;)
        X$(l, a), l = l.sibling;
    }
    var a_ = Cc(null), i_;
    i_ = {};
    var pb = null, xp = null, o_ = null, mb = !1;
    function vb() {
      pb = null, xp = null, o_ = null, mb = !1;
    }
    function OR() {
      mb = !0;
    }
    function NR() {
      mb = !1;
    }
    function jR(t, a, l) {
      si(a_, a._currentValue, t), a._currentValue = l, a._currentRenderer !== void 0 && a._currentRenderer !== null && a._currentRenderer !== i_ && f("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), a._currentRenderer = i_;
    }
    function s_(t, a) {
      var l = a_.current;
      oi(a_, a), t._currentValue = l;
    }
    function l_(t, a, l) {
      for (var d = t; d !== null;) {
        var p = d.alternate;
        if (Zl(d.childLanes, a) ? p !== null && !Zl(p.childLanes, a) && (p.childLanes = Pt(p.childLanes, a)) : (d.childLanes = Pt(d.childLanes, a), p !== null && (p.childLanes = Pt(p.childLanes, a))), d === l)
          break;
        d = d.return;
      }
      d !== l && f("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
    }
    function hU(t, a, l) {
      pU(t, a, l);
    }
    function pU(t, a, l) {
      var d = t.child;
      for (d !== null && (d.return = t); d !== null;) {
        var p = void 0, g = d.dependencies;
        if (g !== null) {
          p = d.child;
          for (var S = g.firstContext; S !== null;) {
            if (S.context === a) {
              if (d.tag === b) {
                var R = oc(l), O = du($n, R);
                O.tag = yb;
                var L = d.updateQueue;
                if (L !== null) {
                  var F = L.shared, J = F.pending;
                  J === null ? O.next = O : (O.next = J.next, J.next = O), F.pending = O;
                }
              }
              d.lanes = Pt(d.lanes, l);
              var G = d.alternate;
              G !== null && (G.lanes = Pt(G.lanes, l)), l_(d.return, l, t), g.lanes = Pt(g.lanes, l);
              break;
            }
            S = S.next;
          }
        } else if (d.tag === I)
          p = d.type === t.type ? null : d.child;
        else if (d.tag === ke) {
          var ie = d.return;
          if (ie === null)
            throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
          ie.lanes = Pt(ie.lanes, l);
          var le = ie.alternate;
          le !== null && (le.lanes = Pt(le.lanes, l)), l_(ie, l, t), p = d.sibling;
        } else
          p = d.child;
        if (p !== null)
          p.return = d;
        else
          for (p = d; p !== null;) {
            if (p === t) {
              p = null;
              break;
            }
            var de = p.sibling;
            if (de !== null) {
              de.return = p.return, p = de;
              break;
            }
            p = p.return;
          }
        d = p;
      }
    }
    function Sp(t, a) {
      pb = t, xp = null, o_ = null;
      var l = t.dependencies;
      if (l !== null) {
        var d = l.firstContext;
        d !== null && (ai(l.lanes, a) && yg(), l.firstContext = null);
      }
    }
    function na(t) {
      mb && f("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      var a = t._currentValue;
      if (o_ !== t) {
        var l = {
          context: t,
          memoizedValue: a,
          next: null
        };
        if (xp === null) {
          if (pb === null)
            throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          xp = l, pb.dependencies = {
            lanes: ye,
            firstContext: l
          };
        } else
          xp = xp.next = l;
      }
      return a;
    }
    var pf = null;
    function u_(t) {
      pf === null ? pf = [t] : pf.push(t);
    }
    function mU() {
      if (pf !== null) {
        for (var t = 0; t < pf.length; t++) {
          var a = pf[t], l = a.interleaved;
          if (l !== null) {
            a.interleaved = null;
            var d = l.next, p = a.pending;
            if (p !== null) {
              var g = p.next;
              p.next = d, l.next = g;
            }
            a.pending = l;
          }
        }
        pf = null;
      }
    }
    function AR(t, a, l, d) {
      var p = a.interleaved;
      return p === null ? (l.next = l, u_(a)) : (l.next = p.next, p.next = l), a.interleaved = l, gb(t, d);
    }
    function vU(t, a, l, d) {
      var p = a.interleaved;
      p === null ? (l.next = l, u_(a)) : (l.next = p.next, p.next = l), a.interleaved = l;
    }
    function gU(t, a, l, d) {
      var p = a.interleaved;
      return p === null ? (l.next = l, u_(a)) : (l.next = p.next, p.next = l), a.interleaved = l, gb(t, d);
    }
    function Qi(t, a) {
      return gb(t, a);
    }
    var yU = gb;
    function gb(t, a) {
      t.lanes = Pt(t.lanes, a);
      var l = t.alternate;
      l !== null && (l.lanes = Pt(l.lanes, a)), l === null && (t.flags & (Yn | Ui)) !== ht && kO(t);
      for (var d = t, p = t.return; p !== null;)
        p.childLanes = Pt(p.childLanes, a), l = p.alternate, l !== null ? l.childLanes = Pt(l.childLanes, a) : (p.flags & (Yn | Ui)) !== ht && kO(t), d = p, p = p.return;
      if (d.tag === T) {
        var g = d.stateNode;
        return g;
      } else
        return null;
    }
    var DR = 0, PR = 1, yb = 2, c_ = 3, bb = !1, d_, wb;
    d_ = !1, wb = null;
    function f_(t) {
      var a = {
        baseState: t.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
          pending: null,
          interleaved: null,
          lanes: ye
        },
        effects: null
      };
      t.updateQueue = a;
    }
    function MR(t, a) {
      var l = a.updateQueue, d = t.updateQueue;
      if (l === d) {
        var p = {
          baseState: d.baseState,
          firstBaseUpdate: d.firstBaseUpdate,
          lastBaseUpdate: d.lastBaseUpdate,
          shared: d.shared,
          effects: d.effects
        };
        a.updateQueue = p;
      }
    }
    function du(t, a) {
      var l = {
        eventTime: t,
        lane: a,
        tag: DR,
        payload: null,
        callback: null,
        next: null
      };
      return l;
    }
    function Oc(t, a, l) {
      var d = t.updateQueue;
      if (d === null)
        return null;
      var p = d.shared;
      if (wb === p && !d_ && (f("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback."), d_ = !0), v$()) {
        var g = p.pending;
        return g === null ? a.next = a : (a.next = g.next, g.next = a), p.pending = a, yU(t, l);
      } else
        return gU(t, p, a, l);
    }
    function xb(t, a, l) {
      var d = a.updateQueue;
      if (d !== null) {
        var p = d.shared;
        if (yv(l)) {
          var g = p.lanes;
          g = Fh(g, t.pendingLanes);
          var S = Pt(g, l);
          p.lanes = S, bv(t, S);
        }
      }
    }
    function h_(t, a) {
      var l = t.updateQueue, d = t.alternate;
      if (d !== null) {
        var p = d.updateQueue;
        if (l === p) {
          var g = null, S = null, R = l.firstBaseUpdate;
          if (R !== null) {
            var O = R;
            do {
              var L = {
                eventTime: O.eventTime,
                lane: O.lane,
                tag: O.tag,
                payload: O.payload,
                callback: O.callback,
                next: null
              };
              S === null ? g = S = L : (S.next = L, S = L), O = O.next;
            } while (O !== null);
            S === null ? g = S = a : (S.next = a, S = a);
          } else
            g = S = a;
          l = {
            baseState: p.baseState,
            firstBaseUpdate: g,
            lastBaseUpdate: S,
            shared: p.shared,
            effects: p.effects
          }, t.updateQueue = l;
          return;
        }
      }
      var F = l.lastBaseUpdate;
      F === null ? l.firstBaseUpdate = a : F.next = a, l.lastBaseUpdate = a;
    }
    function bU(t, a, l, d, p, g) {
      switch (l.tag) {
        case PR: {
          var S = l.payload;
          if (typeof S == "function") {
            OR();
            var R = S.call(g, d, p);
            {
              if (t.mode & Bt) {
                Dr(!0);
                try {
                  S.call(g, d, p);
                } finally {
                  Dr(!1);
                }
              }
              NR();
            }
            return R;
          }
          return S;
        }
        case c_:
          t.flags = t.flags & ~Zr | Tt;
        case DR: {
          var O = l.payload, L;
          if (typeof O == "function") {
            OR(), L = O.call(g, d, p);
            {
              if (t.mode & Bt) {
                Dr(!0);
                try {
                  O.call(g, d, p);
                } finally {
                  Dr(!1);
                }
              }
              NR();
            }
          } else
            L = O;
          return L == null ? d : Ft({}, d, L);
        }
        case yb:
          return bb = !0, d;
      }
      return d;
    }
    function Sb(t, a, l, d) {
      var p = t.updateQueue;
      bb = !1, wb = p.shared;
      var g = p.firstBaseUpdate, S = p.lastBaseUpdate, R = p.shared.pending;
      if (R !== null) {
        p.shared.pending = null;
        var O = R, L = O.next;
        O.next = null, S === null ? g = L : S.next = L, S = O;
        var F = t.alternate;
        if (F !== null) {
          var J = F.updateQueue, G = J.lastBaseUpdate;
          G !== S && (G === null ? J.firstBaseUpdate = L : G.next = L, J.lastBaseUpdate = O);
        }
      }
      if (g !== null) {
        var ie = p.baseState, le = ye, de = null, Be = null, pt = null, lt = g;
        do {
          var rn = lt.lane, Kt = lt.eventTime;
          if (Zl(d, rn)) {
            if (pt !== null) {
              var fe = {
                eventTime: Kt,
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: Pr,
                tag: lt.tag,
                payload: lt.payload,
                callback: lt.callback,
                next: null
              };
              pt = pt.next = fe;
            }
            ie = bU(t, p, lt, ie, a, l);
            var ee = lt.callback;
            if (ee !== null && // If the update was already committed, we should not queue its
              // callback again.
              lt.lane !== Pr) {
              t.flags |= Oo;
              var Ee = p.effects;
              Ee === null ? p.effects = [lt] : Ee.push(lt);
            }
          } else {
            var X = {
              eventTime: Kt,
              lane: rn,
              tag: lt.tag,
              payload: lt.payload,
              callback: lt.callback,
              next: null
            };
            pt === null ? (Be = pt = X, de = ie) : pt = pt.next = X, le = Pt(le, rn);
          }
          if (lt = lt.next, lt === null) {
            if (R = p.shared.pending, R === null)
              break;
            var qe = R, Ve = qe.next;
            qe.next = null, lt = Ve, p.lastBaseUpdate = qe, p.shared.pending = null;
          }
        } while (!0);
        pt === null && (de = ie), p.baseState = de, p.firstBaseUpdate = Be, p.lastBaseUpdate = pt;
        var Ct = p.shared.interleaved;
        if (Ct !== null) {
          var Dt = Ct;
          do
            le = Pt(le, Dt.lane), Dt = Dt.next;
          while (Dt !== Ct);
        } else g === null && (p.shared.lanes = ye);
        Ng(le), t.lanes = le, t.memoizedState = ie;
      }
      wb = null;
    }
    function wU(t, a) {
      if (typeof t != "function")
        throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + t));
      t.call(a);
    }
    function LR() {
      bb = !1;
    }
    function _b() {
      return bb;
    }
    function IR(t, a, l) {
      var d = a.effects;
      if (a.effects = null, d !== null)
        for (var p = 0; p < d.length; p++) {
          var g = d[p], S = g.callback;
          S !== null && (g.callback = null, wU(S, l));
        }
    }
    var ag = {}, Nc = Cc(ag), ig = Cc(ag), Eb = Cc(ag);
    function Cb(t) {
      if (t === ag)
        throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
      return t;
    }
    function UR() {
      var t = Cb(Eb.current);
      return t;
    }
    function p_(t, a) {
      si(Eb, a, t), si(ig, t, t), si(Nc, ag, t);
      var l = IL(a);
      oi(Nc, t), si(Nc, l, t);
    }
    function _p(t) {
      oi(Nc, t), oi(ig, t), oi(Eb, t);
    }
    function m_() {
      var t = Cb(Nc.current);
      return t;
    }
    function FR(t) {
      Cb(Eb.current);
      var a = Cb(Nc.current), l = UL(a, t.type);
      a !== l && (si(ig, t, t), si(Nc, l, t));
    }
    function v_(t) {
      ig.current === t && (oi(Nc, t), oi(ig, t));
    }
    var xU = 0, $R = 1, zR = 1, og = 2, vs = Cc(xU);
    function g_(t, a) {
      return (t & a) !== 0;
    }
    function Ep(t) {
      return t & $R;
    }
    function y_(t, a) {
      return t & $R | a;
    }
    function SU(t, a) {
      return t | a;
    }
    function jc(t, a) {
      si(vs, a, t);
    }
    function Cp(t) {
      oi(vs, t);
    }
    function _U(t, a) {
      var l = t.memoizedState;
      return l !== null ? l.dehydrated !== null : (t.memoizedProps, !0);
    }
    function Tb(t) {
      for (var a = t; a !== null;) {
        if (a.tag === K) {
          var l = a.memoizedState;
          if (l !== null) {
            var d = l.dehydrated;
            if (d === null || aR(d) || LS(d))
              return a;
          }
        } else if (a.tag === Ie && // revealOrder undefined can't be trusted because it don't
          // keep track of whether it suspended or not.
          a.memoizedProps.revealOrder !== void 0) {
          var p = (a.flags & Tt) !== ht;
          if (p)
            return a;
        } else if (a.child !== null) {
          a.child.return = a, a = a.child;
          continue;
        }
        if (a === t)
          return null;
        for (; a.sibling === null;) {
          if (a.return === null || a.return === t)
            return null;
          a = a.return;
        }
        a.sibling.return = a.return, a = a.sibling;
      }
      return null;
    }
    var Ji = (
      /*   */
      0
    ), ua = (
      /* */
      1
    ), pl = (
      /*  */
      2
    ), ca = (
      /*    */
      4
    ), Ua = (
      /*   */
      8
    ), b_ = [];
    function w_() {
      for (var t = 0; t < b_.length; t++) {
        var a = b_[t];
        a._workInProgressVersionPrimary = null;
      }
      b_.length = 0;
    }
    function EU(t, a) {
      var l = a._getVersion, d = l(a._source);
      t.mutableSourceEagerHydrationData == null ? t.mutableSourceEagerHydrationData = [a, d] : t.mutableSourceEagerHydrationData.push(a, d);
    }
    var We = r.ReactCurrentDispatcher, sg = r.ReactCurrentBatchConfig, x_, Tp;
    x_ = /* @__PURE__ */ new Set();
    var mf = ye, On = null, da = null, fa = null, Rb = !1, lg = !1, ug = 0, CU = 0, TU = 25, pe = null, Uo = null, Ac = -1, S_ = !1;
    function Cn() {
      {
        var t = pe;
        Uo === null ? Uo = [t] : Uo.push(t);
      }
    }
    function $e() {
      {
        var t = pe;
        Uo !== null && (Ac++, Uo[Ac] !== t && RU(t));
      }
    }
    function Rp(t) {
      t != null && !Zt(t) && f("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", pe, typeof t);
    }
    function RU(t) {
      {
        var a = Ot(On);
        if (!x_.has(a) && (x_.add(a), Uo !== null)) {
          for (var l = "", d = 30, p = 0; p <= Ac; p++) {
            for (var g = Uo[p], S = p === Ac ? t : g, R = p + 1 + ". " + g; R.length < d;)
              R += " ";
            R += S + `
`, l += R;
          }
          f(`React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`, a, l);
        }
      }
    }
    function li() {
      throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
    }
    function __(t, a) {
      if (S_)
        return !1;
      if (a === null)
        return f("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", pe), !1;
      t.length !== a.length && f(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, pe, "[" + a.join(", ") + "]", "[" + t.join(", ") + "]");
      for (var l = 0; l < a.length && l < t.length; l++)
        if (!Ze(t[l], a[l]))
          return !1;
      return !0;
    }
    function kp(t, a, l, d, p, g) {
      mf = g, On = a, Uo = t !== null ? t._debugHookTypes : null, Ac = -1, S_ = t !== null && t.type !== a.type, a.memoizedState = null, a.updateQueue = null, a.lanes = ye, t !== null && t.memoizedState !== null ? We.current = uk : Uo !== null ? We.current = lk : We.current = sk;
      var S = l(d, p);
      if (lg) {
        var R = 0;
        do {
          if (lg = !1, ug = 0, R >= TU)
            throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
          R += 1, S_ = !1, da = null, fa = null, a.updateQueue = null, Ac = -1, We.current = ck, S = l(d, p);
        } while (lg);
      }
      We.current = $b, a._debugHookTypes = Uo;
      var O = da !== null && da.next !== null;
      if (mf = ye, On = null, da = null, fa = null, pe = null, Uo = null, Ac = -1, t !== null && (t.flags & oa) !== (a.flags & oa) && // Disable this warning in legacy mode, because legacy Suspense is weird
        // and creates false positives. To make this work in legacy mode, we'd
        // need to mark fibers that commit in an incomplete state, somehow. For
        // now I'll disable the warning that most of the bugs that would trigger
        // it are either exclusive to concurrent mode or exist in both.
        (t.mode & st) !== rt && f("Internal React error: Expected static flag was missing. Please notify the React team."), Rb = !1, O)
        throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
      return S;
    }
    function Op() {
      var t = ug !== 0;
      return ug = 0, t;
    }
    function BR(t, a, l) {
      a.updateQueue = t.updateQueue, (a.mode & wi) !== rt ? a.flags &= ~(Vl | Za | er | Mt) : a.flags &= ~(er | Mt), t.lanes = Wd(t.lanes, l);
    }
    function VR() {
      if (We.current = $b, Rb) {
        for (var t = On.memoizedState; t !== null;) {
          var a = t.queue;
          a !== null && (a.pending = null), t = t.next;
        }
        Rb = !1;
      }
      mf = ye, On = null, da = null, fa = null, Uo = null, Ac = -1, pe = null, nk = !1, lg = !1, ug = 0;
    }
    function ml() {
      var t = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      return fa === null ? On.memoizedState = fa = t : fa = fa.next = t, fa;
    }
    function Fo() {
      var t;
      if (da === null) {
        var a = On.alternate;
        a !== null ? t = a.memoizedState : t = null;
      } else
        t = da.next;
      var l;
      if (fa === null ? l = On.memoizedState : l = fa.next, l !== null)
        fa = l, l = fa.next, da = t;
      else {
        if (t === null)
          throw new Error("Rendered more hooks than during the previous render.");
        da = t;
        var d = {
          memoizedState: da.memoizedState,
          baseState: da.baseState,
          baseQueue: da.baseQueue,
          queue: da.queue,
          next: null
        };
        fa === null ? On.memoizedState = fa = d : fa = fa.next = d;
      }
      return fa;
    }
    function HR() {
      return {
        lastEffect: null,
        stores: null
      };
    }
    function E_(t, a) {
      return typeof a == "function" ? a(t) : a;
    }
    function C_(t, a, l) {
      var d = ml(), p;
      l !== void 0 ? p = l(a) : p = a, d.memoizedState = d.baseState = p;
      var g = {
        pending: null,
        interleaved: null,
        lanes: ye,
        dispatch: null,
        lastRenderedReducer: t,
        lastRenderedState: p
      };
      d.queue = g;
      var S = g.dispatch = jU.bind(null, On, g);
      return [d.memoizedState, S];
    }
    function T_(t, a, l) {
      var d = Fo(), p = d.queue;
      if (p === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      p.lastRenderedReducer = t;
      var g = da, S = g.baseQueue, R = p.pending;
      if (R !== null) {
        if (S !== null) {
          var O = S.next, L = R.next;
          S.next = L, R.next = O;
        }
        g.baseQueue !== S && f("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."), g.baseQueue = S = R, p.pending = null;
      }
      if (S !== null) {
        var F = S.next, J = g.baseState, G = null, ie = null, le = null, de = F;
        do {
          var Be = de.lane;
          if (Zl(mf, Be)) {
            if (le !== null) {
              var lt = {
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: Pr,
                action: de.action,
                hasEagerState: de.hasEagerState,
                eagerState: de.eagerState,
                next: null
              };
              le = le.next = lt;
            }
            if (de.hasEagerState)
              J = de.eagerState;
            else {
              var rn = de.action;
              J = t(J, rn);
            }
          } else {
            var pt = {
              lane: Be,
              action: de.action,
              hasEagerState: de.hasEagerState,
              eagerState: de.eagerState,
              next: null
            };
            le === null ? (ie = le = pt, G = J) : le = le.next = pt, On.lanes = Pt(On.lanes, Be), Ng(Be);
          }
          de = de.next;
        } while (de !== null && de !== F);
        le === null ? G = J : le.next = ie, Ze(J, d.memoizedState) || yg(), d.memoizedState = J, d.baseState = G, d.baseQueue = le, p.lastRenderedState = J;
      }
      var Kt = p.interleaved;
      if (Kt !== null) {
        var X = Kt;
        do {
          var fe = X.lane;
          On.lanes = Pt(On.lanes, fe), Ng(fe), X = X.next;
        } while (X !== Kt);
      } else S === null && (p.lanes = ye);
      var ee = p.dispatch;
      return [d.memoizedState, ee];
    }
    function R_(t, a, l) {
      var d = Fo(), p = d.queue;
      if (p === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      p.lastRenderedReducer = t;
      var g = p.dispatch, S = p.pending, R = d.memoizedState;
      if (S !== null) {
        p.pending = null;
        var O = S.next, L = O;
        do {
          var F = L.action;
          R = t(R, F), L = L.next;
        } while (L !== O);
        Ze(R, d.memoizedState) || yg(), d.memoizedState = R, d.baseQueue === null && (d.baseState = R), p.lastRenderedState = R;
      }
      return [R, g];
    }
    function QY(t, a, l) {
    }
    function JY(t, a, l) {
    }
    function k_(t, a, l) {
      var d = On, p = ml(), g, S = Ia();
      if (S) {
        if (l === void 0)
          throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        g = l(), Tp || g !== l() && (f("The result of getServerSnapshot should be cached to avoid an infinite loop"), Tp = !0);
      } else {
        if (g = a(), !Tp) {
          var R = a();
          Ze(g, R) || (f("The result of getSnapshot should be cached to avoid an infinite loop"), Tp = !0);
        }
        var O = iw();
        if (O === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        Hd(O, mf) || WR(d, a, g);
      }
      p.memoizedState = g;
      var L = {
        value: g,
        getSnapshot: a
      };
      return p.queue = L, Ab(YR.bind(null, d, L, t), [t]), d.flags |= er, cg(ua | Ua, qR.bind(null, d, L, g, a), void 0, null), g;
    }
    function kb(t, a, l) {
      var d = On, p = Fo(), g = a();
      if (!Tp) {
        var S = a();
        Ze(g, S) || (f("The result of getSnapshot should be cached to avoid an infinite loop"), Tp = !0);
      }
      var R = p.memoizedState, O = !Ze(R, g);
      O && (p.memoizedState = g, yg());
      var L = p.queue;
      if (fg(YR.bind(null, d, L, t), [t]), L.getSnapshot !== a || O || // Check if the susbcribe function changed. We can save some memory by
        // checking whether we scheduled a subscription effect above.
        fa !== null && fa.memoizedState.tag & ua) {
        d.flags |= er, cg(ua | Ua, qR.bind(null, d, L, g, a), void 0, null);
        var F = iw();
        if (F === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        Hd(F, mf) || WR(d, a, g);
      }
      return g;
    }
    function WR(t, a, l) {
      t.flags |= Pd;
      var d = {
        getSnapshot: a,
        value: l
      }, p = On.updateQueue;
      if (p === null)
        p = HR(), On.updateQueue = p, p.stores = [d];
      else {
        var g = p.stores;
        g === null ? p.stores = [d] : g.push(d);
      }
    }
    function qR(t, a, l, d) {
      a.value = l, a.getSnapshot = d, KR(a) && GR(t);
    }
    function YR(t, a, l) {
      var d = function () {
        KR(a) && GR(t);
      };
      return l(d);
    }
    function KR(t) {
      var a = t.getSnapshot, l = t.value;
      try {
        var d = a();
        return !Ze(l, d);
      } catch {
        return !0;
      }
    }
    function GR(t) {
      var a = Qi(t, ft);
      a !== null && va(a, t, ft, $n);
    }
    function Ob(t) {
      var a = ml();
      typeof t == "function" && (t = t()), a.memoizedState = a.baseState = t;
      var l = {
        pending: null,
        interleaved: null,
        lanes: ye,
        dispatch: null,
        lastRenderedReducer: E_,
        lastRenderedState: t
      };
      a.queue = l;
      var d = l.dispatch = AU.bind(null, On, l);
      return [a.memoizedState, d];
    }
    function O_(t) {
      return T_(E_);
    }
    function N_(t) {
      return R_(E_);
    }
    function cg(t, a, l, d) {
      var p = {
        tag: t,
        create: a,
        destroy: l,
        deps: d,
        // Circular
        next: null
      }, g = On.updateQueue;
      if (g === null)
        g = HR(), On.updateQueue = g, g.lastEffect = p.next = p;
      else {
        var S = g.lastEffect;
        if (S === null)
          g.lastEffect = p.next = p;
        else {
          var R = S.next;
          S.next = p, p.next = R, g.lastEffect = p;
        }
      }
      return p;
    }
    function j_(t) {
      var a = ml();
      {
        var l = {
          current: t
        };
        return a.memoizedState = l, l;
      }
    }
    function Nb(t) {
      var a = Fo();
      return a.memoizedState;
    }
    function dg(t, a, l, d) {
      var p = ml(), g = d === void 0 ? null : d;
      On.flags |= t, p.memoizedState = cg(ua | a, l, void 0, g);
    }
    function jb(t, a, l, d) {
      var p = Fo(), g = d === void 0 ? null : d, S = void 0;
      if (da !== null) {
        var R = da.memoizedState;
        if (S = R.destroy, g !== null) {
          var O = R.deps;
          if (__(g, O)) {
            p.memoizedState = cg(a, l, S, g);
            return;
          }
        }
      }
      On.flags |= t, p.memoizedState = cg(ua | a, l, S, g);
    }
    function Ab(t, a) {
      return (On.mode & wi) !== rt ? dg(Vl | er | nl, Ua, t, a) : dg(er | nl, Ua, t, a);
    }
    function fg(t, a) {
      return jb(er, Ua, t, a);
    }
    function A_(t, a) {
      return dg(Mt, pl, t, a);
    }
    function Db(t, a) {
      return jb(Mt, pl, t, a);
    }
    function D_(t, a) {
      var l = Mt;
      return l |= Ja, (On.mode & wi) !== rt && (l |= Za), dg(l, ca, t, a);
    }
    function Pb(t, a) {
      return jb(Mt, ca, t, a);
    }
    function QR(t, a) {
      if (typeof a == "function") {
        var l = a, d = t();
        return l(d), function () {
          l(null);
        };
      } else if (a != null) {
        var p = a;
        p.hasOwnProperty("current") || f("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(p).join(", ") + "}");
        var g = t();
        return p.current = g, function () {
          p.current = null;
        };
      }
    }
    function P_(t, a, l) {
      typeof a != "function" && f("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", a !== null ? typeof a : "null");
      var d = l != null ? l.concat([t]) : null, p = Mt;
      return p |= Ja, (On.mode & wi) !== rt && (p |= Za), dg(p, ca, QR.bind(null, a, t), d);
    }
    function Mb(t, a, l) {
      typeof a != "function" && f("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", a !== null ? typeof a : "null");
      var d = l != null ? l.concat([t]) : null;
      return jb(Mt, ca, QR.bind(null, a, t), d);
    }
    function kU(t, a) {
    }
    var Lb = kU;
    function M_(t, a) {
      var l = ml(), d = a === void 0 ? null : a;
      return l.memoizedState = [t, d], t;
    }
    function Ib(t, a) {
      var l = Fo(), d = a === void 0 ? null : a, p = l.memoizedState;
      if (p !== null && d !== null) {
        var g = p[1];
        if (__(d, g))
          return p[0];
      }
      return l.memoizedState = [t, d], t;
    }
    function L_(t, a) {
      var l = ml(), d = a === void 0 ? null : a, p = t();
      return l.memoizedState = [p, d], p;
    }
    function Ub(t, a) {
      var l = Fo(), d = a === void 0 ? null : a, p = l.memoizedState;
      if (p !== null && d !== null) {
        var g = p[1];
        if (__(d, g))
          return p[0];
      }
      var S = t();
      return l.memoizedState = [S, d], S;
    }
    function I_(t) {
      var a = ml();
      return a.memoizedState = t, t;
    }
    function JR(t) {
      var a = Fo(), l = da, d = l.memoizedState;
      return XR(a, d, t);
    }
    function ZR(t) {
      var a = Fo();
      if (da === null)
        return a.memoizedState = t, t;
      var l = da.memoizedState;
      return XR(a, l, t);
    }
    function XR(t, a, l) {
      var d = !p0(mf);
      if (d) {
        if (!Ze(l, a)) {
          var p = g0();
          On.lanes = Pt(On.lanes, p), Ng(p), t.baseState = !0;
        }
        return a;
      } else
        return t.baseState && (t.baseState = !1, yg()), t.memoizedState = l, l;
    }
    function OU(t, a, l) {
      var d = Hi();
      mr(rS(d, us)), t(!0);
      var p = sg.transition;
      sg.transition = {};
      var g = sg.transition;
      sg.transition._updatedFibers = /* @__PURE__ */ new Set();
      try {
        t(!1), a();
      } finally {
        if (mr(d), sg.transition = p, p === null && g._updatedFibers) {
          var S = g._updatedFibers.size;
          S > 10 && c("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), g._updatedFibers.clear();
        }
      }
    }
    function U_() {
      var t = Ob(!1), a = t[0], l = t[1], d = OU.bind(null, l), p = ml();
      return p.memoizedState = d, [a, d];
    }
    function ek() {
      var t = O_(), a = t[0], l = Fo(), d = l.memoizedState;
      return [a, d];
    }
    function tk() {
      var t = N_(), a = t[0], l = Fo(), d = l.memoizedState;
      return [a, d];
    }
    var nk = !1;
    function NU() {
      return nk;
    }
    function F_() {
      var t = ml(), a = iw(), l = a.identifierPrefix, d;
      if (Ia()) {
        var p = YI();
        d = ":" + l + "R" + p;
        var g = ug++;
        g > 0 && (d += "H" + g.toString(32)), d += ":";
      } else {
        var S = CU++;
        d = ":" + l + "r" + S.toString(32) + ":";
      }
      return t.memoizedState = d, d;
    }
    function Fb() {
      var t = Fo(), a = t.memoizedState;
      return a;
    }
    function jU(t, a, l) {
      typeof arguments[3] == "function" && f("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var d = Ic(t), p = {
        lane: d,
        action: l,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (rk(t))
        ak(a, p);
      else {
        var g = AR(t, a, p, d);
        if (g !== null) {
          var S = Ei();
          va(g, t, d, S), ik(g, a, d);
        }
      }
      ok(t, d);
    }
    function AU(t, a, l) {
      typeof arguments[3] == "function" && f("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var d = Ic(t), p = {
        lane: d,
        action: l,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (rk(t))
        ak(a, p);
      else {
        var g = t.alternate;
        if (t.lanes === ye && (g === null || g.lanes === ye)) {
          var S = a.lastRenderedReducer;
          if (S !== null) {
            var R;
            R = We.current, We.current = gs;
            try {
              var O = a.lastRenderedState, L = S(O, l);
              if (p.hasEagerState = !0, p.eagerState = L, Ze(L, O)) {
                vU(t, a, p, d);
                return;
              }
            } catch {
            } finally {
              We.current = R;
            }
          }
        }
        var F = AR(t, a, p, d);
        if (F !== null) {
          var J = Ei();
          va(F, t, d, J), ik(F, a, d);
        }
      }
      ok(t, d);
    }
    function rk(t) {
      var a = t.alternate;
      return t === On || a !== null && a === On;
    }
    function ak(t, a) {
      lg = Rb = !0;
      var l = t.pending;
      l === null ? a.next = a : (a.next = l.next, l.next = a), t.pending = a;
    }
    function ik(t, a, l) {
      if (yv(l)) {
        var d = a.lanes;
        d = Fh(d, t.pendingLanes);
        var p = Pt(d, l);
        a.lanes = p, bv(t, p);
      }
    }
    function ok(t, a, l) {
      Ud(t, a);
    }
    var $b = {
      readContext: na,
      useCallback: li,
      useContext: li,
      useEffect: li,
      useImperativeHandle: li,
      useInsertionEffect: li,
      useLayoutEffect: li,
      useMemo: li,
      useReducer: li,
      useRef: li,
      useState: li,
      useDebugValue: li,
      useDeferredValue: li,
      useTransition: li,
      useMutableSource: li,
      useSyncExternalStore: li,
      useId: li,
      unstable_isNewReconciler: ue
    }, sk = null, lk = null, uk = null, ck = null, vl = null, gs = null, zb = null;
    {
      var $_ = function () {
        f("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      }, Nt = function () {
        f("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
      };
      sk = {
        readContext: function (t) {
          return na(t);
        },
        useCallback: function (t, a) {
          return pe = "useCallback", Cn(), Rp(a), M_(t, a);
        },
        useContext: function (t) {
          return pe = "useContext", Cn(), na(t);
        },
        useEffect: function (t, a) {
          return pe = "useEffect", Cn(), Rp(a), Ab(t, a);
        },
        useImperativeHandle: function (t, a, l) {
          return pe = "useImperativeHandle", Cn(), Rp(l), P_(t, a, l);
        },
        useInsertionEffect: function (t, a) {
          return pe = "useInsertionEffect", Cn(), Rp(a), A_(t, a);
        },
        useLayoutEffect: function (t, a) {
          return pe = "useLayoutEffect", Cn(), Rp(a), D_(t, a);
        },
        useMemo: function (t, a) {
          pe = "useMemo", Cn(), Rp(a);
          var l = We.current;
          We.current = vl;
          try {
            return L_(t, a);
          } finally {
            We.current = l;
          }
        },
        useReducer: function (t, a, l) {
          pe = "useReducer", Cn();
          var d = We.current;
          We.current = vl;
          try {
            return C_(t, a, l);
          } finally {
            We.current = d;
          }
        },
        useRef: function (t) {
          return pe = "useRef", Cn(), j_(t);
        },
        useState: function (t) {
          pe = "useState", Cn();
          var a = We.current;
          We.current = vl;
          try {
            return Ob(t);
          } finally {
            We.current = a;
          }
        },
        useDebugValue: function (t, a) {
          return pe = "useDebugValue", Cn(), void 0;
        },
        useDeferredValue: function (t) {
          return pe = "useDeferredValue", Cn(), I_(t);
        },
        useTransition: function () {
          return pe = "useTransition", Cn(), U_();
        },
        useMutableSource: function (t, a, l) {
          return pe = "useMutableSource", Cn(), void 0;
        },
        useSyncExternalStore: function (t, a, l) {
          return pe = "useSyncExternalStore", Cn(), k_(t, a, l);
        },
        useId: function () {
          return pe = "useId", Cn(), F_();
        },
        unstable_isNewReconciler: ue
      }, lk = {
        readContext: function (t) {
          return na(t);
        },
        useCallback: function (t, a) {
          return pe = "useCallback", $e(), M_(t, a);
        },
        useContext: function (t) {
          return pe = "useContext", $e(), na(t);
        },
        useEffect: function (t, a) {
          return pe = "useEffect", $e(), Ab(t, a);
        },
        useImperativeHandle: function (t, a, l) {
          return pe = "useImperativeHandle", $e(), P_(t, a, l);
        },
        useInsertionEffect: function (t, a) {
          return pe = "useInsertionEffect", $e(), A_(t, a);
        },
        useLayoutEffect: function (t, a) {
          return pe = "useLayoutEffect", $e(), D_(t, a);
        },
        useMemo: function (t, a) {
          pe = "useMemo", $e();
          var l = We.current;
          We.current = vl;
          try {
            return L_(t, a);
          } finally {
            We.current = l;
          }
        },
        useReducer: function (t, a, l) {
          pe = "useReducer", $e();
          var d = We.current;
          We.current = vl;
          try {
            return C_(t, a, l);
          } finally {
            We.current = d;
          }
        },
        useRef: function (t) {
          return pe = "useRef", $e(), j_(t);
        },
        useState: function (t) {
          pe = "useState", $e();
          var a = We.current;
          We.current = vl;
          try {
            return Ob(t);
          } finally {
            We.current = a;
          }
        },
        useDebugValue: function (t, a) {
          return pe = "useDebugValue", $e(), void 0;
        },
        useDeferredValue: function (t) {
          return pe = "useDeferredValue", $e(), I_(t);
        },
        useTransition: function () {
          return pe = "useTransition", $e(), U_();
        },
        useMutableSource: function (t, a, l) {
          return pe = "useMutableSource", $e(), void 0;
        },
        useSyncExternalStore: function (t, a, l) {
          return pe = "useSyncExternalStore", $e(), k_(t, a, l);
        },
        useId: function () {
          return pe = "useId", $e(), F_();
        },
        unstable_isNewReconciler: ue
      }, uk = {
        readContext: function (t) {
          return na(t);
        },
        useCallback: function (t, a) {
          return pe = "useCallback", $e(), Ib(t, a);
        },
        useContext: function (t) {
          return pe = "useContext", $e(), na(t);
        },
        useEffect: function (t, a) {
          return pe = "useEffect", $e(), fg(t, a);
        },
        useImperativeHandle: function (t, a, l) {
          return pe = "useImperativeHandle", $e(), Mb(t, a, l);
        },
        useInsertionEffect: function (t, a) {
          return pe = "useInsertionEffect", $e(), Db(t, a);
        },
        useLayoutEffect: function (t, a) {
          return pe = "useLayoutEffect", $e(), Pb(t, a);
        },
        useMemo: function (t, a) {
          pe = "useMemo", $e();
          var l = We.current;
          We.current = gs;
          try {
            return Ub(t, a);
          } finally {
            We.current = l;
          }
        },
        useReducer: function (t, a, l) {
          pe = "useReducer", $e();
          var d = We.current;
          We.current = gs;
          try {
            return T_(t, a, l);
          } finally {
            We.current = d;
          }
        },
        useRef: function (t) {
          return pe = "useRef", $e(), Nb();
        },
        useState: function (t) {
          pe = "useState", $e();
          var a = We.current;
          We.current = gs;
          try {
            return O_(t);
          } finally {
            We.current = a;
          }
        },
        useDebugValue: function (t, a) {
          return pe = "useDebugValue", $e(), Lb();
        },
        useDeferredValue: function (t) {
          return pe = "useDeferredValue", $e(), JR(t);
        },
        useTransition: function () {
          return pe = "useTransition", $e(), ek();
        },
        useMutableSource: function (t, a, l) {
          return pe = "useMutableSource", $e(), void 0;
        },
        useSyncExternalStore: function (t, a, l) {
          return pe = "useSyncExternalStore", $e(), kb(t, a);
        },
        useId: function () {
          return pe = "useId", $e(), Fb();
        },
        unstable_isNewReconciler: ue
      }, ck = {
        readContext: function (t) {
          return na(t);
        },
        useCallback: function (t, a) {
          return pe = "useCallback", $e(), Ib(t, a);
        },
        useContext: function (t) {
          return pe = "useContext", $e(), na(t);
        },
        useEffect: function (t, a) {
          return pe = "useEffect", $e(), fg(t, a);
        },
        useImperativeHandle: function (t, a, l) {
          return pe = "useImperativeHandle", $e(), Mb(t, a, l);
        },
        useInsertionEffect: function (t, a) {
          return pe = "useInsertionEffect", $e(), Db(t, a);
        },
        useLayoutEffect: function (t, a) {
          return pe = "useLayoutEffect", $e(), Pb(t, a);
        },
        useMemo: function (t, a) {
          pe = "useMemo", $e();
          var l = We.current;
          We.current = zb;
          try {
            return Ub(t, a);
          } finally {
            We.current = l;
          }
        },
        useReducer: function (t, a, l) {
          pe = "useReducer", $e();
          var d = We.current;
          We.current = zb;
          try {
            return R_(t, a, l);
          } finally {
            We.current = d;
          }
        },
        useRef: function (t) {
          return pe = "useRef", $e(), Nb();
        },
        useState: function (t) {
          pe = "useState", $e();
          var a = We.current;
          We.current = zb;
          try {
            return N_(t);
          } finally {
            We.current = a;
          }
        },
        useDebugValue: function (t, a) {
          return pe = "useDebugValue", $e(), Lb();
        },
        useDeferredValue: function (t) {
          return pe = "useDeferredValue", $e(), ZR(t);
        },
        useTransition: function () {
          return pe = "useTransition", $e(), tk();
        },
        useMutableSource: function (t, a, l) {
          return pe = "useMutableSource", $e(), void 0;
        },
        useSyncExternalStore: function (t, a, l) {
          return pe = "useSyncExternalStore", $e(), kb(t, a);
        },
        useId: function () {
          return pe = "useId", $e(), Fb();
        },
        unstable_isNewReconciler: ue
      }, vl = {
        readContext: function (t) {
          return $_(), na(t);
        },
        useCallback: function (t, a) {
          return pe = "useCallback", Nt(), Cn(), M_(t, a);
        },
        useContext: function (t) {
          return pe = "useContext", Nt(), Cn(), na(t);
        },
        useEffect: function (t, a) {
          return pe = "useEffect", Nt(), Cn(), Ab(t, a);
        },
        useImperativeHandle: function (t, a, l) {
          return pe = "useImperativeHandle", Nt(), Cn(), P_(t, a, l);
        },
        useInsertionEffect: function (t, a) {
          return pe = "useInsertionEffect", Nt(), Cn(), A_(t, a);
        },
        useLayoutEffect: function (t, a) {
          return pe = "useLayoutEffect", Nt(), Cn(), D_(t, a);
        },
        useMemo: function (t, a) {
          pe = "useMemo", Nt(), Cn();
          var l = We.current;
          We.current = vl;
          try {
            return L_(t, a);
          } finally {
            We.current = l;
          }
        },
        useReducer: function (t, a, l) {
          pe = "useReducer", Nt(), Cn();
          var d = We.current;
          We.current = vl;
          try {
            return C_(t, a, l);
          } finally {
            We.current = d;
          }
        },
        useRef: function (t) {
          return pe = "useRef", Nt(), Cn(), j_(t);
        },
        useState: function (t) {
          pe = "useState", Nt(), Cn();
          var a = We.current;
          We.current = vl;
          try {
            return Ob(t);
          } finally {
            We.current = a;
          }
        },
        useDebugValue: function (t, a) {
          return pe = "useDebugValue", Nt(), Cn(), void 0;
        },
        useDeferredValue: function (t) {
          return pe = "useDeferredValue", Nt(), Cn(), I_(t);
        },
        useTransition: function () {
          return pe = "useTransition", Nt(), Cn(), U_();
        },
        useMutableSource: function (t, a, l) {
          return pe = "useMutableSource", Nt(), Cn(), void 0;
        },
        useSyncExternalStore: function (t, a, l) {
          return pe = "useSyncExternalStore", Nt(), Cn(), k_(t, a, l);
        },
        useId: function () {
          return pe = "useId", Nt(), Cn(), F_();
        },
        unstable_isNewReconciler: ue
      }, gs = {
        readContext: function (t) {
          return $_(), na(t);
        },
        useCallback: function (t, a) {
          return pe = "useCallback", Nt(), $e(), Ib(t, a);
        },
        useContext: function (t) {
          return pe = "useContext", Nt(), $e(), na(t);
        },
        useEffect: function (t, a) {
          return pe = "useEffect", Nt(), $e(), fg(t, a);
        },
        useImperativeHandle: function (t, a, l) {
          return pe = "useImperativeHandle", Nt(), $e(), Mb(t, a, l);
        },
        useInsertionEffect: function (t, a) {
          return pe = "useInsertionEffect", Nt(), $e(), Db(t, a);
        },
        useLayoutEffect: function (t, a) {
          return pe = "useLayoutEffect", Nt(), $e(), Pb(t, a);
        },
        useMemo: function (t, a) {
          pe = "useMemo", Nt(), $e();
          var l = We.current;
          We.current = gs;
          try {
            return Ub(t, a);
          } finally {
            We.current = l;
          }
        },
        useReducer: function (t, a, l) {
          pe = "useReducer", Nt(), $e();
          var d = We.current;
          We.current = gs;
          try {
            return T_(t, a, l);
          } finally {
            We.current = d;
          }
        },
        useRef: function (t) {
          return pe = "useRef", Nt(), $e(), Nb();
        },
        useState: function (t) {
          pe = "useState", Nt(), $e();
          var a = We.current;
          We.current = gs;
          try {
            return O_(t);
          } finally {
            We.current = a;
          }
        },
        useDebugValue: function (t, a) {
          return pe = "useDebugValue", Nt(), $e(), Lb();
        },
        useDeferredValue: function (t) {
          return pe = "useDeferredValue", Nt(), $e(), JR(t);
        },
        useTransition: function () {
          return pe = "useTransition", Nt(), $e(), ek();
        },
        useMutableSource: function (t, a, l) {
          return pe = "useMutableSource", Nt(), $e(), void 0;
        },
        useSyncExternalStore: function (t, a, l) {
          return pe = "useSyncExternalStore", Nt(), $e(), kb(t, a);
        },
        useId: function () {
          return pe = "useId", Nt(), $e(), Fb();
        },
        unstable_isNewReconciler: ue
      }, zb = {
        readContext: function (t) {
          return $_(), na(t);
        },
        useCallback: function (t, a) {
          return pe = "useCallback", Nt(), $e(), Ib(t, a);
        },
        useContext: function (t) {
          return pe = "useContext", Nt(), $e(), na(t);
        },
        useEffect: function (t, a) {
          return pe = "useEffect", Nt(), $e(), fg(t, a);
        },
        useImperativeHandle: function (t, a, l) {
          return pe = "useImperativeHandle", Nt(), $e(), Mb(t, a, l);
        },
        useInsertionEffect: function (t, a) {
          return pe = "useInsertionEffect", Nt(), $e(), Db(t, a);
        },
        useLayoutEffect: function (t, a) {
          return pe = "useLayoutEffect", Nt(), $e(), Pb(t, a);
        },
        useMemo: function (t, a) {
          pe = "useMemo", Nt(), $e();
          var l = We.current;
          We.current = gs;
          try {
            return Ub(t, a);
          } finally {
            We.current = l;
          }
        },
        useReducer: function (t, a, l) {
          pe = "useReducer", Nt(), $e();
          var d = We.current;
          We.current = gs;
          try {
            return R_(t, a, l);
          } finally {
            We.current = d;
          }
        },
        useRef: function (t) {
          return pe = "useRef", Nt(), $e(), Nb();
        },
        useState: function (t) {
          pe = "useState", Nt(), $e();
          var a = We.current;
          We.current = gs;
          try {
            return N_(t);
          } finally {
            We.current = a;
          }
        },
        useDebugValue: function (t, a) {
          return pe = "useDebugValue", Nt(), $e(), Lb();
        },
        useDeferredValue: function (t) {
          return pe = "useDeferredValue", Nt(), $e(), ZR(t);
        },
        useTransition: function () {
          return pe = "useTransition", Nt(), $e(), tk();
        },
        useMutableSource: function (t, a, l) {
          return pe = "useMutableSource", Nt(), $e(), void 0;
        },
        useSyncExternalStore: function (t, a, l) {
          return pe = "useSyncExternalStore", Nt(), $e(), kb(t, a);
        },
        useId: function () {
          return pe = "useId", Nt(), $e(), Fb();
        },
        unstable_isNewReconciler: ue
      };
    }
    var Dc = e.unstable_now, dk = 0, Bb = -1, hg = -1, Vb = -1, z_ = !1, Hb = !1;
    function fk() {
      return z_;
    }
    function DU() {
      Hb = !0;
    }
    function PU() {
      z_ = !1, Hb = !1;
    }
    function MU() {
      z_ = Hb, Hb = !1;
    }
    function hk() {
      return dk;
    }
    function pk() {
      dk = Dc();
    }
    function B_(t) {
      hg = Dc(), t.actualStartTime < 0 && (t.actualStartTime = Dc());
    }
    function mk(t) {
      hg = -1;
    }
    function Wb(t, a) {
      if (hg >= 0) {
        var l = Dc() - hg;
        t.actualDuration += l, a && (t.selfBaseDuration = l), hg = -1;
      }
    }
    function gl(t) {
      if (Bb >= 0) {
        var a = Dc() - Bb;
        Bb = -1;
        for (var l = t.return; l !== null;) {
          switch (l.tag) {
            case T:
              var d = l.stateNode;
              d.effectDuration += a;
              return;
            case B:
              var p = l.stateNode;
              p.effectDuration += a;
              return;
          }
          l = l.return;
        }
      }
    }
    function V_(t) {
      if (Vb >= 0) {
        var a = Dc() - Vb;
        Vb = -1;
        for (var l = t.return; l !== null;) {
          switch (l.tag) {
            case T:
              var d = l.stateNode;
              d !== null && (d.passiveEffectDuration += a);
              return;
            case B:
              var p = l.stateNode;
              p !== null && (p.passiveEffectDuration += a);
              return;
          }
          l = l.return;
        }
      }
    }
    function yl() {
      Bb = Dc();
    }
    function H_() {
      Vb = Dc();
    }
    function W_(t) {
      for (var a = t.child; a;)
        t.actualDuration += a.actualDuration, a = a.sibling;
    }
    function ys(t, a) {
      if (t && t.defaultProps) {
        var l = Ft({}, a), d = t.defaultProps;
        for (var p in d)
          l[p] === void 0 && (l[p] = d[p]);
        return l;
      }
      return a;
    }
    var q_ = {}, Y_, K_, G_, Q_, J_, vk, qb, Z_, X_, eE, pg;
    {
      Y_ = /* @__PURE__ */ new Set(), K_ = /* @__PURE__ */ new Set(), G_ = /* @__PURE__ */ new Set(), Q_ = /* @__PURE__ */ new Set(), Z_ = /* @__PURE__ */ new Set(), J_ = /* @__PURE__ */ new Set(), X_ = /* @__PURE__ */ new Set(), eE = /* @__PURE__ */ new Set(), pg = /* @__PURE__ */ new Set();
      var gk = /* @__PURE__ */ new Set();
      qb = function (t, a) {
        if (!(t === null || typeof t == "function")) {
          var l = a + "_" + t;
          gk.has(l) || (gk.add(l), f("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", a, t));
        }
      }, vk = function (t, a) {
        if (a === void 0) {
          var l = Jt(t) || "Component";
          J_.has(l) || (J_.add(l), f("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", l));
        }
      }, Object.defineProperty(q_, "_processChildContext", {
        enumerable: !1,
        value: function () {
          throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
        }
      }), Object.freeze(q_);
    }
    function tE(t, a, l, d) {
      var p = t.memoizedState, g = l(d, p);
      {
        if (t.mode & Bt) {
          Dr(!0);
          try {
            g = l(d, p);
          } finally {
            Dr(!1);
          }
        }
        vk(a, g);
      }
      var S = g == null ? p : Ft({}, p, g);
      if (t.memoizedState = S, t.lanes === ye) {
        var R = t.updateQueue;
        R.baseState = S;
      }
    }
    var nE = {
      isMounted: yi,
      enqueueSetState: function (t, a, l) {
        var d = Li(t), p = Ei(), g = Ic(d), S = du(p, g);
        S.payload = a, l != null && (qb(l, "setState"), S.callback = l);
        var R = Oc(d, S, g);
        R !== null && (va(R, d, g, p), xb(R, d, g)), Ud(d, g);
      },
      enqueueReplaceState: function (t, a, l) {
        var d = Li(t), p = Ei(), g = Ic(d), S = du(p, g);
        S.tag = PR, S.payload = a, l != null && (qb(l, "replaceState"), S.callback = l);
        var R = Oc(d, S, g);
        R !== null && (va(R, d, g, p), xb(R, d, g)), Ud(d, g);
      },
      enqueueForceUpdate: function (t, a) {
        var l = Li(t), d = Ei(), p = Ic(l), g = du(d, p);
        g.tag = yb, a != null && (qb(a, "forceUpdate"), g.callback = a);
        var S = Oc(l, g, p);
        S !== null && (va(S, l, p, d), xb(S, l, p)), Sh(l, p);
      }
    };
    function yk(t, a, l, d, p, g, S) {
      var R = t.stateNode;
      if (typeof R.shouldComponentUpdate == "function") {
        var O = R.shouldComponentUpdate(d, g, S);
        {
          if (t.mode & Bt) {
            Dr(!0);
            try {
              O = R.shouldComponentUpdate(d, g, S);
            } finally {
              Dr(!1);
            }
          }
          O === void 0 && f("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", Jt(a) || "Component");
        }
        return O;
      }
      return a.prototype && a.prototype.isPureReactComponent ? !St(l, d) || !St(p, g) : !0;
    }
    function LU(t, a, l) {
      var d = t.stateNode;
      {
        var p = Jt(a) || "Component", g = d.render;
        g || (a.prototype && typeof a.prototype.render == "function" ? f("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", p) : f("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", p)), d.getInitialState && !d.getInitialState.isReactClassApproved && !d.state && f("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", p), d.getDefaultProps && !d.getDefaultProps.isReactClassApproved && f("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", p), d.propTypes && f("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", p), d.contextType && f("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", p), a.childContextTypes && !pg.has(a) && // Strict Mode has its own warning for legacy context, so we can skip
          // this one.
          (t.mode & Bt) === rt && (pg.add(a), f(`%s uses the legacy childContextTypes API which is no longer supported and will be removed in the next major release. Use React.createContext() instead

.Learn more about this warning here: https://reactjs.org/link/legacy-context`, p)), a.contextTypes && !pg.has(a) && // Strict Mode has its own warning for legacy context, so we can skip
          // this one.
          (t.mode & Bt) === rt && (pg.add(a), f(`%s uses the legacy contextTypes API which is no longer supported and will be removed in the next major release. Use React.createContext() with static contextType instead.

Learn more about this warning here: https://reactjs.org/link/legacy-context`, p)), d.contextTypes && f("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", p), a.contextType && a.contextTypes && !X_.has(a) && (X_.add(a), f("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", p)), typeof d.componentShouldUpdate == "function" && f("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", p), a.prototype && a.prototype.isPureReactComponent && typeof d.shouldComponentUpdate < "u" && f("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", Jt(a) || "A pure component"), typeof d.componentDidUnmount == "function" && f("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", p), typeof d.componentDidReceiveProps == "function" && f("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", p), typeof d.componentWillRecieveProps == "function" && f("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", p), typeof d.UNSAFE_componentWillRecieveProps == "function" && f("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", p);
        var S = d.props !== l;
        d.props !== void 0 && S && f("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", p, p), d.defaultProps && f("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", p, p), typeof d.getSnapshotBeforeUpdate == "function" && typeof d.componentDidUpdate != "function" && !G_.has(a) && (G_.add(a), f("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", Jt(a))), typeof d.getDerivedStateFromProps == "function" && f("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", p), typeof d.getDerivedStateFromError == "function" && f("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", p), typeof a.getSnapshotBeforeUpdate == "function" && f("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", p);
        var R = d.state;
        R && (typeof R != "object" || Zt(R)) && f("%s.state: must be set to an object or null", p), typeof d.getChildContext == "function" && typeof a.childContextTypes != "object" && f("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", p);
      }
    }
    function bk(t, a) {
      a.updater = nE, t.stateNode = a, qu(a, t), a._reactInternalInstance = q_;
    }
    function wk(t, a, l) {
      var d = !1, p = ho, g = ho, S = a.contextType;
      if ("contextType" in a) {
        var R = (
          // Allow null for conditional declaration
          S === null || S !== void 0 && S.$$typeof === xe && S._context === void 0
        );
        if (!R && !eE.has(a)) {
          eE.add(a);
          var O = "";
          S === void 0 ? O = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof S != "object" ? O = " However, it is set to a " + typeof S + "." : S.$$typeof === H ? O = " Did you accidentally pass the Context.Provider instead?" : S._context !== void 0 ? O = " Did you accidentally pass the Context.Consumer instead?" : O = " However, it is set to an object with keys {" + Object.keys(S).join(", ") + "}.", f("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", Jt(a) || "Component", O);
        }
      }
      if (typeof S == "object" && S !== null)
        g = na(S);
      else {
        p = mp(t, a, !0);
        var L = a.contextTypes;
        d = L != null, g = d ? vp(t, p) : ho;
      }
      var F = new a(l, g);
      if (t.mode & Bt) {
        Dr(!0);
        try {
          F = new a(l, g);
        } finally {
          Dr(!1);
        }
      }
      var J = t.memoizedState = F.state !== null && F.state !== void 0 ? F.state : null;
      bk(t, F);
      {
        if (typeof a.getDerivedStateFromProps == "function" && J === null) {
          var G = Jt(a) || "Component";
          K_.has(G) || (K_.add(G), f("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", G, F.state === null ? "null" : "undefined", G));
        }
        if (typeof a.getDerivedStateFromProps == "function" || typeof F.getSnapshotBeforeUpdate == "function") {
          var ie = null, le = null, de = null;
          if (typeof F.componentWillMount == "function" && F.componentWillMount.__suppressDeprecationWarning !== !0 ? ie = "componentWillMount" : typeof F.UNSAFE_componentWillMount == "function" && (ie = "UNSAFE_componentWillMount"), typeof F.componentWillReceiveProps == "function" && F.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? le = "componentWillReceiveProps" : typeof F.UNSAFE_componentWillReceiveProps == "function" && (le = "UNSAFE_componentWillReceiveProps"), typeof F.componentWillUpdate == "function" && F.componentWillUpdate.__suppressDeprecationWarning !== !0 ? de = "componentWillUpdate" : typeof F.UNSAFE_componentWillUpdate == "function" && (de = "UNSAFE_componentWillUpdate"), ie !== null || le !== null || de !== null) {
            var Be = Jt(a) || "Component", pt = typeof a.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            Q_.has(Be) || (Q_.add(Be), f(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, Be, pt, ie !== null ? `
  ` + ie : "", le !== null ? `
  ` + le : "", de !== null ? `
  ` + de : ""));
          }
        }
      }
      return d && uR(t, p, g), F;
    }
    function IU(t, a) {
      var l = a.state;
      typeof a.componentWillMount == "function" && a.componentWillMount(), typeof a.UNSAFE_componentWillMount == "function" && a.UNSAFE_componentWillMount(), l !== a.state && (f("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", Ot(t) || "Component"), nE.enqueueReplaceState(a, a.state, null));
    }
    function xk(t, a, l, d) {
      var p = a.state;
      if (typeof a.componentWillReceiveProps == "function" && a.componentWillReceiveProps(l, d), typeof a.UNSAFE_componentWillReceiveProps == "function" && a.UNSAFE_componentWillReceiveProps(l, d), a.state !== p) {
        {
          var g = Ot(t) || "Component";
          Y_.has(g) || (Y_.add(g), f("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", g));
        }
        nE.enqueueReplaceState(a, a.state, null);
      }
    }
    function rE(t, a, l, d) {
      LU(t, a, l);
      var p = t.stateNode;
      p.props = l, p.state = t.memoizedState, p.refs = {}, f_(t);
      var g = a.contextType;
      if (typeof g == "object" && g !== null)
        p.context = na(g);
      else {
        var S = mp(t, a, !0);
        p.context = vp(t, S);
      }
      {
        if (p.state === l) {
          var R = Jt(a) || "Component";
          Z_.has(R) || (Z_.add(R), f("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", R));
        }
        t.mode & Bt && ms.recordLegacyContextWarning(t, p), ms.recordUnsafeLifecycleWarnings(t, p);
      }
      p.state = t.memoizedState;
      var O = a.getDerivedStateFromProps;
      if (typeof O == "function" && (tE(t, a, O, l), p.state = t.memoizedState), typeof a.getDerivedStateFromProps != "function" && typeof p.getSnapshotBeforeUpdate != "function" && (typeof p.UNSAFE_componentWillMount == "function" || typeof p.componentWillMount == "function") && (IU(t, p), Sb(t, l, p, d), p.state = t.memoizedState), typeof p.componentDidMount == "function") {
        var L = Mt;
        L |= Ja, (t.mode & wi) !== rt && (L |= Za), t.flags |= L;
      }
    }
    function UU(t, a, l, d) {
      var p = t.stateNode, g = t.memoizedProps;
      p.props = g;
      var S = p.context, R = a.contextType, O = ho;
      if (typeof R == "object" && R !== null)
        O = na(R);
      else {
        var L = mp(t, a, !0);
        O = vp(t, L);
      }
      var F = a.getDerivedStateFromProps, J = typeof F == "function" || typeof p.getSnapshotBeforeUpdate == "function";
      !J && (typeof p.UNSAFE_componentWillReceiveProps == "function" || typeof p.componentWillReceiveProps == "function") && (g !== l || S !== O) && xk(t, p, l, O), LR();
      var G = t.memoizedState, ie = p.state = G;
      if (Sb(t, l, p, d), ie = t.memoizedState, g === l && G === ie && !rb() && !_b()) {
        if (typeof p.componentDidMount == "function") {
          var le = Mt;
          le |= Ja, (t.mode & wi) !== rt && (le |= Za), t.flags |= le;
        }
        return !1;
      }
      typeof F == "function" && (tE(t, a, F, l), ie = t.memoizedState);
      var de = _b() || yk(t, a, g, l, G, ie, O);
      if (de) {
        if (!J && (typeof p.UNSAFE_componentWillMount == "function" || typeof p.componentWillMount == "function") && (typeof p.componentWillMount == "function" && p.componentWillMount(), typeof p.UNSAFE_componentWillMount == "function" && p.UNSAFE_componentWillMount()), typeof p.componentDidMount == "function") {
          var Be = Mt;
          Be |= Ja, (t.mode & wi) !== rt && (Be |= Za), t.flags |= Be;
        }
      } else {
        if (typeof p.componentDidMount == "function") {
          var pt = Mt;
          pt |= Ja, (t.mode & wi) !== rt && (pt |= Za), t.flags |= pt;
        }
        t.memoizedProps = l, t.memoizedState = ie;
      }
      return p.props = l, p.state = ie, p.context = O, de;
    }
    function FU(t, a, l, d, p) {
      var g = a.stateNode;
      MR(t, a);
      var S = a.memoizedProps, R = a.type === a.elementType ? S : ys(a.type, S);
      g.props = R;
      var O = a.pendingProps, L = g.context, F = l.contextType, J = ho;
      if (typeof F == "object" && F !== null)
        J = na(F);
      else {
        var G = mp(a, l, !0);
        J = vp(a, G);
      }
      var ie = l.getDerivedStateFromProps, le = typeof ie == "function" || typeof g.getSnapshotBeforeUpdate == "function";
      !le && (typeof g.UNSAFE_componentWillReceiveProps == "function" || typeof g.componentWillReceiveProps == "function") && (S !== O || L !== J) && xk(a, g, d, J), LR();
      var de = a.memoizedState, Be = g.state = de;
      if (Sb(a, d, g, p), Be = a.memoizedState, S === O && de === Be && !rb() && !_b() && !he)
        return typeof g.componentDidUpdate == "function" && (S !== t.memoizedProps || de !== t.memoizedState) && (a.flags |= Mt), typeof g.getSnapshotBeforeUpdate == "function" && (S !== t.memoizedProps || de !== t.memoizedState) && (a.flags |= Ii), !1;
      typeof ie == "function" && (tE(a, l, ie, d), Be = a.memoizedState);
      var pt = _b() || yk(a, l, R, d, de, Be, J) || // TODO: In some cases, we'll end up checking if context has changed twice,
        // both before and after `shouldComponentUpdate` has been called. Not ideal,
        // but I'm loath to refactor this function. This only happens for memoized
        // components so it's not that common.
        he;
      return pt ? (!le && (typeof g.UNSAFE_componentWillUpdate == "function" || typeof g.componentWillUpdate == "function") && (typeof g.componentWillUpdate == "function" && g.componentWillUpdate(d, Be, J), typeof g.UNSAFE_componentWillUpdate == "function" && g.UNSAFE_componentWillUpdate(d, Be, J)), typeof g.componentDidUpdate == "function" && (a.flags |= Mt), typeof g.getSnapshotBeforeUpdate == "function" && (a.flags |= Ii)) : (typeof g.componentDidUpdate == "function" && (S !== t.memoizedProps || de !== t.memoizedState) && (a.flags |= Mt), typeof g.getSnapshotBeforeUpdate == "function" && (S !== t.memoizedProps || de !== t.memoizedState) && (a.flags |= Ii), a.memoizedProps = d, a.memoizedState = Be), g.props = d, g.state = Be, g.context = J, pt;
    }
    function vf(t, a) {
      return {
        value: t,
        source: a,
        stack: Du(a),
        digest: null
      };
    }
    function aE(t, a, l) {
      return {
        value: t,
        source: null,
        stack: l ?? null,
        digest: a ?? null
      };
    }
    function $U(t, a) {
      return !0;
    }
    function iE(t, a) {
      try {
        var l = $U(t, a);
        if (l === !1)
          return;
        var d = a.value, p = a.source, g = a.stack, S = g !== null ? g : "";
        if (d != null && d._suppressLogging) {
          if (t.tag === b)
            return;
          console.error(d);
        }
        var R = p ? Ot(p) : null, O = R ? "The above error occurred in the <" + R + "> component:" : "The above error occurred in one of your React components:", L;
        if (t.tag === T)
          L = `Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.`;
        else {
          var F = Ot(t) || "Anonymous";
          L = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + F + ".");
        }
        var J = O + `
` + S + `

` + ("" + L);
        console.error(J);
      } catch (G) {
        setTimeout(function () {
          throw G;
        });
      }
    }
    var zU = typeof WeakMap == "function" ? WeakMap : Map;
    function Sk(t, a, l) {
      var d = du($n, l);
      d.tag = c_, d.payload = {
        element: null
      };
      var p = a.value;
      return d.callback = function () {
        D$(p), iE(t, a);
      }, d;
    }
    function oE(t, a, l) {
      var d = du($n, l);
      d.tag = c_;
      var p = t.type.getDerivedStateFromError;
      if (typeof p == "function") {
        var g = a.value;
        d.payload = function () {
          return p(g);
        }, d.callback = function () {
          DO(t), iE(t, a);
        };
      }
      var S = t.stateNode;
      return S !== null && typeof S.componentDidCatch == "function" && (d.callback = function () {
        DO(t), iE(t, a), typeof p != "function" && j$(this);
        var O = a.value, L = a.stack;
        this.componentDidCatch(O, {
          componentStack: L !== null ? L : ""
        }), typeof p != "function" && (ai(t.lanes, ft) || f("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", Ot(t) || "Unknown"));
      }), d;
    }
    function _k(t, a, l) {
      var d = t.pingCache, p;
      if (d === null ? (d = t.pingCache = new zU(), p = /* @__PURE__ */ new Set(), d.set(a, p)) : (p = d.get(a), p === void 0 && (p = /* @__PURE__ */ new Set(), d.set(a, p))), !p.has(l)) {
        p.add(l);
        var g = P$.bind(null, t, a, l);
        bi && jg(t, l), a.then(g, g);
      }
    }
    function BU(t, a, l, d) {
      var p = t.updateQueue;
      if (p === null) {
        var g = /* @__PURE__ */ new Set();
        g.add(l), t.updateQueue = g;
      } else
        p.add(l);
    }
    function VU(t, a) {
      var l = t.tag;
      if ((t.mode & st) === rt && (l === y || l === U || l === re)) {
        var d = t.alternate;
        d ? (t.updateQueue = d.updateQueue, t.memoizedState = d.memoizedState, t.lanes = d.lanes) : (t.updateQueue = null, t.memoizedState = null);
      }
    }
    function Ek(t) {
      var a = t;
      do {
        if (a.tag === K && _U(a))
          return a;
        a = a.return;
      } while (a !== null);
      return null;
    }
    function Ck(t, a, l, d, p) {
      if ((t.mode & st) === rt) {
        if (t === a)
          t.flags |= Zr;
        else {
          if (t.flags |= Tt, l.flags |= Md, l.flags &= ~(ch | vi), l.tag === b) {
            var g = l.alternate;
            if (g === null)
              l.tag = Ce;
            else {
              var S = du($n, ft);
              S.tag = yb, Oc(l, S, ft);
            }
          }
          l.lanes = Pt(l.lanes, ft);
        }
        return t;
      }
      return t.flags |= Zr, t.lanes = p, t;
    }
    function HU(t, a, l, d, p) {
      if (l.flags |= vi, bi && jg(t, p), d !== null && typeof d == "object" && typeof d.then == "function") {
        var g = d;
        VU(l), Ia() && l.mode & st && vR();
        var S = Ek(a);
        if (S !== null) {
          S.flags &= ~pr, Ck(S, a, l, t, p), S.mode & st && _k(t, g, p), BU(S, t, g);
          return;
        } else {
          if (!gv(p)) {
            _k(t, g, p), FE();
            return;
          }
          var R = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
          d = R;
        }
      } else if (Ia() && l.mode & st) {
        vR();
        var O = Ek(a);
        if (O !== null) {
          (O.flags & Zr) === ht && (O.flags |= pr), Ck(O, a, l, t, p), ZS(vf(d, l));
          return;
        }
      }
      d = vf(d, l), _$(d);
      var L = a;
      do {
        switch (L.tag) {
          case T: {
            var F = d;
            L.flags |= Zr;
            var J = oc(p);
            L.lanes = Pt(L.lanes, J);
            var G = Sk(L, F, J);
            h_(L, G);
            return;
          }
          case b:
            var ie = d, le = L.type, de = L.stateNode;
            if ((L.flags & Tt) === ht && (typeof le.getDerivedStateFromError == "function" || de !== null && typeof de.componentDidCatch == "function" && !EO(de))) {
              L.flags |= Zr;
              var Be = oc(p);
              L.lanes = Pt(L.lanes, Be);
              var pt = oE(L, ie, Be);
              h_(L, pt);
              return;
            }
            break;
        }
        L = L.return;
      } while (L !== null);
    }
    function WU() {
      return null;
    }
    var mg = r.ReactCurrentOwner, bs = !1, sE, vg, lE, uE, cE, gf, dE, Yb, gg;
    sE = {}, vg = {}, lE = {}, uE = {}, cE = {}, gf = !1, dE = {}, Yb = {}, gg = {};
    function Si(t, a, l, d) {
      t === null ? a.child = kR(a, null, l, d) : a.child = wp(a, t.child, l, d);
    }
    function qU(t, a, l, d) {
      a.child = wp(a, t.child, null, d), a.child = wp(a, null, l, d);
    }
    function Tk(t, a, l, d, p) {
      if (a.type !== a.elementType) {
        var g = l.propTypes;
        g && hs(
          g,
          d,
          // Resolved props
          "prop",
          Jt(l)
        );
      }
      var S = l.render, R = a.ref, O, L;
      Sp(a, p), Qu(a);
      {
        if (mg.current = a, Ka(!0), O = kp(t, a, S, d, R, p), L = Op(), a.mode & Bt) {
          Dr(!0);
          try {
            O = kp(t, a, S, d, R, p), L = Op();
          } finally {
            Dr(!1);
          }
        }
        Ka(!1);
      }
      return ti(), t !== null && !bs ? (BR(t, a, p), fu(t, a, p)) : (Ia() && L && qS(a), a.flags |= el, Si(t, a, O, p), a.child);
    }
    function Rk(t, a, l, d, p) {
      if (t === null) {
        var g = l.type;
        if (J$(g) && l.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.
          l.defaultProps === void 0) {
          var S = g;
          return S = Ip(g), a.tag = re, a.type = S, pE(a, g), kk(t, a, S, d, p);
        }
        {
          var R = g.propTypes;
          if (R && hs(
            R,
            d,
            // Resolved props
            "prop",
            Jt(g)
          ), l.defaultProps !== void 0) {
            var O = Jt(g) || "Unknown";
            gg[O] || (f("%s: Support for defaultProps will be removed from memo components in a future major release. Use JavaScript default parameters instead.", O), gg[O] = !0);
          }
        }
        var L = QE(l.type, null, d, a, a.mode, p);
        return L.ref = a.ref, L.return = a, a.child = L, L;
      }
      {
        var F = l.type, J = F.propTypes;
        J && hs(
          J,
          d,
          // Resolved props
          "prop",
          Jt(F)
        );
      }
      var G = t.child, ie = wE(t, p);
      if (!ie) {
        var le = G.memoizedProps, de = l.compare;
        if (de = de !== null ? de : St, de(le, d) && t.ref === a.ref)
          return fu(t, a, p);
      }
      a.flags |= el;
      var Be = Sf(G, d);
      return Be.ref = a.ref, Be.return = a, a.child = Be, Be;
    }
    function kk(t, a, l, d, p) {
      if (a.type !== a.elementType) {
        var g = a.elementType;
        if (g.$$typeof === yt) {
          var S = g, R = S._payload, O = S._init;
          try {
            g = O(R);
          } catch {
            g = null;
          }
          var L = g && g.propTypes;
          L && hs(
            L,
            d,
            // Resolved (SimpleMemoComponent has no defaultProps)
            "prop",
            Jt(g)
          );
        }
      }
      if (t !== null) {
        var F = t.memoizedProps;
        if (St(F, d) && t.ref === a.ref && // Prevent bailout if the implementation changed due to hot reload.
          a.type === t.type)
          if (bs = !1, a.pendingProps = d = F, wE(t, p))
            (t.flags & Md) !== ht && (bs = !0);
          else return a.lanes = t.lanes, fu(t, a, p);
      }
      return fE(t, a, l, d, p);
    }
    function Ok(t, a, l) {
      var d = a.pendingProps, p = d.children, g = t !== null ? t.memoizedState : null;
      if (d.mode === "hidden" || ge)
        if ((a.mode & st) === rt) {
          var S = {
            baseLanes: ye,
            cachePool: null,
            transitions: null
          };
          a.memoizedState = S, ow(a, l);
        } else if (ai(l, _a)) {
          var J = {
            baseLanes: ye,
            cachePool: null,
            transitions: null
          };
          a.memoizedState = J;
          var G = g !== null ? g.baseLanes : l;
          ow(a, G);
        } else {
          var R = null, O;
          if (g !== null) {
            var L = g.baseLanes;
            O = Pt(L, l);
          } else
            O = l;
          a.lanes = a.childLanes = _a;
          var F = {
            baseLanes: O,
            cachePool: R,
            transitions: null
          };
          return a.memoizedState = F, a.updateQueue = null, ow(a, O), null;
        }
      else {
        var ie;
        g !== null ? (ie = Pt(g.baseLanes, l), a.memoizedState = null) : ie = l, ow(a, ie);
      }
      return Si(t, a, p, l), a.child;
    }
    function YU(t, a, l) {
      var d = a.pendingProps;
      return Si(t, a, d, l), a.child;
    }
    function KU(t, a, l) {
      var d = a.pendingProps.children;
      return Si(t, a, d, l), a.child;
    }
    function GU(t, a, l) {
      {
        a.flags |= Mt;
        {
          var d = a.stateNode;
          d.effectDuration = 0, d.passiveEffectDuration = 0;
        }
      }
      var p = a.pendingProps, g = p.children;
      return Si(t, a, g, l), a.child;
    }
    function Nk(t, a) {
      var l = a.ref;
      (t === null && l !== null || t !== null && t.ref !== l) && (a.flags |= Qa, a.flags |= av);
    }
    function fE(t, a, l, d, p) {
      if (a.type !== a.elementType) {
        var g = l.propTypes;
        g && hs(
          g,
          d,
          // Resolved props
          "prop",
          Jt(l)
        );
      }
      var S;
      {
        var R = mp(a, l, !0);
        S = vp(a, R);
      }
      var O, L;
      Sp(a, p), Qu(a);
      {
        if (mg.current = a, Ka(!0), O = kp(t, a, l, d, S, p), L = Op(), a.mode & Bt) {
          Dr(!0);
          try {
            O = kp(t, a, l, d, S, p), L = Op();
          } finally {
            Dr(!1);
          }
        }
        Ka(!1);
      }
      return ti(), t !== null && !bs ? (BR(t, a, p), fu(t, a, p)) : (Ia() && L && qS(a), a.flags |= el, Si(t, a, O, p), a.child);
    }
    function jk(t, a, l, d, p) {
      {
        switch (fz(a)) {
          case !1: {
            var g = a.stateNode, S = a.type, R = new S(a.memoizedProps, g.context), O = R.state;
            g.updater.enqueueSetState(g, O, null);
            break;
          }
          case !0: {
            a.flags |= Tt, a.flags |= Zr;
            var L = new Error("Simulated error coming from DevTools"), F = oc(p);
            a.lanes = Pt(a.lanes, F);
            var J = oE(a, vf(L, a), F);
            h_(a, J);
            break;
          }
        }
        if (a.type !== a.elementType) {
          var G = l.propTypes;
          G && hs(
            G,
            d,
            // Resolved props
            "prop",
            Jt(l)
          );
        }
      }
      var ie;
      hl(l) ? (ie = !0, ib(a)) : ie = !1, Sp(a, p);
      var le = a.stateNode, de;
      le === null ? (Gb(t, a), wk(a, l, d), rE(a, l, d, p), de = !0) : t === null ? de = UU(a, l, d, p) : de = FU(t, a, l, d, p);
      var Be = hE(t, a, l, de, ie, p);
      {
        var pt = a.stateNode;
        de && pt.props !== d && (gf || f("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", Ot(a) || "a component"), gf = !0);
      }
      return Be;
    }
    function hE(t, a, l, d, p, g) {
      Nk(t, a);
      var S = (a.flags & Tt) !== ht;
      if (!d && !S)
        return p && fR(a, l, !1), fu(t, a, g);
      var R = a.stateNode;
      mg.current = a;
      var O;
      if (S && typeof l.getDerivedStateFromError != "function")
        O = null, mk();
      else {
        Qu(a);
        {
          if (Ka(!0), O = R.render(), a.mode & Bt) {
            Dr(!0);
            try {
              R.render();
            } finally {
              Dr(!1);
            }
          }
          Ka(!1);
        }
        ti();
      }
      return a.flags |= el, t !== null && S ? qU(t, a, O, g) : Si(t, a, O, g), a.memoizedState = R.state, p && fR(a, l, !0), a.child;
    }
    function Ak(t) {
      var a = t.stateNode;
      a.pendingContext ? cR(t, a.pendingContext, a.pendingContext !== a.context) : a.context && cR(t, a.context, !1), p_(t, a.containerInfo);
    }
    function QU(t, a, l) {
      if (Ak(a), t === null)
        throw new Error("Should have a current fiber. This is a bug in React.");
      var d = a.pendingProps, p = a.memoizedState, g = p.element;
      MR(t, a), Sb(a, d, null, l);
      var S = a.memoizedState;
      a.stateNode;
      var R = S.element;
      if (p.isDehydrated) {
        var O = {
          element: R,
          isDehydrated: !1,
          cache: S.cache,
          pendingSuspenseBoundaries: S.pendingSuspenseBoundaries,
          transitions: S.transitions
        }, L = a.updateQueue;
        if (L.baseState = O, a.memoizedState = O, a.flags & pr) {
          var F = vf(new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering."), a);
          return Dk(t, a, R, l, F);
        } else if (R !== g) {
          var J = vf(new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), a);
          return Dk(t, a, R, l, J);
        } else {
          XI(a);
          var G = kR(a, null, R, l);
          a.child = G;
          for (var ie = G; ie;)
            ie.flags = ie.flags & ~Yn | Ui, ie = ie.sibling;
        }
      } else {
        if (bp(), R === g)
          return fu(t, a, l);
        Si(t, a, R, l);
      }
      return a.child;
    }
    function Dk(t, a, l, d, p) {
      return bp(), ZS(p), a.flags |= pr, Si(t, a, l, d), a.child;
    }
    function JU(t, a, l) {
      FR(a), t === null && JS(a);
      var d = a.type, p = a.pendingProps, g = t !== null ? t.memoizedProps : null, S = p.children, R = AS(d, p);
      return R ? S = null : g !== null && AS(d, g) && (a.flags |= En), Nk(t, a), Si(t, a, S, l), a.child;
    }
    function ZU(t, a) {
      return t === null && JS(a), null;
    }
    function XU(t, a, l, d) {
      Gb(t, a);
      var p = a.pendingProps, g = l, S = g._payload, R = g._init, O = R(S);
      a.type = O;
      var L = a.tag = Z$(O), F = ys(O, p), J;
      switch (L) {
        case y:
          return pE(a, O), a.type = O = Ip(O), J = fE(null, a, O, F, d), J;
        case b:
          return a.type = O = HE(O), J = jk(null, a, O, F, d), J;
        case U:
          return a.type = O = WE(O), J = Tk(null, a, O, F, d), J;
        case te: {
          if (a.type !== a.elementType) {
            var G = O.propTypes;
            G && hs(
              G,
              F,
              // Resolved for outer only
              "prop",
              Jt(O)
            );
          }
          return J = Rk(
            null,
            a,
            O,
            ys(O.type, F),
            // The inner type can have defaults too
            d
          ), J;
        }
      }
      var ie = "";
      throw O !== null && typeof O == "object" && O.$$typeof === yt && (ie = " Did you wrap a component in React.lazy() more than once?"), new Error("Element type is invalid. Received a promise that resolves to: " + O + ". " + ("Lazy element type must resolve to a class or function." + ie));
    }
    function eF(t, a, l, d, p) {
      Gb(t, a), a.tag = b;
      var g;
      return hl(l) ? (g = !0, ib(a)) : g = !1, Sp(a, p), wk(a, l, d), rE(a, l, d, p), hE(null, a, l, !0, g, p);
    }
    function tF(t, a, l, d) {
      Gb(t, a);
      var p = a.pendingProps, g;
      {
        var S = mp(a, l, !1);
        g = vp(a, S);
      }
      Sp(a, d);
      var R, O;
      Qu(a);
      {
        if (l.prototype && typeof l.prototype.render == "function") {
          var L = Jt(l) || "Unknown";
          sE[L] || (f("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", L, L), sE[L] = !0);
        }
        a.mode & Bt && ms.recordLegacyContextWarning(a, null), Ka(!0), mg.current = a, R = kp(null, a, l, p, g, d), O = Op(), Ka(!1);
      }
      if (ti(), a.flags |= el, typeof R == "object" && R !== null && typeof R.render == "function" && R.$$typeof === void 0) {
        var F = Jt(l) || "Unknown";
        vg[F] || (f("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", F, F, F), vg[F] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof R == "object" && R !== null && typeof R.render == "function" && R.$$typeof === void 0
      ) {
        {
          var J = Jt(l) || "Unknown";
          vg[J] || (f("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", J, J, J), vg[J] = !0);
        }
        a.tag = b, a.memoizedState = null, a.updateQueue = null;
        var G = !1;
        return hl(l) ? (G = !0, ib(a)) : G = !1, a.memoizedState = R.state !== null && R.state !== void 0 ? R.state : null, f_(a), bk(a, R), rE(a, l, p, d), hE(null, a, l, !0, G, d);
      } else {
        if (a.tag = y, a.mode & Bt) {
          Dr(!0);
          try {
            R = kp(null, a, l, p, g, d), O = Op();
          } finally {
            Dr(!1);
          }
        }
        return Ia() && O && qS(a), Si(null, a, R, d), pE(a, l), a.child;
      }
    }
    function pE(t, a) {
      {
        if (a && a.childContextTypes && f("%s(...): childContextTypes cannot be defined on a function component.", a.displayName || a.name || "Component"), t.ref !== null) {
          var l = "", d = Pa();
          d && (l += `

Check the render method of \`` + d + "`.");
          var p = d || "", g = t._debugSource;
          g && (p = g.fileName + ":" + g.lineNumber), cE[p] || (cE[p] = !0, f("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", l));
        }
        if (a.defaultProps !== void 0) {
          var S = Jt(a) || "Unknown";
          gg[S] || (f("%s: Support for defaultProps will be removed from function components in a future major release. Use JavaScript default parameters instead.", S), gg[S] = !0);
        }
        if (typeof a.getDerivedStateFromProps == "function") {
          var R = Jt(a) || "Unknown";
          uE[R] || (f("%s: Function components do not support getDerivedStateFromProps.", R), uE[R] = !0);
        }
        if (typeof a.contextType == "object" && a.contextType !== null) {
          var O = Jt(a) || "Unknown";
          lE[O] || (f("%s: Function components do not support contextType.", O), lE[O] = !0);
        }
      }
    }
    var mE = {
      dehydrated: null,
      treeContext: null,
      retryLane: Pr
    };
    function vE(t) {
      return {
        baseLanes: t,
        cachePool: WU(),
        transitions: null
      };
    }
    function nF(t, a) {
      var l = null;
      return {
        baseLanes: Pt(t.baseLanes, a),
        cachePool: l,
        transitions: t.transitions
      };
    }
    function rF(t, a, l, d) {
      if (a !== null) {
        var p = a.memoizedState;
        if (p === null)
          return !1;
      }
      return g_(t, og);
    }
    function aF(t, a) {
      return Wd(t.childLanes, a);
    }
    function Pk(t, a, l) {
      var d = a.pendingProps;
      hz(a) && (a.flags |= Tt);
      var p = vs.current, g = !1, S = (a.flags & Tt) !== ht;
      if (S || rF(p, t) ? (g = !0, a.flags &= ~Tt) : (t === null || t.memoizedState !== null) && (p = SU(p, zR)), p = Ep(p), jc(a, p), t === null) {
        JS(a);
        var R = a.memoizedState;
        if (R !== null) {
          var O = R.dehydrated;
          if (O !== null)
            return uF(a, O);
        }
        var L = d.children, F = d.fallback;
        if (g) {
          var J = iF(a, L, F, l), G = a.child;
          return G.memoizedState = vE(l), a.memoizedState = mE, J;
        } else
          return gE(a, L);
      } else {
        var ie = t.memoizedState;
        if (ie !== null) {
          var le = ie.dehydrated;
          if (le !== null)
            return cF(t, a, S, d, le, ie, l);
        }
        if (g) {
          var de = d.fallback, Be = d.children, pt = sF(t, a, Be, de, l), lt = a.child, rn = t.child.memoizedState;
          return lt.memoizedState = rn === null ? vE(l) : nF(rn, l), lt.childLanes = aF(t, l), a.memoizedState = mE, pt;
        } else {
          var Kt = d.children, X = oF(t, a, Kt, l);
          return a.memoizedState = null, X;
        }
      }
    }
    function gE(t, a, l) {
      var d = t.mode, p = {
        mode: "visible",
        children: a
      }, g = yE(p, d);
      return g.return = t, t.child = g, g;
    }
    function iF(t, a, l, d) {
      var p = t.mode, g = t.child, S = {
        mode: "hidden",
        children: a
      }, R, O;
      return (p & st) === rt && g !== null ? (R = g, R.childLanes = ye, R.pendingProps = S, t.mode & Rt && (R.actualDuration = 0, R.actualStartTime = -1, R.selfBaseDuration = 0, R.treeBaseDuration = 0), O = Fc(l, p, d, null)) : (R = yE(S, p), O = Fc(l, p, d, null)), R.return = t, O.return = t, R.sibling = O, t.child = R, O;
    }
    function yE(t, a, l) {
      return MO(t, a, ye, null);
    }
    function Mk(t, a) {
      return Sf(t, a);
    }
    function oF(t, a, l, d) {
      var p = t.child, g = p.sibling, S = Mk(p, {
        mode: "visible",
        children: l
      });
      if ((a.mode & st) === rt && (S.lanes = d), S.return = a, S.sibling = null, g !== null) {
        var R = a.deletions;
        R === null ? (a.deletions = [g], a.flags |= bn) : R.push(g);
      }
      return a.child = S, S;
    }
    function sF(t, a, l, d, p) {
      var g = a.mode, S = t.child, R = S.sibling, O = {
        mode: "hidden",
        children: l
      }, L;
      if (
        // In legacy mode, we commit the primary tree as if it successfully
        // completed, even though it's in an inconsistent state.
        (g & st) === rt && // Make sure we're on the second pass, i.e. the primary child fragment was
        // already cloned. In legacy mode, the only case where this isn't true is
        // when DevTools forces us to display a fallback; we skip the first render
        // pass entirely and go straight to rendering the fallback. (In Concurrent
        // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
        // only codepath.)
        a.child !== S
      ) {
        var F = a.child;
        L = F, L.childLanes = ye, L.pendingProps = O, a.mode & Rt && (L.actualDuration = 0, L.actualStartTime = -1, L.selfBaseDuration = S.selfBaseDuration, L.treeBaseDuration = S.treeBaseDuration), a.deletions = null;
      } else
        L = Mk(S, O), L.subtreeFlags = S.subtreeFlags & oa;
      var J;
      return R !== null ? J = Sf(R, d) : (J = Fc(d, g, p, null), J.flags |= Yn), J.return = a, L.return = a, L.sibling = J, a.child = L, J;
    }
    function Kb(t, a, l, d) {
      d !== null && ZS(d), wp(a, t.child, null, l);
      var p = a.pendingProps, g = p.children, S = gE(a, g);
      return S.flags |= Yn, a.memoizedState = null, S;
    }
    function lF(t, a, l, d, p) {
      var g = a.mode, S = {
        mode: "visible",
        children: l
      }, R = yE(S, g), O = Fc(d, g, p, null);
      return O.flags |= Yn, R.return = a, O.return = a, R.sibling = O, a.child = R, (a.mode & st) !== rt && wp(a, t.child, null, p), O;
    }
    function uF(t, a, l) {
      return (t.mode & st) === rt ? (f("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components."), t.lanes = ft) : LS(a) ? t.lanes = ls : t.lanes = _a, null;
    }
    function cF(t, a, l, d, p, g, S) {
      if (l)
        if (a.flags & pr) {
          a.flags &= ~pr;
          var X = aE(new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
          return Kb(t, a, S, X);
        } else {
          if (a.memoizedState !== null)
            return a.child = t.child, a.flags |= Tt, null;
          var fe = d.children, ee = d.fallback, Ee = lF(t, a, fe, ee, S), qe = a.child;
          return qe.memoizedState = vE(S), a.memoizedState = mE, Ee;
        }
      else {
        if (JI(), (a.mode & st) === rt)
          return Kb(
            t,
            a,
            S,
            // TODO: When we delete legacy mode, we should make this error argument
            // required  every concurrent mode path that causes hydration to
            // de-opt to client rendering should have an error message.
            null
          );
        if (LS(p)) {
          var R, O, L;
          {
            var F = pI(p);
            R = F.digest, O = F.message, L = F.stack;
          }
          var J;
          O ? J = new Error(O) : J = new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.");
          var G = aE(J, R, L);
          return Kb(t, a, S, G);
        }
        var ie = ai(S, t.childLanes);
        if (bs || ie) {
          var le = iw();
          if (le !== null) {
            var de = w0(le, S);
            if (de !== Pr && de !== g.retryLane) {
              g.retryLane = de;
              var Be = $n;
              Qi(t, de), va(le, t, de, Be);
            }
          }
          FE();
          var pt = aE(new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
          return Kb(t, a, S, pt);
        } else if (aR(p)) {
          a.flags |= Tt, a.child = t.child;
          var lt = M$.bind(null, t);
          return mI(p, lt), null;
        } else {
          eU(a, p, g.treeContext);
          var rn = d.children, Kt = gE(a, rn);
          return Kt.flags |= Ui, Kt;
        }
      }
    }
    function Lk(t, a, l) {
      t.lanes = Pt(t.lanes, a);
      var d = t.alternate;
      d !== null && (d.lanes = Pt(d.lanes, a)), l_(t.return, a, l);
    }
    function dF(t, a, l) {
      for (var d = a; d !== null;) {
        if (d.tag === K) {
          var p = d.memoizedState;
          p !== null && Lk(d, l, t);
        } else if (d.tag === Ie)
          Lk(d, l, t);
        else if (d.child !== null) {
          d.child.return = d, d = d.child;
          continue;
        }
        if (d === t)
          return;
        for (; d.sibling === null;) {
          if (d.return === null || d.return === t)
            return;
          d = d.return;
        }
        d.sibling.return = d.return, d = d.sibling;
      }
    }
    function fF(t) {
      for (var a = t, l = null; a !== null;) {
        var d = a.alternate;
        d !== null && Tb(d) === null && (l = a), a = a.sibling;
      }
      return l;
    }
    function hF(t) {
      if (t !== void 0 && t !== "forwards" && t !== "backwards" && t !== "together" && !dE[t])
        if (dE[t] = !0, typeof t == "string")
          switch (t.toLowerCase()) {
            case "together":
            case "forwards":
            case "backwards": {
              f('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', t, t.toLowerCase());
              break;
            }
            case "forward":
            case "backward": {
              f('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', t, t.toLowerCase());
              break;
            }
            default:
              f('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', t);
              break;
          }
        else
          f('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', t);
    }
    function pF(t, a) {
      t !== void 0 && !Yb[t] && (t !== "collapsed" && t !== "hidden" ? (Yb[t] = !0, f('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', t)) : a !== "forwards" && a !== "backwards" && (Yb[t] = !0, f('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', t)));
    }
    function Ik(t, a) {
      {
        var l = Zt(t), d = !l && typeof ja(t) == "function";
        if (l || d) {
          var p = l ? "array" : "iterable";
          return f("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", p, a, p), !1;
        }
      }
      return !0;
    }
    function mF(t, a) {
      if ((a === "forwards" || a === "backwards") && t !== void 0 && t !== null && t !== !1)
        if (Zt(t)) {
          for (var l = 0; l < t.length; l++)
            if (!Ik(t[l], l))
              return;
        } else {
          var d = ja(t);
          if (typeof d == "function") {
            var p = d.call(t);
            if (p)
              for (var g = p.next(), S = 0; !g.done; g = p.next()) {
                if (!Ik(g.value, S))
                  return;
                S++;
              }
          } else
            f('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', a);
        }
    }
    function bE(t, a, l, d, p) {
      var g = t.memoizedState;
      g === null ? t.memoizedState = {
        isBackwards: a,
        rendering: null,
        renderingStartTime: 0,
        last: d,
        tail: l,
        tailMode: p
      } : (g.isBackwards = a, g.rendering = null, g.renderingStartTime = 0, g.last = d, g.tail = l, g.tailMode = p);
    }
    function Uk(t, a, l) {
      var d = a.pendingProps, p = d.revealOrder, g = d.tail, S = d.children;
      hF(p), pF(g, p), mF(S, p), Si(t, a, S, l);
      var R = vs.current, O = g_(R, og);
      if (O)
        R = y_(R, og), a.flags |= Tt;
      else {
        var L = t !== null && (t.flags & Tt) !== ht;
        L && dF(a, a.child, l), R = Ep(R);
      }
      if (jc(a, R), (a.mode & st) === rt)
        a.memoizedState = null;
      else
        switch (p) {
          case "forwards": {
            var F = fF(a.child), J;
            F === null ? (J = a.child, a.child = null) : (J = F.sibling, F.sibling = null), bE(
              a,
              !1,
              // isBackwards
              J,
              F,
              g
            );
            break;
          }
          case "backwards": {
            var G = null, ie = a.child;
            for (a.child = null; ie !== null;) {
              var le = ie.alternate;
              if (le !== null && Tb(le) === null) {
                a.child = ie;
                break;
              }
              var de = ie.sibling;
              ie.sibling = G, G = ie, ie = de;
            }
            bE(
              a,
              !0,
              // isBackwards
              G,
              null,
              // last
              g
            );
            break;
          }
          case "together": {
            bE(
              a,
              !1,
              // isBackwards
              null,
              // tail
              null,
              // last
              void 0
            );
            break;
          }
          default:
            a.memoizedState = null;
        }
      return a.child;
    }
    function vF(t, a, l) {
      p_(a, a.stateNode.containerInfo);
      var d = a.pendingProps;
      return t === null ? a.child = wp(a, null, d, l) : Si(t, a, d, l), a.child;
    }
    var Fk = !1;
    function gF(t, a, l) {
      var d = a.type, p = d._context, g = a.pendingProps, S = a.memoizedProps, R = g.value;
      {
        "value" in g || Fk || (Fk = !0, f("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"));
        var O = a.type.propTypes;
        O && hs(O, g, "prop", "Context.Provider");
      }
      if (jR(a, p, R), S !== null) {
        var L = S.value;
        if (Ze(L, R)) {
          if (S.children === g.children && !rb())
            return fu(t, a, l);
        } else
          hU(a, p, l);
      }
      var F = g.children;
      return Si(t, a, F, l), a.child;
    }
    var $k = !1;
    function yF(t, a, l) {
      var d = a.type;
      d._context === void 0 ? d !== d.Consumer && ($k || ($k = !0, f("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : d = d._context;
      var p = a.pendingProps, g = p.children;
      typeof g != "function" && f("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), Sp(a, l);
      var S = na(d);
      Qu(a);
      var R;
      return mg.current = a, Ka(!0), R = g(S), Ka(!1), ti(), a.flags |= el, Si(t, a, R, l), a.child;
    }
    function yg() {
      bs = !0;
    }
    function Gb(t, a) {
      (a.mode & st) === rt && t !== null && (t.alternate = null, a.alternate = null, a.flags |= Yn);
    }
    function fu(t, a, l) {
      return t !== null && (a.dependencies = t.dependencies), mk(), Ng(a.lanes), ai(l, a.childLanes) ? (dU(t, a), a.child) : null;
    }
    function bF(t, a, l) {
      {
        var d = a.return;
        if (d === null)
          throw new Error("Cannot swap the root fiber.");
        if (t.alternate = null, a.alternate = null, l.index = a.index, l.sibling = a.sibling, l.return = a.return, l.ref = a.ref, a === d.child)
          d.child = l;
        else {
          var p = d.child;
          if (p === null)
            throw new Error("Expected parent to have a child.");
          for (; p.sibling !== a;)
            if (p = p.sibling, p === null)
              throw new Error("Expected to find the previous sibling.");
          p.sibling = l;
        }
        var g = d.deletions;
        return g === null ? (d.deletions = [t], d.flags |= bn) : g.push(t), l.flags |= Yn, l;
      }
    }
    function wE(t, a) {
      var l = t.lanes;
      return !!ai(l, a);
    }
    function wF(t, a, l) {
      switch (a.tag) {
        case T:
          Ak(a), a.stateNode, bp();
          break;
        case C:
          FR(a);
          break;
        case b: {
          var d = a.type;
          hl(d) && ib(a);
          break;
        }
        case k:
          p_(a, a.stateNode.containerInfo);
          break;
        case I: {
          var p = a.memoizedProps.value, g = a.type._context;
          jR(a, g, p);
          break;
        }
        case B:
          {
            var S = ai(l, a.childLanes);
            S && (a.flags |= Mt);
            {
              var R = a.stateNode;
              R.effectDuration = 0, R.passiveEffectDuration = 0;
            }
          }
          break;
        case K: {
          var O = a.memoizedState;
          if (O !== null) {
            if (O.dehydrated !== null)
              return jc(a, Ep(vs.current)), a.flags |= Tt, null;
            var L = a.child, F = L.childLanes;
            if (ai(l, F))
              return Pk(t, a, l);
            jc(a, Ep(vs.current));
            var J = fu(t, a, l);
            return J !== null ? J.sibling : null;
          } else
            jc(a, Ep(vs.current));
          break;
        }
        case Ie: {
          var G = (t.flags & Tt) !== ht, ie = ai(l, a.childLanes);
          if (G) {
            if (ie)
              return Uk(t, a, l);
            a.flags |= Tt;
          }
          var le = a.memoizedState;
          if (le !== null && (le.rendering = null, le.tail = null, le.lastEffect = null), jc(a, vs.current), ie)
            break;
          return null;
        }
        case Re:
        case me:
          return a.lanes = ye, Ok(t, a, l);
      }
      return fu(t, a, l);
    }
    function zk(t, a, l) {
      if (a._debugNeedsRemount && t !== null)
        return bF(t, a, QE(a.type, a.key, a.pendingProps, a._debugOwner || null, a.mode, a.lanes));
      if (t !== null) {
        var d = t.memoizedProps, p = a.pendingProps;
        if (d !== p || rb() || // Force a re-render if the implementation changed due to hot reload:
          a.type !== t.type)
          bs = !0;
        else {
          var g = wE(t, l);
          if (!g && // If this is the second pass of an error or suspense boundary, there
            // may not be work scheduled on `current`, so we check for this flag.
            (a.flags & Tt) === ht)
            return bs = !1, wF(t, a, l);
          (t.flags & Md) !== ht ? bs = !0 : bs = !1;
        }
      } else if (bs = !1, Ia() && WI(a)) {
        var S = a.index, R = qI();
        mR(a, R, S);
      }
      switch (a.lanes = ye, a.tag) {
        case _:
          return tF(t, a, a.type, l);
        case ve: {
          var O = a.elementType;
          return XU(t, a, O, l);
        }
        case y: {
          var L = a.type, F = a.pendingProps, J = a.elementType === L ? F : ys(L, F);
          return fE(t, a, L, J, l);
        }
        case b: {
          var G = a.type, ie = a.pendingProps, le = a.elementType === G ? ie : ys(G, ie);
          return jk(t, a, G, le, l);
        }
        case T:
          return QU(t, a, l);
        case C:
          return JU(t, a, l);
        case M:
          return ZU(t, a);
        case K:
          return Pk(t, a, l);
        case k:
          return vF(t, a, l);
        case U: {
          var de = a.type, Be = a.pendingProps, pt = a.elementType === de ? Be : ys(de, Be);
          return Tk(t, a, de, pt, l);
        }
        case N:
          return YU(t, a, l);
        case A:
          return KU(t, a, l);
        case B:
          return GU(t, a, l);
        case I:
          return gF(t, a, l);
        case $:
          return yF(t, a, l);
        case te: {
          var lt = a.type, rn = a.pendingProps, Kt = ys(lt, rn);
          if (a.type !== a.elementType) {
            var X = lt.propTypes;
            X && hs(
              X,
              Kt,
              // Resolved for outer only
              "prop",
              Jt(lt)
            );
          }
          return Kt = ys(lt.type, Kt), Rk(t, a, lt, Kt, l);
        }
        case re:
          return kk(t, a, a.type, a.pendingProps, l);
        case Ce: {
          var fe = a.type, ee = a.pendingProps, Ee = a.elementType === fe ? ee : ys(fe, ee);
          return eF(t, a, fe, Ee, l);
        }
        case Ie:
          return Uk(t, a, l);
        case Ne:
          break;
        case Re:
          return Ok(t, a, l);
      }
      throw new Error("Unknown unit of work tag (" + a.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function Np(t) {
      t.flags |= Mt;
    }
    function Bk(t) {
      t.flags |= Qa, t.flags |= av;
    }
    var Vk, xE, Hk, Wk;
    Vk = function (t, a, l, d) {
      for (var p = a.child; p !== null;) {
        if (p.tag === C || p.tag === M)
          BL(t, p.stateNode);
        else if (p.tag !== k) {
          if (p.child !== null) {
            p.child.return = p, p = p.child;
            continue;
          }
        }
        if (p === a)
          return;
        for (; p.sibling === null;) {
          if (p.return === null || p.return === a)
            return;
          p = p.return;
        }
        p.sibling.return = p.return, p = p.sibling;
      }
    }, xE = function (t, a) {
    }, Hk = function (t, a, l, d, p) {
      var g = t.memoizedProps;
      if (g !== d) {
        var S = a.stateNode, R = m_(), O = HL(S, l, g, d, p, R);
        a.updateQueue = O, O && Np(a);
      }
    }, Wk = function (t, a, l, d) {
      l !== d && Np(a);
    };
    function bg(t, a) {
      if (!Ia())
        switch (t.tailMode) {
          case "hidden": {
            for (var l = t.tail, d = null; l !== null;)
              l.alternate !== null && (d = l), l = l.sibling;
            d === null ? t.tail = null : d.sibling = null;
            break;
          }
          case "collapsed": {
            for (var p = t.tail, g = null; p !== null;)
              p.alternate !== null && (g = p), p = p.sibling;
            g === null ? !a && t.tail !== null ? t.tail.sibling = null : t.tail = null : g.sibling = null;
            break;
          }
        }
    }
    function Fa(t) {
      var a = t.alternate !== null && t.alternate.child === t.child, l = ye, d = ht;
      if (a) {
        if ((t.mode & Rt) !== rt) {
          for (var O = t.selfBaseDuration, L = t.child; L !== null;)
            l = Pt(l, Pt(L.lanes, L.childLanes)), d |= L.subtreeFlags & oa, d |= L.flags & oa, O += L.treeBaseDuration, L = L.sibling;
          t.treeBaseDuration = O;
        } else
          for (var F = t.child; F !== null;)
            l = Pt(l, Pt(F.lanes, F.childLanes)), d |= F.subtreeFlags & oa, d |= F.flags & oa, F.return = t, F = F.sibling;
        t.subtreeFlags |= d;
      } else {
        if ((t.mode & Rt) !== rt) {
          for (var p = t.actualDuration, g = t.selfBaseDuration, S = t.child; S !== null;)
            l = Pt(l, Pt(S.lanes, S.childLanes)), d |= S.subtreeFlags, d |= S.flags, p += S.actualDuration, g += S.treeBaseDuration, S = S.sibling;
          t.actualDuration = p, t.treeBaseDuration = g;
        } else
          for (var R = t.child; R !== null;)
            l = Pt(l, Pt(R.lanes, R.childLanes)), d |= R.subtreeFlags, d |= R.flags, R.return = t, R = R.sibling;
        t.subtreeFlags |= d;
      }
      return t.childLanes = l, a;
    }
    function xF(t, a, l) {
      if (iU() && (a.mode & st) !== rt && (a.flags & Tt) === ht)
        return SR(a), bp(), a.flags |= pr | vi | Zr, !1;
      var d = cb(a);
      if (l !== null && l.dehydrated !== null)
        if (t === null) {
          if (!d)
            throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
          if (rU(a), Fa(a), (a.mode & Rt) !== rt) {
            var p = l !== null;
            if (p) {
              var g = a.child;
              g !== null && (a.treeBaseDuration -= g.treeBaseDuration);
            }
          }
          return !1;
        } else {
          if (bp(), (a.flags & Tt) === ht && (a.memoizedState = null), a.flags |= Mt, Fa(a), (a.mode & Rt) !== rt) {
            var S = l !== null;
            if (S) {
              var R = a.child;
              R !== null && (a.treeBaseDuration -= R.treeBaseDuration);
            }
          }
          return !1;
        }
      else
        return _R(), !0;
    }
    function qk(t, a, l) {
      var d = a.pendingProps;
      switch (YS(a), a.tag) {
        case _:
        case ve:
        case re:
        case y:
        case U:
        case N:
        case A:
        case B:
        case $:
        case te:
          return Fa(a), null;
        case b: {
          var p = a.type;
          return hl(p) && ab(a), Fa(a), null;
        }
        case T: {
          var g = a.stateNode;
          if (_p(a), VS(a), w_(), g.pendingContext && (g.context = g.pendingContext, g.pendingContext = null), t === null || t.child === null) {
            var S = cb(a);
            if (S)
              Np(a);
            else if (t !== null) {
              var R = t.memoizedState;
              // Check if this is a client root
              (!R.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)
                (a.flags & pr) !== ht) && (a.flags |= Ii, _R());
            }
          }
          return xE(t, a), Fa(a), null;
        }
        case C: {
          v_(a);
          var O = UR(), L = a.type;
          if (t !== null && a.stateNode != null)
            Hk(t, a, L, d, O), t.ref !== a.ref && Bk(a);
          else {
            if (!d) {
              if (a.stateNode === null)
                throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              return Fa(a), null;
            }
            var F = m_(), J = cb(a);
            if (J)
              tU(a, O, F) && Np(a);
            else {
              var G = zL(L, d, O, F, a);
              Vk(G, a, !1, !1), a.stateNode = G, VL(G, L, d, O) && Np(a);
            }
            a.ref !== null && Bk(a);
          }
          return Fa(a), null;
        }
        case M: {
          var ie = d;
          if (t && a.stateNode != null) {
            var le = t.memoizedProps;
            Wk(t, a, le, ie);
          } else {
            if (typeof ie != "string" && a.stateNode === null)
              throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
            var de = UR(), Be = m_(), pt = cb(a);
            pt ? nU(a) && Np(a) : a.stateNode = WL(ie, de, Be, a);
          }
          return Fa(a), null;
        }
        case K: {
          Cp(a);
          var lt = a.memoizedState;
          if (t === null || t.memoizedState !== null && t.memoizedState.dehydrated !== null) {
            var rn = xF(t, a, lt);
            if (!rn)
              return a.flags & Zr ? a : null;
          }
          if ((a.flags & Tt) !== ht)
            return a.lanes = l, (a.mode & Rt) !== rt && W_(a), a;
          var Kt = lt !== null, X = t !== null && t.memoizedState !== null;
          if (Kt !== X && Kt) {
            var fe = a.child;
            if (fe.flags |= tl, (a.mode & st) !== rt) {
              var ee = t === null && (a.memoizedProps.unstable_avoidThisFallback !== !0 || !Y);
              ee || g_(vs.current, zR) ? S$() : FE();
            }
          }
          var Ee = a.updateQueue;
          if (Ee !== null && (a.flags |= Mt), Fa(a), (a.mode & Rt) !== rt && Kt) {
            var qe = a.child;
            qe !== null && (a.treeBaseDuration -= qe.treeBaseDuration);
          }
          return null;
        }
        case k:
          return _p(a), xE(t, a), t === null && UI(a.stateNode.containerInfo), Fa(a), null;
        case I:
          var Ve = a.type._context;
          return s_(Ve, a), Fa(a), null;
        case Ce: {
          var Ct = a.type;
          return hl(Ct) && ab(a), Fa(a), null;
        }
        case Ie: {
          Cp(a);
          var Dt = a.memoizedState;
          if (Dt === null)
            return Fa(a), null;
          var Nn = (a.flags & Tt) !== ht, vn = Dt.rendering;
          if (vn === null)
            if (Nn)
              bg(Dt, !1);
            else {
              var Hr = E$() && (t === null || (t.flags & Tt) === ht);
              if (!Hr)
                for (var gn = a.child; gn !== null;) {
                  var Mr = Tb(gn);
                  if (Mr !== null) {
                    Nn = !0, a.flags |= Tt, bg(Dt, !1);
                    var ui = Mr.updateQueue;
                    return ui !== null && (a.updateQueue = ui, a.flags |= Mt), a.subtreeFlags = ht, fU(a, l), jc(a, y_(vs.current, og)), a.child;
                  }
                  gn = gn.sibling;
                }
              Dt.tail !== null && sr() > hO() && (a.flags |= Tt, Nn = !0, bg(Dt, !1), a.lanes = u0);
            }
          else {
            if (!Nn) {
              var Ha = Tb(vn);
              if (Ha !== null) {
                a.flags |= Tt, Nn = !0;
                var mo = Ha.updateQueue;
                if (mo !== null && (a.updateQueue = mo, a.flags |= Mt), bg(Dt, !0), Dt.tail === null && Dt.tailMode === "hidden" && !vn.alternate && !Ia())
                  return Fa(a), null;
              } else // The time it took to render last row is greater than the remaining
                // time we have to render. So rendering one more row would likely
                // exceed it.
                sr() * 2 - Dt.renderingStartTime > hO() && l !== _a && (a.flags |= Tt, Nn = !0, bg(Dt, !1), a.lanes = u0);
            }
            if (Dt.isBackwards)
              vn.sibling = a.child, a.child = vn;
            else {
              var Ci = Dt.last;
              Ci !== null ? Ci.sibling = vn : a.child = vn, Dt.last = vn;
            }
          }
          if (Dt.tail !== null) {
            var Ti = Dt.tail;
            Dt.rendering = Ti, Dt.tail = Ti.sibling, Dt.renderingStartTime = sr(), Ti.sibling = null;
            var ci = vs.current;
            return Nn ? ci = y_(ci, og) : ci = Ep(ci), jc(a, ci), Ti;
          }
          return Fa(a), null;
        }
        case Ne:
          break;
        case Re:
        case me: {
          UE(a);
          var gu = a.memoizedState, Up = gu !== null;
          if (t !== null) {
            var Mg = t.memoizedState, xl = Mg !== null;
            xl !== Up && // LegacyHidden doesn't do any hiding  it only pre-renders.
              !ge && (a.flags |= tl);
          }
          return !Up || (a.mode & st) === rt ? Fa(a) : ai(wl, _a) && (Fa(a), a.subtreeFlags & (Yn | Mt) && (a.flags |= tl)), null;
        }
        case Ge:
          return null;
        case Me:
          return null;
      }
      throw new Error("Unknown unit of work tag (" + a.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function SF(t, a, l) {
      switch (YS(a), a.tag) {
        case b: {
          var d = a.type;
          hl(d) && ab(a);
          var p = a.flags;
          return p & Zr ? (a.flags = p & ~Zr | Tt, (a.mode & Rt) !== rt && W_(a), a) : null;
        }
        case T: {
          a.stateNode, _p(a), VS(a), w_();
          var g = a.flags;
          return (g & Zr) !== ht && (g & Tt) === ht ? (a.flags = g & ~Zr | Tt, a) : null;
        }
        case C:
          return v_(a), null;
        case K: {
          Cp(a);
          var S = a.memoizedState;
          if (S !== null && S.dehydrated !== null) {
            if (a.alternate === null)
              throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
            bp();
          }
          var R = a.flags;
          return R & Zr ? (a.flags = R & ~Zr | Tt, (a.mode & Rt) !== rt && W_(a), a) : null;
        }
        case Ie:
          return Cp(a), null;
        case k:
          return _p(a), null;
        case I:
          var O = a.type._context;
          return s_(O, a), null;
        case Re:
        case me:
          return UE(a), null;
        case Ge:
          return null;
        default:
          return null;
      }
    }
    function Yk(t, a, l) {
      switch (YS(a), a.tag) {
        case b: {
          var d = a.type.childContextTypes;
          d != null && ab(a);
          break;
        }
        case T: {
          a.stateNode, _p(a), VS(a), w_();
          break;
        }
        case C: {
          v_(a);
          break;
        }
        case k:
          _p(a);
          break;
        case K:
          Cp(a);
          break;
        case Ie:
          Cp(a);
          break;
        case I:
          var p = a.type._context;
          s_(p, a);
          break;
        case Re:
        case me:
          UE(a);
          break;
      }
    }
    var Kk = null;
    Kk = /* @__PURE__ */ new Set();
    var Qb = !1, $a = !1, _F = typeof WeakSet == "function" ? WeakSet : Set, Xe = null, jp = null, Ap = null;
    function EF(t) {
      Bl(null, function () {
        throw t;
      }), nv();
    }
    var CF = function (t, a) {
      if (a.props = t.memoizedProps, a.state = t.memoizedState, t.mode & Rt)
        try {
          yl(), a.componentWillUnmount();
        } finally {
          gl(t);
        }
      else
        a.componentWillUnmount();
    };
    function Gk(t, a) {
      try {
        Pc(ca, t);
      } catch (l) {
        Qn(t, a, l);
      }
    }
    function SE(t, a, l) {
      try {
        CF(t, l);
      } catch (d) {
        Qn(t, a, d);
      }
    }
    function TF(t, a, l) {
      try {
        l.componentDidMount();
      } catch (d) {
        Qn(t, a, d);
      }
    }
    function Qk(t, a) {
      try {
        Zk(t);
      } catch (l) {
        Qn(t, a, l);
      }
    }
    function Dp(t, a) {
      var l = t.ref;
      if (l !== null)
        if (typeof l == "function") {
          var d;
          try {
            if (xt && et && t.mode & Rt)
              try {
                yl(), d = l(null);
              } finally {
                gl(t);
              }
            else
              d = l(null);
          } catch (p) {
            Qn(t, a, p);
          }
          typeof d == "function" && f("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", Ot(t));
        } else
          l.current = null;
    }
    function Jb(t, a, l) {
      try {
        l();
      } catch (d) {
        Qn(t, a, d);
      }
    }
    var Jk = !1;
    function RF(t, a) {
      FL(t.containerInfo), Xe = a, kF();
      var l = Jk;
      return Jk = !1, l;
    }
    function kF() {
      for (; Xe !== null;) {
        var t = Xe, a = t.child;
        (t.subtreeFlags & Yu) !== ht && a !== null ? (a.return = t, Xe = a) : OF();
      }
    }
    function OF() {
      for (; Xe !== null;) {
        var t = Xe;
        _n(t);
        try {
          NF(t);
        } catch (l) {
          Qn(t, t.return, l);
        }
        hr();
        var a = t.sibling;
        if (a !== null) {
          a.return = t.return, Xe = a;
          return;
        }
        Xe = t.return;
      }
    }
    function NF(t) {
      var a = t.alternate, l = t.flags;
      if ((l & Ii) !== ht) {
        switch (_n(t), t.tag) {
          case y:
          case U:
          case re:
            break;
          case b: {
            if (a !== null) {
              var d = a.memoizedProps, p = a.memoizedState, g = t.stateNode;
              t.type === t.elementType && !gf && (g.props !== t.memoizedProps && f("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Ot(t) || "instance"), g.state !== t.memoizedState && f("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Ot(t) || "instance"));
              var S = g.getSnapshotBeforeUpdate(t.elementType === t.type ? d : ys(t.type, d), p);
              {
                var R = Kk;
                S === void 0 && !R.has(t.type) && (R.add(t.type), f("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", Ot(t)));
              }
              g.__reactInternalSnapshotBeforeUpdate = S;
            }
            break;
          }
          case T: {
            {
              var O = t.stateNode;
              cI(O.containerInfo);
            }
            break;
          }
          case C:
          case M:
          case k:
          case Ce:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
        hr();
      }
    }
    function ws(t, a, l) {
      var d = a.updateQueue, p = d !== null ? d.lastEffect : null;
      if (p !== null) {
        var g = p.next, S = g;
        do {
          if ((S.tag & t) === t) {
            var R = S.destroy;
            S.destroy = void 0, R !== void 0 && ((t & Ua) !== Ji ? o0(a) : (t & ca) !== Ji && fo(a), (t & pl) !== Ji && Ag(!0), Jb(a, l, R), (t & pl) !== Ji && Ag(!1), (t & Ua) !== Ji ? bh() : (t & ca) !== Ji && Ju());
          }
          S = S.next;
        } while (S !== g);
      }
    }
    function Pc(t, a) {
      var l = a.updateQueue, d = l !== null ? l.lastEffect : null;
      if (d !== null) {
        var p = d.next, g = p;
        do {
          if ((g.tag & t) === t) {
            (t & Ua) !== Ji ? al(a) : (t & ca) !== Ji && s0(a);
            var S = g.create;
            (t & pl) !== Ji && Ag(!0), g.destroy = S(), (t & pl) !== Ji && Ag(!1), (t & Ua) !== Ji ? yh() : (t & ca) !== Ji && Ld();
            {
              var R = g.destroy;
              if (R !== void 0 && typeof R != "function") {
                var O = void 0;
                (g.tag & ca) !== ht ? O = "useLayoutEffect" : (g.tag & pl) !== ht ? O = "useInsertionEffect" : O = "useEffect";
                var L = void 0;
                R === null ? L = " You returned null. If your effect does not require clean up, return undefined (or nothing)." : typeof R.then == "function" ? L = `

It looks like you wrote ` + O + `(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

` + O + `(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching` : L = " You returned: " + R, f("%s must not return anything besides a function, which is used for clean-up.%s", O, L);
              }
            }
          }
          g = g.next;
        } while (g !== p);
      }
    }
    function jF(t, a) {
      if ((a.flags & Mt) !== ht)
        switch (a.tag) {
          case B: {
            var l = a.stateNode.passiveEffectDuration, d = a.memoizedProps, p = d.id, g = d.onPostCommit, S = hk(), R = a.alternate === null ? "mount" : "update";
            fk() && (R = "nested-update"), typeof g == "function" && g(p, R, l, S);
            var O = a.return;
            e: for (; O !== null;) {
              switch (O.tag) {
                case T:
                  var L = O.stateNode;
                  L.passiveEffectDuration += l;
                  break e;
                case B:
                  var F = O.stateNode;
                  F.passiveEffectDuration += l;
                  break e;
              }
              O = O.return;
            }
            break;
          }
        }
    }
    function AF(t, a, l, d) {
      if ((l.flags & xa) !== ht)
        switch (l.tag) {
          case y:
          case U:
          case re: {
            if (!$a)
              if (l.mode & Rt)
                try {
                  yl(), Pc(ca | ua, l);
                } finally {
                  gl(l);
                }
              else
                Pc(ca | ua, l);
            break;
          }
          case b: {
            var p = l.stateNode;
            if (l.flags & Mt && !$a)
              if (a === null)
                if (l.type === l.elementType && !gf && (p.props !== l.memoizedProps && f("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Ot(l) || "instance"), p.state !== l.memoizedState && f("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Ot(l) || "instance")), l.mode & Rt)
                  try {
                    yl(), p.componentDidMount();
                  } finally {
                    gl(l);
                  }
                else
                  p.componentDidMount();
              else {
                var g = l.elementType === l.type ? a.memoizedProps : ys(l.type, a.memoizedProps), S = a.memoizedState;
                if (l.type === l.elementType && !gf && (p.props !== l.memoizedProps && f("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Ot(l) || "instance"), p.state !== l.memoizedState && f("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Ot(l) || "instance")), l.mode & Rt)
                  try {
                    yl(), p.componentDidUpdate(g, S, p.__reactInternalSnapshotBeforeUpdate);
                  } finally {
                    gl(l);
                  }
                else
                  p.componentDidUpdate(g, S, p.__reactInternalSnapshotBeforeUpdate);
              }
            var R = l.updateQueue;
            R !== null && (l.type === l.elementType && !gf && (p.props !== l.memoizedProps && f("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Ot(l) || "instance"), p.state !== l.memoizedState && f("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Ot(l) || "instance")), IR(l, R, p));
            break;
          }
          case T: {
            var O = l.updateQueue;
            if (O !== null) {
              var L = null;
              if (l.child !== null)
                switch (l.child.tag) {
                  case C:
                    L = l.child.stateNode;
                    break;
                  case b:
                    L = l.child.stateNode;
                    break;
                }
              IR(l, O, L);
            }
            break;
          }
          case C: {
            var F = l.stateNode;
            if (a === null && l.flags & Mt) {
              var J = l.type, G = l.memoizedProps;
              QL(F, J, G);
            }
            break;
          }
          case M:
            break;
          case k:
            break;
          case B: {
            {
              var ie = l.memoizedProps, le = ie.onCommit, de = ie.onRender, Be = l.stateNode.effectDuration, pt = hk(), lt = a === null ? "mount" : "update";
              fk() && (lt = "nested-update"), typeof de == "function" && de(l.memoizedProps.id, lt, l.actualDuration, l.treeBaseDuration, l.actualStartTime, pt);
              {
                typeof le == "function" && le(l.memoizedProps.id, lt, Be, pt), O$(l);
                var rn = l.return;
                e: for (; rn !== null;) {
                  switch (rn.tag) {
                    case T:
                      var Kt = rn.stateNode;
                      Kt.effectDuration += Be;
                      break e;
                    case B:
                      var X = rn.stateNode;
                      X.effectDuration += Be;
                      break e;
                  }
                  rn = rn.return;
                }
              }
            }
            break;
          }
          case K: {
            $F(t, l);
            break;
          }
          case Ie:
          case Ce:
          case Ne:
          case Re:
          case me:
          case Me:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
      $a || l.flags & Qa && Zk(l);
    }
    function DF(t) {
      switch (t.tag) {
        case y:
        case U:
        case re: {
          if (t.mode & Rt)
            try {
              yl(), Gk(t, t.return);
            } finally {
              gl(t);
            }
          else
            Gk(t, t.return);
          break;
        }
        case b: {
          var a = t.stateNode;
          typeof a.componentDidMount == "function" && TF(t, t.return, a), Qk(t, t.return);
          break;
        }
        case C: {
          Qk(t, t.return);
          break;
        }
      }
    }
    function PF(t, a) {
      for (var l = null, d = t; ;) {
        if (d.tag === C) {
          if (l === null) {
            l = d;
            try {
              var p = d.stateNode;
              a ? oI(p) : lI(d.stateNode, d.memoizedProps);
            } catch (S) {
              Qn(t, t.return, S);
            }
          }
        } else if (d.tag === M) {
          if (l === null)
            try {
              var g = d.stateNode;
              a ? sI(g) : uI(g, d.memoizedProps);
            } catch (S) {
              Qn(t, t.return, S);
            }
        } else if (!((d.tag === Re || d.tag === me) && d.memoizedState !== null && d !== t)) {
          if (d.child !== null) {
            d.child.return = d, d = d.child;
            continue;
          }
        }
        if (d === t)
          return;
        for (; d.sibling === null;) {
          if (d.return === null || d.return === t)
            return;
          l === d && (l = null), d = d.return;
        }
        l === d && (l = null), d.sibling.return = d.return, d = d.sibling;
      }
    }
    function Zk(t) {
      var a = t.ref;
      if (a !== null) {
        var l = t.stateNode, d;
        switch (t.tag) {
          case C:
            d = l;
            break;
          default:
            d = l;
        }
        if (typeof a == "function") {
          var p;
          if (t.mode & Rt)
            try {
              yl(), p = a(d);
            } finally {
              gl(t);
            }
          else
            p = a(d);
          typeof p == "function" && f("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", Ot(t));
        } else
          a.hasOwnProperty("current") || f("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", Ot(t)), a.current = d;
      }
    }
    function MF(t) {
      var a = t.alternate;
      a !== null && (a.return = null), t.return = null;
    }
    function Xk(t) {
      var a = t.alternate;
      a !== null && (t.alternate = null, Xk(a));
      {
        if (t.child = null, t.deletions = null, t.sibling = null, t.tag === C) {
          var l = t.stateNode;
          l !== null && zI(l);
        }
        t.stateNode = null, t._debugOwner = null, t.return = null, t.dependencies = null, t.memoizedProps = null, t.memoizedState = null, t.pendingProps = null, t.stateNode = null, t.updateQueue = null;
      }
    }
    function LF(t) {
      for (var a = t.return; a !== null;) {
        if (eO(a))
          return a;
        a = a.return;
      }
      throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
    }
    function eO(t) {
      return t.tag === C || t.tag === T || t.tag === k;
    }
    function tO(t) {
      var a = t;
      e: for (; ;) {
        for (; a.sibling === null;) {
          if (a.return === null || eO(a.return))
            return null;
          a = a.return;
        }
        for (a.sibling.return = a.return, a = a.sibling; a.tag !== C && a.tag !== M && a.tag !== ke;) {
          if (a.flags & Yn || a.child === null || a.tag === k)
            continue e;
          a.child.return = a, a = a.child;
        }
        if (!(a.flags & Yn))
          return a.stateNode;
      }
    }
    function IF(t) {
      var a = LF(t);
      switch (a.tag) {
        case C: {
          var l = a.stateNode;
          a.flags & En && (rR(l), a.flags &= ~En);
          var d = tO(t);
          EE(t, d, l);
          break;
        }
        case T:
        case k: {
          var p = a.stateNode.containerInfo, g = tO(t);
          _E(t, g, p);
          break;
        }
        default:
          throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    function _E(t, a, l) {
      var d = t.tag, p = d === C || d === M;
      if (p) {
        var g = t.stateNode;
        a ? nI(l, g, a) : eI(l, g);
      } else if (d !== k) {
        var S = t.child;
        if (S !== null) {
          _E(S, a, l);
          for (var R = S.sibling; R !== null;)
            _E(R, a, l), R = R.sibling;
        }
      }
    }
    function EE(t, a, l) {
      var d = t.tag, p = d === C || d === M;
      if (p) {
        var g = t.stateNode;
        a ? tI(l, g, a) : XL(l, g);
      } else if (d !== k) {
        var S = t.child;
        if (S !== null) {
          EE(S, a, l);
          for (var R = S.sibling; R !== null;)
            EE(R, a, l), R = R.sibling;
        }
      }
    }
    var za = null, xs = !1;
    function UF(t, a, l) {
      {
        var d = a;
        e: for (; d !== null;) {
          switch (d.tag) {
            case C: {
              za = d.stateNode, xs = !1;
              break e;
            }
            case T: {
              za = d.stateNode.containerInfo, xs = !0;
              break e;
            }
            case k: {
              za = d.stateNode.containerInfo, xs = !0;
              break e;
            }
          }
          d = d.return;
        }
        if (za === null)
          throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
        nO(t, a, l), za = null, xs = !1;
      }
      MF(l);
    }
    function Mc(t, a, l) {
      for (var d = l.child; d !== null;)
        nO(t, a, d), d = d.sibling;
    }
    function nO(t, a, l) {
      switch (Wl(l), l.tag) {
        case C:
          $a || Dp(l, a);
        case M: {
          {
            var d = za, p = xs;
            za = null, Mc(t, a, l), za = d, xs = p, za !== null && (xs ? aI(za, l.stateNode) : rI(za, l.stateNode));
          }
          return;
        }
        case ke: {
          za !== null && (xs ? iI(za, l.stateNode) : MS(za, l.stateNode));
          return;
        }
        case k: {
          {
            var g = za, S = xs;
            za = l.stateNode.containerInfo, xs = !0, Mc(t, a, l), za = g, xs = S;
          }
          return;
        }
        case y:
        case U:
        case te:
        case re: {
          if (!$a) {
            var R = l.updateQueue;
            if (R !== null) {
              var O = R.lastEffect;
              if (O !== null) {
                var L = O.next, F = L;
                do {
                  var J = F, G = J.destroy, ie = J.tag;
                  G !== void 0 && ((ie & pl) !== Ji ? Jb(l, a, G) : (ie & ca) !== Ji && (fo(l), l.mode & Rt ? (yl(), Jb(l, a, G), gl(l)) : Jb(l, a, G), Ju())), F = F.next;
                } while (F !== L);
              }
            }
          }
          Mc(t, a, l);
          return;
        }
        case b: {
          if (!$a) {
            Dp(l, a);
            var le = l.stateNode;
            typeof le.componentWillUnmount == "function" && SE(l, a, le);
          }
          Mc(t, a, l);
          return;
        }
        case Ne: {
          Mc(t, a, l);
          return;
        }
        case Re: {
          if (
            // TODO: Remove this dead flag
            l.mode & st
          ) {
            var de = $a;
            $a = de || l.memoizedState !== null, Mc(t, a, l), $a = de;
          } else
            Mc(t, a, l);
          break;
        }
        default: {
          Mc(t, a, l);
          return;
        }
      }
    }
    function FF(t) {
      t.memoizedState;
    }
    function $F(t, a) {
      var l = a.memoizedState;
      if (l === null) {
        var d = a.alternate;
        if (d !== null) {
          var p = d.memoizedState;
          if (p !== null) {
            var g = p.dehydrated;
            g !== null && EI(g);
          }
        }
      }
    }
    function rO(t) {
      var a = t.updateQueue;
      if (a !== null) {
        t.updateQueue = null;
        var l = t.stateNode;
        l === null && (l = t.stateNode = new _F()), a.forEach(function (d) {
          var p = L$.bind(null, t, d);
          if (!l.has(d)) {
            if (l.add(d), bi)
              if (jp !== null && Ap !== null)
                jg(Ap, jp);
              else
                throw Error("Expected finished root and lanes to be set. This is a bug in React.");
            d.then(p, p);
          }
        });
      }
    }
    function zF(t, a, l) {
      jp = l, Ap = t, _n(a), aO(a, t), _n(a), jp = null, Ap = null;
    }
    function Ss(t, a, l) {
      var d = a.deletions;
      if (d !== null)
        for (var p = 0; p < d.length; p++) {
          var g = d[p];
          try {
            UF(t, a, g);
          } catch (O) {
            Qn(g, a, O);
          }
        }
      var S = Qf();
      if (a.subtreeFlags & Xa)
        for (var R = a.child; R !== null;)
          _n(R), aO(R, t), R = R.sibling;
      _n(S);
    }
    function aO(t, a, l) {
      var d = t.alternate, p = t.flags;
      switch (t.tag) {
        case y:
        case U:
        case te:
        case re: {
          if (Ss(a, t), bl(t), p & Mt) {
            try {
              ws(pl | ua, t, t.return), Pc(pl | ua, t);
            } catch (Ct) {
              Qn(t, t.return, Ct);
            }
            if (t.mode & Rt) {
              try {
                yl(), ws(ca | ua, t, t.return);
              } catch (Ct) {
                Qn(t, t.return, Ct);
              }
              gl(t);
            } else
              try {
                ws(ca | ua, t, t.return);
              } catch (Ct) {
                Qn(t, t.return, Ct);
              }
          }
          return;
        }
        case b: {
          Ss(a, t), bl(t), p & Qa && d !== null && Dp(d, d.return);
          return;
        }
        case C: {
          Ss(a, t), bl(t), p & Qa && d !== null && Dp(d, d.return);
          {
            if (t.flags & En) {
              var g = t.stateNode;
              try {
                rR(g);
              } catch (Ct) {
                Qn(t, t.return, Ct);
              }
            }
            if (p & Mt) {
              var S = t.stateNode;
              if (S != null) {
                var R = t.memoizedProps, O = d !== null ? d.memoizedProps : R, L = t.type, F = t.updateQueue;
                if (t.updateQueue = null, F !== null)
                  try {
                    JL(S, F, L, O, R, t);
                  } catch (Ct) {
                    Qn(t, t.return, Ct);
                  }
              }
            }
          }
          return;
        }
        case M: {
          if (Ss(a, t), bl(t), p & Mt) {
            if (t.stateNode === null)
              throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
            var J = t.stateNode, G = t.memoizedProps, ie = d !== null ? d.memoizedProps : G;
            try {
              ZL(J, ie, G);
            } catch (Ct) {
              Qn(t, t.return, Ct);
            }
          }
          return;
        }
        case T: {
          if (Ss(a, t), bl(t), p & Mt && d !== null) {
            var le = d.memoizedState;
            if (le.isDehydrated)
              try {
                _I(a.containerInfo);
              } catch (Ct) {
                Qn(t, t.return, Ct);
              }
          }
          return;
        }
        case k: {
          Ss(a, t), bl(t);
          return;
        }
        case K: {
          Ss(a, t), bl(t);
          var de = t.child;
          if (de.flags & tl) {
            var Be = de.stateNode, pt = de.memoizedState, lt = pt !== null;
            if (Be.isHidden = lt, lt) {
              var rn = de.alternate !== null && de.alternate.memoizedState !== null;
              rn || x$();
            }
          }
          if (p & Mt) {
            try {
              FF(t);
            } catch (Ct) {
              Qn(t, t.return, Ct);
            }
            rO(t);
          }
          return;
        }
        case Re: {
          var Kt = d !== null && d.memoizedState !== null;
          if (
            // TODO: Remove this dead flag
            t.mode & st
          ) {
            var X = $a;
            $a = X || Kt, Ss(a, t), $a = X;
          } else
            Ss(a, t);
          if (bl(t), p & tl) {
            var fe = t.stateNode, ee = t.memoizedState, Ee = ee !== null, qe = t;
            if (fe.isHidden = Ee, Ee && !Kt && (qe.mode & st) !== rt) {
              Xe = qe;
              for (var Ve = qe.child; Ve !== null;)
                Xe = Ve, VF(Ve), Ve = Ve.sibling;
            }
            PF(qe, Ee);
          }
          return;
        }
        case Ie: {
          Ss(a, t), bl(t), p & Mt && rO(t);
          return;
        }
        case Ne:
          return;
        default: {
          Ss(a, t), bl(t);
          return;
        }
      }
    }
    function bl(t) {
      var a = t.flags;
      if (a & Yn) {
        try {
          IF(t);
        } catch (l) {
          Qn(t, t.return, l);
        }
        t.flags &= ~Yn;
      }
      a & Ui && (t.flags &= ~Ui);
    }
    function BF(t, a, l) {
      jp = l, Ap = a, Xe = t, iO(t, a, l), jp = null, Ap = null;
    }
    function iO(t, a, l) {
      for (var d = (t.mode & st) !== rt; Xe !== null;) {
        var p = Xe, g = p.child;
        if (p.tag === Re && d) {
          var S = p.memoizedState !== null, R = S || Qb;
          if (R) {
            CE(t, a, l);
            continue;
          } else {
            var O = p.alternate, L = O !== null && O.memoizedState !== null, F = L || $a, J = Qb, G = $a;
            Qb = R, $a = F, $a && !G && (Xe = p, HF(p));
            for (var ie = g; ie !== null;)
              Xe = ie, iO(
                ie,
                // New root; bubble back up to here and stop.
                a,
                l
              ), ie = ie.sibling;
            Xe = p, Qb = J, $a = G, CE(t, a, l);
            continue;
          }
        }
        (p.subtreeFlags & xa) !== ht && g !== null ? (g.return = p, Xe = g) : CE(t, a, l);
      }
    }
    function CE(t, a, l) {
      for (; Xe !== null;) {
        var d = Xe;
        if ((d.flags & xa) !== ht) {
          var p = d.alternate;
          _n(d);
          try {
            AF(a, p, d, l);
          } catch (S) {
            Qn(d, d.return, S);
          }
          hr();
        }
        if (d === t) {
          Xe = null;
          return;
        }
        var g = d.sibling;
        if (g !== null) {
          g.return = d.return, Xe = g;
          return;
        }
        Xe = d.return;
      }
    }
    function VF(t) {
      for (; Xe !== null;) {
        var a = Xe, l = a.child;
        switch (a.tag) {
          case y:
          case U:
          case te:
          case re: {
            if (a.mode & Rt)
              try {
                yl(), ws(ca, a, a.return);
              } finally {
                gl(a);
              }
            else
              ws(ca, a, a.return);
            break;
          }
          case b: {
            Dp(a, a.return);
            var d = a.stateNode;
            typeof d.componentWillUnmount == "function" && SE(a, a.return, d);
            break;
          }
          case C: {
            Dp(a, a.return);
            break;
          }
          case Re: {
            var p = a.memoizedState !== null;
            if (p) {
              oO(t);
              continue;
            }
            break;
          }
        }
        l !== null ? (l.return = a, Xe = l) : oO(t);
      }
    }
    function oO(t) {
      for (; Xe !== null;) {
        var a = Xe;
        if (a === t) {
          Xe = null;
          return;
        }
        var l = a.sibling;
        if (l !== null) {
          l.return = a.return, Xe = l;
          return;
        }
        Xe = a.return;
      }
    }
    function HF(t) {
      for (; Xe !== null;) {
        var a = Xe, l = a.child;
        if (a.tag === Re) {
          var d = a.memoizedState !== null;
          if (d) {
            sO(t);
            continue;
          }
        }
        l !== null ? (l.return = a, Xe = l) : sO(t);
      }
    }
    function sO(t) {
      for (; Xe !== null;) {
        var a = Xe;
        _n(a);
        try {
          DF(a);
        } catch (d) {
          Qn(a, a.return, d);
        }
        if (hr(), a === t) {
          Xe = null;
          return;
        }
        var l = a.sibling;
        if (l !== null) {
          l.return = a.return, Xe = l;
          return;
        }
        Xe = a.return;
      }
    }
    function WF(t, a, l, d) {
      Xe = a, qF(a, t, l, d);
    }
    function qF(t, a, l, d) {
      for (; Xe !== null;) {
        var p = Xe, g = p.child;
        (p.subtreeFlags & Fi) !== ht && g !== null ? (g.return = p, Xe = g) : YF(t, a, l, d);
      }
    }
    function YF(t, a, l, d) {
      for (; Xe !== null;) {
        var p = Xe;
        if ((p.flags & er) !== ht) {
          _n(p);
          try {
            KF(a, p, l, d);
          } catch (S) {
            Qn(p, p.return, S);
          }
          hr();
        }
        if (p === t) {
          Xe = null;
          return;
        }
        var g = p.sibling;
        if (g !== null) {
          g.return = p.return, Xe = g;
          return;
        }
        Xe = p.return;
      }
    }
    function KF(t, a, l, d) {
      switch (a.tag) {
        case y:
        case U:
        case re: {
          if (a.mode & Rt) {
            H_();
            try {
              Pc(Ua | ua, a);
            } finally {
              V_(a);
            }
          } else
            Pc(Ua | ua, a);
          break;
        }
      }
    }
    function GF(t) {
      Xe = t, QF();
    }
    function QF() {
      for (; Xe !== null;) {
        var t = Xe, a = t.child;
        if ((Xe.flags & bn) !== ht) {
          var l = t.deletions;
          if (l !== null) {
            for (var d = 0; d < l.length; d++) {
              var p = l[d];
              Xe = p, XF(p, t);
            }
            {
              var g = t.alternate;
              if (g !== null) {
                var S = g.child;
                if (S !== null) {
                  g.child = null;
                  do {
                    var R = S.sibling;
                    S.sibling = null, S = R;
                  } while (S !== null);
                }
              }
            }
            Xe = t;
          }
        }
        (t.subtreeFlags & Fi) !== ht && a !== null ? (a.return = t, Xe = a) : JF();
      }
    }
    function JF() {
      for (; Xe !== null;) {
        var t = Xe;
        (t.flags & er) !== ht && (_n(t), ZF(t), hr());
        var a = t.sibling;
        if (a !== null) {
          a.return = t.return, Xe = a;
          return;
        }
        Xe = t.return;
      }
    }
    function ZF(t) {
      switch (t.tag) {
        case y:
        case U:
        case re: {
          t.mode & Rt ? (H_(), ws(Ua | ua, t, t.return), V_(t)) : ws(Ua | ua, t, t.return);
          break;
        }
      }
    }
    function XF(t, a) {
      for (; Xe !== null;) {
        var l = Xe;
        _n(l), t$(l, a), hr();
        var d = l.child;
        d !== null ? (d.return = l, Xe = d) : e$(t);
      }
    }
    function e$(t) {
      for (; Xe !== null;) {
        var a = Xe, l = a.sibling, d = a.return;
        if (Xk(a), a === t) {
          Xe = null;
          return;
        }
        if (l !== null) {
          l.return = d, Xe = l;
          return;
        }
        Xe = d;
      }
    }
    function t$(t, a) {
      switch (t.tag) {
        case y:
        case U:
        case re: {
          t.mode & Rt ? (H_(), ws(Ua, t, a), V_(t)) : ws(Ua, t, a);
          break;
        }
      }
    }
    function n$(t) {
      switch (t.tag) {
        case y:
        case U:
        case re: {
          try {
            Pc(ca | ua, t);
          } catch (l) {
            Qn(t, t.return, l);
          }
          break;
        }
        case b: {
          var a = t.stateNode;
          try {
            a.componentDidMount();
          } catch (l) {
            Qn(t, t.return, l);
          }
          break;
        }
      }
    }
    function r$(t) {
      switch (t.tag) {
        case y:
        case U:
        case re: {
          try {
            Pc(Ua | ua, t);
          } catch (a) {
            Qn(t, t.return, a);
          }
          break;
        }
      }
    }
    function a$(t) {
      switch (t.tag) {
        case y:
        case U:
        case re: {
          try {
            ws(ca | ua, t, t.return);
          } catch (l) {
            Qn(t, t.return, l);
          }
          break;
        }
        case b: {
          var a = t.stateNode;
          typeof a.componentWillUnmount == "function" && SE(t, t.return, a);
          break;
        }
      }
    }
    function i$(t) {
      switch (t.tag) {
        case y:
        case U:
        case re:
          try {
            ws(Ua | ua, t, t.return);
          } catch (a) {
            Qn(t, t.return, a);
          }
      }
    }
    if (typeof Symbol == "function" && Symbol.for) {
      var wg = Symbol.for;
      wg("selector.component"), wg("selector.has_pseudo_class"), wg("selector.role"), wg("selector.test_id"), wg("selector.text");
    }
    var o$ = [];
    function s$() {
      o$.forEach(function (t) {
        return t();
      });
    }
    var l$ = r.ReactCurrentActQueue;
    function u$(t) {
      {
        var a = (
          // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        ), l = typeof jest < "u";
        return l && a !== !1;
      }
    }
    function lO() {
      {
        var t = (
          // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        );
        return !t && l$.current !== null && f("The current testing environment is not configured to support act(...)"), t;
      }
    }
    var c$ = Math.ceil, TE = r.ReactCurrentDispatcher, RE = r.ReactCurrentOwner, Ba = r.ReactCurrentBatchConfig, _s = r.ReactCurrentActQueue, ha = (
      /*             */
      0
    ), uO = (
      /*               */
      1
    ), Va = (
      /*                */
      2
    ), $o = (
      /*                */
      4
    ), hu = 0, xg = 1, yf = 2, Zb = 3, Sg = 4, cO = 5, kE = 6, nn = ha, _i = null, Cr = null, pa = ye, wl = ye, OE = Cc(ye), ma = hu, _g = null, Xb = ye, Eg = ye, ew = ye, Cg = null, Zi = null, NE = 0, dO = 500, fO = 1 / 0, d$ = 500, pu = null;
    function Tg() {
      fO = sr() + d$;
    }
    function hO() {
      return fO;
    }
    var tw = !1, jE = null, Pp = null, bf = !1, Lc = null, Rg = ye, AE = [], DE = null, f$ = 50, kg = 0, PE = null, ME = !1, nw = !1, h$ = 50, Mp = 0, rw = null, Og = $n, aw = ye, pO = !1;
    function iw() {
      return _i;
    }
    function Ei() {
      return (nn & (Va | $o)) !== ha ? sr() : (Og !== $n || (Og = sr()), Og);
    }
    function Ic(t) {
      var a = t.mode;
      if ((a & st) === rt)
        return ft;
      if ((nn & Va) !== ha && pa !== ye)
        return oc(pa);
      var l = lU() !== sU;
      if (l) {
        if (Ba.transition !== null) {
          var d = Ba.transition;
          d._updatedFibers || (d._updatedFibers = /* @__PURE__ */ new Set()), d._updatedFibers.add(t);
        }
        return aw === Pr && (aw = g0()), aw;
      }
      var p = Hi();
      if (p !== Pr)
        return p;
      var g = qL();
      return g;
    }
    function p$(t) {
      var a = t.mode;
      return (a & st) === rt ? ft : ri();
    }
    function va(t, a, l, d) {
      U$(), pO && f("useInsertionEffect must not schedule updates."), ME && (nw = !0), Xl(t, l, d), (nn & Va) !== ye && t === _i ? z$(a) : (bi && Bh(t, a, l), B$(a), t === _i && ((nn & Va) === ha && (Eg = Pt(Eg, l)), ma === Sg && Uc(t, pa)), Xi(t, d), l === ft && nn === ha && (a.mode & st) === rt && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
        !_s.isBatchingLegacy && (Tg(), pR()));
    }
    function m$(t, a, l) {
      var d = t.current;
      d.lanes = a, Xl(t, a, l), Xi(t, l);
    }
    function v$(t) {
      return (
        // TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We
        // decided not to enable it.
        (nn & Va) !== ha
      );
    }
    function Xi(t, a) {
      var l = t.callbackNode;
      f0(t, a);
      var d = Jl(t, t === _i ? pa : ye);
      if (d === ye) {
        l !== null && NO(l), t.callbackNode = null, t.callbackPriority = Pr;
        return;
      }
      var p = Sr(d), g = t.callbackPriority;
      if (g === p && // Special case related to `act`. If the currently scheduled task is a
        // Scheduler task, rather than an `act` task, cancel it and re-scheduled
        // on the `act` queue.
        !(_s.current !== null && l !== BE)) {
        l == null && g !== ft && f("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
        return;
      }
      l != null && NO(l);
      var S;
      if (p === ft)
        t.tag === Tc ? (_s.isBatchingLegacy !== null && (_s.didScheduleLegacyUpdate = !0), HI(gO.bind(null, t))) : hR(gO.bind(null, t)), _s.current !== null ? _s.current.push(Rc) : KL(function () {
          (nn & (Va | $o)) === ha && Rc();
        }), S = null;
      else {
        var R;
        switch (la(d)) {
          case _r:
            R = mh;
            break;
          case us:
            R = Hl;
            break;
          case jo:
            R = No;
            break;
          case sc:
            R = vh;
            break;
          default:
            R = No;
            break;
        }
        S = VE(R, mO.bind(null, t));
      }
      t.callbackPriority = p, t.callbackNode = S;
    }
    function mO(t, a) {
      if (PU(), Og = $n, aw = ye, (nn & (Va | $o)) !== ha)
        throw new Error("Should not already be working.");
      var l = t.callbackNode, d = vu();
      if (d && t.callbackNode !== l)
        return null;
      var p = Jl(t, t === _i ? pa : ye);
      if (p === ye)
        return null;
      var g = !Hd(t, p) && !v0(t, p) && !a, S = g ? T$(t, p) : sw(t, p);
      if (S !== hu) {
        if (S === yf) {
          var R = ol(t);
          R !== ye && (p = R, S = LE(t, R));
        }
        if (S === xg) {
          var O = _g;
          throw wf(t, ye), Uc(t, p), Xi(t, sr()), O;
        }
        if (S === kE)
          Uc(t, p);
        else {
          var L = !Hd(t, p), F = t.current.alternate;
          if (L && !y$(F)) {
            if (S = sw(t, p), S === yf) {
              var J = ol(t);
              J !== ye && (p = J, S = LE(t, J));
            }
            if (S === xg) {
              var G = _g;
              throw wf(t, ye), Uc(t, p), Xi(t, sr()), G;
            }
          }
          t.finishedWork = F, t.finishedLanes = p, g$(t, S, p);
        }
      }
      return Xi(t, sr()), t.callbackNode === l ? mO.bind(null, t) : null;
    }
    function LE(t, a) {
      var l = Cg;
      if (Vh(t)) {
        var d = wf(t, a);
        d.flags |= pr, II(t.containerInfo);
      }
      var p = sw(t, a);
      if (p !== yf) {
        var g = Zi;
        Zi = l, g !== null && vO(g);
      }
      return p;
    }
    function vO(t) {
      Zi === null ? Zi = t : Zi.push.apply(Zi, t);
    }
    function g$(t, a, l) {
      switch (a) {
        case hu:
        case xg:
          throw new Error("Root did not complete. This is a bug in React.");
        case yf: {
          xf(t, Zi, pu);
          break;
        }
        case Zb: {
          if (Uc(t, l), h0(l) && // do not delay if we're inside an act() scope
            !jO()) {
            var d = NE + dO - sr();
            if (d > 10) {
              var p = Jl(t, ye);
              if (p !== ye)
                break;
              var g = t.suspendedLanes;
              if (!Zl(g, l)) {
                Ei(), $h(t, g);
                break;
              }
              t.timeoutHandle = DS(xf.bind(null, t, Zi, pu), d);
              break;
            }
          }
          xf(t, Zi, pu);
          break;
        }
        case Sg: {
          if (Uc(t, l), m0(l))
            break;
          if (!jO()) {
            var S = c0(t, l), R = S, O = sr() - R, L = I$(O) - O;
            if (L > 10) {
              t.timeoutHandle = DS(xf.bind(null, t, Zi, pu), L);
              break;
            }
          }
          xf(t, Zi, pu);
          break;
        }
        case cO: {
          xf(t, Zi, pu);
          break;
        }
        default:
          throw new Error("Unknown root exit status.");
      }
    }
    function y$(t) {
      for (var a = t; ;) {
        if (a.flags & Pd) {
          var l = a.updateQueue;
          if (l !== null) {
            var d = l.stores;
            if (d !== null)
              for (var p = 0; p < d.length; p++) {
                var g = d[p], S = g.getSnapshot, R = g.value;
                try {
                  if (!Ze(S(), R))
                    return !1;
                } catch {
                  return !1;
                }
              }
          }
        }
        var O = a.child;
        if (a.subtreeFlags & Pd && O !== null) {
          O.return = a, a = O;
          continue;
        }
        if (a === t)
          return !0;
        for (; a.sibling === null;) {
          if (a.return === null || a.return === t)
            return !0;
          a = a.return;
        }
        a.sibling.return = a.return, a = a.sibling;
      }
      return !0;
    }
    function Uc(t, a) {
      a = Wd(a, ew), a = Wd(a, Eg), b0(t, a);
    }
    function gO(t) {
      if (MU(), (nn & (Va | $o)) !== ha)
        throw new Error("Should not already be working.");
      vu();
      var a = Jl(t, ye);
      if (!ai(a, ft))
        return Xi(t, sr()), null;
      var l = sw(t, a);
      if (t.tag !== Tc && l === yf) {
        var d = ol(t);
        d !== ye && (a = d, l = LE(t, d));
      }
      if (l === xg) {
        var p = _g;
        throw wf(t, ye), Uc(t, a), Xi(t, sr()), p;
      }
      if (l === kE)
        throw new Error("Root did not complete. This is a bug in React.");
      var g = t.current.alternate;
      return t.finishedWork = g, t.finishedLanes = a, xf(t, Zi, pu), Xi(t, sr()), null;
    }
    function b$(t, a) {
      a !== ye && (bv(t, Pt(a, ft)), Xi(t, sr()), (nn & (Va | $o)) === ha && (Tg(), Rc()));
    }
    function IE(t, a) {
      var l = nn;
      nn |= uO;
      try {
        return t(a);
      } finally {
        nn = l, nn === ha && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
          !_s.isBatchingLegacy && (Tg(), pR());
      }
    }
    function w$(t, a, l, d, p) {
      var g = Hi(), S = Ba.transition;
      try {
        return Ba.transition = null, mr(_r), t(a, l, d, p);
      } finally {
        mr(g), Ba.transition = S, nn === ha && Tg();
      }
    }
    function mu(t) {
      Lc !== null && Lc.tag === Tc && (nn & (Va | $o)) === ha && vu();
      var a = nn;
      nn |= uO;
      var l = Ba.transition, d = Hi();
      try {
        return Ba.transition = null, mr(_r), t ? t() : void 0;
      } finally {
        mr(d), Ba.transition = l, nn = a, (nn & (Va | $o)) === ha && Rc();
      }
    }
    function yO() {
      return (nn & (Va | $o)) !== ha;
    }
    function ow(t, a) {
      si(OE, wl, t), wl = Pt(wl, a);
    }
    function UE(t) {
      wl = OE.current, oi(OE, t);
    }
    function wf(t, a) {
      t.finishedWork = null, t.finishedLanes = ye;
      var l = t.timeoutHandle;
      if (l !== PS && (t.timeoutHandle = PS, YL(l)), Cr !== null)
        for (var d = Cr.return; d !== null;) {
          var p = d.alternate;
          Yk(p, d), d = d.return;
        }
      _i = t;
      var g = Sf(t.current, null);
      return Cr = g, pa = wl = a, ma = hu, _g = null, Xb = ye, Eg = ye, ew = ye, Cg = null, Zi = null, mU(), ms.discardPendingWarnings(), g;
    }
    function bO(t, a) {
      do {
        var l = Cr;
        try {
          if (vb(), VR(), hr(), RE.current = null, l === null || l.return === null) {
            ma = xg, _g = a, Cr = null;
            return;
          }
          if (xt && l.mode & Rt && Wb(l, !0), ut)
            if (ti(), a !== null && typeof a == "object" && typeof a.then == "function") {
              var d = a;
              ql(l, d, pa);
            } else
              Id(l, a, pa);
          HU(t, l.return, l, a, pa), _O(l);
        } catch (p) {
          a = p, Cr === l && l !== null ? (l = l.return, Cr = l) : l = Cr;
          continue;
        }
        return;
      } while (!0);
    }
    function wO() {
      var t = TE.current;
      return TE.current = $b, t === null ? $b : t;
    }
    function xO(t) {
      TE.current = t;
    }
    function x$() {
      NE = sr();
    }
    function Ng(t) {
      Xb = Pt(t, Xb);
    }
    function S$() {
      ma === hu && (ma = Zb);
    }
    function FE() {
      (ma === hu || ma === Zb || ma === yf) && (ma = Sg), _i !== null && (Vd(Xb) || Vd(Eg)) && Uc(_i, pa);
    }
    function _$(t) {
      ma !== Sg && (ma = yf), Cg === null ? Cg = [t] : Cg.push(t);
    }
    function E$() {
      return ma === hu;
    }
    function sw(t, a) {
      var l = nn;
      nn |= Va;
      var d = wO();
      if (_i !== t || pa !== a) {
        if (bi) {
          var p = t.memoizedUpdaters;
          p.size > 0 && (jg(t, pa), p.clear()), wv(t, a);
        }
        pu = Yd(), wf(t, a);
      }
      tr(a);
      do
        try {
          C$();
          break;
        } catch (g) {
          bO(t, g);
        }
      while (!0);
      if (vb(), nn = l, xO(d), Cr !== null)
        throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
      return xh(), _i = null, pa = ye, ma;
    }
    function C$() {
      for (; Cr !== null;)
        SO(Cr);
    }
    function T$(t, a) {
      var l = nn;
      nn |= Va;
      var d = wO();
      if (_i !== t || pa !== a) {
        if (bi) {
          var p = t.memoizedUpdaters;
          p.size > 0 && (jg(t, pa), p.clear()), wv(t, a);
        }
        pu = Yd(), Tg(), wf(t, a);
      }
      tr(a);
      do
        try {
          R$();
          break;
        } catch (g) {
          bO(t, g);
        }
      while (!0);
      return vb(), xO(d), nn = l, Cr !== null ? (wh(), hu) : (xh(), _i = null, pa = ye, ma);
    }
    function R$() {
      for (; Cr !== null && !ph();)
        SO(Cr);
    }
    function SO(t) {
      var a = t.alternate;
      _n(t);
      var l;
      (t.mode & Rt) !== rt ? (B_(t), l = $E(a, t, wl), Wb(t, !0)) : l = $E(a, t, wl), hr(), t.memoizedProps = t.pendingProps, l === null ? _O(t) : Cr = l, RE.current = null;
    }
    function _O(t) {
      var a = t;
      do {
        var l = a.alternate, d = a.return;
        if ((a.flags & vi) === ht) {
          _n(a);
          var p = void 0;
          if ((a.mode & Rt) === rt ? p = qk(l, a, wl) : (B_(a), p = qk(l, a, wl), Wb(a, !1)), hr(), p !== null) {
            Cr = p;
            return;
          }
        } else {
          var g = SF(l, a);
          if (g !== null) {
            g.flags &= Xy, Cr = g;
            return;
          }
          if ((a.mode & Rt) !== rt) {
            Wb(a, !1);
            for (var S = a.actualDuration, R = a.child; R !== null;)
              S += R.actualDuration, R = R.sibling;
            a.actualDuration = S;
          }
          if (d !== null)
            d.flags |= vi, d.subtreeFlags = ht, d.deletions = null;
          else {
            ma = kE, Cr = null;
            return;
          }
        }
        var O = a.sibling;
        if (O !== null) {
          Cr = O;
          return;
        }
        a = d, Cr = a;
      } while (a !== null);
      ma === hu && (ma = cO);
    }
    function xf(t, a, l) {
      var d = Hi(), p = Ba.transition;
      try {
        Ba.transition = null, mr(_r), k$(t, a, l, d);
      } finally {
        Ba.transition = p, mr(d);
      }
      return null;
    }
    function k$(t, a, l, d) {
      do
        vu();
      while (Lc !== null);
      if (F$(), (nn & (Va | $o)) !== ha)
        throw new Error("Should not already be working.");
      var p = t.finishedWork, g = t.finishedLanes;
      if (rl(g), p === null)
        return gh(), null;
      if (g === ye && f("root.finishedLanes should not be empty during a commit. This is a bug in React."), t.finishedWork = null, t.finishedLanes = ye, p === t.current)
        throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
      t.callbackNode = null, t.callbackPriority = Pr;
      var S = Pt(p.lanes, p.childLanes);
      zh(t, S), t === _i && (_i = null, Cr = null, pa = ye), ((p.subtreeFlags & Fi) !== ht || (p.flags & Fi) !== ht) && (bf || (bf = !0, DE = l, VE(No, function () {
        return vu(), null;
      })));
      var R = (p.subtreeFlags & (Yu | Xa | xa | Fi)) !== ht, O = (p.flags & (Yu | Xa | xa | Fi)) !== ht;
      if (R || O) {
        var L = Ba.transition;
        Ba.transition = null;
        var F = Hi();
        mr(_r);
        var J = nn;
        nn |= $o, RE.current = null, RF(t, p), pk(), zF(t, p, g), $L(t.containerInfo), t.current = p, dv(g), BF(p, t, g), Zu(), n0(), nn = J, mr(F), Ba.transition = L;
      } else
        t.current = p, pk();
      var G = bf;
      if (bf ? (bf = !1, Lc = t, Rg = g) : (Mp = 0, rw = null), S = t.pendingLanes, S === ye && (Pp = null), G || RO(t.current, !1), Gu(p.stateNode, d), bi && t.memoizedUpdaters.clear(), s$(), Xi(t, sr()), a !== null)
        for (var ie = t.onRecoverableError, le = 0; le < a.length; le++) {
          var de = a[le], Be = de.stack, pt = de.digest;
          ie(de.value, {
            componentStack: Be,
            digest: pt
          });
        }
      if (tw) {
        tw = !1;
        var lt = jE;
        throw jE = null, lt;
      }
      return ai(Rg, ft) && t.tag !== Tc && vu(), S = t.pendingLanes, ai(S, ft) ? (DU(), t === PE ? kg++ : (kg = 0, PE = t)) : kg = 0, Rc(), gh(), null;
    }
    function vu() {
      if (Lc !== null) {
        var t = la(Rg), a = aS(jo, t), l = Ba.transition, d = Hi();
        try {
          return Ba.transition = null, mr(a), N$();
        } finally {
          mr(d), Ba.transition = l;
        }
      }
      return !1;
    }
    function O$(t) {
      AE.push(t), bf || (bf = !0, VE(No, function () {
        return vu(), null;
      }));
    }
    function N$() {
      if (Lc === null)
        return !1;
      var t = DE;
      DE = null;
      var a = Lc, l = Rg;
      if (Lc = null, Rg = ye, (nn & (Va | $o)) !== ha)
        throw new Error("Cannot flush passive effects while already rendering.");
      ME = !0, nw = !1, l0(l);
      var d = nn;
      nn |= $o, GF(a.current), WF(a, a.current, l, t);
      {
        var p = AE;
        AE = [];
        for (var g = 0; g < p.length; g++) {
          var S = p[g];
          jF(a, S);
        }
      }
      fv(), RO(a.current, !0), nn = d, Rc(), nw ? a === rw ? Mp++ : (Mp = 0, rw = a) : Mp = 0, ME = !1, nw = !1, Bi(a);
      {
        var R = a.current.stateNode;
        R.effectDuration = 0, R.passiveEffectDuration = 0;
      }
      return !0;
    }
    function EO(t) {
      return Pp !== null && Pp.has(t);
    }
    function j$(t) {
      Pp === null ? Pp = /* @__PURE__ */ new Set([t]) : Pp.add(t);
    }
    function A$(t) {
      tw || (tw = !0, jE = t);
    }
    var D$ = A$;
    function CO(t, a, l) {
      var d = vf(l, a), p = Sk(t, d, ft), g = Oc(t, p, ft), S = Ei();
      g !== null && (Xl(g, ft, S), Xi(g, S));
    }
    function Qn(t, a, l) {
      if (EF(l), Ag(!1), t.tag === T) {
        CO(t, t, l);
        return;
      }
      var d = null;
      for (d = a; d !== null;) {
        if (d.tag === T) {
          CO(d, t, l);
          return;
        } else if (d.tag === b) {
          var p = d.type, g = d.stateNode;
          if (typeof p.getDerivedStateFromError == "function" || typeof g.componentDidCatch == "function" && !EO(g)) {
            var S = vf(l, t), R = oE(d, S, ft), O = Oc(d, R, ft), L = Ei();
            O !== null && (Xl(O, ft, L), Xi(O, L));
            return;
          }
        }
        d = d.return;
      }
      f(`Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`, l);
    }
    function P$(t, a, l) {
      var d = t.pingCache;
      d !== null && d.delete(a);
      var p = Ei();
      $h(t, l), V$(t), _i === t && Zl(pa, l) && (ma === Sg || ma === Zb && h0(pa) && sr() - NE < dO ? wf(t, ye) : ew = Pt(ew, l)), Xi(t, p);
    }
    function TO(t, a) {
      a === Pr && (a = p$(t));
      var l = Ei(), d = Qi(t, a);
      d !== null && (Xl(d, a, l), Xi(d, l));
    }
    function M$(t) {
      var a = t.memoizedState, l = Pr;
      a !== null && (l = a.retryLane), TO(t, l);
    }
    function L$(t, a) {
      var l = Pr, d;
      switch (t.tag) {
        case K:
          d = t.stateNode;
          var p = t.memoizedState;
          p !== null && (l = p.retryLane);
          break;
        case Ie:
          d = t.stateNode;
          break;
        default:
          throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
      }
      d !== null && d.delete(a), TO(t, l);
    }
    function I$(t) {
      return t < 120 ? 120 : t < 480 ? 480 : t < 1080 ? 1080 : t < 1920 ? 1920 : t < 3e3 ? 3e3 : t < 4320 ? 4320 : c$(t / 1960) * 1960;
    }
    function U$() {
      if (kg > f$)
        throw kg = 0, PE = null, new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
      Mp > h$ && (Mp = 0, rw = null, f("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."));
    }
    function F$() {
      ms.flushLegacyContextWarning(), ms.flushPendingUnsafeLifecycleWarnings();
    }
    function RO(t, a) {
      _n(t), lw(t, Za, a$), a && lw(t, Vl, i$), lw(t, Za, n$), a && lw(t, Vl, r$), hr();
    }
    function lw(t, a, l) {
      for (var d = t, p = null; d !== null;) {
        var g = d.subtreeFlags & a;
        d !== p && d.child !== null && g !== ht ? d = d.child : ((d.flags & a) !== ht && l(d), d.sibling !== null ? d = d.sibling : d = p = d.return);
      }
    }
    var uw = null;
    function kO(t) {
      {
        if ((nn & Va) !== ha || !(t.mode & st))
          return;
        var a = t.tag;
        if (a !== _ && a !== T && a !== b && a !== y && a !== U && a !== te && a !== re)
          return;
        var l = Ot(t) || "ReactComponent";
        if (uw !== null) {
          if (uw.has(l))
            return;
          uw.add(l);
        } else
          uw = /* @__PURE__ */ new Set([l]);
        var d = or;
        try {
          _n(t), f("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
        } finally {
          d ? _n(t) : hr();
        }
      }
    }
    var $E;
    {
      var $$ = null;
      $E = function (t, a, l) {
        var d = LO($$, a);
        try {
          return zk(t, a, l);
        } catch (g) {
          if (ZI() || g !== null && typeof g == "object" && typeof g.then == "function")
            throw g;
          if (vb(), VR(), Yk(t, a), LO(a, d), a.mode & Rt && B_(a), Bl(null, zk, null, t, a, l), Xx()) {
            var p = nv();
            typeof p == "object" && p !== null && p._suppressLogging && typeof g == "object" && g !== null && !g._suppressLogging && (g._suppressLogging = !0);
          }
          throw g;
        }
      };
    }
    var OO = !1, zE;
    zE = /* @__PURE__ */ new Set();
    function z$(t) {
      if (Ya && !NU())
        switch (t.tag) {
          case y:
          case U:
          case re: {
            var a = Cr && Ot(Cr) || "Unknown", l = a;
            if (!zE.has(l)) {
              zE.add(l);
              var d = Ot(t) || "Unknown";
              f("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", d, a, a);
            }
            break;
          }
          case b: {
            OO || (f("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), OO = !0);
            break;
          }
        }
    }
    function jg(t, a) {
      if (bi) {
        var l = t.memoizedUpdaters;
        l.forEach(function (d) {
          Bh(t, d, a);
        });
      }
    }
    var BE = {};
    function VE(t, a) {
      {
        var l = _s.current;
        return l !== null ? (l.push(a), BE) : hh(t, a);
      }
    }
    function NO(t) {
      if (t !== BE)
        return t0(t);
    }
    function jO() {
      return _s.current !== null;
    }
    function B$(t) {
      {
        if (t.mode & st) {
          if (!lO())
            return;
        } else if (!u$() || nn !== ha || t.tag !== y && t.tag !== U && t.tag !== re)
          return;
        if (_s.current === null) {
          var a = or;
          try {
            _n(t), f(`An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`, Ot(t));
          } finally {
            a ? _n(t) : hr();
          }
        }
      }
    }
    function V$(t) {
      t.tag !== Tc && lO() && _s.current === null && f(`A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`);
    }
    function Ag(t) {
      pO = t;
    }
    var zo = null, Lp = null, H$ = function (t) {
      zo = t;
    };
    function Ip(t) {
      {
        if (zo === null)
          return t;
        var a = zo(t);
        return a === void 0 ? t : a.current;
      }
    }
    function HE(t) {
      return Ip(t);
    }
    function WE(t) {
      {
        if (zo === null)
          return t;
        var a = zo(t);
        if (a === void 0) {
          if (t != null && typeof t.render == "function") {
            var l = Ip(t.render);
            if (t.render !== l) {
              var d = {
                $$typeof: Te,
                render: l
              };
              return t.displayName !== void 0 && (d.displayName = t.displayName), d;
            }
          }
          return t;
        }
        return a.current;
      }
    }
    function AO(t, a) {
      {
        if (zo === null)
          return !1;
        var l = t.elementType, d = a.type, p = !1, g = typeof d == "object" && d !== null ? d.$$typeof : null;
        switch (t.tag) {
          case b: {
            typeof d == "function" && (p = !0);
            break;
          }
          case y: {
            (typeof d == "function" || g === yt) && (p = !0);
            break;
          }
          case U: {
            (g === Te || g === yt) && (p = !0);
            break;
          }
          case te:
          case re: {
            (g === Qt || g === yt) && (p = !0);
            break;
          }
          default:
            return !1;
        }
        if (p) {
          var S = zo(l);
          if (S !== void 0 && S === zo(d))
            return !0;
        }
        return !1;
      }
    }
    function DO(t) {
      {
        if (zo === null || typeof WeakSet != "function")
          return;
        Lp === null && (Lp = /* @__PURE__ */ new WeakSet()), Lp.add(t);
      }
    }
    var W$ = function (t, a) {
      {
        if (zo === null)
          return;
        var l = a.staleFamilies, d = a.updatedFamilies;
        vu(), mu(function () {
          qE(t.current, d, l);
        });
      }
    }, q$ = function (t, a) {
      {
        if (t.context !== ho)
          return;
        vu(), mu(function () {
          Dg(a, t, null, null);
        });
      }
    };
    function qE(t, a, l) {
      {
        var d = t.alternate, p = t.child, g = t.sibling, S = t.tag, R = t.type, O = null;
        switch (S) {
          case y:
          case re:
          case b:
            O = R;
            break;
          case U:
            O = R.render;
            break;
        }
        if (zo === null)
          throw new Error("Expected resolveFamily to be set during hot reload.");
        var L = !1, F = !1;
        if (O !== null) {
          var J = zo(O);
          J !== void 0 && (l.has(J) ? F = !0 : a.has(J) && (S === b ? F = !0 : L = !0));
        }
        if (Lp !== null && (Lp.has(t) || d !== null && Lp.has(d)) && (F = !0), F && (t._debugNeedsRemount = !0), F || L) {
          var G = Qi(t, ft);
          G !== null && va(G, t, ft, $n);
        }
        p !== null && !F && qE(p, a, l), g !== null && qE(g, a, l);
      }
    }
    var Y$ = function (t, a) {
      {
        var l = /* @__PURE__ */ new Set(), d = new Set(a.map(function (p) {
          return p.current;
        }));
        return YE(t.current, d, l), l;
      }
    };
    function YE(t, a, l) {
      {
        var d = t.child, p = t.sibling, g = t.tag, S = t.type, R = null;
        switch (g) {
          case y:
          case re:
          case b:
            R = S;
            break;
          case U:
            R = S.render;
            break;
        }
        var O = !1;
        R !== null && a.has(R) && (O = !0), O ? K$(t, l) : d !== null && YE(d, a, l), p !== null && YE(p, a, l);
      }
    }
    function K$(t, a) {
      {
        var l = G$(t, a);
        if (l)
          return;
        for (var d = t; ;) {
          switch (d.tag) {
            case C:
              a.add(d.stateNode);
              return;
            case k:
              a.add(d.stateNode.containerInfo);
              return;
            case T:
              a.add(d.stateNode.containerInfo);
              return;
          }
          if (d.return === null)
            throw new Error("Expected to reach root first.");
          d = d.return;
        }
      }
    }
    function G$(t, a) {
      for (var l = t, d = !1; ;) {
        if (l.tag === C)
          d = !0, a.add(l.stateNode);
        else if (l.child !== null) {
          l.child.return = l, l = l.child;
          continue;
        }
        if (l === t)
          return d;
        for (; l.sibling === null;) {
          if (l.return === null || l.return === t)
            return d;
          l = l.return;
        }
        l.sibling.return = l.return, l = l.sibling;
      }
      return !1;
    }
    var KE;
    {
      KE = !1;
      try {
        var PO = Object.preventExtensions({});
      } catch {
        KE = !0;
      }
    }
    function Q$(t, a, l, d) {
      this.tag = t, this.key = l, this.elementType = null, this.type = null, this.stateNode = null, this.return = null, this.child = null, this.sibling = null, this.index = 0, this.ref = null, this.pendingProps = a, this.memoizedProps = null, this.updateQueue = null, this.memoizedState = null, this.dependencies = null, this.mode = d, this.flags = ht, this.subtreeFlags = ht, this.deletions = null, this.lanes = ye, this.childLanes = ye, this.alternate = null, this.actualDuration = Number.NaN, this.actualStartTime = Number.NaN, this.selfBaseDuration = Number.NaN, this.treeBaseDuration = Number.NaN, this.actualDuration = 0, this.actualStartTime = -1, this.selfBaseDuration = 0, this.treeBaseDuration = 0, this._debugSource = null, this._debugOwner = null, this._debugNeedsRemount = !1, this._debugHookTypes = null, !KE && typeof Object.preventExtensions == "function" && Object.preventExtensions(this);
    }
    var po = function (t, a, l, d) {
      return new Q$(t, a, l, d);
    };
    function GE(t) {
      var a = t.prototype;
      return !!(a && a.isReactComponent);
    }
    function J$(t) {
      return typeof t == "function" && !GE(t) && t.defaultProps === void 0;
    }
    function Z$(t) {
      if (typeof t == "function")
        return GE(t) ? b : y;
      if (t != null) {
        var a = t.$$typeof;
        if (a === Te)
          return U;
        if (a === Qt)
          return te;
      }
      return _;
    }
    function Sf(t, a) {
      var l = t.alternate;
      l === null ? (l = po(t.tag, a, t.key, t.mode), l.elementType = t.elementType, l.type = t.type, l.stateNode = t.stateNode, l._debugSource = t._debugSource, l._debugOwner = t._debugOwner, l._debugHookTypes = t._debugHookTypes, l.alternate = t, t.alternate = l) : (l.pendingProps = a, l.type = t.type, l.flags = ht, l.subtreeFlags = ht, l.deletions = null, l.actualDuration = 0, l.actualStartTime = -1), l.flags = t.flags & oa, l.childLanes = t.childLanes, l.lanes = t.lanes, l.child = t.child, l.memoizedProps = t.memoizedProps, l.memoizedState = t.memoizedState, l.updateQueue = t.updateQueue;
      var d = t.dependencies;
      switch (l.dependencies = d === null ? null : {
        lanes: d.lanes,
        firstContext: d.firstContext
      }, l.sibling = t.sibling, l.index = t.index, l.ref = t.ref, l.selfBaseDuration = t.selfBaseDuration, l.treeBaseDuration = t.treeBaseDuration, l._debugNeedsRemount = t._debugNeedsRemount, l.tag) {
        case _:
        case y:
        case re:
          l.type = Ip(t.type);
          break;
        case b:
          l.type = HE(t.type);
          break;
        case U:
          l.type = WE(t.type);
          break;
      }
      return l;
    }
    function X$(t, a) {
      t.flags &= oa | Yn;
      var l = t.alternate;
      if (l === null)
        t.childLanes = ye, t.lanes = a, t.child = null, t.subtreeFlags = ht, t.memoizedProps = null, t.memoizedState = null, t.updateQueue = null, t.dependencies = null, t.stateNode = null, t.selfBaseDuration = 0, t.treeBaseDuration = 0;
      else {
        t.childLanes = l.childLanes, t.lanes = l.lanes, t.child = l.child, t.subtreeFlags = ht, t.deletions = null, t.memoizedProps = l.memoizedProps, t.memoizedState = l.memoizedState, t.updateQueue = l.updateQueue, t.type = l.type;
        var d = l.dependencies;
        t.dependencies = d === null ? null : {
          lanes: d.lanes,
          firstContext: d.firstContext
        }, t.selfBaseDuration = l.selfBaseDuration, t.treeBaseDuration = l.treeBaseDuration;
      }
      return t;
    }
    function ez(t, a, l) {
      var d;
      return t === ob ? (d = st, a === !0 && (d |= Bt, d |= wi)) : d = rt, bi && (d |= Rt), po(T, null, null, d);
    }
    function QE(t, a, l, d, p, g) {
      var S = _, R = t;
      if (typeof t == "function")
        GE(t) ? (S = b, R = HE(R)) : R = Ip(R);
      else if (typeof t == "string")
        S = C;
      else
        e: switch (t) {
          case mi:
            return Fc(l.children, p, g, a);
          case _o:
            S = A, p |= Bt, (p & st) !== rt && (p |= wi);
            break;
          case Eo:
            return tz(l, p, g, a);
          case ot:
            return nz(l, p, g, a);
          case Wt:
            return rz(l, p, g, a);
          case Dn:
            return MO(l, p, g, a);
          case qn:
          case Ut:
          case wa:
          case Co:
          case jr:
          default: {
            if (typeof t == "object" && t !== null)
              switch (t.$$typeof) {
                case H:
                  S = I;
                  break e;
                case xe:
                  S = $;
                  break e;
                case Te:
                  S = U, R = WE(R);
                  break e;
                case Qt:
                  S = te;
                  break e;
                case yt:
                  S = ve, R = null;
                  break e;
              }
            var O = "";
            {
              (t === void 0 || typeof t == "object" && t !== null && Object.keys(t).length === 0) && (O += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
              var L = d ? Ot(d) : null;
              L && (O += `

Check the render method of \`` + L + "`.");
            }
            throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (t == null ? t : typeof t) + "." + O));
          }
        }
      var F = po(S, l, a, p);
      return F.elementType = t, F.type = R, F.lanes = g, F._debugOwner = d, F;
    }
    function JE(t, a, l) {
      var d = null;
      d = t._owner;
      var p = t.type, g = t.key, S = t.props, R = QE(p, g, S, d, a, l);
      return R._debugSource = t._source, R._debugOwner = t._owner, R;
    }
    function Fc(t, a, l, d) {
      var p = po(N, t, d, a);
      return p.lanes = l, p;
    }
    function tz(t, a, l, d) {
      typeof t.id != "string" && f('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof t.id);
      var p = po(B, t, d, a | Rt);
      return p.elementType = Eo, p.lanes = l, p.stateNode = {
        effectDuration: 0,
        passiveEffectDuration: 0
      }, p;
    }
    function nz(t, a, l, d) {
      var p = po(K, t, d, a);
      return p.elementType = ot, p.lanes = l, p;
    }
    function rz(t, a, l, d) {
      var p = po(Ie, t, d, a);
      return p.elementType = Wt, p.lanes = l, p;
    }
    function MO(t, a, l, d) {
      var p = po(Re, t, d, a);
      p.elementType = Dn, p.lanes = l;
      var g = {
        isHidden: !1
      };
      return p.stateNode = g, p;
    }
    function ZE(t, a, l) {
      var d = po(M, t, null, a);
      return d.lanes = l, d;
    }
    function az() {
      var t = po(C, null, null, rt);
      return t.elementType = "DELETED", t;
    }
    function iz(t) {
      var a = po(ke, null, null, rt);
      return a.stateNode = t, a;
    }
    function XE(t, a, l) {
      var d = t.children !== null ? t.children : [], p = po(k, d, t.key, a);
      return p.lanes = l, p.stateNode = {
        containerInfo: t.containerInfo,
        pendingChildren: null,
        // Used by persistent updates
        implementation: t.implementation
      }, p;
    }
    function LO(t, a) {
      return t === null && (t = po(_, null, null, rt)), t.tag = a.tag, t.key = a.key, t.elementType = a.elementType, t.type = a.type, t.stateNode = a.stateNode, t.return = a.return, t.child = a.child, t.sibling = a.sibling, t.index = a.index, t.ref = a.ref, t.pendingProps = a.pendingProps, t.memoizedProps = a.memoizedProps, t.updateQueue = a.updateQueue, t.memoizedState = a.memoizedState, t.dependencies = a.dependencies, t.mode = a.mode, t.flags = a.flags, t.subtreeFlags = a.subtreeFlags, t.deletions = a.deletions, t.lanes = a.lanes, t.childLanes = a.childLanes, t.alternate = a.alternate, t.actualDuration = a.actualDuration, t.actualStartTime = a.actualStartTime, t.selfBaseDuration = a.selfBaseDuration, t.treeBaseDuration = a.treeBaseDuration, t._debugSource = a._debugSource, t._debugOwner = a._debugOwner, t._debugNeedsRemount = a._debugNeedsRemount, t._debugHookTypes = a._debugHookTypes, t;
    }
    function oz(t, a, l, d, p) {
      this.tag = a, this.containerInfo = t, this.pendingChildren = null, this.current = null, this.pingCache = null, this.finishedWork = null, this.timeoutHandle = PS, this.context = null, this.pendingContext = null, this.callbackNode = null, this.callbackPriority = Pr, this.eventTimes = qd(ye), this.expirationTimes = qd($n), this.pendingLanes = ye, this.suspendedLanes = ye, this.pingedLanes = ye, this.expiredLanes = ye, this.mutableReadLanes = ye, this.finishedLanes = ye, this.entangledLanes = ye, this.entanglements = qd(ye), this.identifierPrefix = d, this.onRecoverableError = p, this.mutableSourceEagerHydrationData = null, this.effectDuration = 0, this.passiveEffectDuration = 0;
      {
        this.memoizedUpdaters = /* @__PURE__ */ new Set();
        for (var g = this.pendingUpdatersLaneMap = [], S = 0; S < $d; S++)
          g.push(/* @__PURE__ */ new Set());
      }
      switch (a) {
        case ob:
          this._debugRootType = l ? "hydrateRoot()" : "createRoot()";
          break;
        case Tc:
          this._debugRootType = l ? "hydrate()" : "render()";
          break;
      }
    }
    function IO(t, a, l, d, p, g, S, R, O, L) {
      var F = new oz(t, a, l, R, O), J = ez(a, g);
      F.current = J, J.stateNode = F;
      {
        var G = {
          element: d,
          isDehydrated: l,
          cache: null,
          // not enabled yet
          transitions: null,
          pendingSuspenseBoundaries: null
        };
        J.memoizedState = G;
      }
      return f_(J), F;
    }
    var eC = "18.3.1";
    function sz(t, a, l) {
      var d = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      return br(d), {
        // This tag allow us to uniquely identify this as a React Portal
        $$typeof: Na,
        key: d == null ? null : "" + d,
        children: t,
        containerInfo: a,
        implementation: l
      };
    }
    var tC, nC;
    tC = !1, nC = {};
    function UO(t) {
      if (!t)
        return ho;
      var a = Li(t), l = VI(a);
      if (a.tag === b) {
        var d = a.type;
        if (hl(d))
          return dR(a, d, l);
      }
      return l;
    }
    function lz(t, a) {
      {
        var l = Li(t);
        if (l === void 0) {
          if (typeof t.render == "function")
            throw new Error("Unable to find node on an unmounted component.");
          var d = Object.keys(t).join(",");
          throw new Error("Argument appears to not be a ReactComponent. Keys: " + d);
        }
        var p = $i(l);
        if (p === null)
          return null;
        if (p.mode & Bt) {
          var g = Ot(l) || "Component";
          if (!nC[g]) {
            nC[g] = !0;
            var S = or;
            try {
              _n(p), l.mode & Bt ? f("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", a, a, g) : f("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", a, a, g);
            } finally {
              S ? _n(S) : hr();
            }
          }
        }
        return p.stateNode;
      }
    }
    function FO(t, a, l, d, p, g, S, R) {
      var O = !1, L = null;
      return IO(t, a, O, L, l, d, p, g, S);
    }
    function $O(t, a, l, d, p, g, S, R, O, L) {
      var F = !0, J = IO(l, d, F, t, p, g, S, R, O);
      J.context = UO(null);
      var G = J.current, ie = Ei(), le = Ic(G), de = du(ie, le);
      return de.callback = a ?? null, Oc(G, de, le), m$(J, le, ie), J;
    }
    function Dg(t, a, l, d) {
      cv(a, t);
      var p = a.current, g = Ei(), S = Ic(p);
      hv(S);
      var R = UO(l);
      a.context === null ? a.context = R : a.pendingContext = R, Ya && or !== null && !tC && (tC = !0, f(`Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`, Ot(or) || "Unknown"));
      var O = du(g, S);
      O.payload = {
        element: t
      }, d = d === void 0 ? null : d, d !== null && (typeof d != "function" && f("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", d), O.callback = d);
      var L = Oc(p, O, S);
      return L !== null && (va(L, p, S, g), xb(L, p, S)), S;
    }
    function cw(t) {
      var a = t.current;
      if (!a.child)
        return null;
      switch (a.child.tag) {
        case C:
          return a.child.stateNode;
        default:
          return a.child.stateNode;
      }
    }
    function uz(t) {
      switch (t.tag) {
        case T: {
          var a = t.stateNode;
          if (Vh(a)) {
            var l = vv(a);
            b$(a, l);
          }
          break;
        }
        case K: {
          mu(function () {
            var p = Qi(t, ft);
            if (p !== null) {
              var g = Ei();
              va(p, t, ft, g);
            }
          });
          var d = ft;
          rC(t, d);
          break;
        }
      }
    }
    function zO(t, a) {
      var l = t.memoizedState;
      l !== null && l.dehydrated !== null && (l.retryLane = y0(l.retryLane, a));
    }
    function rC(t, a) {
      zO(t, a);
      var l = t.alternate;
      l && zO(l, a);
    }
    function cz(t) {
      if (t.tag === K) {
        var a = Bd, l = Qi(t, a);
        if (l !== null) {
          var d = Ei();
          va(l, t, a, d);
        }
        rC(t, a);
      }
    }
    function dz(t) {
      if (t.tag === K) {
        var a = Ic(t), l = Qi(t, a);
        if (l !== null) {
          var d = Ei();
          va(l, t, a, d);
        }
        rC(t, a);
      }
    }
    function BO(t) {
      var a = e0(t);
      return a === null ? null : a.stateNode;
    }
    var VO = function (t) {
      return null;
    };
    function fz(t) {
      return VO(t);
    }
    var HO = function (t) {
      return !1;
    };
    function hz(t) {
      return HO(t);
    }
    var WO = null, qO = null, YO = null, KO = null, GO = null, QO = null, JO = null, ZO = null, XO = null;
    {
      var eN = function (t, a, l) {
        var d = a[l], p = Zt(t) ? t.slice() : Ft({}, t);
        return l + 1 === a.length ? (Zt(p) ? p.splice(d, 1) : delete p[d], p) : (p[d] = eN(t[d], a, l + 1), p);
      }, tN = function (t, a) {
        return eN(t, a, 0);
      }, nN = function (t, a, l, d) {
        var p = a[d], g = Zt(t) ? t.slice() : Ft({}, t);
        if (d + 1 === a.length) {
          var S = l[d];
          g[S] = g[p], Zt(g) ? g.splice(p, 1) : delete g[p];
        } else
          g[p] = nN(
            // $FlowFixMe number or string is fine here
            t[p],
            a,
            l,
            d + 1
          );
        return g;
      }, rN = function (t, a, l) {
        if (a.length !== l.length) {
          c("copyWithRename() expects paths of the same length");
          return;
        } else
          for (var d = 0; d < l.length - 1; d++)
            if (a[d] !== l[d]) {
              c("copyWithRename() expects paths to be the same except for the deepest key");
              return;
            }
        return nN(t, a, l, 0);
      }, aN = function (t, a, l, d) {
        if (l >= a.length)
          return d;
        var p = a[l], g = Zt(t) ? t.slice() : Ft({}, t);
        return g[p] = aN(t[p], a, l + 1, d), g;
      }, iN = function (t, a, l) {
        return aN(t, a, 0, l);
      }, aC = function (t, a) {
        for (var l = t.memoizedState; l !== null && a > 0;)
          l = l.next, a--;
        return l;
      };
      WO = function (t, a, l, d) {
        var p = aC(t, a);
        if (p !== null) {
          var g = iN(p.memoizedState, l, d);
          p.memoizedState = g, p.baseState = g, t.memoizedProps = Ft({}, t.memoizedProps);
          var S = Qi(t, ft);
          S !== null && va(S, t, ft, $n);
        }
      }, qO = function (t, a, l) {
        var d = aC(t, a);
        if (d !== null) {
          var p = tN(d.memoizedState, l);
          d.memoizedState = p, d.baseState = p, t.memoizedProps = Ft({}, t.memoizedProps);
          var g = Qi(t, ft);
          g !== null && va(g, t, ft, $n);
        }
      }, YO = function (t, a, l, d) {
        var p = aC(t, a);
        if (p !== null) {
          var g = rN(p.memoizedState, l, d);
          p.memoizedState = g, p.baseState = g, t.memoizedProps = Ft({}, t.memoizedProps);
          var S = Qi(t, ft);
          S !== null && va(S, t, ft, $n);
        }
      }, KO = function (t, a, l) {
        t.pendingProps = iN(t.memoizedProps, a, l), t.alternate && (t.alternate.pendingProps = t.pendingProps);
        var d = Qi(t, ft);
        d !== null && va(d, t, ft, $n);
      }, GO = function (t, a) {
        t.pendingProps = tN(t.memoizedProps, a), t.alternate && (t.alternate.pendingProps = t.pendingProps);
        var l = Qi(t, ft);
        l !== null && va(l, t, ft, $n);
      }, QO = function (t, a, l) {
        t.pendingProps = rN(t.memoizedProps, a, l), t.alternate && (t.alternate.pendingProps = t.pendingProps);
        var d = Qi(t, ft);
        d !== null && va(d, t, ft, $n);
      }, JO = function (t) {
        var a = Qi(t, ft);
        a !== null && va(a, t, ft, $n);
      }, ZO = function (t) {
        VO = t;
      }, XO = function (t) {
        HO = t;
      };
    }
    function pz(t) {
      var a = $i(t);
      return a === null ? null : a.stateNode;
    }
    function mz(t) {
      return null;
    }
    function vz() {
      return or;
    }
    function gz(t) {
      var a = t.findFiberByHostInstance, l = r.ReactCurrentDispatcher;
      return uv({
        bundleType: t.bundleType,
        version: t.version,
        rendererPackageName: t.rendererPackageName,
        rendererConfig: t.rendererConfig,
        overrideHookState: WO,
        overrideHookStateDeletePath: qO,
        overrideHookStateRenamePath: YO,
        overrideProps: KO,
        overridePropsDeletePath: GO,
        overridePropsRenamePath: QO,
        setErrorHandler: ZO,
        setSuspenseHandler: XO,
        scheduleUpdate: JO,
        currentDispatcherRef: l,
        findHostInstanceByFiber: pz,
        findFiberByHostInstance: a || mz,
        // React Refresh
        findHostInstancesForRefresh: Y$,
        scheduleRefresh: W$,
        scheduleRoot: q$,
        setRefreshHandler: H$,
        // Enables DevTools to append owner stacks to error messages in DEV mode.
        getCurrentFiber: vz,
        // Enables DevTools to detect reconciler version rather than renderer version
        // which may not match for third party renderers.
        reconcilerVersion: eC
      });
    }
    var oN = typeof reportError == "function" ? (
      // In modern browsers, reportError will dispatch an error event,
      // emulating an uncaught JavaScript error.
      reportError
    ) : function (t) {
      console.error(t);
    };
    function iC(t) {
      this._internalRoot = t;
    }
    dw.prototype.render = iC.prototype.render = function (t) {
      var a = this._internalRoot;
      if (a === null)
        throw new Error("Cannot update an unmounted root.");
      {
        typeof arguments[1] == "function" ? f("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().") : fw(arguments[1]) ? f("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.") : typeof arguments[1] < "u" && f("You passed a second argument to root.render(...) but it only accepts one argument.");
        var l = a.containerInfo;
        if (l.nodeType !== Ar) {
          var d = BO(a.current);
          d && d.parentNode !== l && f("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.");
        }
      }
      Dg(t, a, null, null);
    }, dw.prototype.unmount = iC.prototype.unmount = function () {
      typeof arguments[0] == "function" && f("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
      var t = this._internalRoot;
      if (t !== null) {
        this._internalRoot = null;
        var a = t.containerInfo;
        yO() && f("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."), mu(function () {
          Dg(null, t, null, null);
        }), oR(a);
      }
    };
    function yz(t, a) {
      if (!fw(t))
        throw new Error("createRoot(...): Target container is not a DOM element.");
      sN(t);
      var l = !1, d = !1, p = "", g = oN;
      a != null && (a.hydrate ? c("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.") : typeof a == "object" && a !== null && a.$$typeof === Nr && f(`You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:

  let root = createRoot(domContainer);
  root.render(<App />);`), a.unstable_strictMode === !0 && (l = !0), a.identifierPrefix !== void 0 && (p = a.identifierPrefix), a.onRecoverableError !== void 0 && (g = a.onRecoverableError), a.transitionCallbacks !== void 0 && a.transitionCallbacks);
      var S = FO(t, ob, null, l, d, p, g);
      X0(S.current, t);
      var R = t.nodeType === Ar ? t.parentNode : t;
      return Fv(R), new iC(S);
    }
    function dw(t) {
      this._internalRoot = t;
    }
    function bz(t) {
      t && sS(t);
    }
    dw.prototype.unstable_scheduleHydration = bz;
    function wz(t, a, l) {
      if (!fw(t))
        throw new Error("hydrateRoot(...): Target container is not a DOM element.");
      sN(t), a === void 0 && f("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");
      var d = l ?? null, p = l != null && l.hydratedSources || null, g = !1, S = !1, R = "", O = oN;
      l != null && (l.unstable_strictMode === !0 && (g = !0), l.identifierPrefix !== void 0 && (R = l.identifierPrefix), l.onRecoverableError !== void 0 && (O = l.onRecoverableError));
      var L = $O(a, null, t, ob, d, g, S, R, O);
      if (X0(L.current, t), Fv(t), p)
        for (var F = 0; F < p.length; F++) {
          var J = p[F];
          EU(L, J);
        }
      return new dw(L);
    }
    function fw(t) {
      return !!(t && (t.nodeType === Ga || t.nodeType === lo || t.nodeType === Ll || !ae));
    }
    function Pg(t) {
      return !!(t && (t.nodeType === Ga || t.nodeType === lo || t.nodeType === Ll || t.nodeType === Ar && t.nodeValue === " react-mount-point-unstable "));
    }
    function sN(t) {
      t.nodeType === Ga && t.tagName && t.tagName.toUpperCase() === "BODY" && f("createRoot(): Creating roots directly with document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try using a container element created for your app."), Qv(t) && (t._reactRootContainer ? f("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.") : f("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."));
    }
    var xz = r.ReactCurrentOwner, lN;
    lN = function (t) {
      if (t._reactRootContainer && t.nodeType !== Ar) {
        var a = BO(t._reactRootContainer.current);
        a && a.parentNode !== t && f("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.");
      }
      var l = !!t._reactRootContainer, d = oC(t), p = !!(d && Ec(d));
      p && !l && f("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render."), t.nodeType === Ga && t.tagName && t.tagName.toUpperCase() === "BODY" && f("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");
    };
    function oC(t) {
      return t ? t.nodeType === lo ? t.documentElement : t.firstChild : null;
    }
    function uN() {
    }
    function Sz(t, a, l, d, p) {
      if (p) {
        if (typeof d == "function") {
          var g = d;
          d = function () {
            var G = cw(S);
            g.call(G);
          };
        }
        var S = $O(
          a,
          d,
          t,
          Tc,
          null,
          // hydrationCallbacks
          !1,
          // isStrictMode
          !1,
          // concurrentUpdatesByDefaultOverride,
          "",
          // identifierPrefix
          uN
        );
        t._reactRootContainer = S, X0(S.current, t);
        var R = t.nodeType === Ar ? t.parentNode : t;
        return Fv(R), mu(), S;
      } else {
        for (var O; O = t.lastChild;)
          t.removeChild(O);
        if (typeof d == "function") {
          var L = d;
          d = function () {
            var G = cw(F);
            L.call(G);
          };
        }
        var F = FO(
          t,
          Tc,
          null,
          // hydrationCallbacks
          !1,
          // isStrictMode
          !1,
          // concurrentUpdatesByDefaultOverride,
          "",
          // identifierPrefix
          uN
        );
        t._reactRootContainer = F, X0(F.current, t);
        var J = t.nodeType === Ar ? t.parentNode : t;
        return Fv(J), mu(function () {
          Dg(a, F, l, d);
        }), F;
      }
    }
    function _z(t, a) {
      t !== null && typeof t != "function" && f("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", a, t);
    }
    function hw(t, a, l, d, p) {
      lN(l), _z(p === void 0 ? null : p, "render");
      var g = l._reactRootContainer, S;
      if (!g)
        S = Sz(l, a, t, p, d);
      else {
        if (S = g, typeof p == "function") {
          var R = p;
          p = function () {
            var O = cw(S);
            R.call(O);
          };
        }
        Dg(a, S, t, p);
      }
      return cw(S);
    }
    var cN = !1;
    function Ez(t) {
      {
        cN || (cN = !0, f("findDOMNode is deprecated and will be removed in the next major release. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node"));
        var a = xz.current;
        if (a !== null && a.stateNode !== null) {
          var l = a.stateNode._warnedAboutRefsInRender;
          l || f("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", Jt(a.type) || "A component"), a.stateNode._warnedAboutRefsInRender = !0;
        }
      }
      return t == null ? null : t.nodeType === Ga ? t : lz(t, "findDOMNode");
    }
    function Cz(t, a, l) {
      if (f("ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !Pg(a))
        throw new Error("Target container is not a DOM element.");
      {
        var d = Qv(a) && a._reactRootContainer === void 0;
        d && f("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call hydrateRoot(container, element)?");
      }
      return hw(null, t, a, !0, l);
    }
    function Tz(t, a, l) {
      if (f("ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !Pg(a))
        throw new Error("Target container is not a DOM element.");
      {
        var d = Qv(a) && a._reactRootContainer === void 0;
        d && f("You are calling ReactDOM.render() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.render(element)?");
      }
      return hw(null, t, a, !1, l);
    }
    function Rz(t, a, l, d) {
      if (f("ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported in React 18. Consider using a portal instead. Until you switch to the createRoot API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !Pg(l))
        throw new Error("Target container is not a DOM element.");
      if (t == null || !Dd(t))
        throw new Error("parentComponent must be a valid React Component");
      return hw(t, a, l, !1, d);
    }
    var dN = !1;
    function kz(t) {
      if (dN || (dN = !0, f("unmountComponentAtNode is deprecated and will be removed in the next major release. Switch to the createRoot API. Learn more: https://reactjs.org/link/switch-to-createroot")), !Pg(t))
        throw new Error("unmountComponentAtNode(...): Target container is not a DOM element.");
      {
        var a = Qv(t) && t._reactRootContainer === void 0;
        a && f("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?");
      }
      if (t._reactRootContainer) {
        {
          var l = oC(t), d = l && !Ec(l);
          d && f("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.");
        }
        return mu(function () {
          hw(null, null, t, !1, function () {
            t._reactRootContainer = null, oR(t);
          });
        }), !0;
      } else {
        {
          var p = oC(t), g = !!(p && Ec(p)), S = t.nodeType === Ga && Pg(t.parentNode) && !!t.parentNode._reactRootContainer;
          g && f("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s", S ? "You may have accidentally passed in a React root node instead of its container." : "Instead, have the parent component update its state and rerender in order to remove this component.");
        }
        return !1;
      }
    }
    cc(uz), iS(cz), Wh(dz), x0(Hi), S0(Ea), (typeof Map != "function" || // $FlowIssue Flow incorrectly thinks Map has no prototype
      Map.prototype == null || typeof Map.prototype.forEach != "function" || typeof Set != "function" || // $FlowIssue Flow incorrectly thinks Set has no prototype
      Set.prototype == null || typeof Set.prototype.clear != "function" || typeof Set.prototype.forEach != "function") && f("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"), Jy(NL), lh(IE, w$, mu);
    function Oz(t, a) {
      var l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      if (!fw(a))
        throw new Error("Target container is not a DOM element.");
      return sz(t, a, null, l);
    }
    function Nz(t, a, l, d) {
      return Rz(t, a, l, d);
    }
    var sC = {
      usingClientEntryPoint: !1,
      // Keep in sync with ReactTestUtils.js.
      // This is an array for better minification.
      Events: [Ec, pp, eb, sh, Nd, IE]
    };
    function jz(t, a) {
      return sC.usingClientEntryPoint || f('You are importing createRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), yz(t, a);
    }
    function Az(t, a, l) {
      return sC.usingClientEntryPoint || f('You are importing hydrateRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), wz(t, a, l);
    }
    function Dz(t) {
      return yO() && f("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."), mu(t);
    }
    var Pz = gz({
      findFiberByHostInstance: sf,
      bundleType: 1,
      version: eC,
      rendererPackageName: "react-dom"
    });
    if (!Pz && cn && window.top === window.self && (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1)) {
      var fN = window.location.protocol;
      /^(https?|file):$/.test(fN) && console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools" + (fN === "file:" ? `
You might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq` : ""), "font-weight:bold");
    }
    to.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sC, to.createPortal = Oz, to.createRoot = jz, to.findDOMNode = Ez, to.flushSync = Dz, to.hydrate = Cz, to.hydrateRoot = Az, to.render = Tz, to.unmountComponentAtNode = kz, to.unstable_batchedUpdates = IE, to.unstable_renderSubtreeIntoContainer = Nz, to.version = eC, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), to;
}
function LA() {
  if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) {
    if (process.env.NODE_ENV !== "production")
      throw new Error("^_^");
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(LA);
    } catch (n) {
      console.error(n);
    }
  }
}
process.env.NODE_ENV === "production" ? (LA(), $C.exports = Hz()) : $C.exports = Wz();
var my = $C.exports;
const IA = /* @__PURE__ */ PA(my);
var zC, gw = my;
if (process.env.NODE_ENV === "production")
  zC = gw.createRoot, gw.hydrateRoot;
else {
  var EN = gw.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  zC = function (n, e) {
    EN.usingClientEntryPoint = !0;
    try {
      return gw.createRoot(n, e);
    } finally {
      EN.usingClientEntryPoint = !1;
    }
  };
}
var D = py();
const Ae = /* @__PURE__ */ PA(D), I1 = /* @__PURE__ */ DA({
  __proto__: null,
  default: Ae
}, [D]), qz = 1, Yz = 1e6;
let dC = 0;
function Kz() {
  return dC = (dC + 1) % Number.MAX_SAFE_INTEGER, dC.toString();
}
const fC = /* @__PURE__ */ new Map(), CN = (n) => {
  if (fC.has(n))
    return;
  const e = setTimeout(() => {
    fC.delete(n), Hg({
      type: "REMOVE_TOAST",
      toastId: n
    });
  }, Yz);
  fC.set(n, e);
}, Gz = (n, e) => {
  switch (e.type) {
    case "ADD_TOAST":
      return {
        ...n,
        toasts: [e.toast, ...n.toasts].slice(0, qz)
      };
    case "UPDATE_TOAST":
      return {
        ...n,
        toasts: n.toasts.map((r) => r.id === e.toast.id ? { ...r, ...e.toast } : r)
      };
    case "DISMISS_TOAST": {
      const { toastId: r } = e;
      return r ? CN(r) : n.toasts.forEach((o) => {
        CN(o.id);
      }), {
        ...n,
        toasts: n.toasts.map(
          (o) => o.id === r || r === void 0 ? {
            ...o,
            open: !1
          } : o
        )
      };
    }
    case "REMOVE_TOAST":
      return e.toastId === void 0 ? {
        ...n,
        toasts: []
      } : {
        ...n,
        toasts: n.toasts.filter((r) => r.id !== e.toastId)
      };
  }
}, Uw = [];
let Fw = { toasts: [] };
function Hg(n) {
  Fw = Gz(Fw, n), Uw.forEach((e) => {
    e(Fw);
  });
}
function Qz({ ...n }) {
  const e = Kz(), r = (u) => Hg({
    type: "UPDATE_TOAST",
    toast: { ...u, id: e }
  }), o = () => Hg({ type: "DISMISS_TOAST", toastId: e });
  return Hg({
    type: "ADD_TOAST",
    toast: {
      ...n,
      id: e,
      open: !0,
      onOpenChange: (u) => {
        u || o();
      }
    }
  }), {
    id: e,
    dismiss: o,
    update: r
  };
}
function Jz() {
  const [n, e] = D.useState(Fw);
  return D.useEffect(() => (Uw.push(e), () => {
    const r = Uw.indexOf(e);
    r > -1 && Uw.splice(r, 1);
  }), [n]), {
    ...n,
    toast: Qz,
    dismiss: (r) => Hg({ type: "DISMISS_TOAST", toastId: r })
  };
}
function wn(n, e, { checkForDefaultPrevented: r = !0 } = {}) {
  return function (u) {
    if (n == null || n(u), r === !1 || !u.defaultPrevented)
      return e == null ? void 0 : e(u);
  };
}
function TN(n, e) {
  if (typeof n == "function")
    return n(e);
  n != null && (n.current = e);
}
function UA(...n) {
  return (e) => {
    let r = !1;
    const o = n.map((u) => {
      const c = TN(u, e);
      return !r && typeof c == "function" && (r = !0), c;
    });
    if (r)
      return () => {
        for (let u = 0; u < o.length; u++) {
          const c = o[u];
          typeof c == "function" ? c() : TN(n[u], null);
        }
      };
  };
}
function pi(...n) {
  return D.useCallback(UA(...n), n);
}
function Zz(n, e) {
  const r = D.createContext(e), o = (c) => {
    const { children: f, ...m } = c, y = D.useMemo(() => m, Object.values(m));
    return /* @__PURE__ */ x.jsx(r.Provider, { value: y, children: f });
  };
  o.displayName = n + "Provider";
  function u(c) {
    const f = D.useContext(r);
    if (f) return f;
    if (e !== void 0) return e;
    throw new Error(`\`${c}\` must be used within \`${n}\``);
  }
  return [o, u];
}
function Yf(n, e = []) {
  let r = [];
  function o(c, f) {
    const m = D.createContext(f), y = r.length;
    r = [...r, f];
    const b = (T) => {
      var $;
      const { scope: k, children: C, ...M } = T, N = (($ = k == null ? void 0 : k[n]) == null ? void 0 : $[y]) || m, A = D.useMemo(() => M, Object.values(M));
      return /* @__PURE__ */ x.jsx(N.Provider, { value: A, children: C });
    };
    b.displayName = c + "Provider";
    function _(T, k) {
      var N;
      const C = ((N = k == null ? void 0 : k[n]) == null ? void 0 : N[y]) || m, M = D.useContext(C);
      if (M) return M;
      if (f !== void 0) return f;
      throw new Error(`\`${T}\` must be used within \`${c}\``);
    }
    return [b, _];
  }
  const u = () => {
    const c = r.map((f) => D.createContext(f));
    return function (m) {
      const y = (m == null ? void 0 : m[n]) || c;
      return D.useMemo(
        () => ({ [`__scope${n}`]: { ...m, [n]: y } }),
        [m, y]
      );
    };
  };
  return u.scopeName = n, [o, Xz(u, ...e)];
}
function Xz(...n) {
  const e = n[0];
  if (n.length === 1) return e;
  const r = () => {
    const o = n.map((u) => ({
      useScope: u(),
      scopeName: u.scopeName
    }));
    return function (c) {
      const f = o.reduce((m, { useScope: y, scopeName: b }) => {
        const T = y(c)[`__scope${b}`];
        return { ...m, ...T };
      }, {});
      return D.useMemo(() => ({ [`__scope${e.scopeName}`]: f }), [f]);
    };
  };
  return r.scopeName = e.scopeName, r;
}
// @__NO_SIDE_EFFECTS__
function Gg(n) {
  const e = /* @__PURE__ */ t4(n), r = D.forwardRef((o, u) => {
    const { children: c, ...f } = o, m = D.Children.toArray(c), y = m.find(r4);
    if (y) {
      const b = y.props.children, _ = m.map((T) => T === y ? D.Children.count(b) > 1 ? D.Children.only(null) : D.isValidElement(b) ? b.props.children : null : T);
      return /* @__PURE__ */ x.jsx(e, { ...f, ref: u, children: D.isValidElement(b) ? D.cloneElement(b, void 0, _) : null });
    }
    return /* @__PURE__ */ x.jsx(e, { ...f, ref: u, children: c });
  });
  return r.displayName = `${n}.Slot`, r;
}
var e4 = /* @__PURE__ */ Gg("Slot");
// @__NO_SIDE_EFFECTS__
function t4(n) {
  const e = D.forwardRef((r, o) => {
    const { children: u, ...c } = r;
    if (D.isValidElement(u)) {
      const f = i4(u), m = a4(c, u.props);
      return u.type !== D.Fragment && (m.ref = o ? UA(o, f) : f), D.cloneElement(u, m);
    }
    return D.Children.count(u) > 1 ? D.Children.only(null) : null;
  });
  return e.displayName = `${n}.SlotClone`, e;
}
var FA = Symbol("radix.slottable");
// @__NO_SIDE_EFFECTS__
function n4(n) {
  const e = ({ children: r }) => /* @__PURE__ */ x.jsx(x.Fragment, { children: r });
  return e.displayName = `${n}.Slottable`, e.__radixId = FA, e;
}
function r4(n) {
  return D.isValidElement(n) && typeof n.type == "function" && "__radixId" in n.type && n.type.__radixId === FA;
}
function a4(n, e) {
  const r = { ...e };
  for (const o in e) {
    const u = n[o], c = e[o];
    /^on[A-Z]/.test(o) ? u && c ? r[o] = (...m) => {
      const y = c(...m);
      return u(...m), y;
    } : u && (r[o] = u) : o === "style" ? r[o] = { ...u, ...c } : o === "className" && (r[o] = [u, c].filter(Boolean).join(" "));
  }
  return { ...n, ...r };
}
function i4(n) {
  var o, u;
  let e = (o = Object.getOwnPropertyDescriptor(n.props, "ref")) == null ? void 0 : o.get, r = e && "isReactWarning" in e && e.isReactWarning;
  return r ? n.ref : (e = (u = Object.getOwnPropertyDescriptor(n, "ref")) == null ? void 0 : u.get, r = e && "isReactWarning" in e && e.isReactWarning, r ? n.props.ref : n.props.ref || n.ref);
}
function $A(n) {
  const e = n + "CollectionProvider", [r, o] = Yf(e), [u, c] = r(
    e,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  ), f = (N) => {
    const { scope: A, children: $ } = N, I = Ae.useRef(null), U = Ae.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ x.jsx(u, { scope: A, itemMap: U, collectionRef: I, children: $ });
  };
  f.displayName = e;
  const m = n + "CollectionSlot", y = /* @__PURE__ */ Gg(m), b = Ae.forwardRef(
    (N, A) => {
      const { scope: $, children: I } = N, U = c(m, $), B = pi(A, U.collectionRef);
      return /* @__PURE__ */ x.jsx(y, { ref: B, children: I });
    }
  );
  b.displayName = m;
  const _ = n + "CollectionItemSlot", T = "data-radix-collection-item", k = /* @__PURE__ */ Gg(_), C = Ae.forwardRef(
    (N, A) => {
      const { scope: $, children: I, ...U } = N, B = Ae.useRef(null), K = pi(A, B), te = c(_, $);
      return Ae.useEffect(() => (te.itemMap.set(B, { ref: B, ...U }), () => void te.itemMap.delete(B))), /* @__PURE__ */ x.jsx(k, { [T]: "", ref: K, children: I });
    }
  );
  C.displayName = _;
  function M(N) {
    const A = c(n + "CollectionConsumer", N);
    return Ae.useCallback(() => {
      const I = A.collectionRef.current;
      if (!I) return [];
      const U = Array.from(I.querySelectorAll(`[${T}]`));
      return Array.from(A.itemMap.values()).sort(
        (te, re) => U.indexOf(te.ref.current) - U.indexOf(re.ref.current)
      );
    }, [A.collectionRef, A.itemMap]);
  }
  return [
    { Provider: f, Slot: b, ItemSlot: C },
    M,
    o
  ];
}
var o4 = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
], Zn = o4.reduce((n, e) => {
  const r = /* @__PURE__ */ Gg(`Primitive.${e}`), o = D.forwardRef((u, c) => {
    const { asChild: f, ...m } = u, y = f ? r : e;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ x.jsx(y, { ...m, ref: c });
  });
  return o.displayName = `Primitive.${e}`, { ...n, [e]: o };
}, {});
function zA(n, e) {
  n && my.flushSync(() => n.dispatchEvent(e));
}
function As(n) {
  const e = D.useRef(n);
  return D.useEffect(() => {
    e.current = n;
  }), D.useMemo(() => (...r) => {
    var o;
    return (o = e.current) == null ? void 0 : o.call(e, ...r);
  }, []);
}
function s4(n, e = globalThis == null ? void 0 : globalThis.document) {
  const r = As(n);
  D.useEffect(() => {
    const o = (u) => {
      u.key === "Escape" && r(u);
    };
    return e.addEventListener("keydown", o, { capture: !0 }), () => e.removeEventListener("keydown", o, { capture: !0 });
  }, [r, e]);
}
var l4 = "DismissableLayer", BC = "dismissableLayer.update", u4 = "dismissableLayer.pointerDownOutside", c4 = "dismissableLayer.focusOutside", RN, BA = D.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), px = D.forwardRef(
  (n, e) => {
    const {
      disableOutsidePointerEvents: r = !1,
      onEscapeKeyDown: o,
      onPointerDownOutside: u,
      onFocusOutside: c,
      onInteractOutside: f,
      onDismiss: m,
      ...y
    } = n, b = D.useContext(BA), [_, T] = D.useState(null), k = (_ == null ? void 0 : _.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), [, C] = D.useState({}), M = pi(e, (re) => T(re)), N = Array.from(b.layers), [A] = [...b.layersWithOutsidePointerEventsDisabled].slice(-1), $ = N.indexOf(A), I = _ ? N.indexOf(_) : -1, U = b.layersWithOutsidePointerEventsDisabled.size > 0, B = I >= $, K = f4((re) => {
      const ve = re.target, Ce = [...b.branches].some((ke) => ke.contains(ve));
      !B || Ce || (u == null || u(re), f == null || f(re), re.defaultPrevented || m == null || m());
    }, k), te = h4((re) => {
      const ve = re.target;
      [...b.branches].some((ke) => ke.contains(ve)) || (c == null || c(re), f == null || f(re), re.defaultPrevented || m == null || m());
    }, k);
    return s4((re) => {
      I === b.layers.size - 1 && (o == null || o(re), !re.defaultPrevented && m && (re.preventDefault(), m()));
    }, k), D.useEffect(() => {
      if (_)
        return r && (b.layersWithOutsidePointerEventsDisabled.size === 0 && (RN = k.body.style.pointerEvents, k.body.style.pointerEvents = "none"), b.layersWithOutsidePointerEventsDisabled.add(_)), b.layers.add(_), kN(), () => {
          r && b.layersWithOutsidePointerEventsDisabled.size === 1 && (k.body.style.pointerEvents = RN);
        };
    }, [_, k, r, b]), D.useEffect(() => () => {
      _ && (b.layers.delete(_), b.layersWithOutsidePointerEventsDisabled.delete(_), kN());
    }, [_, b]), D.useEffect(() => {
      const re = () => C({});
      return document.addEventListener(BC, re), () => document.removeEventListener(BC, re);
    }, []), /* @__PURE__ */ x.jsx(
      Zn.div,
      {
        ...y,
        ref: M,
        style: {
          pointerEvents: U ? B ? "auto" : "none" : void 0,
          ...n.style
        },
        onFocusCapture: wn(n.onFocusCapture, te.onFocusCapture),
        onBlurCapture: wn(n.onBlurCapture, te.onBlurCapture),
        onPointerDownCapture: wn(
          n.onPointerDownCapture,
          K.onPointerDownCapture
        )
      }
    );
  }
);
px.displayName = l4;
var d4 = "DismissableLayerBranch", VA = D.forwardRef((n, e) => {
  const r = D.useContext(BA), o = D.useRef(null), u = pi(e, o);
  return D.useEffect(() => {
    const c = o.current;
    if (c)
      return r.branches.add(c), () => {
        r.branches.delete(c);
      };
  }, [r.branches]), /* @__PURE__ */ x.jsx(Zn.div, { ...n, ref: u });
});
VA.displayName = d4;
function f4(n, e = globalThis == null ? void 0 : globalThis.document) {
  const r = As(n), o = D.useRef(!1), u = D.useRef(() => {
  });
  return D.useEffect(() => {
    const c = (m) => {
      if (m.target && !o.current) {
        let y = function () {
          HA(
            u4,
            r,
            b,
            { discrete: !0 }
          );
        };
        const b = { originalEvent: m };
        m.pointerType === "touch" ? (e.removeEventListener("click", u.current), u.current = y, e.addEventListener("click", u.current, { once: !0 })) : y();
      } else
        e.removeEventListener("click", u.current);
      o.current = !1;
    }, f = window.setTimeout(() => {
      e.addEventListener("pointerdown", c);
    }, 0);
    return () => {
      window.clearTimeout(f), e.removeEventListener("pointerdown", c), e.removeEventListener("click", u.current);
    };
  }, [e, r]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => o.current = !0
  };
}
function h4(n, e = globalThis == null ? void 0 : globalThis.document) {
  const r = As(n), o = D.useRef(!1);
  return D.useEffect(() => {
    const u = (c) => {
      c.target && !o.current && HA(c4, r, { originalEvent: c }, {
        discrete: !1
      });
    };
    return e.addEventListener("focusin", u), () => e.removeEventListener("focusin", u);
  }, [e, r]), {
    onFocusCapture: () => o.current = !0,
    onBlurCapture: () => o.current = !1
  };
}
function kN() {
  const n = new CustomEvent(BC);
  document.dispatchEvent(n);
}
function HA(n, e, r, { discrete: o }) {
  const u = r.originalEvent.target, c = new CustomEvent(n, { bubbles: !1, cancelable: !0, detail: r });
  e && u.addEventListener(n, e, { once: !0 }), o ? zA(u, c) : u.dispatchEvent(c);
}
var p4 = px, m4 = VA, Cu = globalThis != null && globalThis.document ? D.useLayoutEffect : () => {
}, v4 = "Portal", U1 = D.forwardRef((n, e) => {
  var m;
  const { container: r, ...o } = n, [u, c] = D.useState(!1);
  Cu(() => c(!0), []);
  const f = r || u && ((m = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : m.body);
  return f ? IA.createPortal(/* @__PURE__ */ x.jsx(Zn.div, { ...o, ref: e }), f) : null;
});
U1.displayName = v4;
function g4(n, e) {
  return D.useReducer((r, o) => e[r][o] ?? r, n);
}
var Kf = (n) => {
  const { present: e, children: r } = n, o = y4(e), u = typeof r == "function" ? r({ present: o.isPresent }) : D.Children.only(r), c = pi(o.ref, b4(u));
  return typeof r == "function" || o.isPresent ? D.cloneElement(u, { ref: c }) : null;
};
Kf.displayName = "Presence";
function y4(n) {
  const [e, r] = D.useState(), o = D.useRef(null), u = D.useRef(n), c = D.useRef("none"), f = n ? "mounted" : "unmounted", [m, y] = g4(f, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return D.useEffect(() => {
    const b = yw(o.current);
    c.current = m === "mounted" ? b : "none";
  }, [m]), Cu(() => {
    const b = o.current, _ = u.current;
    if (_ !== n) {
      const k = c.current, C = yw(b);
      n ? y("MOUNT") : C === "none" || (b == null ? void 0 : b.display) === "none" ? y("UNMOUNT") : y(_ && k !== C ? "ANIMATION_OUT" : "UNMOUNT"), u.current = n;
    }
  }, [n, y]), Cu(() => {
    if (e) {
      let b;
      const _ = e.ownerDocument.defaultView ?? window, T = (C) => {
        const N = yw(o.current).includes(C.animationName);
        if (C.target === e && N && (y("ANIMATION_END"), !u.current)) {
          const A = e.style.animationFillMode;
          e.style.animationFillMode = "forwards", b = _.setTimeout(() => {
            e.style.animationFillMode === "forwards" && (e.style.animationFillMode = A);
          });
        }
      }, k = (C) => {
        C.target === e && (c.current = yw(o.current));
      };
      return e.addEventListener("animationstart", k), e.addEventListener("animationcancel", T), e.addEventListener("animationend", T), () => {
        _.clearTimeout(b), e.removeEventListener("animationstart", k), e.removeEventListener("animationcancel", T), e.removeEventListener("animationend", T);
      };
    } else
      y("ANIMATION_END");
  }, [e, y]), {
    isPresent: ["mounted", "unmountSuspended"].includes(m),
    ref: D.useCallback((b) => {
      o.current = b ? getComputedStyle(b) : null, r(b);
    }, [])
  };
}
function yw(n) {
  return (n == null ? void 0 : n.animationName) || "none";
}
function b4(n) {
  var o, u;
  let e = (o = Object.getOwnPropertyDescriptor(n.props, "ref")) == null ? void 0 : o.get, r = e && "isReactWarning" in e && e.isReactWarning;
  return r ? n.ref : (e = (u = Object.getOwnPropertyDescriptor(n, "ref")) == null ? void 0 : u.get, r = e && "isReactWarning" in e && e.isReactWarning, r ? n.props.ref : n.props.ref || n.ref);
}
var w4 = I1[" useInsertionEffect ".trim().toString()] || Cu;
function mx({
  prop: n,
  defaultProp: e,
  onChange: r = () => {
  },
  caller: o
}) {
  const [u, c, f] = x4({
    defaultProp: e,
    onChange: r
  }), m = n !== void 0, y = m ? n : u;
  {
    const _ = D.useRef(n !== void 0);
    D.useEffect(() => {
      const T = _.current;
      T !== m && console.warn(
        `${o} is changing from ${T ? "controlled" : "uncontrolled"} to ${m ? "controlled" : "uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`
      ), _.current = m;
    }, [m, o]);
  }
  const b = D.useCallback(
    (_) => {
      var T;
      if (m) {
        const k = S4(_) ? _(n) : _;
        k !== n && ((T = f.current) == null || T.call(f, k));
      } else
        c(_);
    },
    [m, n, c, f]
  );
  return [y, b];
}
function x4({
  defaultProp: n,
  onChange: e
}) {
  const [r, o] = D.useState(n), u = D.useRef(r), c = D.useRef(e);
  return w4(() => {
    c.current = e;
  }, [e]), D.useEffect(() => {
    var f;
    u.current !== r && ((f = c.current) == null || f.call(c, r), u.current = r);
  }, [r, u]), [r, o, c];
}
function S4(n) {
  return typeof n == "function";
}
var _4 = Object.freeze({
  // See: https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss
  position: "absolute",
  border: 0,
  width: 1,
  height: 1,
  padding: 0,
  margin: -1,
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  wordWrap: "normal"
}), E4 = "VisuallyHidden", vx = D.forwardRef(
  (n, e) => /* @__PURE__ */ x.jsx(
    Zn.span,
    {
      ...n,
      ref: e,
      style: { ..._4, ...n.style }
    }
  )
);
vx.displayName = E4;
var C4 = vx, F1 = "ToastProvider", [$1, T4, R4] = $A("Toast"), [WA, XY] = Yf("Toast", [R4]), [k4, gx] = WA(F1), qA = (n) => {
  const {
    __scopeToast: e,
    label: r = "Notification",
    duration: o = 5e3,
    swipeDirection: u = "right",
    swipeThreshold: c = 50,
    children: f
  } = n, [m, y] = D.useState(null), [b, _] = D.useState(0), T = D.useRef(!1), k = D.useRef(!1);
  return r.trim() || console.error(
    `Invalid prop \`label\` supplied to \`${F1}\`. Expected non-empty \`string\`.`
  ), /* @__PURE__ */ x.jsx($1.Provider, {
    scope: e, children: /* @__PURE__ */ x.jsx(
      k4,
      {
        scope: e,
        label: r,
        duration: o,
        swipeDirection: u,
        swipeThreshold: c,
        toastCount: b,
        viewport: m,
        onViewportChange: y,
        onToastAdd: D.useCallback(() => _((C) => C + 1), []),
        onToastRemove: D.useCallback(() => _((C) => C - 1), []),
        isFocusedToastEscapeKeyDownRef: T,
        isClosePausedRef: k,
        children: f
      }
    )
  });
};
qA.displayName = F1;
var YA = "ToastViewport", O4 = ["F8"], VC = "toast.viewportPause", HC = "toast.viewportResume", KA = D.forwardRef(
  (n, e) => {
    const {
      __scopeToast: r,
      hotkey: o = O4,
      label: u = "Notifications ({hotkey})",
      ...c
    } = n, f = gx(YA, r), m = T4(r), y = D.useRef(null), b = D.useRef(null), _ = D.useRef(null), T = D.useRef(null), k = pi(e, T, f.onViewportChange), C = o.join("+").replace(/Key/g, "").replace(/Digit/g, ""), M = f.toastCount > 0;
    D.useEffect(() => {
      const A = ($) => {
        var U;
        o.length !== 0 && o.every((B) => $[B] || $.code === B) && ((U = T.current) == null || U.focus());
      };
      return document.addEventListener("keydown", A), () => document.removeEventListener("keydown", A);
    }, [o]), D.useEffect(() => {
      const A = y.current, $ = T.current;
      if (M && A && $) {
        const I = () => {
          if (!f.isClosePausedRef.current) {
            const te = new CustomEvent(VC);
            $.dispatchEvent(te), f.isClosePausedRef.current = !0;
          }
        }, U = () => {
          if (f.isClosePausedRef.current) {
            const te = new CustomEvent(HC);
            $.dispatchEvent(te), f.isClosePausedRef.current = !1;
          }
        }, B = (te) => {
          !A.contains(te.relatedTarget) && U();
        }, K = () => {
          A.contains(document.activeElement) || U();
        };
        return A.addEventListener("focusin", I), A.addEventListener("focusout", B), A.addEventListener("pointermove", I), A.addEventListener("pointerleave", K), window.addEventListener("blur", I), window.addEventListener("focus", U), () => {
          A.removeEventListener("focusin", I), A.removeEventListener("focusout", B), A.removeEventListener("pointermove", I), A.removeEventListener("pointerleave", K), window.removeEventListener("blur", I), window.removeEventListener("focus", U);
        };
      }
    }, [M, f.isClosePausedRef]);
    const N = D.useCallback(
      ({ tabbingDirection: A }) => {
        const I = m().map((U) => {
          const B = U.ref.current, K = [B, ...B4(B)];
          return A === "forwards" ? K : K.reverse();
        });
        return (A === "forwards" ? I.reverse() : I).flat();
      },
      [m]
    );
    return D.useEffect(() => {
      const A = T.current;
      if (A) {
        const $ = (I) => {
          var K, te, re;
          const U = I.altKey || I.ctrlKey || I.metaKey;
          if (I.key === "Tab" && !U) {
            const ve = document.activeElement, Ce = I.shiftKey;
            if (I.target === A && Ce) {
              (K = b.current) == null || K.focus();
              return;
            }
            const Ne = N({ tabbingDirection: Ce ? "backwards" : "forwards" }), Re = Ne.findIndex((me) => me === ve);
            hC(Ne.slice(Re + 1)) ? I.preventDefault() : Ce ? (te = b.current) == null || te.focus() : (re = _.current) == null || re.focus();
          }
        };
        return A.addEventListener("keydown", $), () => A.removeEventListener("keydown", $);
      }
    }, [m, N]), /* @__PURE__ */ x.jsxs(
      m4,
      {
        ref: y,
        role: "region",
        "aria-label": u.replace("{hotkey}", C),
        tabIndex: -1,
        style: { pointerEvents: M ? void 0 : "none" },
        children: [
          M && /* @__PURE__ */ x.jsx(
            WC,
            {
              ref: b,
              onFocusFromOutsideViewport: () => {
                const A = N({
                  tabbingDirection: "forwards"
                });
                hC(A);
              }
            }
          ),
          /* @__PURE__ */ x.jsx($1.Slot, { scope: r, children: /* @__PURE__ */ x.jsx(Zn.ol, { tabIndex: -1, ...c, ref: k }) }),
          M && /* @__PURE__ */ x.jsx(
            WC,
            {
              ref: _,
              onFocusFromOutsideViewport: () => {
                const A = N({
                  tabbingDirection: "backwards"
                });
                hC(A);
              }
            }
          )
        ]
      }
    );
  }
);
KA.displayName = YA;
var GA = "ToastFocusProxy", WC = D.forwardRef(
  (n, e) => {
    const { __scopeToast: r, onFocusFromOutsideViewport: o, ...u } = n, c = gx(GA, r);
    return /* @__PURE__ */ x.jsx(
      vx,
      {
        "aria-hidden": !0,
        tabIndex: 0,
        ...u,
        ref: e,
        style: { position: "fixed" },
        onFocus: (f) => {
          var b;
          const m = f.relatedTarget;
          !((b = c.viewport) != null && b.contains(m)) && o();
        }
      }
    );
  }
);
WC.displayName = GA;
var vy = "Toast", N4 = "toast.swipeStart", j4 = "toast.swipeMove", A4 = "toast.swipeCancel", D4 = "toast.swipeEnd", QA = D.forwardRef(
  (n, e) => {
    const { forceMount: r, open: o, defaultOpen: u, onOpenChange: c, ...f } = n, [m, y] = mx({
      prop: o,
      defaultProp: u ?? !0,
      onChange: c,
      caller: vy
    });
    return /* @__PURE__ */ x.jsx(Kf, {
      present: r || m, children: /* @__PURE__ */ x.jsx(
        L4,
        {
          open: m,
          ...f,
          ref: e,
          onClose: () => y(!1),
          onPause: As(n.onPause),
          onResume: As(n.onResume),
          onSwipeStart: wn(n.onSwipeStart, (b) => {
            b.currentTarget.setAttribute("data-swipe", "start");
          }),
          onSwipeMove: wn(n.onSwipeMove, (b) => {
            const { x: _, y: T } = b.detail.delta;
            b.currentTarget.setAttribute("data-swipe", "move"), b.currentTarget.style.setProperty("--radix-toast-swipe-move-x", `${_}px`), b.currentTarget.style.setProperty("--radix-toast-swipe-move-y", `${T}px`);
          }),
          onSwipeCancel: wn(n.onSwipeCancel, (b) => {
            b.currentTarget.setAttribute("data-swipe", "cancel"), b.currentTarget.style.removeProperty("--radix-toast-swipe-move-x"), b.currentTarget.style.removeProperty("--radix-toast-swipe-move-y"), b.currentTarget.style.removeProperty("--radix-toast-swipe-end-x"), b.currentTarget.style.removeProperty("--radix-toast-swipe-end-y");
          }),
          onSwipeEnd: wn(n.onSwipeEnd, (b) => {
            const { x: _, y: T } = b.detail.delta;
            b.currentTarget.setAttribute("data-swipe", "end"), b.currentTarget.style.removeProperty("--radix-toast-swipe-move-x"), b.currentTarget.style.removeProperty("--radix-toast-swipe-move-y"), b.currentTarget.style.setProperty("--radix-toast-swipe-end-x", `${_}px`), b.currentTarget.style.setProperty("--radix-toast-swipe-end-y", `${T}px`), y(!1);
          })
        }
      )
    });
  }
);
QA.displayName = vy;
var [P4, M4] = WA(vy, {
  onClose() {
  }
}), L4 = D.forwardRef(
  (n, e) => {
    const {
      __scopeToast: r,
      type: o = "foreground",
      duration: u,
      open: c,
      onClose: f,
      onEscapeKeyDown: m,
      onPause: y,
      onResume: b,
      onSwipeStart: _,
      onSwipeMove: T,
      onSwipeCancel: k,
      onSwipeEnd: C,
      ...M
    } = n, N = gx(vy, r), [A, $] = D.useState(null), I = pi(e, (me) => $(me)), U = D.useRef(null), B = D.useRef(null), K = u || N.duration, te = D.useRef(0), re = D.useRef(K), ve = D.useRef(0), { onToastAdd: Ce, onToastRemove: ke } = N, Ie = As(() => {
      var Ge;
      (A == null ? void 0 : A.contains(document.activeElement)) && ((Ge = N.viewport) == null || Ge.focus()), f();
    }), Ne = D.useCallback(
      (me) => {
        !me || me === 1 / 0 || (window.clearTimeout(ve.current), te.current = (/* @__PURE__ */ new Date()).getTime(), ve.current = window.setTimeout(Ie, me));
      },
      [Ie]
    );
    D.useEffect(() => {
      const me = N.viewport;
      if (me) {
        const Ge = () => {
          Ne(re.current), b == null || b();
        }, Me = () => {
          const we = (/* @__PURE__ */ new Date()).getTime() - te.current;
          re.current = re.current - we, window.clearTimeout(ve.current), y == null || y();
        };
        return me.addEventListener(VC, Me), me.addEventListener(HC, Ge), () => {
          me.removeEventListener(VC, Me), me.removeEventListener(HC, Ge);
        };
      }
    }, [N.viewport, K, y, b, Ne]), D.useEffect(() => {
      c && !N.isClosePausedRef.current && Ne(K);
    }, [c, K, N.isClosePausedRef, Ne]), D.useEffect(() => (Ce(), () => ke()), [Ce, ke]);
    const Re = D.useMemo(() => A ? rD(A) : null, [A]);
    return N.viewport ? /* @__PURE__ */ x.jsxs(x.Fragment, {
      children: [
        Re && /* @__PURE__ */ x.jsx(
          I4,
          {
            __scopeToast: r,
            role: "status",
            "aria-live": o === "foreground" ? "assertive" : "polite",
            "aria-atomic": !0,
            children: Re
          }
        ),
      /* @__PURE__ */ x.jsx(P4, {
          scope: r, onClose: Ie, children: my.createPortal(
        /* @__PURE__ */ x.jsx($1.ItemSlot, {
            scope: r, children: /* @__PURE__ */ x.jsx(
              p4,
              {
                asChild: !0,
                onEscapeKeyDown: wn(m, () => {
                  N.isFocusedToastEscapeKeyDownRef.current || Ie(), N.isFocusedToastEscapeKeyDownRef.current = !1;
                }),
                children: /* @__PURE__ */ x.jsx(
                  Zn.li,
                  {
                    role: "status",
                    "aria-live": "off",
                    "aria-atomic": !0,
                    tabIndex: 0,
                    "data-state": c ? "open" : "closed",
                    "data-swipe-direction": N.swipeDirection,
                    ...M,
                    ref: I,
                    style: { userSelect: "none", touchAction: "none", ...n.style },
                    onKeyDown: wn(n.onKeyDown, (me) => {
                      me.key === "Escape" && (m == null || m(me.nativeEvent), me.nativeEvent.defaultPrevented || (N.isFocusedToastEscapeKeyDownRef.current = !0, Ie()));
                    }),
                    onPointerDown: wn(n.onPointerDown, (me) => {
                      me.button === 0 && (U.current = { x: me.clientX, y: me.clientY });
                    }),
                    onPointerMove: wn(n.onPointerMove, (me) => {
                      if (!U.current) return;
                      const Ge = me.clientX - U.current.x, Me = me.clientY - U.current.y, we = !!B.current, ue = ["left", "right"].includes(N.swipeDirection), he = ["left", "up"].includes(N.swipeDirection) ? Math.min : Math.max, ge = ue ? he(0, Ge) : 0, Y = ue ? 0 : he(0, Me), ae = me.pointerType === "touch" ? 10 : 2, Pe = { x: ge, y: Y }, Ue = { originalEvent: me, delta: Pe };
                      we ? (B.current = Pe, bw(j4, T, Ue, {
                        discrete: !1
                      })) : ON(Pe, N.swipeDirection, ae) ? (B.current = Pe, bw(N4, _, Ue, {
                        discrete: !1
                      }), me.target.setPointerCapture(me.pointerId)) : (Math.abs(Ge) > ae || Math.abs(Me) > ae) && (U.current = null);
                    }),
                    onPointerUp: wn(n.onPointerUp, (me) => {
                      const Ge = B.current, Me = me.target;
                      if (Me.hasPointerCapture(me.pointerId) && Me.releasePointerCapture(me.pointerId), B.current = null, U.current = null, Ge) {
                        const we = me.currentTarget, ue = { originalEvent: me, delta: Ge };
                        ON(Ge, N.swipeDirection, N.swipeThreshold) ? bw(D4, C, ue, {
                          discrete: !0
                        }) : bw(
                          A4,
                          k,
                          ue,
                          {
                            discrete: !0
                          }
                        ), we.addEventListener("click", (he) => he.preventDefault(), {
                          once: !0
                        });
                      }
                    })
                  }
                )
              }
            )
          }),
            N.viewport
          )
        })
      ]
    }) : null;
  }
), I4 = (n) => {
  const { __scopeToast: e, children: r, ...o } = n, u = gx(vy, e), [c, f] = D.useState(!1), [m, y] = D.useState(!1);
  return $4(() => f(!0)), D.useEffect(() => {
    const b = window.setTimeout(() => y(!0), 1e3);
    return () => window.clearTimeout(b);
  }, []), m ? null : /* @__PURE__ */ x.jsx(U1, {
    asChild: !0, children: /* @__PURE__ */ x.jsx(vx, {
      ...o, children: c && /* @__PURE__ */ x.jsxs(x.Fragment, {
        children: [
          u.label,
          " ",
          r
        ]
      })
    })
  });
}, U4 = "ToastTitle", JA = D.forwardRef(
  (n, e) => {
    const { __scopeToast: r, ...o } = n;
    return /* @__PURE__ */ x.jsx(Zn.div, { ...o, ref: e });
  }
);
JA.displayName = U4;
var F4 = "ToastDescription", ZA = D.forwardRef(
  (n, e) => {
    const { __scopeToast: r, ...o } = n;
    return /* @__PURE__ */ x.jsx(Zn.div, { ...o, ref: e });
  }
);
ZA.displayName = F4;
var XA = "ToastAction", eD = D.forwardRef(
  (n, e) => {
    const { altText: r, ...o } = n;
    return r.trim() ? /* @__PURE__ */ x.jsx(nD, { altText: r, asChild: !0, children: /* @__PURE__ */ x.jsx(z1, { ...o, ref: e }) }) : (console.error(
      `Invalid prop \`altText\` supplied to \`${XA}\`. Expected non-empty \`string\`.`
    ), null);
  }
);
eD.displayName = XA;
var tD = "ToastClose", z1 = D.forwardRef(
  (n, e) => {
    const { __scopeToast: r, ...o } = n, u = M4(tD, r);
    return /* @__PURE__ */ x.jsx(nD, {
      asChild: !0, children: /* @__PURE__ */ x.jsx(
        Zn.button,
        {
          type: "button",
          ...o,
          ref: e,
          onClick: wn(n.onClick, u.onClose)
        }
      )
    });
  }
);
z1.displayName = tD;
var nD = D.forwardRef((n, e) => {
  const { __scopeToast: r, altText: o, ...u } = n;
  return /* @__PURE__ */ x.jsx(
    Zn.div,
    {
      "data-radix-toast-announce-exclude": "",
      "data-radix-toast-announce-alt": o || void 0,
      ...u,
      ref: e
    }
  );
});
function rD(n) {
  const e = [];
  return Array.from(n.childNodes).forEach((o) => {
    if (o.nodeType === o.TEXT_NODE && o.textContent && e.push(o.textContent), z4(o)) {
      const u = o.ariaHidden || o.hidden || o.style.display === "none", c = o.dataset.radixToastAnnounceExclude === "";
      if (!u)
        if (c) {
          const f = o.dataset.radixToastAnnounceAlt;
          f && e.push(f);
        } else
          e.push(...rD(o));
    }
  }), e;
}
function bw(n, e, r, { discrete: o }) {
  const u = r.originalEvent.currentTarget, c = new CustomEvent(n, { bubbles: !0, cancelable: !0, detail: r });
  e && u.addEventListener(n, e, { once: !0 }), o ? zA(u, c) : u.dispatchEvent(c);
}
var ON = (n, e, r = 0) => {
  const o = Math.abs(n.x), u = Math.abs(n.y), c = o > u;
  return e === "left" || e === "right" ? c && o > r : !c && u > r;
};
function $4(n = () => {
}) {
  const e = As(n);
  Cu(() => {
    let r = 0, o = 0;
    return r = window.requestAnimationFrame(() => o = window.requestAnimationFrame(e)), () => {
      window.cancelAnimationFrame(r), window.cancelAnimationFrame(o);
    };
  }, [e]);
}
function z4(n) {
  return n.nodeType === n.ELEMENT_NODE;
}
function B4(n) {
  const e = [], r = document.createTreeWalker(n, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (o) => {
      const u = o.tagName === "INPUT" && o.type === "hidden";
      return o.disabled || o.hidden || u ? NodeFilter.FILTER_SKIP : o.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; r.nextNode();) e.push(r.currentNode);
  return e;
}
function hC(n) {
  const e = document.activeElement;
  return n.some((r) => r === e ? !0 : (r.focus(), document.activeElement !== e));
}
var V4 = qA, aD = KA, iD = QA, oD = JA, sD = ZA, lD = eD, uD = z1;
function cD(n) {
  var e, r, o = "";
  if (typeof n == "string" || typeof n == "number") o += n;
  else if (typeof n == "object") if (Array.isArray(n)) {
    var u = n.length;
    for (e = 0; e < u; e++) n[e] && (r = cD(n[e])) && (o && (o += " "), o += r);
  } else for (r in n) n[r] && (o && (o += " "), o += r);
  return o;
}
function dD() {
  for (var n, e, r = 0, o = "", u = arguments.length; r < u; r++) (n = arguments[r]) && (e = cD(n)) && (o && (o += " "), o += e);
  return o;
}
const NN = (n) => typeof n == "boolean" ? `${n}` : n === 0 ? "0" : n, jN = dD, gy = (n, e) => (r) => {
  var o;
  if ((e == null ? void 0 : e.variants) == null) return jN(n, r == null ? void 0 : r.class, r == null ? void 0 : r.className);
  const { variants: u, defaultVariants: c } = e, f = Object.keys(u).map((b) => {
    const _ = r == null ? void 0 : r[b], T = c == null ? void 0 : c[b];
    if (_ === null) return null;
    const k = NN(_) || NN(T);
    return u[b][k];
  }), m = r && Object.entries(r).reduce((b, _) => {
    let [T, k] = _;
    return k === void 0 || (b[T] = k), b;
  }, {}), y = e == null || (o = e.compoundVariants) === null || o === void 0 ? void 0 : o.reduce((b, _) => {
    let { class: T, className: k, ...C } = _;
    return Object.entries(C).every((M) => {
      let [N, A] = M;
      return Array.isArray(A) ? A.includes({
        ...c,
        ...m
      }[N]) : {
        ...c,
        ...m
      }[N] === A;
    }) ? [
      ...b,
      T,
      k
    ] : b;
  }, []);
  return jN(n, f, y, r == null ? void 0 : r.class, r == null ? void 0 : r.className);
};
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const H4 = (n) => n.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), fD = (...n) => n.filter((e, r, o) => !!e && e.trim() !== "" && o.indexOf(e) === r).join(" ").trim();
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
var W4 = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const q4 = D.forwardRef(
  ({
    color: n = "currentColor",
    size: e = 24,
    strokeWidth: r = 2,
    absoluteStrokeWidth: o,
    className: u = "",
    children: c,
    iconNode: f,
    ...m
  }, y) => D.createElement(
    "svg",
    {
      ref: y,
      ...W4,
      width: e,
      height: e,
      stroke: n,
      strokeWidth: o ? Number(r) * 24 / Number(e) : r,
      className: fD("lucide", u),
      ...m
    },
    [
      ...f.map(([b, _]) => D.createElement(b, _)),
      ...Array.isArray(c) ? c : [c]
    ]
  )
);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Un = (n, e) => {
  const r = D.forwardRef(
    ({ className: o, ...u }, c) => D.createElement(q4, {
      ref: c,
      iconNode: e,
      className: fD(`lucide-${H4(n)}`, o),
      ...u
    })
  );
  return r.displayName = `${n}`, r;
};
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Y4 = Un("DollarSign", [
  ["line", { x1: "12", x2: "12", y1: "2", y2: "22", key: "7eqyqh" }],
  ["path", { d: "M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6", key: "1b0p4s" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const hD = Un("ExternalLink", [
  ["path", { d: "M15 3h6v6", key: "1q9fwt" }],
  ["path", { d: "M10 14 21 3", key: "gplh6r" }],
  ["path", { d: "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6", key: "a6xqqp" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const K4 = Un("Eye", [
  [
    "path",
    {
      d: "M2.062 12.348a1 1 0 0 1 0-.696 10.75 10.75 0 0 1 19.876 0 1 1 0 0 1 0 .696 10.75 10.75 0 0 1-19.876 0",
      key: "1nclc0"
    }
  ],
  ["circle", { cx: "12", cy: "12", r: "3", key: "1v7zrd" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const G4 = Un("Facebook", [
  [
    "path",
    { d: "M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z", key: "1jg4f8" }
  ]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Q4 = Un("Footprints", [
  [
    "path",
    {
      d: "M4 16v-2.38C4 11.5 2.97 10.5 3 8c.03-2.72 1.49-6 4.5-6C9.37 2 10 3.8 10 5.5c0 3.11-2 5.66-2 8.68V16a2 2 0 1 1-4 0Z",
      key: "1dudjm"
    }
  ],
  [
    "path",
    {
      d: "M20 20v-2.38c0-2.12 1.03-3.12 1-5.62-.03-2.72-1.49-6-4.5-6C14.63 6 14 7.8 14 9.5c0 3.11 2 5.66 2 8.68V20a2 2 0 1 0 4 0Z",
      key: "l2t8xc"
    }
  ],
  ["path", { d: "M16 17h4", key: "1dejxt" }],
  ["path", { d: "M4 13h4", key: "1bwh8b" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const J4 = Un("Globe", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["path", { d: "M12 2a14.5 14.5 0 0 0 0 20 14.5 14.5 0 0 0 0-20", key: "13o1zl" }],
  ["path", { d: "M2 12h20", key: "9i4pu4" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Z4 = Un("Heart", [
  [
    "path",
    {
      d: "M19 14c1.49-1.46 3-3.21 3-5.5A5.5 5.5 0 0 0 16.5 3c-1.76 0-3 .5-4.5 2-1.5-1.5-2.74-2-4.5-2A5.5 5.5 0 0 0 2 8.5c0 2.3 1.5 4.05 3 5.5l7 7Z",
      key: "c3ymky"
    }
  ]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const X4 = Un("Instagram", [
  ["rect", { width: "20", height: "20", x: "2", y: "2", rx: "5", ry: "5", key: "2e1cvw" }],
  ["path", { d: "M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z", key: "9exkf1" }],
  ["line", { x1: "17.5", x2: "17.51", y1: "6.5", y2: "6.5", key: "r4j83e" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const e3 = Un("LayoutDashboard", [
  ["rect", { width: "7", height: "9", x: "3", y: "3", rx: "1", key: "10lvy0" }],
  ["rect", { width: "7", height: "5", x: "14", y: "3", rx: "1", key: "16une8" }],
  ["rect", { width: "7", height: "9", x: "14", y: "12", rx: "1", key: "1hutg5" }],
  ["rect", { width: "7", height: "5", x: "3", y: "16", rx: "1", key: "ldoo1y" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Ff = Un("LoaderCircle", [
  ["path", { d: "M21 12a9 9 0 1 1-6.219-8.56", key: "13zald" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const t3 = Un("LogOut", [
  ["path", { d: "M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4", key: "1uf3rs" }],
  ["polyline", { points: "16 17 21 12 16 7", key: "1gabdz" }],
  ["line", { x1: "21", x2: "9", y1: "12", y2: "12", key: "1uyos4" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const n3 = Un("Mail", [
  ["rect", { width: "20", height: "16", x: "2", y: "4", rx: "2", key: "18n3k1" }],
  ["path", { d: "m22 7-8.97 5.7a1.94 1.94 0 0 1-2.06 0L2 7", key: "1ocrg3" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const r3 = Un("Menu", [
  ["line", { x1: "4", x2: "20", y1: "12", y2: "12", key: "1e0a9i" }],
  ["line", { x1: "4", x2: "20", y1: "6", y2: "6", key: "1owob3" }],
  ["line", { x1: "4", x2: "20", y1: "18", y2: "18", key: "yk5zj1" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const a3 = Un("Minus", [["path", { d: "M5 12h14", key: "1ays0h" }]]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const pD = Un("Package", [
  [
    "path",
    {
      d: "M11 21.73a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73z",
      key: "1a0edw"
    }
  ],
  ["path", { d: "M12 22V12", key: "d0xqtd" }],
  ["path", { d: "m3.3 7 7.703 4.734a2 2 0 0 0 1.994 0L20.7 7", key: "yx3hmr" }],
  ["path", { d: "m7.5 4.27 9 5.15", key: "1c824w" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const i3 = Un("Palette", [
  ["circle", { cx: "13.5", cy: "6.5", r: ".5", fill: "currentColor", key: "1okk4w" }],
  ["circle", { cx: "17.5", cy: "10.5", r: ".5", fill: "currentColor", key: "f64h9f" }],
  ["circle", { cx: "8.5", cy: "7.5", r: ".5", fill: "currentColor", key: "fotxhn" }],
  ["circle", { cx: "6.5", cy: "12.5", r: ".5", fill: "currentColor", key: "qy21gx" }],
  [
    "path",
    {
      d: "M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10c.926 0 1.648-.746 1.648-1.688 0-.437-.18-.835-.437-1.125-.29-.289-.438-.652-.438-1.125a1.64 1.64 0 0 1 1.668-1.668h1.996c3.051 0 5.555-2.503 5.555-5.554C21.965 6.012 17.461 2 12 2z",
      key: "12rzf8"
    }
  ]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const AN = Un("Phone", [
  [
    "path",
    {
      d: "M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z",
      key: "foiqr5"
    }
  ]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const B1 = Un("Plus", [
  ["path", { d: "M5 12h14", key: "1ays0h" }],
  ["path", { d: "M12 5v14", key: "s699le" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const V1 = Un("Search", [
  ["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }],
  ["path", { d: "m21 21-4.3-4.3", key: "1qie3q" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const o3 = Un("Shield", [
  [
    "path",
    {
      d: "M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z",
      key: "oel41y"
    }
  ]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const s3 = Un("Shirt", [
  [
    "path",
    {
      d: "M20.38 3.46 16 2a4 4 0 0 1-8 0L3.62 3.46a2 2 0 0 0-1.34 2.23l.58 3.47a1 1 0 0 0 .99.84H6v10c0 1.1.9 2 2 2h8a2 2 0 0 0 2-2V10h2.15a1 1 0 0 0 .99-.84l.58-3.47a2 2 0 0 0-1.34-2.23z",
      key: "1wgbhj"
    }
  ]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const vm = Un("ShoppingCart", [
  ["circle", { cx: "8", cy: "21", r: "1", key: "jimo8o" }],
  ["circle", { cx: "19", cy: "21", r: "1", key: "13723u" }],
  [
    "path",
    {
      d: "M2.05 2.05h2l2.66 12.42a2 2 0 0 0 2 1.58h9.78a2 2 0 0 0 1.95-1.57l1.65-7.43H5.12",
      key: "9zh506"
    }
  ]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const l3 = Un("Sparkles", [
  [
    "path",
    {
      d: "M9.937 15.5A2 2 0 0 0 8.5 14.063l-6.135-1.582a.5.5 0 0 1 0-.962L8.5 9.936A2 2 0 0 0 9.937 8.5l1.582-6.135a.5.5 0 0 1 .963 0L14.063 8.5A2 2 0 0 0 15.5 9.937l6.135 1.581a.5.5 0 0 1 0 .964L15.5 14.063a2 2 0 0 0-1.437 1.437l-1.582 6.135a.5.5 0 0 1-.963 0z",
      key: "4pj2yx"
    }
  ],
  ["path", { d: "M20 3v4", key: "1olli1" }],
  ["path", { d: "M22 5h-4", key: "1gvqau" }],
  ["path", { d: "M4 17v2", key: "vumght" }],
  ["path", { d: "M5 18H3", key: "zchphs" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const u3 = Un("SquarePen", [
  ["path", { d: "M12 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7", key: "1m0v6g" }],
  [
    "path",
    {
      d: "M18.375 2.625a1 1 0 0 1 3 3l-9.013 9.014a2 2 0 0 1-.853.505l-2.873.84a.5.5 0 0 1-.62-.62l.84-2.873a2 2 0 0 1 .506-.852z",
      key: "ohrbg2"
    }
  ]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const c3 = Un("Store", [
  ["path", { d: "m2 7 4.41-4.41A2 2 0 0 1 7.83 2h8.34a2 2 0 0 1 1.42.59L22 7", key: "ztvudi" }],
  ["path", { d: "M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8", key: "1b2hhj" }],
  ["path", { d: "M15 22v-4a2 2 0 0 0-2-2h-2a2 2 0 0 0-2 2v4", key: "2ebpfo" }],
  ["path", { d: "M2 7h20", key: "1fcdvo" }],
  [
    "path",
    {
      d: "M22 7v3a2 2 0 0 1-2 2a2.7 2.7 0 0 1-1.59-.63.7.7 0 0 0-.82 0A2.7 2.7 0 0 1 16 12a2.7 2.7 0 0 1-1.59-.63.7.7 0 0 0-.82 0A2.7 2.7 0 0 1 12 12a2.7 2.7 0 0 1-1.59-.63.7.7 0 0 0-.82 0A2.7 2.7 0 0 1 8 12a2.7 2.7 0 0 1-1.59-.63.7.7 0 0 0-.82 0A2.7 2.7 0 0 1 4 12a2 2 0 0 1-2-2V7",
      key: "6c3vgh"
    }
  ]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const mD = Un("Trash2", [
  ["path", { d: "M3 6h18", key: "d0wm0j" }],
  ["path", { d: "M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6", key: "4alrt4" }],
  ["path", { d: "M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2", key: "v07s0e" }],
  ["line", { x1: "10", x2: "10", y1: "11", y2: "17", key: "1uufr5" }],
  ["line", { x1: "14", x2: "14", y1: "11", y2: "17", key: "xtxkd" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const d3 = Un("TrendingUp", [
  ["polyline", { points: "22 7 13.5 15.5 8.5 10.5 2 17", key: "126l90" }],
  ["polyline", { points: "16 7 22 7 22 13", key: "kwv8wd" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const vD = Un("Users", [
  ["path", { d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2", key: "1yyitq" }],
  ["circle", { cx: "9", cy: "7", r: "4", key: "nufk8" }],
  ["path", { d: "M22 21v-2a4 4 0 0 0-3-3.87", key: "kshegd" }],
  ["path", { d: "M16 3.13a4 4 0 0 1 0 7.75", key: "1da9ce" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const H1 = Un("X", [
  ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
  ["path", { d: "m6 6 12 12", key: "d8bk6v" }]
]), W1 = "-", f3 = (n) => {
  const e = p3(n), {
    conflictingClassGroups: r,
    conflictingClassGroupModifiers: o
  } = n;
  return {
    getClassGroupId: (f) => {
      const m = f.split(W1);
      return m[0] === "" && m.length !== 1 && m.shift(), gD(m, e) || h3(f);
    },
    getConflictingClassGroupIds: (f, m) => {
      const y = r[f] || [];
      return m && o[f] ? [...y, ...o[f]] : y;
    }
  };
}, gD = (n, e) => {
  var f;
  if (n.length === 0)
    return e.classGroupId;
  const r = n[0], o = e.nextPart.get(r), u = o ? gD(n.slice(1), o) : void 0;
  if (u)
    return u;
  if (e.validators.length === 0)
    return;
  const c = n.join(W1);
  return (f = e.validators.find(({
    validator: m
  }) => m(c))) == null ? void 0 : f.classGroupId;
}, DN = /^\[(.+)\]$/, h3 = (n) => {
  if (DN.test(n)) {
    const e = DN.exec(n)[1], r = e == null ? void 0 : e.substring(0, e.indexOf(":"));
    if (r)
      return "arbitrary.." + r;
  }
}, p3 = (n) => {
  const {
    theme: e,
    prefix: r
  } = n, o = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  return v3(Object.entries(n.classGroups), r).forEach(([c, f]) => {
    qC(f, o, c, e);
  }), o;
}, qC = (n, e, r, o) => {
  n.forEach((u) => {
    if (typeof u == "string") {
      const c = u === "" ? e : PN(e, u);
      c.classGroupId = r;
      return;
    }
    if (typeof u == "function") {
      if (m3(u)) {
        qC(u(o), e, r, o);
        return;
      }
      e.validators.push({
        validator: u,
        classGroupId: r
      });
      return;
    }
    Object.entries(u).forEach(([c, f]) => {
      qC(f, PN(e, c), r, o);
    });
  });
}, PN = (n, e) => {
  let r = n;
  return e.split(W1).forEach((o) => {
    r.nextPart.has(o) || r.nextPart.set(o, {
      nextPart: /* @__PURE__ */ new Map(),
      validators: []
    }), r = r.nextPart.get(o);
  }), r;
}, m3 = (n) => n.isThemeGetter, v3 = (n, e) => e ? n.map(([r, o]) => {
  const u = o.map((c) => typeof c == "string" ? e + c : typeof c == "object" ? Object.fromEntries(Object.entries(c).map(([f, m]) => [e + f, m])) : c);
  return [r, u];
}) : n, g3 = (n) => {
  if (n < 1)
    return {
      get: () => {
      },
      set: () => {
      }
    };
  let e = 0, r = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map();
  const u = (c, f) => {
    r.set(c, f), e++, e > n && (e = 0, o = r, r = /* @__PURE__ */ new Map());
  };
  return {
    get(c) {
      let f = r.get(c);
      if (f !== void 0)
        return f;
      if ((f = o.get(c)) !== void 0)
        return u(c, f), f;
    },
    set(c, f) {
      r.has(c) ? r.set(c, f) : u(c, f);
    }
  };
}, yD = "!", y3 = (n) => {
  const {
    separator: e,
    experimentalParseClassName: r
  } = n, o = e.length === 1, u = e[0], c = e.length, f = (m) => {
    const y = [];
    let b = 0, _ = 0, T;
    for (let A = 0; A < m.length; A++) {
      let $ = m[A];
      if (b === 0) {
        if ($ === u && (o || m.slice(A, A + c) === e)) {
          y.push(m.slice(_, A)), _ = A + c;
          continue;
        }
        if ($ === "/") {
          T = A;
          continue;
        }
      }
      $ === "[" ? b++ : $ === "]" && b--;
    }
    const k = y.length === 0 ? m : m.substring(_), C = k.startsWith(yD), M = C ? k.substring(1) : k, N = T && T > _ ? T - _ : void 0;
    return {
      modifiers: y,
      hasImportantModifier: C,
      baseClassName: M,
      maybePostfixModifierPosition: N
    };
  };
  return r ? (m) => r({
    className: m,
    parseClassName: f
  }) : f;
}, b3 = (n) => {
  if (n.length <= 1)
    return n;
  const e = [];
  let r = [];
  return n.forEach((o) => {
    o[0] === "[" ? (e.push(...r.sort(), o), r = []) : r.push(o);
  }), e.push(...r.sort()), e;
}, w3 = (n) => ({
  cache: g3(n.cacheSize),
  parseClassName: y3(n),
  ...f3(n)
}), x3 = /\s+/, S3 = (n, e) => {
  const {
    parseClassName: r,
    getClassGroupId: o,
    getConflictingClassGroupIds: u
  } = e, c = [], f = n.trim().split(x3);
  let m = "";
  for (let y = f.length - 1; y >= 0; y -= 1) {
    const b = f[y], {
      modifiers: _,
      hasImportantModifier: T,
      baseClassName: k,
      maybePostfixModifierPosition: C
    } = r(b);
    let M = !!C, N = o(M ? k.substring(0, C) : k);
    if (!N) {
      if (!M) {
        m = b + (m.length > 0 ? " " + m : m);
        continue;
      }
      if (N = o(k), !N) {
        m = b + (m.length > 0 ? " " + m : m);
        continue;
      }
      M = !1;
    }
    const A = b3(_).join(":"), $ = T ? A + yD : A, I = $ + N;
    if (c.includes(I))
      continue;
    c.push(I);
    const U = u(N, M);
    for (let B = 0; B < U.length; ++B) {
      const K = U[B];
      c.push($ + K);
    }
    m = b + (m.length > 0 ? " " + m : m);
  }
  return m;
};
function _3() {
  let n = 0, e, r, o = "";
  for (; n < arguments.length;)
    (e = arguments[n++]) && (r = bD(e)) && (o && (o += " "), o += r);
  return o;
}
const bD = (n) => {
  if (typeof n == "string")
    return n;
  let e, r = "";
  for (let o = 0; o < n.length; o++)
    n[o] && (e = bD(n[o])) && (r && (r += " "), r += e);
  return r;
};
function E3(n, ...e) {
  let r, o, u, c = f;
  function f(y) {
    const b = e.reduce((_, T) => T(_), n());
    return r = w3(b), o = r.cache.get, u = r.cache.set, c = m, m(y);
  }
  function m(y) {
    const b = o(y);
    if (b)
      return b;
    const _ = S3(y, r);
    return u(y, _), _;
  }
  return function () {
    return c(_3.apply(null, arguments));
  };
}
const cr = (n) => {
  const e = (r) => r[n] || [];
  return e.isThemeGetter = !0, e;
}, wD = /^\[(?:([a-z-]+):)?(.+)\]$/i, C3 = /^\d+\/\d+$/, T3 = /* @__PURE__ */ new Set(["px", "full", "screen"]), R3 = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, k3 = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, O3 = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/, N3 = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, j3 = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, yu = (n) => Jp(n) || T3.has(n) || C3.test(n), $c = (n) => Cm(n, "length", F3), Jp = (n) => !!n && !Number.isNaN(Number(n)), pC = (n) => Cm(n, "number", Jp), Ug = (n) => !!n && Number.isInteger(Number(n)), A3 = (n) => n.endsWith("%") && Jp(n.slice(0, -1)), Vt = (n) => wD.test(n), zc = (n) => R3.test(n), D3 = /* @__PURE__ */ new Set(["length", "size", "percentage"]), P3 = (n) => Cm(n, D3, xD), M3 = (n) => Cm(n, "position", xD), L3 = /* @__PURE__ */ new Set(["image", "url"]), I3 = (n) => Cm(n, L3, z3), U3 = (n) => Cm(n, "", $3), Fg = () => !0, Cm = (n, e, r) => {
  const o = wD.exec(n);
  return o ? o[1] ? typeof e == "string" ? o[1] === e : e.has(o[1]) : r(o[2]) : !1;
}, F3 = (n) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  k3.test(n) && !O3.test(n)
), xD = () => !1, $3 = (n) => N3.test(n), z3 = (n) => j3.test(n), B3 = () => {
  const n = cr("colors"), e = cr("spacing"), r = cr("blur"), o = cr("brightness"), u = cr("borderColor"), c = cr("borderRadius"), f = cr("borderSpacing"), m = cr("borderWidth"), y = cr("contrast"), b = cr("grayscale"), _ = cr("hueRotate"), T = cr("invert"), k = cr("gap"), C = cr("gradientColorStops"), M = cr("gradientColorStopPositions"), N = cr("inset"), A = cr("margin"), $ = cr("opacity"), I = cr("padding"), U = cr("saturate"), B = cr("scale"), K = cr("sepia"), te = cr("skew"), re = cr("space"), ve = cr("translate"), Ce = () => ["auto", "contain", "none"], ke = () => ["auto", "hidden", "clip", "visible", "scroll"], Ie = () => ["auto", Vt, e], Ne = () => [Vt, e], Re = () => ["", yu, $c], me = () => ["auto", Jp, Vt], Ge = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"], Me = () => ["solid", "dashed", "dotted", "double", "none"], we = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], ue = () => ["start", "end", "center", "between", "around", "evenly", "stretch"], he = () => ["", "0", Vt], ge = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], Y = () => [Jp, Vt];
  return {
    cacheSize: 500,
    separator: ":",
    theme: {
      colors: [Fg],
      spacing: [yu, $c],
      blur: ["none", "", zc, Vt],
      brightness: Y(),
      borderColor: [n],
      borderRadius: ["none", "", "full", zc, Vt],
      borderSpacing: Ne(),
      borderWidth: Re(),
      contrast: Y(),
      grayscale: he(),
      hueRotate: Y(),
      invert: he(),
      gap: Ne(),
      gradientColorStops: [n],
      gradientColorStopPositions: [A3, $c],
      inset: Ie(),
      margin: Ie(),
      opacity: Y(),
      padding: Ne(),
      saturate: Y(),
      scale: Y(),
      sepia: he(),
      skew: Y(),
      space: Ne(),
      translate: Ne()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", Vt]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [zc]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": ge()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": ge()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [...Ge(), Vt]
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: ke()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": ke()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": ke()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: Ce()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": Ce()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": Ce()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [N]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [N]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [N]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [N]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [N]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [N]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [N]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [N]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [N]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", Ug, Vt]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: Ie()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", Vt]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: he()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: he()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", Ug, Vt]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [Fg]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", Ug, Vt]
        }, Vt]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": me()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": me()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [Fg]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [Ug, Vt]
        }, Vt]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": me()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": me()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", Vt]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", Vt]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [k]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [k]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [k]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal", ...ue()]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...ue(), "baseline"]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [...ue(), "baseline"]
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [I]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [I]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [I]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [I]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [I]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [I]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [I]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [I]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [I]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [A]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [A]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [A]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [A]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [A]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [A]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [A]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [A]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [A]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [re]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [re]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", Vt, e]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [Vt, e, "min", "max", "fit"]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [Vt, e, "none", "full", "min", "max", "fit", "prose", {
          screen: [zc]
        }, zc]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [Vt, e, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": [Vt, e, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [Vt, e, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Size
       * @see https://tailwindcss.com/docs/size
       */
      size: [{
        size: [Vt, e, "auto", "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", zc, $c]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", pC]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [Fg]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", Vt]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", Jp, pC]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", yu, Vt]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", Vt]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", Vt]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [n]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [$]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [n]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [$]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...Me(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", yu, $c]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", yu, Vt]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [n]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: Ne()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", Vt]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", Vt]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [$]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [...Ge(), M3]
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", P3]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, I3]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [n]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [M]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [M]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [M]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [C]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [C]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [C]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [c]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [c]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [c]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [c]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [c]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [c]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [c]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [c]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [c]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [c]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [c]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [c]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [c]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [c]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [c]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [m]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [m]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [m]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [m]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [m]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [m]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [m]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [m]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [m]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [$]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...Me(), "hidden"]
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [m]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [m]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [$]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: Me()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [u]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [u]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [u]
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": [u]
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": [u]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [u]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [u]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [u]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [u]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [u]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: ["", ...Me()]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [yu, Vt]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [yu, $c]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [n]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: Re()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [n]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [$]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [yu, $c]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [n]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", zc, U3]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [Fg]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [$]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...we(), "plus-lighter", "plus-darker"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": we()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [r]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [o]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [y]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", zc, Vt]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [b]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [_]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [T]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [U]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [K]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [r]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [o]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [y]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [b]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [_]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [T]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [$]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [U]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [K]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [f]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [f]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [f]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", Vt]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: Y()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", Vt]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: Y()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", Vt]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [B]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [B]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [B]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [Ug, Vt]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [ve]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [ve]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [te]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [te]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", Vt]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", n]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", Vt]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [n]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": Ne()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": Ne()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": Ne()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": Ne()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": Ne()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": Ne()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": Ne()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": Ne()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": Ne()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": Ne()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": Ne()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": Ne()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": Ne()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": Ne()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": Ne()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": Ne()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": Ne()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": Ne()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", Vt]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [n, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [yu, $c, pC]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [n, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
}, V3 = /* @__PURE__ */ E3(B3);
function tn(...n) {
  return V3(dD(n));
}
const H3 = V4, SD = D.forwardRef(({ className: n, ...e }, r) => /* @__PURE__ */ x.jsx(
  aD,
  {
    ref: r,
    className: tn(
      "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
      n
    ),
    ...e
  }
));
SD.displayName = aD.displayName;
const W3 = gy(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border bg-background text-foreground",
        destructive: "destructive group border-destructive bg-destructive text-destructive-foreground"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
), _D = D.forwardRef(({ className: n, variant: e, ...r }, o) => /* @__PURE__ */ x.jsx(iD, { ref: o, className: tn(W3({ variant: e }), n), ...r }));
_D.displayName = iD.displayName;
const q3 = D.forwardRef(({ className: n, ...e }, r) => /* @__PURE__ */ x.jsx(
  lD,
  {
    ref: r,
    className: tn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors group-[.destructive]:border-muted/40 hover:bg-secondary group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 group-[.destructive]:focus:ring-destructive disabled:pointer-events-none disabled:opacity-50",
      n
    ),
    ...e
  }
));
q3.displayName = lD.displayName;
const ED = D.forwardRef(({ className: n, ...e }, r) => /* @__PURE__ */ x.jsx(
  uD,
  {
    ref: r,
    className: tn(
      "absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity group-hover:opacity-100 group-[.destructive]:text-red-300 hover:text-foreground group-[.destructive]:hover:text-red-50 focus:opacity-100 focus:outline-none focus:ring-2 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      n
    ),
    "toast-close": "",
    ...e,
    children: /* @__PURE__ */ x.jsx(H1, { className: "h-4 w-4" })
  }
));
ED.displayName = uD.displayName;
const CD = D.forwardRef(({ className: n, ...e }, r) => /* @__PURE__ */ x.jsx(oD, { ref: r, className: tn("text-sm font-semibold", n), ...e }));
CD.displayName = oD.displayName;
const TD = D.forwardRef(({ className: n, ...e }, r) => /* @__PURE__ */ x.jsx(sD, { ref: r, className: tn("text-sm opacity-90", n), ...e }));
TD.displayName = sD.displayName;
function Y3() {
  const { toasts: n } = Jz();
  return /* @__PURE__ */ x.jsxs(H3, {
    children: [
      n.map(function ({ id: e, title: r, description: o, action: u, ...c }) {
        return /* @__PURE__ */ x.jsxs(_D, {
          ...c, children: [
        /* @__PURE__ */ x.jsxs("div", {
            className: "grid gap-1", children: [
              r && /* @__PURE__ */ x.jsx(CD, { children: r }),
              o && /* @__PURE__ */ x.jsx(TD, { children: o })
            ]
          }),
            u,
        /* @__PURE__ */ x.jsx(ED, {})
          ]
        }, e);
      }),
    /* @__PURE__ */ x.jsx(SD, {})
    ]
  });
}
var MN = ["light", "dark"], K3 = "(prefers-color-scheme: dark)", G3 = D.createContext(void 0), Q3 = {
  setTheme: (n) => {
  }, themes: []
}, J3 = () => {
  var n;
  return (n = D.useContext(G3)) != null ? n : Q3;
};
D.memo(({ forcedTheme: n, storageKey: e, attribute: r, enableSystem: o, enableColorScheme: u, defaultTheme: c, value: f, attrs: m, nonce: y }) => {
  let b = c === "system", _ = r === "class" ? `var d=document.documentElement,c=d.classList;${`c.remove(${m.map((M) => `'${M}'`).join(",")})`};` : `var d=document.documentElement,n='${r}',s='setAttribute';`, T = u ? MN.includes(c) && c ? `if(e==='light'||e==='dark'||!e)d.style.colorScheme=e||'${c}'` : "if(e==='light'||e==='dark')d.style.colorScheme=e" : "", k = (M, N = !1, A = !0) => {
    let $ = f ? f[M] : M, I = N ? M + "|| ''" : `'${$}'`, U = "";
    return u && A && !N && MN.includes(M) && (U += `d.style.colorScheme = '${M}';`), r === "class" ? N || $ ? U += `c.add(${I})` : U += "null" : $ && (U += `d[s](n,${I})`), U;
  }, C = n ? `!function(){${_}${k(n)}}()` : o ? `!function(){try{${_}var e=localStorage.getItem('${e}');if('system'===e||(!e&&${b})){var t='${K3}',m=window.matchMedia(t);if(m.media!==t||m.matches){${k("dark")}}else{${k("light")}}}else if(e){${f ? `var x=${JSON.stringify(f)};` : ""}${k(f ? "x[e]" : "e", !0)}}${b ? "" : "else{" + k(c, !1, !1) + "}"}${T}}catch(e){}}()` : `!function(){try{${_}var e=localStorage.getItem('${e}');if(e){${f ? `var x=${JSON.stringify(f)};` : ""}${k(f ? "x[e]" : "e", !0)}}else{${k(c, !1, !1)};}${T}}catch(t){}}();`;
  return D.createElement("script", { nonce: y, dangerouslySetInnerHTML: { __html: C } });
});
var Z3 = (n) => {
  switch (n) {
    case "success":
      return tB;
    case "info":
      return rB;
    case "warning":
      return nB;
    case "error":
      return aB;
    default:
      return null;
  }
}, X3 = Array(12).fill(0), eB = ({ visible: n, className: e }) => Ae.createElement("div", { className: ["sonner-loading-wrapper", e].filter(Boolean).join(" "), "data-visible": n }, Ae.createElement("div", { className: "sonner-spinner" }, X3.map((r, o) => Ae.createElement("div", { className: "sonner-loading-bar", key: `spinner-bar-${o}` })))), tB = Ae.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", fill: "currentColor", height: "20", width: "20" }, Ae.createElement("path", { fillRule: "evenodd", d: "M10 18a8 8 0 100-16 8 8 0 000 16zm3.857-9.809a.75.75 0 00-1.214-.882l-3.483 4.79-1.88-1.88a.75.75 0 10-1.06 1.061l2.5 2.5a.75.75 0 001.137-.089l4-5.5z", clipRule: "evenodd" })), nB = Ae.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor", height: "20", width: "20" }, Ae.createElement("path", { fillRule: "evenodd", d: "M9.401 3.003c1.155-2 4.043-2 5.197 0l7.355 12.748c1.154 2-.29 4.5-2.599 4.5H4.645c-2.309 0-3.752-2.5-2.598-4.5L9.4 3.003zM12 8.25a.75.75 0 01.75.75v3.75a.75.75 0 01-1.5 0V9a.75.75 0 01.75-.75zm0 8.25a.75.75 0 100-1.5.75.75 0 000 1.5z", clipRule: "evenodd" })), rB = Ae.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", fill: "currentColor", height: "20", width: "20" }, Ae.createElement("path", { fillRule: "evenodd", d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a.75.75 0 000 1.5h.253a.25.25 0 01.244.304l-.459 2.066A1.75 1.75 0 0010.747 15H11a.75.75 0 000-1.5h-.253a.25.25 0 01-.244-.304l.459-2.066A1.75 1.75 0 009.253 9H9z", clipRule: "evenodd" })), aB = Ae.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", fill: "currentColor", height: "20", width: "20" }, Ae.createElement("path", { fillRule: "evenodd", d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-5a.75.75 0 01.75.75v4.5a.75.75 0 01-1.5 0v-4.5A.75.75 0 0110 5zm0 10a1 1 0 100-2 1 1 0 000 2z", clipRule: "evenodd" })), iB = Ae.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "12", height: "12", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" }, Ae.createElement("line", { x1: "18", y1: "6", x2: "6", y2: "18" }), Ae.createElement("line", { x1: "6", y1: "6", x2: "18", y2: "18" })), oB = () => {
  let [n, e] = Ae.useState(document.hidden);
  return Ae.useEffect(() => {
    let r = () => {
      e(document.hidden);
    };
    return document.addEventListener("visibilitychange", r), () => window.removeEventListener("visibilitychange", r);
  }, []), n;
}, YC = 1, sB = class {
  constructor() {
    this.subscribe = (n) => (this.subscribers.push(n), () => {
      let e = this.subscribers.indexOf(n);
      this.subscribers.splice(e, 1);
    }), this.publish = (n) => {
      this.subscribers.forEach((e) => e(n));
    }, this.addToast = (n) => {
      this.publish(n), this.toasts = [...this.toasts, n];
    }, this.create = (n) => {
      var e;
      let { message: r, ...o } = n, u = typeof (n == null ? void 0 : n.id) == "number" || ((e = n.id) == null ? void 0 : e.length) > 0 ? n.id : YC++, c = this.toasts.find((m) => m.id === u), f = n.dismissible === void 0 ? !0 : n.dismissible;
      return this.dismissedToasts.has(u) && this.dismissedToasts.delete(u), c ? this.toasts = this.toasts.map((m) => m.id === u ? (this.publish({ ...m, ...n, id: u, title: r }), { ...m, ...n, id: u, dismissible: f, title: r }) : m) : this.addToast({ title: r, ...o, dismissible: f, id: u }), u;
    }, this.dismiss = (n) => (this.dismissedToasts.add(n), n || this.toasts.forEach((e) => {
      this.subscribers.forEach((r) => r({ id: e.id, dismiss: !0 }));
    }), this.subscribers.forEach((e) => e({ id: n, dismiss: !0 })), n), this.message = (n, e) => this.create({ ...e, message: n }), this.error = (n, e) => this.create({ ...e, message: n, type: "error" }), this.success = (n, e) => this.create({ ...e, type: "success", message: n }), this.info = (n, e) => this.create({ ...e, type: "info", message: n }), this.warning = (n, e) => this.create({ ...e, type: "warning", message: n }), this.loading = (n, e) => this.create({ ...e, type: "loading", message: n }), this.promise = (n, e) => {
      if (!e) return;
      let r;
      e.loading !== void 0 && (r = this.create({ ...e, promise: n, type: "loading", message: e.loading, description: typeof e.description != "function" ? e.description : void 0 }));
      let o = n instanceof Promise ? n : n(), u = r !== void 0, c, f = o.then(async (y) => {
        if (c = ["resolve", y], Ae.isValidElement(y)) u = !1, this.create({ id: r, type: "default", message: y });
        else if (uB(y) && !y.ok) {
          u = !1;
          let b = typeof e.error == "function" ? await e.error(`HTTP error! status: ${y.status}`) : e.error, _ = typeof e.description == "function" ? await e.description(`HTTP error! status: ${y.status}`) : e.description;
          this.create({ id: r, type: "error", message: b, description: _ });
        } else if (e.success !== void 0) {
          u = !1;
          let b = typeof e.success == "function" ? await e.success(y) : e.success, _ = typeof e.description == "function" ? await e.description(y) : e.description;
          this.create({ id: r, type: "success", message: b, description: _ });
        }
      }).catch(async (y) => {
        if (c = ["reject", y], e.error !== void 0) {
          u = !1;
          let b = typeof e.error == "function" ? await e.error(y) : e.error, _ = typeof e.description == "function" ? await e.description(y) : e.description;
          this.create({ id: r, type: "error", message: b, description: _ });
        }
      }).finally(() => {
        var y;
        u && (this.dismiss(r), r = void 0), (y = e.finally) == null || y.call(e);
      }), m = () => new Promise((y, b) => f.then(() => c[0] === "reject" ? b(c[1]) : y(c[1])).catch(b));
      return typeof r != "string" && typeof r != "number" ? { unwrap: m } : Object.assign(r, { unwrap: m });
    }, this.custom = (n, e) => {
      let r = (e == null ? void 0 : e.id) || YC++;
      return this.create({ jsx: n(r), id: r, ...e }), r;
    }, this.getActiveToasts = () => this.toasts.filter((n) => !this.dismissedToasts.has(n.id)), this.subscribers = [], this.toasts = [], this.dismissedToasts = /* @__PURE__ */ new Set();
  }
}, ao = new sB(), lB = (n, e) => {
  let r = (e == null ? void 0 : e.id) || YC++;
  return ao.addToast({ title: n, ...e, id: r }), r;
}, uB = (n) => n && typeof n == "object" && "ok" in n && typeof n.ok == "boolean" && "status" in n && typeof n.status == "number", cB = lB, dB = () => ao.toasts, fB = () => ao.getActiveToasts(), ya = Object.assign(cB, { success: ao.success, info: ao.info, warning: ao.warning, error: ao.error, custom: ao.custom, message: ao.message, promise: ao.promise, dismiss: ao.dismiss, loading: ao.loading }, { getHistory: dB, getToasts: fB });
function hB(n, { insertAt: e } = {}) {
  if (typeof document > "u") return;
  let r = document.head || document.getElementsByTagName("head")[0], o = document.createElement("style");
  o.type = "text/css", e === "top" && r.firstChild ? r.insertBefore(o, r.firstChild) : r.appendChild(o), o.styleSheet ? o.styleSheet.cssText = n : o.appendChild(document.createTextNode(n));
}
hB(`:where(html[dir="ltr"]),:where([data-sonner-toaster][dir="ltr"]){--toast-icon-margin-start: -3px;--toast-icon-margin-end: 4px;--toast-svg-margin-start: -1px;--toast-svg-margin-end: 0px;--toast-button-margin-start: auto;--toast-button-margin-end: 0;--toast-close-button-start: 0;--toast-close-button-end: unset;--toast-close-button-transform: translate(-35%, -35%)}:where(html[dir="rtl"]),:where([data-sonner-toaster][dir="rtl"]){--toast-icon-margin-start: 4px;--toast-icon-margin-end: -3px;--toast-svg-margin-start: 0px;--toast-svg-margin-end: -1px;--toast-button-margin-start: 0;--toast-button-margin-end: auto;--toast-close-button-start: unset;--toast-close-button-end: 0;--toast-close-button-transform: translate(35%, -35%)}:where([data-sonner-toaster]){position:fixed;width:var(--width);font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;--gray1: hsl(0, 0%, 99%);--gray2: hsl(0, 0%, 97.3%);--gray3: hsl(0, 0%, 95.1%);--gray4: hsl(0, 0%, 93%);--gray5: hsl(0, 0%, 90.9%);--gray6: hsl(0, 0%, 88.7%);--gray7: hsl(0, 0%, 85.8%);--gray8: hsl(0, 0%, 78%);--gray9: hsl(0, 0%, 56.1%);--gray10: hsl(0, 0%, 52.3%);--gray11: hsl(0, 0%, 43.5%);--gray12: hsl(0, 0%, 9%);--border-radius: 8px;box-sizing:border-box;padding:0;margin:0;list-style:none;outline:none;z-index:999999999;transition:transform .4s ease}:where([data-sonner-toaster][data-lifted="true"]){transform:translateY(-10px)}@media (hover: none) and (pointer: coarse){:where([data-sonner-toaster][data-lifted="true"]){transform:none}}:where([data-sonner-toaster][data-x-position="right"]){right:var(--offset-right)}:where([data-sonner-toaster][data-x-position="left"]){left:var(--offset-left)}:where([data-sonner-toaster][data-x-position="center"]){left:50%;transform:translate(-50%)}:where([data-sonner-toaster][data-y-position="top"]){top:var(--offset-top)}:where([data-sonner-toaster][data-y-position="bottom"]){bottom:var(--offset-bottom)}:where([data-sonner-toast]){--y: translateY(100%);--lift-amount: calc(var(--lift) * var(--gap));z-index:var(--z-index);position:absolute;opacity:0;transform:var(--y);filter:blur(0);touch-action:none;transition:transform .4s,opacity .4s,height .4s,box-shadow .2s;box-sizing:border-box;outline:none;overflow-wrap:anywhere}:where([data-sonner-toast][data-styled="true"]){padding:16px;background:var(--normal-bg);border:1px solid var(--normal-border);color:var(--normal-text);border-radius:var(--border-radius);box-shadow:0 4px 12px #0000001a;width:var(--width);font-size:13px;display:flex;align-items:center;gap:6px}:where([data-sonner-toast]:focus-visible){box-shadow:0 4px 12px #0000001a,0 0 0 2px #0003}:where([data-sonner-toast][data-y-position="top"]){top:0;--y: translateY(-100%);--lift: 1;--lift-amount: calc(1 * var(--gap))}:where([data-sonner-toast][data-y-position="bottom"]){bottom:0;--y: translateY(100%);--lift: -1;--lift-amount: calc(var(--lift) * var(--gap))}:where([data-sonner-toast]) :where([data-description]){font-weight:400;line-height:1.4;color:inherit}:where([data-sonner-toast]) :where([data-title]){font-weight:500;line-height:1.5;color:inherit}:where([data-sonner-toast]) :where([data-icon]){display:flex;height:16px;width:16px;position:relative;justify-content:flex-start;align-items:center;flex-shrink:0;margin-left:var(--toast-icon-margin-start);margin-right:var(--toast-icon-margin-end)}:where([data-sonner-toast][data-promise="true"]) :where([data-icon])>svg{opacity:0;transform:scale(.8);transform-origin:center;animation:sonner-fade-in .3s ease forwards}:where([data-sonner-toast]) :where([data-icon])>*{flex-shrink:0}:where([data-sonner-toast]) :where([data-icon]) svg{margin-left:var(--toast-svg-margin-start);margin-right:var(--toast-svg-margin-end)}:where([data-sonner-toast]) :where([data-content]){display:flex;flex-direction:column;gap:2px}[data-sonner-toast][data-styled=true] [data-button]{border-radius:4px;padding-left:8px;padding-right:8px;height:24px;font-size:12px;color:var(--normal-bg);background:var(--normal-text);margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end);border:none;cursor:pointer;outline:none;display:flex;align-items:center;flex-shrink:0;transition:opacity .4s,box-shadow .2s}:where([data-sonner-toast]) :where([data-button]):focus-visible{box-shadow:0 0 0 2px #0006}:where([data-sonner-toast]) :where([data-button]):first-of-type{margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end)}:where([data-sonner-toast]) :where([data-cancel]){color:var(--normal-text);background:rgba(0,0,0,.08)}:where([data-sonner-toast][data-theme="dark"]) :where([data-cancel]){background:rgba(255,255,255,.3)}:where([data-sonner-toast]) :where([data-close-button]){position:absolute;left:var(--toast-close-button-start);right:var(--toast-close-button-end);top:0;height:20px;width:20px;display:flex;justify-content:center;align-items:center;padding:0;color:var(--gray12);border:1px solid var(--gray4);transform:var(--toast-close-button-transform);border-radius:50%;cursor:pointer;z-index:1;transition:opacity .1s,background .2s,border-color .2s}[data-sonner-toast] [data-close-button]{background:var(--gray1)}:where([data-sonner-toast]) :where([data-close-button]):focus-visible{box-shadow:0 4px 12px #0000001a,0 0 0 2px #0003}:where([data-sonner-toast]) :where([data-disabled="true"]){cursor:not-allowed}:where([data-sonner-toast]):hover :where([data-close-button]):hover{background:var(--gray2);border-color:var(--gray5)}:where([data-sonner-toast][data-swiping="true"]):before{content:"";position:absolute;left:-50%;right:-50%;height:100%;z-index:-1}:where([data-sonner-toast][data-y-position="top"][data-swiping="true"]):before{bottom:50%;transform:scaleY(3) translateY(50%)}:where([data-sonner-toast][data-y-position="bottom"][data-swiping="true"]):before{top:50%;transform:scaleY(3) translateY(-50%)}:where([data-sonner-toast][data-swiping="false"][data-removed="true"]):before{content:"";position:absolute;inset:0;transform:scaleY(2)}:where([data-sonner-toast]):after{content:"";position:absolute;left:0;height:calc(var(--gap) + 1px);bottom:100%;width:100%}:where([data-sonner-toast][data-mounted="true"]){--y: translateY(0);opacity:1}:where([data-sonner-toast][data-expanded="false"][data-front="false"]){--scale: var(--toasts-before) * .05 + 1;--y: translateY(calc(var(--lift-amount) * var(--toasts-before))) scale(calc(-1 * var(--scale)));height:var(--front-toast-height)}:where([data-sonner-toast])>*{transition:opacity .4s}:where([data-sonner-toast][data-expanded="false"][data-front="false"][data-styled="true"])>*{opacity:0}:where([data-sonner-toast][data-visible="false"]){opacity:0;pointer-events:none}:where([data-sonner-toast][data-mounted="true"][data-expanded="true"]){--y: translateY(calc(var(--lift) * var(--offset)));height:var(--initial-height)}:where([data-sonner-toast][data-removed="true"][data-front="true"][data-swipe-out="false"]){--y: translateY(calc(var(--lift) * -100%));opacity:0}:where([data-sonner-toast][data-removed="true"][data-front="false"][data-swipe-out="false"][data-expanded="true"]){--y: translateY(calc(var(--lift) * var(--offset) + var(--lift) * -100%));opacity:0}:where([data-sonner-toast][data-removed="true"][data-front="false"][data-swipe-out="false"][data-expanded="false"]){--y: translateY(40%);opacity:0;transition:transform .5s,opacity .2s}:where([data-sonner-toast][data-removed="true"][data-front="false"]):before{height:calc(var(--initial-height) + 20%)}[data-sonner-toast][data-swiping=true]{transform:var(--y) translateY(var(--swipe-amount-y, 0px)) translate(var(--swipe-amount-x, 0px));transition:none}[data-sonner-toast][data-swiped=true]{user-select:none}[data-sonner-toast][data-swipe-out=true][data-y-position=bottom],[data-sonner-toast][data-swipe-out=true][data-y-position=top]{animation-duration:.2s;animation-timing-function:ease-out;animation-fill-mode:forwards}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=left]{animation-name:swipe-out-left}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=right]{animation-name:swipe-out-right}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=up]{animation-name:swipe-out-up}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=down]{animation-name:swipe-out-down}@keyframes swipe-out-left{0%{transform:var(--y) translate(var(--swipe-amount-x));opacity:1}to{transform:var(--y) translate(calc(var(--swipe-amount-x) - 100%));opacity:0}}@keyframes swipe-out-right{0%{transform:var(--y) translate(var(--swipe-amount-x));opacity:1}to{transform:var(--y) translate(calc(var(--swipe-amount-x) + 100%));opacity:0}}@keyframes swipe-out-up{0%{transform:var(--y) translateY(var(--swipe-amount-y));opacity:1}to{transform:var(--y) translateY(calc(var(--swipe-amount-y) - 100%));opacity:0}}@keyframes swipe-out-down{0%{transform:var(--y) translateY(var(--swipe-amount-y));opacity:1}to{transform:var(--y) translateY(calc(var(--swipe-amount-y) + 100%));opacity:0}}@media (max-width: 600px){[data-sonner-toaster]{position:fixed;right:var(--mobile-offset-right);left:var(--mobile-offset-left);width:100%}[data-sonner-toaster][dir=rtl]{left:calc(var(--mobile-offset-left) * -1)}[data-sonner-toaster] [data-sonner-toast]{left:0;right:0;width:calc(100% - var(--mobile-offset-left) * 2)}[data-sonner-toaster][data-x-position=left]{left:var(--mobile-offset-left)}[data-sonner-toaster][data-y-position=bottom]{bottom:var(--mobile-offset-bottom)}[data-sonner-toaster][data-y-position=top]{top:var(--mobile-offset-top)}[data-sonner-toaster][data-x-position=center]{left:var(--mobile-offset-left);right:var(--mobile-offset-right);transform:none}}[data-sonner-toaster][data-theme=light]{--normal-bg: #fff;--normal-border: var(--gray4);--normal-text: var(--gray12);--success-bg: hsl(143, 85%, 96%);--success-border: hsl(145, 92%, 91%);--success-text: hsl(140, 100%, 27%);--info-bg: hsl(208, 100%, 97%);--info-border: hsl(221, 91%, 91%);--info-text: hsl(210, 92%, 45%);--warning-bg: hsl(49, 100%, 97%);--warning-border: hsl(49, 91%, 91%);--warning-text: hsl(31, 92%, 45%);--error-bg: hsl(359, 100%, 97%);--error-border: hsl(359, 100%, 94%);--error-text: hsl(360, 100%, 45%)}[data-sonner-toaster][data-theme=light] [data-sonner-toast][data-invert=true]{--normal-bg: #000;--normal-border: hsl(0, 0%, 20%);--normal-text: var(--gray1)}[data-sonner-toaster][data-theme=dark] [data-sonner-toast][data-invert=true]{--normal-bg: #fff;--normal-border: var(--gray3);--normal-text: var(--gray12)}[data-sonner-toaster][data-theme=dark]{--normal-bg: #000;--normal-bg-hover: hsl(0, 0%, 12%);--normal-border: hsl(0, 0%, 20%);--normal-border-hover: hsl(0, 0%, 25%);--normal-text: var(--gray1);--success-bg: hsl(150, 100%, 6%);--success-border: hsl(147, 100%, 12%);--success-text: hsl(150, 86%, 65%);--info-bg: hsl(215, 100%, 6%);--info-border: hsl(223, 100%, 12%);--info-text: hsl(216, 87%, 65%);--warning-bg: hsl(64, 100%, 6%);--warning-border: hsl(60, 100%, 12%);--warning-text: hsl(46, 87%, 65%);--error-bg: hsl(358, 76%, 10%);--error-border: hsl(357, 89%, 16%);--error-text: hsl(358, 100%, 81%)}[data-sonner-toaster][data-theme=dark] [data-sonner-toast] [data-close-button]{background:var(--normal-bg);border-color:var(--normal-border);color:var(--normal-text)}[data-sonner-toaster][data-theme=dark] [data-sonner-toast] [data-close-button]:hover{background:var(--normal-bg-hover);border-color:var(--normal-border-hover)}[data-rich-colors=true][data-sonner-toast][data-type=success],[data-rich-colors=true][data-sonner-toast][data-type=success] [data-close-button]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true][data-sonner-toast][data-type=info],[data-rich-colors=true][data-sonner-toast][data-type=info] [data-close-button]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true][data-sonner-toast][data-type=warning],[data-rich-colors=true][data-sonner-toast][data-type=warning] [data-close-button]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true][data-sonner-toast][data-type=error],[data-rich-colors=true][data-sonner-toast][data-type=error] [data-close-button]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}.sonner-loading-wrapper{--size: 16px;height:var(--size);width:var(--size);position:absolute;inset:0;z-index:10}.sonner-loading-wrapper[data-visible=false]{transform-origin:center;animation:sonner-fade-out .2s ease forwards}.sonner-spinner{position:relative;top:50%;left:50%;height:var(--size);width:var(--size)}.sonner-loading-bar{animation:sonner-spin 1.2s linear infinite;background:var(--gray11);border-radius:6px;height:8%;left:-10%;position:absolute;top:-3.9%;width:24%}.sonner-loading-bar:nth-child(1){animation-delay:-1.2s;transform:rotate(.0001deg) translate(146%)}.sonner-loading-bar:nth-child(2){animation-delay:-1.1s;transform:rotate(30deg) translate(146%)}.sonner-loading-bar:nth-child(3){animation-delay:-1s;transform:rotate(60deg) translate(146%)}.sonner-loading-bar:nth-child(4){animation-delay:-.9s;transform:rotate(90deg) translate(146%)}.sonner-loading-bar:nth-child(5){animation-delay:-.8s;transform:rotate(120deg) translate(146%)}.sonner-loading-bar:nth-child(6){animation-delay:-.7s;transform:rotate(150deg) translate(146%)}.sonner-loading-bar:nth-child(7){animation-delay:-.6s;transform:rotate(180deg) translate(146%)}.sonner-loading-bar:nth-child(8){animation-delay:-.5s;transform:rotate(210deg) translate(146%)}.sonner-loading-bar:nth-child(9){animation-delay:-.4s;transform:rotate(240deg) translate(146%)}.sonner-loading-bar:nth-child(10){animation-delay:-.3s;transform:rotate(270deg) translate(146%)}.sonner-loading-bar:nth-child(11){animation-delay:-.2s;transform:rotate(300deg) translate(146%)}.sonner-loading-bar:nth-child(12){animation-delay:-.1s;transform:rotate(330deg) translate(146%)}@keyframes sonner-fade-in{0%{opacity:0;transform:scale(.8)}to{opacity:1;transform:scale(1)}}@keyframes sonner-fade-out{0%{opacity:1;transform:scale(1)}to{opacity:0;transform:scale(.8)}}@keyframes sonner-spin{0%{opacity:1}to{opacity:.15}}@media (prefers-reduced-motion){[data-sonner-toast],[data-sonner-toast]>*,.sonner-loading-bar{transition:none!important;animation:none!important}}.sonner-loader{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);transform-origin:center;transition:opacity .2s,transform .2s}.sonner-loader[data-visible=false]{opacity:0;transform:scale(.8) translate(-50%,-50%)}
`);
function ww(n) {
  return n.label !== void 0;
}
var pB = 3, mB = "32px", vB = "16px", LN = 4e3, gB = 356, yB = 14, bB = 20, wB = 200;
function Es(...n) {
  return n.filter(Boolean).join(" ");
}
function xB(n) {
  let [e, r] = n.split("-"), o = [];
  return e && o.push(e), r && o.push(r), o;
}
var SB = (n) => {
  var e, r, o, u, c, f, m, y, b, _, T;
  let { invert: k, toast: C, unstyled: M, interacting: N, setHeights: A, visibleToasts: $, heights: I, index: U, toasts: B, expanded: K, removeToast: te, defaultRichColors: re, closeButton: ve, style: Ce, cancelButtonStyle: ke, actionButtonStyle: Ie, className: Ne = "", descriptionClassName: Re = "", duration: me, position: Ge, gap: Me, loadingIcon: we, expandByDefault: ue, classNames: he, icons: ge, closeButtonAriaLabel: Y = "Close toast", pauseWhenPageIsHidden: ae } = n, [Pe, Ue] = Ae.useState(null), [ut, xt] = Ae.useState(null), [et, kt] = Ae.useState(!1), [Et, an] = Ae.useState(!1), [zn, yr] = Ae.useState(!1), [cn, ar] = Ae.useState(!1), [ir, Bn] = Ae.useState(!1), [Vn, Rr] = Ae.useState(0), [br, wr] = Ae.useState(0), dr = Ae.useRef(C.duration || me || LN), aa = Ae.useRef(null), Xn = Ae.useRef(null), Oa = U === 0, Ur = U + 1 <= $, An = C.type, Sn = C.dismissible !== !1, ia = C.className || "", ji = C.descriptionClassName || "", Wr = Ae.useMemo(() => I.findIndex((gt) => gt.toastId === C.id) || 0, [I, C.id]), Le = Ae.useMemo(() => {
    var gt;
    return (gt = C.closeButton) != null ? gt : ve;
  }, [C.closeButton, ve]), nt = Ae.useMemo(() => C.duration || me || LN, [C.duration, me]), At = Ae.useRef(0), Ht = Ae.useRef(0), ln = Ae.useRef(0), kn = Ae.useRef(null), [Hn, qr] = Ge.split("-"), dn = Ae.useMemo(() => I.reduce((gt, Gt, yn) => yn >= Wr ? gt : gt + Gt.height, 0), [I, Wr]), Yr = oB(), fn = C.invert || k, on = An === "loading";
  Ht.current = Ae.useMemo(() => Wr * Me + dn, [Wr, dn]), Ae.useEffect(() => {
    dr.current = nt;
  }, [nt]), Ae.useEffect(() => {
    kt(!0);
  }, []), Ae.useEffect(() => {
    let gt = Xn.current;
    if (gt) {
      let Gt = gt.getBoundingClientRect().height;
      return wr(Gt), A((yn) => [{ toastId: C.id, height: Gt, position: C.position }, ...yn]), () => A((yn) => yn.filter((xr) => xr.toastId !== C.id));
    }
  }, [A, C.id]), Ae.useLayoutEffect(() => {
    if (!et) return;
    let gt = Xn.current, Gt = gt.style.height;
    gt.style.height = "auto";
    let yn = gt.getBoundingClientRect().height;
    gt.style.height = Gt, wr(yn), A((xr) => xr.find((Or) => Or.toastId === C.id) ? xr.map((Or) => Or.toastId === C.id ? { ...Or, height: yn } : Or) : [{ toastId: C.id, height: yn, position: C.position }, ...xr]);
  }, [et, C.title, C.description, A, C.id]);
  let kr = Ae.useCallback(() => {
    an(!0), Rr(Ht.current), A((gt) => gt.filter((Gt) => Gt.toastId !== C.id)), setTimeout(() => {
      te(C);
    }, wB);
  }, [C, te, A, Ht]);
  Ae.useEffect(() => {
    if (C.promise && An === "loading" || C.duration === 1 / 0 || C.type === "loading") return;
    let gt;
    return K || N || ae && Yr ? (() => {
      if (ln.current < At.current) {
        let Gt = (/* @__PURE__ */ new Date()).getTime() - At.current;
        dr.current = dr.current - Gt;
      }
      ln.current = (/* @__PURE__ */ new Date()).getTime();
    })() : dr.current !== 1 / 0 && (At.current = (/* @__PURE__ */ new Date()).getTime(), gt = setTimeout(() => {
      var Gt;
      (Gt = C.onAutoClose) == null || Gt.call(C, C), kr();
    }, dr.current)), () => clearTimeout(gt);
  }, [K, N, C, An, ae, Yr, kr]), Ae.useEffect(() => {
    C.delete && kr();
  }, [kr, C.delete]);
  function Wa() {
    var gt, Gt, yn;
    return ge != null && ge.loading ? Ae.createElement("div", { className: Es(he == null ? void 0 : he.loader, (gt = C == null ? void 0 : C.classNames) == null ? void 0 : gt.loader, "sonner-loader"), "data-visible": An === "loading" }, ge.loading) : we ? Ae.createElement("div", { className: Es(he == null ? void 0 : he.loader, (Gt = C == null ? void 0 : C.classNames) == null ? void 0 : Gt.loader, "sonner-loader"), "data-visible": An === "loading" }, we) : Ae.createElement(eB, { className: Es(he == null ? void 0 : he.loader, (yn = C == null ? void 0 : C.classNames) == null ? void 0 : yn.loader), visible: An === "loading" });
  }
  return Ae.createElement("li", {
    tabIndex: 0, ref: Xn, className: Es(Ne, ia, he == null ? void 0 : he.toast, (e = C == null ? void 0 : C.classNames) == null ? void 0 : e.toast, he == null ? void 0 : he.default, he == null ? void 0 : he[An], (r = C == null ? void 0 : C.classNames) == null ? void 0 : r[An]), "data-sonner-toast": "", "data-rich-colors": (o = C.richColors) != null ? o : re, "data-styled": !(C.jsx || C.unstyled || M), "data-mounted": et, "data-promise": !!C.promise, "data-swiped": ir, "data-removed": Et, "data-visible": Ur, "data-y-position": Hn, "data-x-position": qr, "data-index": U, "data-front": Oa, "data-swiping": zn, "data-dismissible": Sn, "data-type": An, "data-invert": fn, "data-swipe-out": cn, "data-swipe-direction": ut, "data-expanded": !!(K || ue && et), style: { "--index": U, "--toasts-before": U, "--z-index": B.length - U, "--offset": `${Et ? Vn : Ht.current}px`, "--initial-height": ue ? "auto" : `${br}px`, ...Ce, ...C.style }, onDragEnd: () => {
      yr(!1), Ue(null), kn.current = null;
    }, onPointerDown: (gt) => {
      on || !Sn || (aa.current = /* @__PURE__ */ new Date(), Rr(Ht.current), gt.target.setPointerCapture(gt.pointerId), gt.target.tagName !== "BUTTON" && (yr(!0), kn.current = { x: gt.clientX, y: gt.clientY }));
    }, onPointerUp: () => {
      var gt, Gt, yn, xr;
      if (cn || !Sn) return;
      kn.current = null;
      let Or = Number(((gt = Xn.current) == null ? void 0 : gt.style.getPropertyValue("--swipe-amount-x").replace("px", "")) || 0), fr = Number(((Gt = Xn.current) == null ? void 0 : Gt.style.getPropertyValue("--swipe-amount-y").replace("px", "")) || 0), Kr = (/* @__PURE__ */ new Date()).getTime() - ((yn = aa.current) == null ? void 0 : yn.getTime()), Wn = Pe === "x" ? Or : fr, Nr = Math.abs(Wn) / Kr;
      if (Math.abs(Wn) >= bB || Nr > 0.11) {
        Rr(Ht.current), (xr = C.onDismiss) == null || xr.call(C, C), xt(Pe === "x" ? Or > 0 ? "right" : "left" : fr > 0 ? "down" : "up"), kr(), ar(!0), Bn(!1);
        return;
      }
      yr(!1), Ue(null);
    }, onPointerMove: (gt) => {
      var Gt, yn, xr, Or;
      if (!kn.current || !Sn || ((Gt = window.getSelection()) == null ? void 0 : Gt.toString().length) > 0) return;
      let fr = gt.clientY - kn.current.y, Kr = gt.clientX - kn.current.x, Wn = (yn = n.swipeDirections) != null ? yn : xB(Ge);
      !Pe && (Math.abs(Kr) > 1 || Math.abs(fr) > 1) && Ue(Math.abs(Kr) > Math.abs(fr) ? "x" : "y");
      let Nr = { x: 0, y: 0 };
      Pe === "y" ? (Wn.includes("top") || Wn.includes("bottom")) && (Wn.includes("top") && fr < 0 || Wn.includes("bottom") && fr > 0) && (Nr.y = fr) : Pe === "x" && (Wn.includes("left") || Wn.includes("right")) && (Wn.includes("left") && Kr < 0 || Wn.includes("right") && Kr > 0) && (Nr.x = Kr), (Math.abs(Nr.x) > 0 || Math.abs(Nr.y) > 0) && Bn(!0), (xr = Xn.current) == null || xr.style.setProperty("--swipe-amount-x", `${Nr.x}px`), (Or = Xn.current) == null || Or.style.setProperty("--swipe-amount-y", `${Nr.y}px`);
    }
  }, Le && !C.jsx ? Ae.createElement("button", {
    "aria-label": Y, "data-disabled": on, "data-close-button": !0, onClick: on || !Sn ? () => {
    } : () => {
      var gt;
      kr(), (gt = C.onDismiss) == null || gt.call(C, C);
    }, className: Es(he == null ? void 0 : he.closeButton, (u = C == null ? void 0 : C.classNames) == null ? void 0 : u.closeButton)
  }, (c = ge == null ? void 0 : ge.close) != null ? c : iB) : null, C.jsx || D.isValidElement(C.title) ? C.jsx ? C.jsx : typeof C.title == "function" ? C.title() : C.title : Ae.createElement(Ae.Fragment, null, An || C.icon || C.promise ? Ae.createElement("div", { "data-icon": "", className: Es(he == null ? void 0 : he.icon, (f = C == null ? void 0 : C.classNames) == null ? void 0 : f.icon) }, C.promise || C.type === "loading" && !C.icon ? C.icon || Wa() : null, C.type !== "loading" ? C.icon || (ge == null ? void 0 : ge[An]) || Z3(An) : null) : null, Ae.createElement("div", { "data-content": "", className: Es(he == null ? void 0 : he.content, (m = C == null ? void 0 : C.classNames) == null ? void 0 : m.content) }, Ae.createElement("div", { "data-title": "", className: Es(he == null ? void 0 : he.title, (y = C == null ? void 0 : C.classNames) == null ? void 0 : y.title) }, typeof C.title == "function" ? C.title() : C.title), C.description ? Ae.createElement("div", { "data-description": "", className: Es(Re, ji, he == null ? void 0 : he.description, (b = C == null ? void 0 : C.classNames) == null ? void 0 : b.description) }, typeof C.description == "function" ? C.description() : C.description) : null), D.isValidElement(C.cancel) ? C.cancel : C.cancel && ww(C.cancel) ? Ae.createElement("button", {
    "data-button": !0, "data-cancel": !0, style: C.cancelButtonStyle || ke, onClick: (gt) => {
      var Gt, yn;
      ww(C.cancel) && Sn && ((yn = (Gt = C.cancel).onClick) == null || yn.call(Gt, gt), kr());
    }, className: Es(he == null ? void 0 : he.cancelButton, (_ = C == null ? void 0 : C.classNames) == null ? void 0 : _.cancelButton)
  }, C.cancel.label) : null, D.isValidElement(C.action) ? C.action : C.action && ww(C.action) ? Ae.createElement("button", {
    "data-button": !0, "data-action": !0, style: C.actionButtonStyle || Ie, onClick: (gt) => {
      var Gt, yn;
      ww(C.action) && ((yn = (Gt = C.action).onClick) == null || yn.call(Gt, gt), !gt.defaultPrevented && kr());
    }, className: Es(he == null ? void 0 : he.actionButton, (T = C == null ? void 0 : C.classNames) == null ? void 0 : T.actionButton)
  }, C.action.label) : null));
};
function IN() {
  if (typeof window > "u" || typeof document > "u") return "ltr";
  let n = document.documentElement.getAttribute("dir");
  return n === "auto" || !n ? window.getComputedStyle(document.documentElement).direction : n;
}
function _B(n, e) {
  let r = {};
  return [n, e].forEach((o, u) => {
    let c = u === 1, f = c ? "--mobile-offset" : "--offset", m = c ? vB : mB;
    function y(b) {
      ["top", "right", "bottom", "left"].forEach((_) => {
        r[`${f}-${_}`] = typeof b == "number" ? `${b}px` : b;
      });
    }
    typeof o == "number" || typeof o == "string" ? y(o) : typeof o == "object" ? ["top", "right", "bottom", "left"].forEach((b) => {
      o[b] === void 0 ? r[`${f}-${b}`] = m : r[`${f}-${b}`] = typeof o[b] == "number" ? `${o[b]}px` : o[b];
    }) : y(m);
  }), r;
}
var EB = D.forwardRef(function (n, e) {
  let { invert: r, position: o = "bottom-right", hotkey: u = ["altKey", "KeyT"], expand: c, closeButton: f, className: m, offset: y, mobileOffset: b, theme: _ = "light", richColors: T, duration: k, style: C, visibleToasts: M = pB, toastOptions: N, dir: A = IN(), gap: $ = yB, loadingIcon: I, icons: U, containerAriaLabel: B = "Notifications", pauseWhenPageIsHidden: K } = n, [te, re] = Ae.useState([]), ve = Ae.useMemo(() => Array.from(new Set([o].concat(te.filter((ae) => ae.position).map((ae) => ae.position)))), [te, o]), [Ce, ke] = Ae.useState([]), [Ie, Ne] = Ae.useState(!1), [Re, me] = Ae.useState(!1), [Ge, Me] = Ae.useState(_ !== "system" ? _ : typeof window < "u" && window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light"), we = Ae.useRef(null), ue = u.join("+").replace(/Key/g, "").replace(/Digit/g, ""), he = Ae.useRef(null), ge = Ae.useRef(!1), Y = Ae.useCallback((ae) => {
    re((Pe) => {
      var Ue;
      return (Ue = Pe.find((ut) => ut.id === ae.id)) != null && Ue.delete || ao.dismiss(ae.id), Pe.filter(({ id: ut }) => ut !== ae.id);
    });
  }, []);
  return Ae.useEffect(() => ao.subscribe((ae) => {
    if (ae.dismiss) {
      re((Pe) => Pe.map((Ue) => Ue.id === ae.id ? { ...Ue, delete: !0 } : Ue));
      return;
    }
    setTimeout(() => {
      IA.flushSync(() => {
        re((Pe) => {
          let Ue = Pe.findIndex((ut) => ut.id === ae.id);
          return Ue !== -1 ? [...Pe.slice(0, Ue), { ...Pe[Ue], ...ae }, ...Pe.slice(Ue + 1)] : [ae, ...Pe];
        });
      });
    });
  }), []), Ae.useEffect(() => {
    if (_ !== "system") {
      Me(_);
      return;
    }
    if (_ === "system" && (window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? Me("dark") : Me("light")), typeof window > "u") return;
    let ae = window.matchMedia("(prefers-color-scheme: dark)");
    try {
      ae.addEventListener("change", ({ matches: Pe }) => {
        Me(Pe ? "dark" : "light");
      });
    } catch {
      ae.addListener(({ matches: Ue }) => {
        try {
          Me(Ue ? "dark" : "light");
        } catch (ut) {
          console.error(ut);
        }
      });
    }
  }, [_]), Ae.useEffect(() => {
    te.length <= 1 && Ne(!1);
  }, [te]), Ae.useEffect(() => {
    let ae = (Pe) => {
      var Ue, ut;
      u.every((xt) => Pe[xt] || Pe.code === xt) && (Ne(!0), (Ue = we.current) == null || Ue.focus()), Pe.code === "Escape" && (document.activeElement === we.current || (ut = we.current) != null && ut.contains(document.activeElement)) && Ne(!1);
    };
    return document.addEventListener("keydown", ae), () => document.removeEventListener("keydown", ae);
  }, [u]), Ae.useEffect(() => {
    if (we.current) return () => {
      he.current && (he.current.focus({ preventScroll: !0 }), he.current = null, ge.current = !1);
    };
  }, [we.current]), Ae.createElement("section", { ref: e, "aria-label": `${B} ${ue}`, tabIndex: -1, "aria-live": "polite", "aria-relevant": "additions text", "aria-atomic": "false", suppressHydrationWarning: !0 }, ve.map((ae, Pe) => {
    var Ue;
    let [ut, xt] = ae.split("-");
    return te.length ? Ae.createElement("ol", {
      key: ae, dir: A === "auto" ? IN() : A, tabIndex: -1, ref: we, className: m, "data-sonner-toaster": !0, "data-theme": Ge, "data-y-position": ut, "data-lifted": Ie && te.length > 1 && !c, "data-x-position": xt, style: { "--front-toast-height": `${((Ue = Ce[0]) == null ? void 0 : Ue.height) || 0}px`, "--width": `${gB}px`, "--gap": `${$}px`, ...C, ..._B(y, b) }, onBlur: (et) => {
        ge.current && !et.currentTarget.contains(et.relatedTarget) && (ge.current = !1, he.current && (he.current.focus({ preventScroll: !0 }), he.current = null));
      }, onFocus: (et) => {
        et.target instanceof HTMLElement && et.target.dataset.dismissible === "false" || ge.current || (ge.current = !0, he.current = et.relatedTarget);
      }, onMouseEnter: () => Ne(!0), onMouseMove: () => Ne(!0), onMouseLeave: () => {
        Re || Ne(!1);
      }, onDragEnd: () => Ne(!1), onPointerDown: (et) => {
        et.target instanceof HTMLElement && et.target.dataset.dismissible === "false" || me(!0);
      }, onPointerUp: () => me(!1)
    }, te.filter((et) => !et.position && Pe === 0 || et.position === ae).map((et, kt) => {
      var Et, an;
      return Ae.createElement(SB, { key: et.id, icons: U, index: kt, toast: et, defaultRichColors: T, duration: (Et = N == null ? void 0 : N.duration) != null ? Et : k, className: N == null ? void 0 : N.className, descriptionClassName: N == null ? void 0 : N.descriptionClassName, invert: r, visibleToasts: M, closeButton: (an = N == null ? void 0 : N.closeButton) != null ? an : f, interacting: Re, position: ae, style: N == null ? void 0 : N.style, unstyled: N == null ? void 0 : N.unstyled, classNames: N == null ? void 0 : N.classNames, cancelButtonStyle: N == null ? void 0 : N.cancelButtonStyle, actionButtonStyle: N == null ? void 0 : N.actionButtonStyle, removeToast: Y, toasts: te.filter((zn) => zn.position == et.position), heights: Ce.filter((zn) => zn.position == et.position), setHeights: ke, expandByDefault: c, gap: $, loadingIcon: I, expanded: Ie, pauseWhenPageIsHidden: K, swipeDirections: n.swipeDirections });
    })) : null;
  }));
});
const CB = ({ ...n }) => {
  const { theme: e = "system" } = J3();
  return /* @__PURE__ */ x.jsx(
    EB,
    {
      theme: e,
      className: "toaster group",
      toastOptions: {
        classNames: {
          toast: "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg",
          description: "group-[.toast]:text-muted-foreground",
          actionButton: "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground",
          cancelButton: "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground"
        }
      },
      ...n
    }
  );
};
var TB = I1[" useId ".trim().toString()] || (() => {
}), RB = 0;
function Wg(n) {
  const [e, r] = D.useState(TB());
  return Cu(() => {
    n || r((o) => o ?? String(RB++));
  }, [n]), n || (e ? `radix-${e}` : "");
}
const kB = ["top", "right", "bottom", "left"], ld = Math.min, go = Math.max, qw = Math.round, xw = Math.floor, Ol = (n) => ({
  x: n,
  y: n
}), OB = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, NB = {
  start: "end",
  end: "start"
};
function KC(n, e, r) {
  return go(n, ld(e, r));
}
function Tu(n, e) {
  return typeof n == "function" ? n(e) : n;
}
function Ru(n) {
  return n.split("-")[0];
}
function Tm(n) {
  return n.split("-")[1];
}
function q1(n) {
  return n === "x" ? "y" : "x";
}
function Y1(n) {
  return n === "y" ? "height" : "width";
}
const jB = /* @__PURE__ */ new Set(["top", "bottom"]);
function Rl(n) {
  return jB.has(Ru(n)) ? "y" : "x";
}
function K1(n) {
  return q1(Rl(n));
}
function AB(n, e, r) {
  r === void 0 && (r = !1);
  const o = Tm(n), u = K1(n), c = Y1(u);
  let f = u === "x" ? o === (r ? "end" : "start") ? "right" : "left" : o === "start" ? "bottom" : "top";
  return e.reference[c] > e.floating[c] && (f = Yw(f)), [f, Yw(f)];
}
function DB(n) {
  const e = Yw(n);
  return [GC(n), e, GC(e)];
}
function GC(n) {
  return n.replace(/start|end/g, (e) => NB[e]);
}
const UN = ["left", "right"], FN = ["right", "left"], PB = ["top", "bottom"], MB = ["bottom", "top"];
function LB(n, e, r) {
  switch (n) {
    case "top":
    case "bottom":
      return r ? e ? FN : UN : e ? UN : FN;
    case "left":
    case "right":
      return e ? PB : MB;
    default:
      return [];
  }
}
function IB(n, e, r, o) {
  const u = Tm(n);
  let c = LB(Ru(n), r === "start", o);
  return u && (c = c.map((f) => f + "-" + u), e && (c = c.concat(c.map(GC)))), c;
}
function Yw(n) {
  return n.replace(/left|right|bottom|top/g, (e) => OB[e]);
}
function UB(n) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...n
  };
}
function RD(n) {
  return typeof n != "number" ? UB(n) : {
    top: n,
    right: n,
    bottom: n,
    left: n
  };
}
function Kw(n) {
  const {
    x: e,
    y: r,
    width: o,
    height: u
  } = n;
  return {
    width: o,
    height: u,
    top: r,
    left: e,
    right: e + o,
    bottom: r + u,
    x: e,
    y: r
  };
}
function $N(n, e, r) {
  let {
    reference: o,
    floating: u
  } = n;
  const c = Rl(e), f = K1(e), m = Y1(f), y = Ru(e), b = c === "y", _ = o.x + o.width / 2 - u.width / 2, T = o.y + o.height / 2 - u.height / 2, k = o[m] / 2 - u[m] / 2;
  let C;
  switch (y) {
    case "top":
      C = {
        x: _,
        y: o.y - u.height
      };
      break;
    case "bottom":
      C = {
        x: _,
        y: o.y + o.height
      };
      break;
    case "right":
      C = {
        x: o.x + o.width,
        y: T
      };
      break;
    case "left":
      C = {
        x: o.x - u.width,
        y: T
      };
      break;
    default:
      C = {
        x: o.x,
        y: o.y
      };
  }
  switch (Tm(e)) {
    case "start":
      C[f] -= k * (r && b ? -1 : 1);
      break;
    case "end":
      C[f] += k * (r && b ? -1 : 1);
      break;
  }
  return C;
}
const FB = async (n, e, r) => {
  const {
    placement: o = "bottom",
    strategy: u = "absolute",
    middleware: c = [],
    platform: f
  } = r, m = c.filter(Boolean), y = await (f.isRTL == null ? void 0 : f.isRTL(e));
  let b = await f.getElementRects({
    reference: n,
    floating: e,
    strategy: u
  }), {
    x: _,
    y: T
  } = $N(b, o, y), k = o, C = {}, M = 0;
  for (let N = 0; N < m.length; N++) {
    const {
      name: A,
      fn: $
    } = m[N], {
      x: I,
      y: U,
      data: B,
      reset: K
    } = await $({
      x: _,
      y: T,
      initialPlacement: o,
      placement: k,
      strategy: u,
      middlewareData: C,
      rects: b,
      platform: f,
      elements: {
        reference: n,
        floating: e
      }
    });
    _ = I ?? _, T = U ?? T, C = {
      ...C,
      [A]: {
        ...C[A],
        ...B
      }
    }, K && M <= 50 && (M++, typeof K == "object" && (K.placement && (k = K.placement), K.rects && (b = K.rects === !0 ? await f.getElementRects({
      reference: n,
      floating: e,
      strategy: u
    }) : K.rects), {
      x: _,
      y: T
    } = $N(b, k, y)), N = -1);
  }
  return {
    x: _,
    y: T,
    placement: k,
    strategy: u,
    middlewareData: C
  };
};
async function Qg(n, e) {
  var r;
  e === void 0 && (e = {});
  const {
    x: o,
    y: u,
    platform: c,
    rects: f,
    elements: m,
    strategy: y
  } = n, {
    boundary: b = "clippingAncestors",
    rootBoundary: _ = "viewport",
    elementContext: T = "floating",
    altBoundary: k = !1,
    padding: C = 0
  } = Tu(e, n), M = RD(C), A = m[k ? T === "floating" ? "reference" : "floating" : T], $ = Kw(await c.getClippingRect({
    element: (r = await (c.isElement == null ? void 0 : c.isElement(A))) == null || r ? A : A.contextElement || await (c.getDocumentElement == null ? void 0 : c.getDocumentElement(m.floating)),
    boundary: b,
    rootBoundary: _,
    strategy: y
  })), I = T === "floating" ? {
    x: o,
    y: u,
    width: f.floating.width,
    height: f.floating.height
  } : f.reference, U = await (c.getOffsetParent == null ? void 0 : c.getOffsetParent(m.floating)), B = await (c.isElement == null ? void 0 : c.isElement(U)) ? await (c.getScale == null ? void 0 : c.getScale(U)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, K = Kw(c.convertOffsetParentRelativeRectToViewportRelativeRect ? await c.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: m,
    rect: I,
    offsetParent: U,
    strategy: y
  }) : I);
  return {
    top: ($.top - K.top + M.top) / B.y,
    bottom: (K.bottom - $.bottom + M.bottom) / B.y,
    left: ($.left - K.left + M.left) / B.x,
    right: (K.right - $.right + M.right) / B.x
  };
}
const $B = (n) => ({
  name: "arrow",
  options: n,
  async fn(e) {
    const {
      x: r,
      y: o,
      placement: u,
      rects: c,
      platform: f,
      elements: m,
      middlewareData: y
    } = e, {
      element: b,
      padding: _ = 0
    } = Tu(n, e) || {};
    if (b == null)
      return {};
    const T = RD(_), k = {
      x: r,
      y: o
    }, C = K1(u), M = Y1(C), N = await f.getDimensions(b), A = C === "y", $ = A ? "top" : "left", I = A ? "bottom" : "right", U = A ? "clientHeight" : "clientWidth", B = c.reference[M] + c.reference[C] - k[C] - c.floating[M], K = k[C] - c.reference[C], te = await (f.getOffsetParent == null ? void 0 : f.getOffsetParent(b));
    let re = te ? te[U] : 0;
    (!re || !await (f.isElement == null ? void 0 : f.isElement(te))) && (re = m.floating[U] || c.floating[M]);
    const ve = B / 2 - K / 2, Ce = re / 2 - N[M] / 2 - 1, ke = ld(T[$], Ce), Ie = ld(T[I], Ce), Ne = ke, Re = re - N[M] - Ie, me = re / 2 - N[M] / 2 + ve, Ge = KC(Ne, me, Re), Me = !y.arrow && Tm(u) != null && me !== Ge && c.reference[M] / 2 - (me < Ne ? ke : Ie) - N[M] / 2 < 0, we = Me ? me < Ne ? me - Ne : me - Re : 0;
    return {
      [C]: k[C] + we,
      data: {
        [C]: Ge,
        centerOffset: me - Ge - we,
        ...Me && {
          alignmentOffset: we
        }
      },
      reset: Me
    };
  }
}), zB = function (n) {
  return n === void 0 && (n = {}), {
    name: "flip",
    options: n,
    async fn(e) {
      var r, o;
      const {
        placement: u,
        middlewareData: c,
        rects: f,
        initialPlacement: m,
        platform: y,
        elements: b
      } = e, {
        mainAxis: _ = !0,
        crossAxis: T = !0,
        fallbackPlacements: k,
        fallbackStrategy: C = "bestFit",
        fallbackAxisSideDirection: M = "none",
        flipAlignment: N = !0,
        ...A
      } = Tu(n, e);
      if ((r = c.arrow) != null && r.alignmentOffset)
        return {};
      const $ = Ru(u), I = Rl(m), U = Ru(m) === m, B = await (y.isRTL == null ? void 0 : y.isRTL(b.floating)), K = k || (U || !N ? [Yw(m)] : DB(m)), te = M !== "none";
      !k && te && K.push(...IB(m, N, M, B));
      const re = [m, ...K], ve = await Qg(e, A), Ce = [];
      let ke = ((o = c.flip) == null ? void 0 : o.overflows) || [];
      if (_ && Ce.push(ve[$]), T) {
        const me = AB(u, f, B);
        Ce.push(ve[me[0]], ve[me[1]]);
      }
      if (ke = [...ke, {
        placement: u,
        overflows: Ce
      }], !Ce.every((me) => me <= 0)) {
        var Ie, Ne;
        const me = (((Ie = c.flip) == null ? void 0 : Ie.index) || 0) + 1, Ge = re[me];
        if (Ge && (!(T === "alignment" ? I !== Rl(Ge) : !1) || // We leave the current main axis only if every placement on that axis
          // overflows the main axis.
          ke.every((ue) => ue.overflows[0] > 0 && Rl(ue.placement) === I)))
          return {
            data: {
              index: me,
              overflows: ke
            },
            reset: {
              placement: Ge
            }
          };
        let Me = (Ne = ke.filter((we) => we.overflows[0] <= 0).sort((we, ue) => we.overflows[1] - ue.overflows[1])[0]) == null ? void 0 : Ne.placement;
        if (!Me)
          switch (C) {
            case "bestFit": {
              var Re;
              const we = (Re = ke.filter((ue) => {
                if (te) {
                  const he = Rl(ue.placement);
                  return he === I || // Create a bias to the `y` side axis due to horizontal
                    // reading directions favoring greater width.
                    he === "y";
                }
                return !0;
              }).map((ue) => [ue.placement, ue.overflows.filter((he) => he > 0).reduce((he, ge) => he + ge, 0)]).sort((ue, he) => ue[1] - he[1])[0]) == null ? void 0 : Re[0];
              we && (Me = we);
              break;
            }
            case "initialPlacement":
              Me = m;
              break;
          }
        if (u !== Me)
          return {
            reset: {
              placement: Me
            }
          };
      }
      return {};
    }
  };
};
function zN(n, e) {
  return {
    top: n.top - e.height,
    right: n.right - e.width,
    bottom: n.bottom - e.height,
    left: n.left - e.width
  };
}
function BN(n) {
  return kB.some((e) => n[e] >= 0);
}
const BB = function (n) {
  return n === void 0 && (n = {}), {
    name: "hide",
    options: n,
    async fn(e) {
      const {
        rects: r
      } = e, {
        strategy: o = "referenceHidden",
        ...u
      } = Tu(n, e);
      switch (o) {
        case "referenceHidden": {
          const c = await Qg(e, {
            ...u,
            elementContext: "reference"
          }), f = zN(c, r.reference);
          return {
            data: {
              referenceHiddenOffsets: f,
              referenceHidden: BN(f)
            }
          };
        }
        case "escaped": {
          const c = await Qg(e, {
            ...u,
            altBoundary: !0
          }), f = zN(c, r.floating);
          return {
            data: {
              escapedOffsets: f,
              escaped: BN(f)
            }
          };
        }
        default:
          return {};
      }
    }
  };
}, kD = /* @__PURE__ */ new Set(["left", "top"]);
async function VB(n, e) {
  const {
    placement: r,
    platform: o,
    elements: u
  } = n, c = await (o.isRTL == null ? void 0 : o.isRTL(u.floating)), f = Ru(r), m = Tm(r), y = Rl(r) === "y", b = kD.has(f) ? -1 : 1, _ = c && y ? -1 : 1, T = Tu(e, n);
  let {
    mainAxis: k,
    crossAxis: C,
    alignmentAxis: M
  } = typeof T == "number" ? {
    mainAxis: T,
    crossAxis: 0,
    alignmentAxis: null
  } : {
      mainAxis: T.mainAxis || 0,
      crossAxis: T.crossAxis || 0,
      alignmentAxis: T.alignmentAxis
    };
  return m && typeof M == "number" && (C = m === "end" ? M * -1 : M), y ? {
    x: C * _,
    y: k * b
  } : {
    x: k * b,
    y: C * _
  };
}
const HB = function (n) {
  return n === void 0 && (n = 0), {
    name: "offset",
    options: n,
    async fn(e) {
      var r, o;
      const {
        x: u,
        y: c,
        placement: f,
        middlewareData: m
      } = e, y = await VB(e, n);
      return f === ((r = m.offset) == null ? void 0 : r.placement) && (o = m.arrow) != null && o.alignmentOffset ? {} : {
        x: u + y.x,
        y: c + y.y,
        data: {
          ...y,
          placement: f
        }
      };
    }
  };
}, WB = function (n) {
  return n === void 0 && (n = {}), {
    name: "shift",
    options: n,
    async fn(e) {
      const {
        x: r,
        y: o,
        placement: u
      } = e, {
        mainAxis: c = !0,
        crossAxis: f = !1,
        limiter: m = {
          fn: (A) => {
            let {
              x: $,
              y: I
            } = A;
            return {
              x: $,
              y: I
            };
          }
        },
        ...y
      } = Tu(n, e), b = {
        x: r,
        y: o
      }, _ = await Qg(e, y), T = Rl(Ru(u)), k = q1(T);
      let C = b[k], M = b[T];
      if (c) {
        const A = k === "y" ? "top" : "left", $ = k === "y" ? "bottom" : "right", I = C + _[A], U = C - _[$];
        C = KC(I, C, U);
      }
      if (f) {
        const A = T === "y" ? "top" : "left", $ = T === "y" ? "bottom" : "right", I = M + _[A], U = M - _[$];
        M = KC(I, M, U);
      }
      const N = m.fn({
        ...e,
        [k]: C,
        [T]: M
      });
      return {
        ...N,
        data: {
          x: N.x - r,
          y: N.y - o,
          enabled: {
            [k]: c,
            [T]: f
          }
        }
      };
    }
  };
}, qB = function (n) {
  return n === void 0 && (n = {}), {
    options: n,
    fn(e) {
      const {
        x: r,
        y: o,
        placement: u,
        rects: c,
        middlewareData: f
      } = e, {
        offset: m = 0,
        mainAxis: y = !0,
        crossAxis: b = !0
      } = Tu(n, e), _ = {
        x: r,
        y: o
      }, T = Rl(u), k = q1(T);
      let C = _[k], M = _[T];
      const N = Tu(m, e), A = typeof N == "number" ? {
        mainAxis: N,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...N
      };
      if (y) {
        const U = k === "y" ? "height" : "width", B = c.reference[k] - c.floating[U] + A.mainAxis, K = c.reference[k] + c.reference[U] - A.mainAxis;
        C < B ? C = B : C > K && (C = K);
      }
      if (b) {
        var $, I;
        const U = k === "y" ? "width" : "height", B = kD.has(Ru(u)), K = c.reference[T] - c.floating[U] + (B && (($ = f.offset) == null ? void 0 : $[T]) || 0) + (B ? 0 : A.crossAxis), te = c.reference[T] + c.reference[U] + (B ? 0 : ((I = f.offset) == null ? void 0 : I[T]) || 0) - (B ? A.crossAxis : 0);
        M < K ? M = K : M > te && (M = te);
      }
      return {
        [k]: C,
        [T]: M
      };
    }
  };
}, YB = function (n) {
  return n === void 0 && (n = {}), {
    name: "size",
    options: n,
    async fn(e) {
      var r, o;
      const {
        placement: u,
        rects: c,
        platform: f,
        elements: m
      } = e, {
        apply: y = () => {
        },
        ...b
      } = Tu(n, e), _ = await Qg(e, b), T = Ru(u), k = Tm(u), C = Rl(u) === "y", {
        width: M,
        height: N
      } = c.floating;
      let A, $;
      T === "top" || T === "bottom" ? (A = T, $ = k === (await (f.isRTL == null ? void 0 : f.isRTL(m.floating)) ? "start" : "end") ? "left" : "right") : ($ = T, A = k === "end" ? "top" : "bottom");
      const I = N - _.top - _.bottom, U = M - _.left - _.right, B = ld(N - _[A], I), K = ld(M - _[$], U), te = !e.middlewareData.shift;
      let re = B, ve = K;
      if ((r = e.middlewareData.shift) != null && r.enabled.x && (ve = U), (o = e.middlewareData.shift) != null && o.enabled.y && (re = I), te && !k) {
        const ke = go(_.left, 0), Ie = go(_.right, 0), Ne = go(_.top, 0), Re = go(_.bottom, 0);
        C ? ve = M - 2 * (ke !== 0 || Ie !== 0 ? ke + Ie : go(_.left, _.right)) : re = N - 2 * (Ne !== 0 || Re !== 0 ? Ne + Re : go(_.top, _.bottom));
      }
      await y({
        ...e,
        availableWidth: ve,
        availableHeight: re
      });
      const Ce = await f.getDimensions(m.floating);
      return M !== Ce.width || N !== Ce.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function yx() {
  return typeof window < "u";
}
function Rm(n) {
  return OD(n) ? (n.nodeName || "").toLowerCase() : "#document";
}
function xo(n) {
  var e;
  return (n == null || (e = n.ownerDocument) == null ? void 0 : e.defaultView) || window;
}
function Al(n) {
  var e;
  return (e = (OD(n) ? n.ownerDocument : n.document) || window.document) == null ? void 0 : e.documentElement;
}
function OD(n) {
  return yx() ? n instanceof Node || n instanceof xo(n).Node : !1;
}
function Ds(n) {
  return yx() ? n instanceof Element || n instanceof xo(n).Element : !1;
}
function jl(n) {
  return yx() ? n instanceof HTMLElement || n instanceof xo(n).HTMLElement : !1;
}
function VN(n) {
  return !yx() || typeof ShadowRoot > "u" ? !1 : n instanceof ShadowRoot || n instanceof xo(n).ShadowRoot;
}
const KB = /* @__PURE__ */ new Set(["inline", "contents"]);
function yy(n) {
  const {
    overflow: e,
    overflowX: r,
    overflowY: o,
    display: u
  } = Ps(n);
  return /auto|scroll|overlay|hidden|clip/.test(e + o + r) && !KB.has(u);
}
const GB = /* @__PURE__ */ new Set(["table", "td", "th"]);
function QB(n) {
  return GB.has(Rm(n));
}
const JB = [":popover-open", ":modal"];
function bx(n) {
  return JB.some((e) => {
    try {
      return n.matches(e);
    } catch {
      return !1;
    }
  });
}
const ZB = ["transform", "translate", "scale", "rotate", "perspective"], XB = ["transform", "translate", "scale", "rotate", "perspective", "filter"], eV = ["paint", "layout", "strict", "content"];
function G1(n) {
  const e = Q1(), r = Ds(n) ? Ps(n) : n;
  return ZB.some((o) => r[o] ? r[o] !== "none" : !1) || (r.containerType ? r.containerType !== "normal" : !1) || !e && (r.backdropFilter ? r.backdropFilter !== "none" : !1) || !e && (r.filter ? r.filter !== "none" : !1) || XB.some((o) => (r.willChange || "").includes(o)) || eV.some((o) => (r.contain || "").includes(o));
}
function tV(n) {
  let e = ud(n);
  for (; jl(e) && !gm(e);) {
    if (G1(e))
      return e;
    if (bx(e))
      return null;
    e = ud(e);
  }
  return null;
}
function Q1() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
const nV = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function gm(n) {
  return nV.has(Rm(n));
}
function Ps(n) {
  return xo(n).getComputedStyle(n);
}
function wx(n) {
  return Ds(n) ? {
    scrollLeft: n.scrollLeft,
    scrollTop: n.scrollTop
  } : {
    scrollLeft: n.scrollX,
    scrollTop: n.scrollY
  };
}
function ud(n) {
  if (Rm(n) === "html")
    return n;
  const e = (
    // Step into the shadow DOM of the parent of a slotted node.
    n.assignedSlot || // DOM Element detected.
    n.parentNode || // ShadowRoot detected.
    VN(n) && n.host || // Fallback.
    Al(n)
  );
  return VN(e) ? e.host : e;
}
function ND(n) {
  const e = ud(n);
  return gm(e) ? n.ownerDocument ? n.ownerDocument.body : n.body : jl(e) && yy(e) ? e : ND(e);
}
function Jg(n, e, r) {
  var o;
  e === void 0 && (e = []), r === void 0 && (r = !0);
  const u = ND(n), c = u === ((o = n.ownerDocument) == null ? void 0 : o.body), f = xo(u);
  if (c) {
    const m = QC(f);
    return e.concat(f, f.visualViewport || [], yy(u) ? u : [], m && r ? Jg(m) : []);
  }
  return e.concat(u, Jg(u, [], r));
}
function QC(n) {
  return n.parent && Object.getPrototypeOf(n.parent) ? n.frameElement : null;
}
function jD(n) {
  const e = Ps(n);
  let r = parseFloat(e.width) || 0, o = parseFloat(e.height) || 0;
  const u = jl(n), c = u ? n.offsetWidth : r, f = u ? n.offsetHeight : o, m = qw(r) !== c || qw(o) !== f;
  return m && (r = c, o = f), {
    width: r,
    height: o,
    $: m
  };
}
function J1(n) {
  return Ds(n) ? n : n.contextElement;
}
function Zp(n) {
  const e = J1(n);
  if (!jl(e))
    return Ol(1);
  const r = e.getBoundingClientRect(), {
    width: o,
    height: u,
    $: c
  } = jD(e);
  let f = (c ? qw(r.width) : r.width) / o, m = (c ? qw(r.height) : r.height) / u;
  return (!f || !Number.isFinite(f)) && (f = 1), (!m || !Number.isFinite(m)) && (m = 1), {
    x: f,
    y: m
  };
}
const rV = /* @__PURE__ */ Ol(0);
function AD(n) {
  const e = xo(n);
  return !Q1() || !e.visualViewport ? rV : {
    x: e.visualViewport.offsetLeft,
    y: e.visualViewport.offsetTop
  };
}
function aV(n, e, r) {
  return e === void 0 && (e = !1), !r || e && r !== xo(n) ? !1 : e;
}
function $f(n, e, r, o) {
  e === void 0 && (e = !1), r === void 0 && (r = !1);
  const u = n.getBoundingClientRect(), c = J1(n);
  let f = Ol(1);
  e && (o ? Ds(o) && (f = Zp(o)) : f = Zp(n));
  const m = aV(c, r, o) ? AD(c) : Ol(0);
  let y = (u.left + m.x) / f.x, b = (u.top + m.y) / f.y, _ = u.width / f.x, T = u.height / f.y;
  if (c) {
    const k = xo(c), C = o && Ds(o) ? xo(o) : o;
    let M = k, N = QC(M);
    for (; N && o && C !== M;) {
      const A = Zp(N), $ = N.getBoundingClientRect(), I = Ps(N), U = $.left + (N.clientLeft + parseFloat(I.paddingLeft)) * A.x, B = $.top + (N.clientTop + parseFloat(I.paddingTop)) * A.y;
      y *= A.x, b *= A.y, _ *= A.x, T *= A.y, y += U, b += B, M = xo(N), N = QC(M);
    }
  }
  return Kw({
    width: _,
    height: T,
    x: y,
    y: b
  });
}
function Z1(n, e) {
  const r = wx(n).scrollLeft;
  return e ? e.left + r : $f(Al(n)).left + r;
}
function DD(n, e, r) {
  r === void 0 && (r = !1);
  const o = n.getBoundingClientRect(), u = o.left + e.scrollLeft - (r ? 0 : (
    // RTL <body> scrollbar.
    Z1(n, o)
  )), c = o.top + e.scrollTop;
  return {
    x: u,
    y: c
  };
}
function iV(n) {
  let {
    elements: e,
    rect: r,
    offsetParent: o,
    strategy: u
  } = n;
  const c = u === "fixed", f = Al(o), m = e ? bx(e.floating) : !1;
  if (o === f || m && c)
    return r;
  let y = {
    scrollLeft: 0,
    scrollTop: 0
  }, b = Ol(1);
  const _ = Ol(0), T = jl(o);
  if ((T || !T && !c) && ((Rm(o) !== "body" || yy(f)) && (y = wx(o)), jl(o))) {
    const C = $f(o);
    b = Zp(o), _.x = C.x + o.clientLeft, _.y = C.y + o.clientTop;
  }
  const k = f && !T && !c ? DD(f, y, !0) : Ol(0);
  return {
    width: r.width * b.x,
    height: r.height * b.y,
    x: r.x * b.x - y.scrollLeft * b.x + _.x + k.x,
    y: r.y * b.y - y.scrollTop * b.y + _.y + k.y
  };
}
function oV(n) {
  return Array.from(n.getClientRects());
}
function sV(n) {
  const e = Al(n), r = wx(n), o = n.ownerDocument.body, u = go(e.scrollWidth, e.clientWidth, o.scrollWidth, o.clientWidth), c = go(e.scrollHeight, e.clientHeight, o.scrollHeight, o.clientHeight);
  let f = -r.scrollLeft + Z1(n);
  const m = -r.scrollTop;
  return Ps(o).direction === "rtl" && (f += go(e.clientWidth, o.clientWidth) - u), {
    width: u,
    height: c,
    x: f,
    y: m
  };
}
function lV(n, e) {
  const r = xo(n), o = Al(n), u = r.visualViewport;
  let c = o.clientWidth, f = o.clientHeight, m = 0, y = 0;
  if (u) {
    c = u.width, f = u.height;
    const b = Q1();
    (!b || b && e === "fixed") && (m = u.offsetLeft, y = u.offsetTop);
  }
  return {
    width: c,
    height: f,
    x: m,
    y
  };
}
const uV = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function cV(n, e) {
  const r = $f(n, !0, e === "fixed"), o = r.top + n.clientTop, u = r.left + n.clientLeft, c = jl(n) ? Zp(n) : Ol(1), f = n.clientWidth * c.x, m = n.clientHeight * c.y, y = u * c.x, b = o * c.y;
  return {
    width: f,
    height: m,
    x: y,
    y: b
  };
}
function HN(n, e, r) {
  let o;
  if (e === "viewport")
    o = lV(n, r);
  else if (e === "document")
    o = sV(Al(n));
  else if (Ds(e))
    o = cV(e, r);
  else {
    const u = AD(n);
    o = {
      x: e.x - u.x,
      y: e.y - u.y,
      width: e.width,
      height: e.height
    };
  }
  return Kw(o);
}
function PD(n, e) {
  const r = ud(n);
  return r === e || !Ds(r) || gm(r) ? !1 : Ps(r).position === "fixed" || PD(r, e);
}
function dV(n, e) {
  const r = e.get(n);
  if (r)
    return r;
  let o = Jg(n, [], !1).filter((m) => Ds(m) && Rm(m) !== "body"), u = null;
  const c = Ps(n).position === "fixed";
  let f = c ? ud(n) : n;
  for (; Ds(f) && !gm(f);) {
    const m = Ps(f), y = G1(f);
    !y && m.position === "fixed" && (u = null), (c ? !y && !u : !y && m.position === "static" && !!u && uV.has(u.position) || yy(f) && !y && PD(n, f)) ? o = o.filter((_) => _ !== f) : u = m, f = ud(f);
  }
  return e.set(n, o), o;
}
function fV(n) {
  let {
    element: e,
    boundary: r,
    rootBoundary: o,
    strategy: u
  } = n;
  const f = [...r === "clippingAncestors" ? bx(e) ? [] : dV(e, this._c) : [].concat(r), o], m = f[0], y = f.reduce((b, _) => {
    const T = HN(e, _, u);
    return b.top = go(T.top, b.top), b.right = ld(T.right, b.right), b.bottom = ld(T.bottom, b.bottom), b.left = go(T.left, b.left), b;
  }, HN(e, m, u));
  return {
    width: y.right - y.left,
    height: y.bottom - y.top,
    x: y.left,
    y: y.top
  };
}
function hV(n) {
  const {
    width: e,
    height: r
  } = jD(n);
  return {
    width: e,
    height: r
  };
}
function pV(n, e, r) {
  const o = jl(e), u = Al(e), c = r === "fixed", f = $f(n, !0, c, e);
  let m = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const y = Ol(0);
  function b() {
    y.x = Z1(u);
  }
  if (o || !o && !c)
    if ((Rm(e) !== "body" || yy(u)) && (m = wx(e)), o) {
      const C = $f(e, !0, c, e);
      y.x = C.x + e.clientLeft, y.y = C.y + e.clientTop;
    } else u && b();
  c && !o && u && b();
  const _ = u && !o && !c ? DD(u, m) : Ol(0), T = f.left + m.scrollLeft - y.x - _.x, k = f.top + m.scrollTop - y.y - _.y;
  return {
    x: T,
    y: k,
    width: f.width,
    height: f.height
  };
}
function mC(n) {
  return Ps(n).position === "static";
}
function WN(n, e) {
  if (!jl(n) || Ps(n).position === "fixed")
    return null;
  if (e)
    return e(n);
  let r = n.offsetParent;
  return Al(n) === r && (r = r.ownerDocument.body), r;
}
function MD(n, e) {
  const r = xo(n);
  if (bx(n))
    return r;
  if (!jl(n)) {
    let u = ud(n);
    for (; u && !gm(u);) {
      if (Ds(u) && !mC(u))
        return u;
      u = ud(u);
    }
    return r;
  }
  let o = WN(n, e);
  for (; o && QB(o) && mC(o);)
    o = WN(o, e);
  return o && gm(o) && mC(o) && !G1(o) ? r : o || tV(n) || r;
}
const mV = async function (n) {
  const e = this.getOffsetParent || MD, r = this.getDimensions, o = await r(n.floating);
  return {
    reference: pV(n.reference, await e(n.floating), n.strategy),
    floating: {
      x: 0,
      y: 0,
      width: o.width,
      height: o.height
    }
  };
};
function vV(n) {
  return Ps(n).direction === "rtl";
}
const gV = {
  convertOffsetParentRelativeRectToViewportRelativeRect: iV,
  getDocumentElement: Al,
  getClippingRect: fV,
  getOffsetParent: MD,
  getElementRects: mV,
  getClientRects: oV,
  getDimensions: hV,
  getScale: Zp,
  isElement: Ds,
  isRTL: vV
};
function LD(n, e) {
  return n.x === e.x && n.y === e.y && n.width === e.width && n.height === e.height;
}
function yV(n, e) {
  let r = null, o;
  const u = Al(n);
  function c() {
    var m;
    clearTimeout(o), (m = r) == null || m.disconnect(), r = null;
  }
  function f(m, y) {
    m === void 0 && (m = !1), y === void 0 && (y = 1), c();
    const b = n.getBoundingClientRect(), {
      left: _,
      top: T,
      width: k,
      height: C
    } = b;
    if (m || e(), !k || !C)
      return;
    const M = xw(T), N = xw(u.clientWidth - (_ + k)), A = xw(u.clientHeight - (T + C)), $ = xw(_), U = {
      rootMargin: -M + "px " + -N + "px " + -A + "px " + -$ + "px",
      threshold: go(0, ld(1, y)) || 1
    };
    let B = !0;
    function K(te) {
      const re = te[0].intersectionRatio;
      if (re !== y) {
        if (!B)
          return f();
        re ? f(!1, re) : o = setTimeout(() => {
          f(!1, 1e-7);
        }, 1e3);
      }
      re === 1 && !LD(b, n.getBoundingClientRect()) && f(), B = !1;
    }
    try {
      r = new IntersectionObserver(K, {
        ...U,
        // Handle <iframe>s
        root: u.ownerDocument
      });
    } catch {
      r = new IntersectionObserver(K, U);
    }
    r.observe(n);
  }
  return f(!0), c;
}
function bV(n, e, r, o) {
  o === void 0 && (o = {});
  const {
    ancestorScroll: u = !0,
    ancestorResize: c = !0,
    elementResize: f = typeof ResizeObserver == "function",
    layoutShift: m = typeof IntersectionObserver == "function",
    animationFrame: y = !1
  } = o, b = J1(n), _ = u || c ? [...b ? Jg(b) : [], ...Jg(e)] : [];
  _.forEach(($) => {
    u && $.addEventListener("scroll", r, {
      passive: !0
    }), c && $.addEventListener("resize", r);
  });
  const T = b && m ? yV(b, r) : null;
  let k = -1, C = null;
  f && (C = new ResizeObserver(($) => {
    let [I] = $;
    I && I.target === b && C && (C.unobserve(e), cancelAnimationFrame(k), k = requestAnimationFrame(() => {
      var U;
      (U = C) == null || U.observe(e);
    })), r();
  }), b && !y && C.observe(b), C.observe(e));
  let M, N = y ? $f(n) : null;
  y && A();
  function A() {
    const $ = $f(n);
    N && !LD(N, $) && r(), N = $, M = requestAnimationFrame(A);
  }
  return r(), () => {
    var $;
    _.forEach((I) => {
      u && I.removeEventListener("scroll", r), c && I.removeEventListener("resize", r);
    }), T == null || T(), ($ = C) == null || $.disconnect(), C = null, y && cancelAnimationFrame(M);
  };
}
const wV = HB, xV = WB, SV = zB, _V = YB, EV = BB, qN = $B, CV = qB, TV = (n, e, r) => {
  const o = /* @__PURE__ */ new Map(), u = {
    platform: gV,
    ...r
  }, c = {
    ...u.platform,
    _c: o
  };
  return FB(n, e, {
    ...u,
    platform: c
  });
};
var RV = typeof document < "u", kV = function () {
}, $w = RV ? D.useLayoutEffect : kV;
function Gw(n, e) {
  if (n === e)
    return !0;
  if (typeof n != typeof e)
    return !1;
  if (typeof n == "function" && n.toString() === e.toString())
    return !0;
  let r, o, u;
  if (n && e && typeof n == "object") {
    if (Array.isArray(n)) {
      if (r = n.length, r !== e.length) return !1;
      for (o = r; o-- !== 0;)
        if (!Gw(n[o], e[o]))
          return !1;
      return !0;
    }
    if (u = Object.keys(n), r = u.length, r !== Object.keys(e).length)
      return !1;
    for (o = r; o-- !== 0;)
      if (!{}.hasOwnProperty.call(e, u[o]))
        return !1;
    for (o = r; o-- !== 0;) {
      const c = u[o];
      if (!(c === "_owner" && n.$$typeof) && !Gw(n[c], e[c]))
        return !1;
    }
    return !0;
  }
  return n !== n && e !== e;
}
function ID(n) {
  return typeof window > "u" ? 1 : (n.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function YN(n, e) {
  const r = ID(n);
  return Math.round(e * r) / r;
}
function vC(n) {
  const e = D.useRef(n);
  return $w(() => {
    e.current = n;
  }), e;
}
function OV(n) {
  n === void 0 && (n = {});
  const {
    placement: e = "bottom",
    strategy: r = "absolute",
    middleware: o = [],
    platform: u,
    elements: {
      reference: c,
      floating: f
    } = {},
    transform: m = !0,
    whileElementsMounted: y,
    open: b
  } = n, [_, T] = D.useState({
    x: 0,
    y: 0,
    strategy: r,
    placement: e,
    middlewareData: {},
    isPositioned: !1
  }), [k, C] = D.useState(o);
  Gw(k, o) || C(o);
  const [M, N] = D.useState(null), [A, $] = D.useState(null), I = D.useCallback((ue) => {
    ue !== te.current && (te.current = ue, N(ue));
  }, []), U = D.useCallback((ue) => {
    ue !== re.current && (re.current = ue, $(ue));
  }, []), B = c || M, K = f || A, te = D.useRef(null), re = D.useRef(null), ve = D.useRef(_), Ce = y != null, ke = vC(y), Ie = vC(u), Ne = vC(b), Re = D.useCallback(() => {
    if (!te.current || !re.current)
      return;
    const ue = {
      placement: e,
      strategy: r,
      middleware: k
    };
    Ie.current && (ue.platform = Ie.current), TV(te.current, re.current, ue).then((he) => {
      const ge = {
        ...he,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: Ne.current !== !1
      };
      me.current && !Gw(ve.current, ge) && (ve.current = ge, my.flushSync(() => {
        T(ge);
      }));
    });
  }, [k, e, r, Ie, Ne]);
  $w(() => {
    b === !1 && ve.current.isPositioned && (ve.current.isPositioned = !1, T((ue) => ({
      ...ue,
      isPositioned: !1
    })));
  }, [b]);
  const me = D.useRef(!1);
  $w(() => (me.current = !0, () => {
    me.current = !1;
  }), []), $w(() => {
    if (B && (te.current = B), K && (re.current = K), B && K) {
      if (ke.current)
        return ke.current(B, K, Re);
      Re();
    }
  }, [B, K, Re, ke, Ce]);
  const Ge = D.useMemo(() => ({
    reference: te,
    floating: re,
    setReference: I,
    setFloating: U
  }), [I, U]), Me = D.useMemo(() => ({
    reference: B,
    floating: K
  }), [B, K]), we = D.useMemo(() => {
    const ue = {
      position: r,
      left: 0,
      top: 0
    };
    if (!Me.floating)
      return ue;
    const he = YN(Me.floating, _.x), ge = YN(Me.floating, _.y);
    return m ? {
      ...ue,
      transform: "translate(" + he + "px, " + ge + "px)",
      ...ID(Me.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: r,
      left: he,
      top: ge
    };
  }, [r, m, Me.floating, _.x, _.y]);
  return D.useMemo(() => ({
    ..._,
    update: Re,
    refs: Ge,
    elements: Me,
    floatingStyles: we
  }), [_, Re, Ge, Me, we]);
}
const NV = (n) => {
  function e(r) {
    return {}.hasOwnProperty.call(r, "current");
  }
  return {
    name: "arrow",
    options: n,
    fn(r) {
      const {
        element: o,
        padding: u
      } = typeof n == "function" ? n(r) : n;
      return o && e(o) ? o.current != null ? qN({
        element: o.current,
        padding: u
      }).fn(r) : {} : o ? qN({
        element: o,
        padding: u
      }).fn(r) : {};
    }
  };
}, jV = (n, e) => ({
  ...wV(n),
  options: [n, e]
}), AV = (n, e) => ({
  ...xV(n),
  options: [n, e]
}), DV = (n, e) => ({
  ...CV(n),
  options: [n, e]
}), PV = (n, e) => ({
  ...SV(n),
  options: [n, e]
}), MV = (n, e) => ({
  ..._V(n),
  options: [n, e]
}), LV = (n, e) => ({
  ...EV(n),
  options: [n, e]
}), IV = (n, e) => ({
  ...NV(n),
  options: [n, e]
});
var UV = "Arrow", UD = D.forwardRef((n, e) => {
  const { children: r, width: o = 10, height: u = 5, ...c } = n;
  return /* @__PURE__ */ x.jsx(
    Zn.svg,
    {
      ...c,
      ref: e,
      width: o,
      height: u,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: n.asChild ? r : /* @__PURE__ */ x.jsx("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
UD.displayName = UV;
var FV = UD;
function $V(n) {
  const [e, r] = D.useState(void 0);
  return Cu(() => {
    if (n) {
      r({ width: n.offsetWidth, height: n.offsetHeight });
      const o = new ResizeObserver((u) => {
        if (!Array.isArray(u) || !u.length)
          return;
        const c = u[0];
        let f, m;
        if ("borderBoxSize" in c) {
          const y = c.borderBoxSize, b = Array.isArray(y) ? y[0] : y;
          f = b.inlineSize, m = b.blockSize;
        } else
          f = n.offsetWidth, m = n.offsetHeight;
        r({ width: f, height: m });
      });
      return o.observe(n, { box: "border-box" }), () => o.unobserve(n);
    } else
      r(void 0);
  }, [n]), e;
}
var FD = "Popper", [$D, zD] = Yf(FD), [eK, BD] = $D(FD), VD = "PopperAnchor", HD = D.forwardRef(
  (n, e) => {
    const { __scopePopper: r, virtualRef: o, ...u } = n, c = BD(VD, r), f = D.useRef(null), m = pi(e, f);
    return D.useEffect(() => {
      c.onAnchorChange((o == null ? void 0 : o.current) || f.current);
    }), o ? null : /* @__PURE__ */ x.jsx(Zn.div, { ...u, ref: m });
  }
);
HD.displayName = VD;
var X1 = "PopperContent", [zV, BV] = $D(X1), WD = D.forwardRef(
  (n, e) => {
    var et, kt, Et, an, zn, yr;
    const {
      __scopePopper: r,
      side: o = "bottom",
      sideOffset: u = 0,
      align: c = "center",
      alignOffset: f = 0,
      arrowPadding: m = 0,
      avoidCollisions: y = !0,
      collisionBoundary: b = [],
      collisionPadding: _ = 0,
      sticky: T = "partial",
      hideWhenDetached: k = !1,
      updatePositionStrategy: C = "optimized",
      onPlaced: M,
      ...N
    } = n, A = BD(X1, r), [$, I] = D.useState(null), U = pi(e, (cn) => I(cn)), [B, K] = D.useState(null), te = $V(B), re = (te == null ? void 0 : te.width) ?? 0, ve = (te == null ? void 0 : te.height) ?? 0, Ce = o + (c !== "center" ? "-" + c : ""), ke = typeof _ == "number" ? _ : { top: 0, right: 0, bottom: 0, left: 0, ..._ }, Ie = Array.isArray(b) ? b : [b], Ne = Ie.length > 0, Re = {
      padding: ke,
      boundary: Ie.filter(HV),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: Ne
    }, { refs: me, floatingStyles: Ge, placement: Me, isPositioned: we, middlewareData: ue } = OV({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: Ce,
      whileElementsMounted: (...cn) => bV(...cn, {
        animationFrame: C === "always"
      }),
      elements: {
        reference: A.anchor
      },
      middleware: [
        jV({ mainAxis: u + ve, alignmentAxis: f }),
        y && AV({
          mainAxis: !0,
          crossAxis: !1,
          limiter: T === "partial" ? DV() : void 0,
          ...Re
        }),
        y && PV({ ...Re }),
        MV({
          ...Re,
          apply: ({ elements: cn, rects: ar, availableWidth: ir, availableHeight: Bn }) => {
            const { width: Vn, height: Rr } = ar.reference, br = cn.floating.style;
            br.setProperty("--radix-popper-available-width", `${ir}px`), br.setProperty("--radix-popper-available-height", `${Bn}px`), br.setProperty("--radix-popper-anchor-width", `${Vn}px`), br.setProperty("--radix-popper-anchor-height", `${Rr}px`);
          }
        }),
        B && IV({ element: B, padding: m }),
        WV({ arrowWidth: re, arrowHeight: ve }),
        k && LV({ strategy: "referenceHidden", ...Re })
      ]
    }), [he, ge] = KD(Me), Y = As(M);
    Cu(() => {
      we && (Y == null || Y());
    }, [we, Y]);
    const ae = (et = ue.arrow) == null ? void 0 : et.x, Pe = (kt = ue.arrow) == null ? void 0 : kt.y, Ue = ((Et = ue.arrow) == null ? void 0 : Et.centerOffset) !== 0, [ut, xt] = D.useState();
    return Cu(() => {
      $ && xt(window.getComputedStyle($).zIndex);
    }, [$]), /* @__PURE__ */ x.jsx(
      "div",
      {
        ref: me.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...Ge,
          transform: we ? Ge.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: ut,
          "--radix-popper-transform-origin": [
            (an = ue.transformOrigin) == null ? void 0 : an.x,
            (zn = ue.transformOrigin) == null ? void 0 : zn.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...((yr = ue.hide) == null ? void 0 : yr.referenceHidden) && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: n.dir,
        children: /* @__PURE__ */ x.jsx(
          zV,
          {
            scope: r,
            placedSide: he,
            onArrowChange: K,
            arrowX: ae,
            arrowY: Pe,
            shouldHideArrow: Ue,
            children: /* @__PURE__ */ x.jsx(
              Zn.div,
              {
                "data-side": he,
                "data-align": ge,
                ...N,
                ref: U,
                style: {
                  ...N.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: we ? void 0 : "none"
                }
              }
            )
          }
        )
      }
    );
  }
);
WD.displayName = X1;
var qD = "PopperArrow", VV = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
}, YD = D.forwardRef(function (e, r) {
  const { __scopePopper: o, ...u } = e, c = BV(qD, o), f = VV[c.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ x.jsx(
    "span",
    {
      ref: c.onArrowChange,
      style: {
        position: "absolute",
        left: c.arrowX,
        top: c.arrowY,
        [f]: 0,
        transformOrigin: {
          top: "",
          right: "0 0",
          bottom: "center 0",
          left: "100% 0"
        }[c.placedSide],
        transform: {
          top: "translateY(100%)",
          right: "translateY(50%) rotate(90deg) translateX(-50%)",
          bottom: "rotate(180deg)",
          left: "translateY(50%) rotate(-90deg) translateX(50%)"
        }[c.placedSide],
        visibility: c.shouldHideArrow ? "hidden" : void 0
      },
      children: /* @__PURE__ */ x.jsx(
        FV,
        {
          ...u,
          ref: r,
          style: {
            ...u.style,
            // ensures the element can be measured correctly (mostly for if SVG)
            display: "block"
          }
        }
      )
    }
  )
  );
});
YD.displayName = qD;
function HV(n) {
  return n !== null;
}
var WV = (n) => ({
  name: "transformOrigin",
  options: n,
  fn(e) {
    var A, $, I;
    const { placement: r, rects: o, middlewareData: u } = e, f = ((A = u.arrow) == null ? void 0 : A.centerOffset) !== 0, m = f ? 0 : n.arrowWidth, y = f ? 0 : n.arrowHeight, [b, _] = KD(r), T = { start: "0%", center: "50%", end: "100%" }[_], k = ((($ = u.arrow) == null ? void 0 : $.x) ?? 0) + m / 2, C = (((I = u.arrow) == null ? void 0 : I.y) ?? 0) + y / 2;
    let M = "", N = "";
    return b === "bottom" ? (M = f ? T : `${k}px`, N = `${-y}px`) : b === "top" ? (M = f ? T : `${k}px`, N = `${o.floating.height + y}px`) : b === "right" ? (M = `${-y}px`, N = f ? T : `${C}px`) : b === "left" && (M = `${o.floating.width + y}px`, N = f ? T : `${C}px`), { data: { x: M, y: N } };
  }
});
function KD(n) {
  const [e, r = "center"] = n.split("-");
  return [e, r];
}
var qV = HD, YV = WD, KV = YD, [xx, tK] = Yf("Tooltip", [
  zD
]), eT = zD(), GD = "TooltipProvider", GV = 700, KN = "tooltip.open", [QV, QD] = xx(GD), JD = (n) => {
  const {
    __scopeTooltip: e,
    delayDuration: r = GV,
    skipDelayDuration: o = 300,
    disableHoverableContent: u = !1,
    children: c
  } = n, f = D.useRef(!0), m = D.useRef(!1), y = D.useRef(0);
  return D.useEffect(() => {
    const b = y.current;
    return () => window.clearTimeout(b);
  }, []), /* @__PURE__ */ x.jsx(
    QV,
    {
      scope: e,
      isOpenDelayedRef: f,
      delayDuration: r,
      onOpen: D.useCallback(() => {
        window.clearTimeout(y.current), f.current = !1;
      }, []),
      onClose: D.useCallback(() => {
        window.clearTimeout(y.current), y.current = window.setTimeout(
          () => f.current = !0,
          o
        );
      }, [o]),
      isPointerInTransitRef: m,
      onPointerInTransitChange: D.useCallback((b) => {
        m.current = b;
      }, []),
      disableHoverableContent: u,
      children: c
    }
  );
};
JD.displayName = GD;
var ZD = "Tooltip", [nK, Sx] = xx(ZD), JC = "TooltipTrigger", JV = D.forwardRef(
  (n, e) => {
    const { __scopeTooltip: r, ...o } = n, u = Sx(JC, r), c = QD(JC, r), f = eT(r), m = D.useRef(null), y = pi(e, m, u.onTriggerChange), b = D.useRef(!1), _ = D.useRef(!1), T = D.useCallback(() => b.current = !1, []);
    return D.useEffect(() => () => document.removeEventListener("pointerup", T), [T]), /* @__PURE__ */ x.jsx(qV, {
      asChild: !0, ...f, children: /* @__PURE__ */ x.jsx(
        Zn.button,
        {
          "aria-describedby": u.open ? u.contentId : void 0,
          "data-state": u.stateAttribute,
          ...o,
          ref: y,
          onPointerMove: wn(n.onPointerMove, (k) => {
            k.pointerType !== "touch" && !_.current && !c.isPointerInTransitRef.current && (u.onTriggerEnter(), _.current = !0);
          }),
          onPointerLeave: wn(n.onPointerLeave, () => {
            u.onTriggerLeave(), _.current = !1;
          }),
          onPointerDown: wn(n.onPointerDown, () => {
            u.open && u.onClose(), b.current = !0, document.addEventListener("pointerup", T, { once: !0 });
          }),
          onFocus: wn(n.onFocus, () => {
            b.current || u.onOpen();
          }),
          onBlur: wn(n.onBlur, u.onClose),
          onClick: wn(n.onClick, u.onClose)
        }
      )
    });
  }
);
JV.displayName = JC;
var ZV = "TooltipPortal", [rK, XV] = xx(ZV, {
  forceMount: void 0
}), ym = "TooltipContent", XD = D.forwardRef(
  (n, e) => {
    const r = XV(ym, n.__scopeTooltip), { forceMount: o = r.forceMount, side: u = "top", ...c } = n, f = Sx(ym, n.__scopeTooltip);
    return /* @__PURE__ */ x.jsx(Kf, { present: o || f.open, children: f.disableHoverableContent ? /* @__PURE__ */ x.jsx(eP, { side: u, ...c, ref: e }) : /* @__PURE__ */ x.jsx(e5, { side: u, ...c, ref: e }) });
  }
), e5 = D.forwardRef((n, e) => {
  const r = Sx(ym, n.__scopeTooltip), o = QD(ym, n.__scopeTooltip), u = D.useRef(null), c = pi(e, u), [f, m] = D.useState(null), { trigger: y, onClose: b } = r, _ = u.current, { onPointerInTransitChange: T } = o, k = D.useCallback(() => {
    m(null), T(!1);
  }, [T]), C = D.useCallback(
    (M, N) => {
      const A = M.currentTarget, $ = { x: M.clientX, y: M.clientY }, I = i5($, A.getBoundingClientRect()), U = o5($, I), B = s5(N.getBoundingClientRect()), K = u5([...U, ...B]);
      m(K), T(!0);
    },
    [T]
  );
  return D.useEffect(() => () => k(), [k]), D.useEffect(() => {
    if (y && _) {
      const M = (A) => C(A, _), N = (A) => C(A, y);
      return y.addEventListener("pointerleave", M), _.addEventListener("pointerleave", N), () => {
        y.removeEventListener("pointerleave", M), _.removeEventListener("pointerleave", N);
      };
    }
  }, [y, _, C, k]), D.useEffect(() => {
    if (f) {
      const M = (N) => {
        const A = N.target, $ = { x: N.clientX, y: N.clientY }, I = (y == null ? void 0 : y.contains(A)) || (_ == null ? void 0 : _.contains(A)), U = !l5($, f);
        I ? k() : U && (k(), b());
      };
      return document.addEventListener("pointermove", M), () => document.removeEventListener("pointermove", M);
    }
  }, [y, _, f, b, k]), /* @__PURE__ */ x.jsx(eP, { ...n, ref: c });
}), [t5, n5] = xx(ZD, { isInside: !1 }), r5 = /* @__PURE__ */ n4("TooltipContent"), eP = D.forwardRef(
  (n, e) => {
    const {
      __scopeTooltip: r,
      children: o,
      "aria-label": u,
      onEscapeKeyDown: c,
      onPointerDownOutside: f,
      ...m
    } = n, y = Sx(ym, r), b = eT(r), { onClose: _ } = y;
    return D.useEffect(() => (document.addEventListener(KN, _), () => document.removeEventListener(KN, _)), [_]), D.useEffect(() => {
      if (y.trigger) {
        const T = (k) => {
          const C = k.target;
          C != null && C.contains(y.trigger) && _();
        };
        return window.addEventListener("scroll", T, { capture: !0 }), () => window.removeEventListener("scroll", T, { capture: !0 });
      }
    }, [y.trigger, _]), /* @__PURE__ */ x.jsx(
      px,
      {
        asChild: !0,
        disableOutsidePointerEvents: !1,
        onEscapeKeyDown: c,
        onPointerDownOutside: f,
        onFocusOutside: (T) => T.preventDefault(),
        onDismiss: _,
        children: /* @__PURE__ */ x.jsxs(
          YV,
          {
            "data-state": y.stateAttribute,
            ...b,
            ...m,
            ref: e,
            style: {
              ...m.style,
              "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
              "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
              "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
              "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
              "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
            },
            children: [
              /* @__PURE__ */ x.jsx(r5, { children: o }),
              /* @__PURE__ */ x.jsx(t5, { scope: r, isInside: !0, children: /* @__PURE__ */ x.jsx(C4, { id: y.contentId, role: "tooltip", children: u || o }) })
            ]
          }
        )
      }
    );
  }
);
XD.displayName = ym;
var tP = "TooltipArrow", a5 = D.forwardRef(
  (n, e) => {
    const { __scopeTooltip: r, ...o } = n, u = eT(r);
    return n5(
      tP,
      r
    ).isInside ? null : /* @__PURE__ */ x.jsx(KV, { ...u, ...o, ref: e });
  }
);
a5.displayName = tP;
function i5(n, e) {
  const r = Math.abs(e.top - n.y), o = Math.abs(e.bottom - n.y), u = Math.abs(e.right - n.x), c = Math.abs(e.left - n.x);
  switch (Math.min(r, o, u, c)) {
    case c:
      return "left";
    case u:
      return "right";
    case r:
      return "top";
    case o:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function o5(n, e, r = 5) {
  const o = [];
  switch (e) {
    case "top":
      o.push(
        { x: n.x - r, y: n.y + r },
        { x: n.x + r, y: n.y + r }
      );
      break;
    case "bottom":
      o.push(
        { x: n.x - r, y: n.y - r },
        { x: n.x + r, y: n.y - r }
      );
      break;
    case "left":
      o.push(
        { x: n.x + r, y: n.y - r },
        { x: n.x + r, y: n.y + r }
      );
      break;
    case "right":
      o.push(
        { x: n.x - r, y: n.y - r },
        { x: n.x - r, y: n.y + r }
      );
      break;
  }
  return o;
}
function s5(n) {
  const { top: e, right: r, bottom: o, left: u } = n;
  return [
    { x: u, y: e },
    { x: r, y: e },
    { x: r, y: o },
    { x: u, y: o }
  ];
}
function l5(n, e) {
  const { x: r, y: o } = n;
  let u = !1;
  for (let c = 0, f = e.length - 1; c < e.length; f = c++) {
    const m = e[c], y = e[f], b = m.x, _ = m.y, T = y.x, k = y.y;
    _ > o != k > o && r < (T - b) * (o - _) / (k - _) + b && (u = !u);
  }
  return u;
}
function u5(n) {
  const e = n.slice();
  return e.sort((r, o) => r.x < o.x ? -1 : r.x > o.x ? 1 : r.y < o.y ? -1 : r.y > o.y ? 1 : 0), c5(e);
}
function c5(n) {
  if (n.length <= 1) return n.slice();
  const e = [];
  for (let o = 0; o < n.length; o++) {
    const u = n[o];
    for (; e.length >= 2;) {
      const c = e[e.length - 1], f = e[e.length - 2];
      if ((c.x - f.x) * (u.y - f.y) >= (c.y - f.y) * (u.x - f.x)) e.pop();
      else break;
    }
    e.push(u);
  }
  e.pop();
  const r = [];
  for (let o = n.length - 1; o >= 0; o--) {
    const u = n[o];
    for (; r.length >= 2;) {
      const c = r[r.length - 1], f = r[r.length - 2];
      if ((c.x - f.x) * (u.y - f.y) >= (c.y - f.y) * (u.x - f.x)) r.pop();
      else break;
    }
    r.push(u);
  }
  return r.pop(), e.length === 1 && r.length === 1 && e[0].x === r[0].x && e[0].y === r[0].y ? e : e.concat(r);
}
var d5 = JD, nP = XD;
const f5 = d5, h5 = D.forwardRef(({ className: n, sideOffset: e = 4, ...r }, o) => /* @__PURE__ */ x.jsx(
  nP,
  {
    ref: o,
    sideOffset: e,
    className: tn(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      n
    ),
    ...r
  }
));
h5.displayName = nP.displayName;
var km = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set(), this.subscribe = this.subscribe.bind(this);
  }
  subscribe(n) {
    return this.listeners.add(n), this.onSubscribe(), () => {
      this.listeners.delete(n), this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
}, zf = typeof window > "u" || "Deno" in globalThis;
function Oi() {
}
function p5(n, e) {
  return typeof n == "function" ? n(e) : n;
}
function ZC(n) {
  return typeof n == "number" && n >= 0 && n !== 1 / 0;
}
function rP(n, e) {
  return Math.max(n + (e || 0) - Date.now(), 0);
}
function od(n, e) {
  return typeof n == "function" ? n(e) : n;
}
function Vo(n, e) {
  return typeof n == "function" ? n(e) : n;
}
function GN(n, e) {
  const {
    type: r = "all",
    exact: o,
    fetchStatus: u,
    predicate: c,
    queryKey: f,
    stale: m
  } = n;
  if (f) {
    if (o) {
      if (e.queryHash !== tT(f, e.options))
        return !1;
    } else if (!Zg(e.queryKey, f))
      return !1;
  }
  if (r !== "all") {
    const y = e.isActive();
    if (r === "active" && !y || r === "inactive" && y)
      return !1;
  }
  return !(typeof m == "boolean" && e.isStale() !== m || u && u !== e.state.fetchStatus || c && !c(e));
}
function QN(n, e) {
  const { exact: r, status: o, predicate: u, mutationKey: c } = n;
  if (c) {
    if (!e.options.mutationKey)
      return !1;
    if (r) {
      if (Bf(e.options.mutationKey) !== Bf(c))
        return !1;
    } else if (!Zg(e.options.mutationKey, c))
      return !1;
  }
  return !(o && e.state.status !== o || u && !u(e));
}
function tT(n, e) {
  return ((e == null ? void 0 : e.queryKeyHashFn) || Bf)(n);
}
function Bf(n) {
  return JSON.stringify(
    n,
    (e, r) => e1(r) ? Object.keys(r).sort().reduce((o, u) => (o[u] = r[u], o), {}) : r
  );
}
function Zg(n, e) {
  return n === e ? !0 : typeof n != typeof e ? !1 : n && e && typeof n == "object" && typeof e == "object" ? Object.keys(e).every((r) => Zg(n[r], e[r])) : !1;
}
function XC(n, e) {
  if (n === e)
    return n;
  const r = JN(n) && JN(e);
  if (r || e1(n) && e1(e)) {
    const o = r ? n : Object.keys(n), u = o.length, c = r ? e : Object.keys(e), f = c.length, m = r ? [] : {}, y = new Set(o);
    let b = 0;
    for (let _ = 0; _ < f; _++) {
      const T = r ? _ : c[_];
      (!r && y.has(T) || r) && n[T] === void 0 && e[T] === void 0 ? (m[T] = void 0, b++) : (m[T] = XC(n[T], e[T]), m[T] === n[T] && n[T] !== void 0 && b++);
    }
    return u === f && b === u ? n : m;
  }
  return e;
}
function Qw(n, e) {
  if (!e || Object.keys(n).length !== Object.keys(e).length)
    return !1;
  for (const r in n)
    if (n[r] !== e[r])
      return !1;
  return !0;
}
function JN(n) {
  return Array.isArray(n) && n.length === Object.keys(n).length;
}
function e1(n) {
  if (!ZN(n))
    return !1;
  const e = n.constructor;
  if (e === void 0)
    return !0;
  const r = e.prototype;
  return !(!ZN(r) || !r.hasOwnProperty("isPrototypeOf") || Object.getPrototypeOf(n) !== Object.prototype);
}
function ZN(n) {
  return Object.prototype.toString.call(n) === "[object Object]";
}
function m5(n) {
  return new Promise((e) => {
    setTimeout(e, n);
  });
}
function t1(n, e, r) {
  if (typeof r.structuralSharing == "function")
    return r.structuralSharing(n, e);
  if (r.structuralSharing !== !1) {
    if (process.env.NODE_ENV !== "production")
      try {
        return XC(n, e);
      } catch (o) {
        throw console.error(
          `Structural sharing requires data to be JSON serializable. To fix this, turn off structuralSharing or return JSON-serializable data from your queryFn. [${r.queryHash}]: ${o}`
        ), o;
      }
    return XC(n, e);
  }
  return e;
}
function v5(n, e, r = 0) {
  const o = [...n, e];
  return r && o.length > r ? o.slice(1) : o;
}
function g5(n, e, r = 0) {
  const o = [e, ...n];
  return r && o.length > r ? o.slice(0, -1) : o;
}
var Jw = Symbol();
function aP(n, e) {
  return process.env.NODE_ENV !== "production" && n.queryFn === Jw && console.error(
    `Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${n.queryHash}'`
  ), !n.queryFn && (e != null && e.initialPromise) ? () => e.initialPromise : !n.queryFn || n.queryFn === Jw ? () => Promise.reject(new Error(`Missing queryFn: '${n.queryHash}'`)) : n.queryFn;
}
function iP(n, e) {
  return typeof n == "function" ? n(...e) : !!n;
}
var Nf, Kc, am, _A, y5 = (_A = class extends km {
  constructor() {
    super();
    _t(this, Nf);
    _t(this, Kc);
    _t(this, am);
    Ye(this, am, (e) => {
      if (!zf && window.addEventListener) {
        const r = () => e();
        return window.addEventListener("visibilitychange", r, !1), () => {
          window.removeEventListener("visibilitychange", r);
        };
      }
    });
  }
  onSubscribe() {
    W(this, Kc) || this.setEventListener(W(this, am));
  }
  onUnsubscribe() {
    var e;
    this.hasListeners() || ((e = W(this, Kc)) == null || e.call(this), Ye(this, Kc, void 0));
  }
  setEventListener(e) {
    var r;
    Ye(this, am, e), (r = W(this, Kc)) == null || r.call(this), Ye(this, Kc, e((o) => {
      typeof o == "boolean" ? this.setFocused(o) : this.onFocus();
    }));
  }
  setFocused(e) {
    W(this, Nf) !== e && (Ye(this, Nf, e), this.onFocus());
  }
  onFocus() {
    const e = this.isFocused();
    this.listeners.forEach((r) => {
      r(e);
    });
  }
  isFocused() {
    var e;
    return typeof W(this, Nf) == "boolean" ? W(this, Nf) : ((e = globalThis.document) == null ? void 0 : e.visibilityState) !== "hidden";
  }
}, Nf = new WeakMap(), Kc = new WeakMap(), am = new WeakMap(), _A), nT = new y5(), im, Gc, om, EA, b5 = (EA = class extends km {
  constructor() {
    super();
    _t(this, im, !0);
    _t(this, Gc);
    _t(this, om);
    Ye(this, om, (e) => {
      if (!zf && window.addEventListener) {
        const r = () => e(!0), o = () => e(!1);
        return window.addEventListener("online", r, !1), window.addEventListener("offline", o, !1), () => {
          window.removeEventListener("online", r), window.removeEventListener("offline", o);
        };
      }
    });
  }
  onSubscribe() {
    W(this, Gc) || this.setEventListener(W(this, om));
  }
  onUnsubscribe() {
    var e;
    this.hasListeners() || ((e = W(this, Gc)) == null || e.call(this), Ye(this, Gc, void 0));
  }
  setEventListener(e) {
    var r;
    Ye(this, om, e), (r = W(this, Gc)) == null || r.call(this), Ye(this, Gc, e(this.setOnline.bind(this)));
  }
  setOnline(e) {
    W(this, im) !== e && (Ye(this, im, e), this.listeners.forEach((o) => {
      o(e);
    }));
  }
  isOnline() {
    return W(this, im);
  }
}, im = new WeakMap(), Gc = new WeakMap(), om = new WeakMap(), EA), Zw = new b5();
function n1() {
  let n, e;
  const r = new Promise((u, c) => {
    n = u, e = c;
  });
  r.status = "pending", r.catch(() => {
  });
  function o(u) {
    Object.assign(r, u), delete r.resolve, delete r.reject;
  }
  return r.resolve = (u) => {
    o({
      status: "fulfilled",
      value: u
    }), n(u);
  }, r.reject = (u) => {
    o({
      status: "rejected",
      reason: u
    }), e(u);
  }, r;
}
function w5(n) {
  return Math.min(1e3 * 2 ** n, 3e4);
}
function oP(n) {
  return (n ?? "online") === "online" ? Zw.isOnline() : !0;
}
var sP = class extends Error {
  constructor(n) {
    super("CancelledError"), this.revert = n == null ? void 0 : n.revert, this.silent = n == null ? void 0 : n.silent;
  }
};
function gC(n) {
  return n instanceof sP;
}
function lP(n) {
  let e = !1, r = 0, o = !1, u;
  const c = n1(), f = (N) => {
    var A;
    o || (k(new sP(N)), (A = n.abort) == null || A.call(n));
  }, m = () => {
    e = !0;
  }, y = () => {
    e = !1;
  }, b = () => nT.isFocused() && (n.networkMode === "always" || Zw.isOnline()) && n.canRun(), _ = () => oP(n.networkMode) && n.canRun(), T = (N) => {
    var A;
    o || (o = !0, (A = n.onSuccess) == null || A.call(n, N), u == null || u(), c.resolve(N));
  }, k = (N) => {
    var A;
    o || (o = !0, (A = n.onError) == null || A.call(n, N), u == null || u(), c.reject(N));
  }, C = () => new Promise((N) => {
    var A;
    u = ($) => {
      (o || b()) && N($);
    }, (A = n.onPause) == null || A.call(n);
  }).then(() => {
    var N;
    u = void 0, o || (N = n.onContinue) == null || N.call(n);
  }), M = () => {
    if (o)
      return;
    let N;
    const A = r === 0 ? n.initialPromise : void 0;
    try {
      N = A ?? n.fn();
    } catch ($) {
      N = Promise.reject($);
    }
    Promise.resolve(N).then(T).catch(($) => {
      var te;
      if (o)
        return;
      const I = n.retry ?? (zf ? 0 : 3), U = n.retryDelay ?? w5, B = typeof U == "function" ? U(r, $) : U, K = I === !0 || typeof I == "number" && r < I || typeof I == "function" && I(r, $);
      if (e || !K) {
        k($);
        return;
      }
      r++, (te = n.onFail) == null || te.call(n, r, $), m5(B).then(() => b() ? void 0 : C()).then(() => {
        e ? k($) : M();
      });
    });
  };
  return {
    promise: c,
    cancel: f,
    continue: () => (u == null || u(), c),
    cancelRetry: m,
    continueRetry: y,
    canStart: _,
    start: () => (_() ? M() : C().then(M), c)
  };
}
var x5 = (n) => setTimeout(n, 0);
function S5() {
  let n = [], e = 0, r = (m) => {
    m();
  }, o = (m) => {
    m();
  }, u = x5;
  const c = (m) => {
    e ? n.push(m) : u(() => {
      r(m);
    });
  }, f = () => {
    const m = n;
    n = [], m.length && u(() => {
      o(() => {
        m.forEach((y) => {
          r(y);
        });
      });
    });
  };
  return {
    batch: (m) => {
      let y;
      e++;
      try {
        y = m();
      } finally {
        e--, e || f();
      }
      return y;
    },
    /**
     * All calls to the wrapped function will be batched.
     */
    batchCalls: (m) => (...y) => {
      c(() => {
        m(...y);
      });
    },
    schedule: c,
    /**
     * Use this method to set a custom notify function.
     * This can be used to for example wrap notifications with `React.act` while running tests.
     */
    setNotifyFunction: (m) => {
      r = m;
    },
    /**
     * Use this method to set a custom function to batch notifications together into a single tick.
     * By default React Query will use the batch function provided by ReactDOM or React Native.
     */
    setBatchNotifyFunction: (m) => {
      o = m;
    },
    setScheduler: (m) => {
      u = m;
    }
  };
}
var ba = S5(), jf, CA, uP = (CA = class {
  constructor() {
    _t(this, jf);
  }
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout(), ZC(this.gcTime) && Ye(this, jf, setTimeout(() => {
      this.optionalRemove();
    }, this.gcTime));
  }
  updateGcTime(n) {
    this.gcTime = Math.max(
      this.gcTime || 0,
      n ?? (zf ? 1 / 0 : 5 * 60 * 1e3)
    );
  }
  clearGcTimeout() {
    W(this, jf) && (clearTimeout(W(this, jf)), Ye(this, jf, void 0));
  }
}, jf = new WeakMap(), CA), sm, Af, Bo, Df, fi, cy, Pf, Os, bu, TA, _5 = (TA = class extends uP {
  constructor(e) {
    super();
    _t(this, Os);
    _t(this, sm);
    _t(this, Af);
    _t(this, Bo);
    _t(this, Df);
    _t(this, fi);
    _t(this, cy);
    _t(this, Pf);
    Ye(this, Pf, !1), Ye(this, cy, e.defaultOptions), this.setOptions(e.options), this.observers = [], Ye(this, Df, e.client), Ye(this, Bo, W(this, Df).getQueryCache()), this.queryKey = e.queryKey, this.queryHash = e.queryHash, Ye(this, sm, E5(this.options)), this.state = e.state ?? W(this, sm), this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  get promise() {
    var e;
    return (e = W(this, fi)) == null ? void 0 : e.promise;
  }
  setOptions(e) {
    this.options = { ...W(this, cy), ...e }, this.updateGcTime(this.options.gcTime);
  }
  optionalRemove() {
    !this.observers.length && this.state.fetchStatus === "idle" && W(this, Bo).remove(this);
  }
  setData(e, r) {
    const o = t1(this.state.data, e, this.options);
    return qt(this, Os, bu).call(this, {
      data: o,
      type: "success",
      dataUpdatedAt: r == null ? void 0 : r.updatedAt,
      manual: r == null ? void 0 : r.manual
    }), o;
  }
  setState(e, r) {
    qt(this, Os, bu).call(this, { type: "setState", state: e, setStateOptions: r });
  }
  cancel(e) {
    var o, u;
    const r = (o = W(this, fi)) == null ? void 0 : o.promise;
    return (u = W(this, fi)) == null || u.cancel(e), r ? r.then(Oi).catch(Oi) : Promise.resolve();
  }
  destroy() {
    super.destroy(), this.cancel({ silent: !0 });
  }
  reset() {
    this.destroy(), this.setState(W(this, sm));
  }
  isActive() {
    return this.observers.some(
      (e) => Vo(e.options.enabled, this) !== !1
    );
  }
  isDisabled() {
    return this.getObserversCount() > 0 ? !this.isActive() : this.options.queryFn === Jw || this.state.dataUpdateCount + this.state.errorUpdateCount === 0;
  }
  isStatic() {
    return this.getObserversCount() > 0 ? this.observers.some(
      (e) => od(e.options.staleTime, this) === "static"
    ) : !1;
  }
  isStale() {
    return this.getObserversCount() > 0 ? this.observers.some(
      (e) => e.getCurrentResult().isStale
    ) : this.state.data === void 0 || this.state.isInvalidated;
  }
  isStaleByTime(e = 0) {
    return this.state.data === void 0 ? !0 : e === "static" ? !1 : this.state.isInvalidated ? !0 : !rP(this.state.dataUpdatedAt, e);
  }
  onFocus() {
    var r;
    const e = this.observers.find((o) => o.shouldFetchOnWindowFocus());
    e == null || e.refetch({ cancelRefetch: !1 }), (r = W(this, fi)) == null || r.continue();
  }
  onOnline() {
    var r;
    const e = this.observers.find((o) => o.shouldFetchOnReconnect());
    e == null || e.refetch({ cancelRefetch: !1 }), (r = W(this, fi)) == null || r.continue();
  }
  addObserver(e) {
    this.observers.includes(e) || (this.observers.push(e), this.clearGcTimeout(), W(this, Bo).notify({ type: "observerAdded", query: this, observer: e }));
  }
  removeObserver(e) {
    this.observers.includes(e) && (this.observers = this.observers.filter((r) => r !== e), this.observers.length || (W(this, fi) && (W(this, Pf) ? W(this, fi).cancel({ revert: !0 }) : W(this, fi).cancelRetry()), this.scheduleGc()), W(this, Bo).notify({ type: "observerRemoved", query: this, observer: e }));
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    this.state.isInvalidated || qt(this, Os, bu).call(this, { type: "invalidate" });
  }
  fetch(e, r) {
    var b, _, T;
    if (this.state.fetchStatus !== "idle") {
      if (this.state.data !== void 0 && (r != null && r.cancelRefetch))
        this.cancel({ silent: !0 });
      else if (W(this, fi))
        return W(this, fi).continueRetry(), W(this, fi).promise;
    }
    if (e && this.setOptions(e), !this.options.queryFn) {
      const k = this.observers.find((C) => C.options.queryFn);
      k && this.setOptions(k.options);
    }
    process.env.NODE_ENV !== "production" && (Array.isArray(this.options.queryKey) || console.error(
      "As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']"
    ));
    const o = new AbortController(), u = (k) => {
      Object.defineProperty(k, "signal", {
        enumerable: !0,
        get: () => (Ye(this, Pf, !0), o.signal)
      });
    }, c = () => {
      const k = aP(this.options, r), M = (() => {
        const N = {
          client: W(this, Df),
          queryKey: this.queryKey,
          meta: this.meta
        };
        return u(N), N;
      })();
      return Ye(this, Pf, !1), this.options.persister ? this.options.persister(
        k,
        M,
        this
      ) : k(M);
    }, m = (() => {
      const k = {
        fetchOptions: r,
        options: this.options,
        queryKey: this.queryKey,
        client: W(this, Df),
        state: this.state,
        fetchFn: c
      };
      return u(k), k;
    })();
    (b = this.options.behavior) == null || b.onFetch(m, this), Ye(this, Af, this.state), (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((_ = m.fetchOptions) == null ? void 0 : _.meta)) && qt(this, Os, bu).call(this, { type: "fetch", meta: (T = m.fetchOptions) == null ? void 0 : T.meta });
    const y = (k) => {
      var C, M, N, A;
      gC(k) && k.silent || qt(this, Os, bu).call(this, {
        type: "error",
        error: k
      }), gC(k) || ((M = (C = W(this, Bo).config).onError) == null || M.call(
        C,
        k,
        this
      ), (A = (N = W(this, Bo).config).onSettled) == null || A.call(
        N,
        this.state.data,
        k,
        this
      )), this.scheduleGc();
    };
    return Ye(this, fi, lP({
      initialPromise: r == null ? void 0 : r.initialPromise,
      fn: m.fetchFn,
      abort: o.abort.bind(o),
      onSuccess: (k) => {
        var C, M, N, A;
        if (k === void 0) {
          process.env.NODE_ENV !== "production" && console.error(
            `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`
          ), y(new Error(`${this.queryHash} data is undefined`));
          return;
        }
        try {
          this.setData(k);
        } catch ($) {
          y($);
          return;
        }
        (M = (C = W(this, Bo).config).onSuccess) == null || M.call(C, k, this), (A = (N = W(this, Bo).config).onSettled) == null || A.call(
          N,
          k,
          this.state.error,
          this
        ), this.scheduleGc();
      },
      onError: y,
      onFail: (k, C) => {
        qt(this, Os, bu).call(this, { type: "failed", failureCount: k, error: C });
      },
      onPause: () => {
        qt(this, Os, bu).call(this, { type: "pause" });
      },
      onContinue: () => {
        qt(this, Os, bu).call(this, { type: "continue" });
      },
      retry: m.options.retry,
      retryDelay: m.options.retryDelay,
      networkMode: m.options.networkMode,
      canRun: () => !0
    })), W(this, fi).start();
  }
}, sm = new WeakMap(), Af = new WeakMap(), Bo = new WeakMap(), Df = new WeakMap(), fi = new WeakMap(), cy = new WeakMap(), Pf = new WeakMap(), Os = new WeakSet(), bu = function (e) {
  const r = (o) => {
    switch (e.type) {
      case "failed":
        return {
          ...o,
          fetchFailureCount: e.failureCount,
          fetchFailureReason: e.error
        };
      case "pause":
        return {
          ...o,
          fetchStatus: "paused"
        };
      case "continue":
        return {
          ...o,
          fetchStatus: "fetching"
        };
      case "fetch":
        return {
          ...o,
          ...cP(o.data, this.options),
          fetchMeta: e.meta ?? null
        };
      case "success":
        return Ye(this, Af, void 0), {
          ...o,
          data: e.data,
          dataUpdateCount: o.dataUpdateCount + 1,
          dataUpdatedAt: e.dataUpdatedAt ?? Date.now(),
          error: null,
          isInvalidated: !1,
          status: "success",
          ...!e.manual && {
            fetchStatus: "idle",
            fetchFailureCount: 0,
            fetchFailureReason: null
          }
        };
      case "error":
        const u = e.error;
        return gC(u) && u.revert && W(this, Af) ? { ...W(this, Af), fetchStatus: "idle" } : {
          ...o,
          error: u,
          errorUpdateCount: o.errorUpdateCount + 1,
          errorUpdatedAt: Date.now(),
          fetchFailureCount: o.fetchFailureCount + 1,
          fetchFailureReason: u,
          fetchStatus: "idle",
          status: "error"
        };
      case "invalidate":
        return {
          ...o,
          isInvalidated: !0
        };
      case "setState":
        return {
          ...o,
          ...e.state
        };
    }
  };
  this.state = r(this.state), ba.batch(() => {
    this.observers.forEach((o) => {
      o.onQueryUpdate();
    }), W(this, Bo).notify({ query: this, type: "updated", action: e });
  });
}, TA);
function cP(n, e) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: oP(e.networkMode) ? "fetching" : "paused",
    ...n === void 0 && {
      error: null,
      status: "pending"
    }
  };
}
function E5(n) {
  const e = typeof n.initialData == "function" ? n.initialData() : n.initialData, r = e !== void 0, o = r ? typeof n.initialDataUpdatedAt == "function" ? n.initialDataUpdatedAt() : n.initialDataUpdatedAt : 0;
  return {
    data: e,
    dataUpdateCount: 0,
    dataUpdatedAt: r ? o ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: !1,
    status: r ? "success" : "pending",
    fetchStatus: "idle"
  };
}
var Sl, RA, C5 = (RA = class extends km {
  constructor(e = {}) {
    super();
    _t(this, Sl);
    this.config = e, Ye(this, Sl, /* @__PURE__ */ new Map());
  }
  build(e, r, o) {
    const u = r.queryKey, c = r.queryHash ?? tT(u, r);
    let f = this.get(c);
    return f || (f = new _5({
      client: e,
      queryKey: u,
      queryHash: c,
      options: e.defaultQueryOptions(r),
      state: o,
      defaultOptions: e.getQueryDefaults(u)
    }), this.add(f)), f;
  }
  add(e) {
    W(this, Sl).has(e.queryHash) || (W(this, Sl).set(e.queryHash, e), this.notify({
      type: "added",
      query: e
    }));
  }
  remove(e) {
    const r = W(this, Sl).get(e.queryHash);
    r && (e.destroy(), r === e && W(this, Sl).delete(e.queryHash), this.notify({ type: "removed", query: e }));
  }
  clear() {
    ba.batch(() => {
      this.getAll().forEach((e) => {
        this.remove(e);
      });
    });
  }
  get(e) {
    return W(this, Sl).get(e);
  }
  getAll() {
    return [...W(this, Sl).values()];
  }
  find(e) {
    const r = { exact: !0, ...e };
    return this.getAll().find(
      (o) => GN(r, o)
    );
  }
  findAll(e = {}) {
    const r = this.getAll();
    return Object.keys(e).length > 0 ? r.filter((o) => GN(e, o)) : r;
  }
  notify(e) {
    ba.batch(() => {
      this.listeners.forEach((r) => {
        r(e);
      });
    });
  }
  onFocus() {
    ba.batch(() => {
      this.getAll().forEach((e) => {
        e.onFocus();
      });
    });
  }
  onOnline() {
    ba.batch(() => {
      this.getAll().forEach((e) => {
        e.onOnline();
      });
    });
  }
}, Sl = new WeakMap(), RA), _l, Ri, Mf, El, Hc, kA, T5 = (kA = class extends uP {
  constructor(e) {
    super();
    _t(this, El);
    _t(this, _l);
    _t(this, Ri);
    _t(this, Mf);
    this.mutationId = e.mutationId, Ye(this, Ri, e.mutationCache), Ye(this, _l, []), this.state = e.state || dP(), this.setOptions(e.options), this.scheduleGc();
  }
  setOptions(e) {
    this.options = e, this.updateGcTime(this.options.gcTime);
  }
  get meta() {
    return this.options.meta;
  }
  addObserver(e) {
    W(this, _l).includes(e) || (W(this, _l).push(e), this.clearGcTimeout(), W(this, Ri).notify({
      type: "observerAdded",
      mutation: this,
      observer: e
    }));
  }
  removeObserver(e) {
    Ye(this, _l, W(this, _l).filter((r) => r !== e)), this.scheduleGc(), W(this, Ri).notify({
      type: "observerRemoved",
      mutation: this,
      observer: e
    });
  }
  optionalRemove() {
    W(this, _l).length || (this.state.status === "pending" ? this.scheduleGc() : W(this, Ri).remove(this));
  }
  continue() {
    var e;
    return ((e = W(this, Mf)) == null ? void 0 : e.continue()) ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before
      this.execute(this.state.variables);
  }
  async execute(e) {
    var c, f, m, y, b, _, T, k, C, M, N, A, $, I, U, B, K, te, re, ve;
    const r = () => {
      qt(this, El, Hc).call(this, { type: "continue" });
    };
    Ye(this, Mf, lP({
      fn: () => this.options.mutationFn ? this.options.mutationFn(e) : Promise.reject(new Error("No mutationFn found")),
      onFail: (Ce, ke) => {
        qt(this, El, Hc).call(this, { type: "failed", failureCount: Ce, error: ke });
      },
      onPause: () => {
        qt(this, El, Hc).call(this, { type: "pause" });
      },
      onContinue: r,
      retry: this.options.retry ?? 0,
      retryDelay: this.options.retryDelay,
      networkMode: this.options.networkMode,
      canRun: () => W(this, Ri).canRun(this)
    }));
    const o = this.state.status === "pending", u = !W(this, Mf).canStart();
    try {
      if (o)
        r();
      else {
        qt(this, El, Hc).call(this, { type: "pending", variables: e, isPaused: u }), await ((f = (c = W(this, Ri).config).onMutate) == null ? void 0 : f.call(
          c,
          e,
          this
        ));
        const ke = await ((y = (m = this.options).onMutate) == null ? void 0 : y.call(m, e));
        ke !== this.state.context && qt(this, El, Hc).call(this, {
          type: "pending",
          context: ke,
          variables: e,
          isPaused: u
        });
      }
      const Ce = await W(this, Mf).start();
      return await ((_ = (b = W(this, Ri).config).onSuccess) == null ? void 0 : _.call(
        b,
        Ce,
        e,
        this.state.context,
        this
      )), await ((k = (T = this.options).onSuccess) == null ? void 0 : k.call(T, Ce, e, this.state.context)), await ((M = (C = W(this, Ri).config).onSettled) == null ? void 0 : M.call(
        C,
        Ce,
        null,
        this.state.variables,
        this.state.context,
        this
      )), await ((A = (N = this.options).onSettled) == null ? void 0 : A.call(N, Ce, null, e, this.state.context)), qt(this, El, Hc).call(this, { type: "success", data: Ce }), Ce;
    } catch (Ce) {
      try {
        throw await ((I = ($ = W(this, Ri).config).onError) == null ? void 0 : I.call(
          $,
          Ce,
          e,
          this.state.context,
          this
        )), await ((B = (U = this.options).onError) == null ? void 0 : B.call(
          U,
          Ce,
          e,
          this.state.context
        )), await ((te = (K = W(this, Ri).config).onSettled) == null ? void 0 : te.call(
          K,
          void 0,
          Ce,
          this.state.variables,
          this.state.context,
          this
        )), await ((ve = (re = this.options).onSettled) == null ? void 0 : ve.call(
          re,
          void 0,
          Ce,
          e,
          this.state.context
        )), Ce;
      } finally {
        qt(this, El, Hc).call(this, { type: "error", error: Ce });
      }
    } finally {
      W(this, Ri).runNext(this);
    }
  }
}, _l = new WeakMap(), Ri = new WeakMap(), Mf = new WeakMap(), El = new WeakSet(), Hc = function (e) {
  const r = (o) => {
    switch (e.type) {
      case "failed":
        return {
          ...o,
          failureCount: e.failureCount,
          failureReason: e.error
        };
      case "pause":
        return {
          ...o,
          isPaused: !0
        };
      case "continue":
        return {
          ...o,
          isPaused: !1
        };
      case "pending":
        return {
          ...o,
          context: e.context,
          data: void 0,
          failureCount: 0,
          failureReason: null,
          error: null,
          isPaused: e.isPaused,
          status: "pending",
          variables: e.variables,
          submittedAt: Date.now()
        };
      case "success":
        return {
          ...o,
          data: e.data,
          failureCount: 0,
          failureReason: null,
          error: null,
          status: "success",
          isPaused: !1
        };
      case "error":
        return {
          ...o,
          data: void 0,
          error: e.error,
          failureCount: o.failureCount + 1,
          failureReason: e.error,
          isPaused: !1,
          status: "error"
        };
    }
  };
  this.state = r(this.state), ba.batch(() => {
    W(this, _l).forEach((o) => {
      o.onMutationUpdate(e);
    }), W(this, Ri).notify({
      mutation: this,
      type: "updated",
      action: e
    });
  });
}, kA);
function dP() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: !1,
    status: "idle",
    variables: void 0,
    submittedAt: 0
  };
}
var xu, Ns, dy, OA, R5 = (OA = class extends km {
  constructor(e = {}) {
    super();
    _t(this, xu);
    _t(this, Ns);
    _t(this, dy);
    this.config = e, Ye(this, xu, /* @__PURE__ */ new Set()), Ye(this, Ns, /* @__PURE__ */ new Map()), Ye(this, dy, 0);
  }
  build(e, r, o) {
    const u = new T5({
      mutationCache: this,
      mutationId: ++pw(this, dy)._,
      options: e.defaultMutationOptions(r),
      state: o
    });
    return this.add(u), u;
  }
  add(e) {
    W(this, xu).add(e);
    const r = Sw(e);
    if (typeof r == "string") {
      const o = W(this, Ns).get(r);
      o ? o.push(e) : W(this, Ns).set(r, [e]);
    }
    this.notify({ type: "added", mutation: e });
  }
  remove(e) {
    if (W(this, xu).delete(e)) {
      const r = Sw(e);
      if (typeof r == "string") {
        const o = W(this, Ns).get(r);
        if (o)
          if (o.length > 1) {
            const u = o.indexOf(e);
            u !== -1 && o.splice(u, 1);
          } else o[0] === e && W(this, Ns).delete(r);
      }
    }
    this.notify({ type: "removed", mutation: e });
  }
  canRun(e) {
    const r = Sw(e);
    if (typeof r == "string") {
      const o = W(this, Ns).get(r), u = o == null ? void 0 : o.find(
        (c) => c.state.status === "pending"
      );
      return !u || u === e;
    } else
      return !0;
  }
  runNext(e) {
    var o;
    const r = Sw(e);
    if (typeof r == "string") {
      const u = (o = W(this, Ns).get(r)) == null ? void 0 : o.find((c) => c !== e && c.state.isPaused);
      return (u == null ? void 0 : u.continue()) ?? Promise.resolve();
    } else
      return Promise.resolve();
  }
  clear() {
    ba.batch(() => {
      W(this, xu).forEach((e) => {
        this.notify({ type: "removed", mutation: e });
      }), W(this, xu).clear(), W(this, Ns).clear();
    });
  }
  getAll() {
    return Array.from(W(this, xu));
  }
  find(e) {
    const r = { exact: !0, ...e };
    return this.getAll().find(
      (o) => QN(r, o)
    );
  }
  findAll(e = {}) {
    return this.getAll().filter((r) => QN(e, r));
  }
  notify(e) {
    ba.batch(() => {
      this.listeners.forEach((r) => {
        r(e);
      });
    });
  }
  resumePausedMutations() {
    const e = this.getAll().filter((r) => r.state.isPaused);
    return ba.batch(
      () => Promise.all(
        e.map((r) => r.continue().catch(Oi))
      )
    );
  }
}, xu = new WeakMap(), Ns = new WeakMap(), dy = new WeakMap(), OA);
function Sw(n) {
  var e;
  return (e = n.options.scope) == null ? void 0 : e.id;
}
function XN(n) {
  return {
    onFetch: (e, r) => {
      var _, T, k, C, M;
      const o = e.options, u = (k = (T = (_ = e.fetchOptions) == null ? void 0 : _.meta) == null ? void 0 : T.fetchMore) == null ? void 0 : k.direction, c = ((C = e.state.data) == null ? void 0 : C.pages) || [], f = ((M = e.state.data) == null ? void 0 : M.pageParams) || [];
      let m = { pages: [], pageParams: [] }, y = 0;
      const b = async () => {
        let N = !1;
        const A = (U) => {
          Object.defineProperty(U, "signal", {
            enumerable: !0,
            get: () => (e.signal.aborted ? N = !0 : e.signal.addEventListener("abort", () => {
              N = !0;
            }), e.signal)
          });
        }, $ = aP(e.options, e.fetchOptions), I = async (U, B, K) => {
          if (N)
            return Promise.reject();
          if (B == null && U.pages.length)
            return Promise.resolve(U);
          const re = (() => {
            const Ie = {
              client: e.client,
              queryKey: e.queryKey,
              pageParam: B,
              direction: K ? "backward" : "forward",
              meta: e.options.meta
            };
            return A(Ie), Ie;
          })(), ve = await $(re), { maxPages: Ce } = e.options, ke = K ? g5 : v5;
          return {
            pages: ke(U.pages, ve, Ce),
            pageParams: ke(U.pageParams, B, Ce)
          };
        };
        if (u && c.length) {
          const U = u === "backward", B = U ? k5 : ej, K = {
            pages: c,
            pageParams: f
          }, te = B(o, K);
          m = await I(K, te, U);
        } else {
          const U = n ?? c.length;
          do {
            const B = y === 0 ? f[0] ?? o.initialPageParam : ej(o, m);
            if (y > 0 && B == null)
              break;
            m = await I(m, B), y++;
          } while (y < U);
        }
        return m;
      };
      e.options.persister ? e.fetchFn = () => {
        var N, A;
        return (A = (N = e.options).persister) == null ? void 0 : A.call(
          N,
          b,
          {
            client: e.client,
            queryKey: e.queryKey,
            meta: e.options.meta,
            signal: e.signal
          },
          r
        );
      } : e.fetchFn = b;
    }
  };
}
function ej(n, { pages: e, pageParams: r }) {
  const o = e.length - 1;
  return e.length > 0 ? n.getNextPageParam(
    e[o],
    e,
    r[o],
    r
  ) : void 0;
}
function k5(n, { pages: e, pageParams: r }) {
  var o;
  return e.length > 0 ? (o = n.getPreviousPageParam) == null ? void 0 : o.call(n, e[0], e, r[0], r) : void 0;
}
var Lr, Qc, Jc, lm, um, Zc, cm, dm, NA, O5 = (NA = class {
  constructor(n = {}) {
    _t(this, Lr);
    _t(this, Qc);
    _t(this, Jc);
    _t(this, lm);
    _t(this, um);
    _t(this, Zc);
    _t(this, cm);
    _t(this, dm);
    Ye(this, Lr, n.queryCache || new C5()), Ye(this, Qc, n.mutationCache || new R5()), Ye(this, Jc, n.defaultOptions || {}), Ye(this, lm, /* @__PURE__ */ new Map()), Ye(this, um, /* @__PURE__ */ new Map()), Ye(this, Zc, 0);
  }
  mount() {
    pw(this, Zc)._++, W(this, Zc) === 1 && (Ye(this, cm, nT.subscribe(async (n) => {
      n && (await this.resumePausedMutations(), W(this, Lr).onFocus());
    })), Ye(this, dm, Zw.subscribe(async (n) => {
      n && (await this.resumePausedMutations(), W(this, Lr).onOnline());
    })));
  }
  unmount() {
    var n, e;
    pw(this, Zc)._--, W(this, Zc) === 0 && ((n = W(this, cm)) == null || n.call(this), Ye(this, cm, void 0), (e = W(this, dm)) == null || e.call(this), Ye(this, dm, void 0));
  }
  isFetching(n) {
    return W(this, Lr).findAll({ ...n, fetchStatus: "fetching" }).length;
  }
  isMutating(n) {
    return W(this, Qc).findAll({ ...n, status: "pending" }).length;
  }
  /**
   * Imperative (non-reactive) way to retrieve data for a QueryKey.
   * Should only be used in callbacks or functions where reading the latest data is necessary, e.g. for optimistic updates.
   *
   * Hint: Do not use this function inside a component, because it won't receive updates.
   * Use `useQuery` to create a `QueryObserver` that subscribes to changes.
   */
  getQueryData(n) {
    var r;
    const e = this.defaultQueryOptions({ queryKey: n });
    return (r = W(this, Lr).get(e.queryHash)) == null ? void 0 : r.state.data;
  }
  ensureQueryData(n) {
    const e = this.defaultQueryOptions(n), r = W(this, Lr).build(this, e), o = r.state.data;
    return o === void 0 ? this.fetchQuery(n) : (n.revalidateIfStale && r.isStaleByTime(od(e.staleTime, r)) && this.prefetchQuery(e), Promise.resolve(o));
  }
  getQueriesData(n) {
    return W(this, Lr).findAll(n).map(({ queryKey: e, state: r }) => {
      const o = r.data;
      return [e, o];
    });
  }
  setQueryData(n, e, r) {
    const o = this.defaultQueryOptions({ queryKey: n }), u = W(this, Lr).get(
      o.queryHash
    ), c = u == null ? void 0 : u.state.data, f = p5(e, c);
    if (f !== void 0)
      return W(this, Lr).build(this, o).setData(f, { ...r, manual: !0 });
  }
  setQueriesData(n, e, r) {
    return ba.batch(
      () => W(this, Lr).findAll(n).map(({ queryKey: o }) => [
        o,
        this.setQueryData(o, e, r)
      ])
    );
  }
  getQueryState(n) {
    var r;
    const e = this.defaultQueryOptions({ queryKey: n });
    return (r = W(this, Lr).get(
      e.queryHash
    )) == null ? void 0 : r.state;
  }
  removeQueries(n) {
    const e = W(this, Lr);
    ba.batch(() => {
      e.findAll(n).forEach((r) => {
        e.remove(r);
      });
    });
  }
  resetQueries(n, e) {
    const r = W(this, Lr);
    return ba.batch(() => (r.findAll(n).forEach((o) => {
      o.reset();
    }), this.refetchQueries(
      {
        type: "active",
        ...n
      },
      e
    )));
  }
  cancelQueries(n, e = {}) {
    const r = { revert: !0, ...e }, o = ba.batch(
      () => W(this, Lr).findAll(n).map((u) => u.cancel(r))
    );
    return Promise.all(o).then(Oi).catch(Oi);
  }
  invalidateQueries(n, e = {}) {
    return ba.batch(() => (W(this, Lr).findAll(n).forEach((r) => {
      r.invalidate();
    }), (n == null ? void 0 : n.refetchType) === "none" ? Promise.resolve() : this.refetchQueries(
      {
        ...n,
        type: (n == null ? void 0 : n.refetchType) ?? (n == null ? void 0 : n.type) ?? "active"
      },
      e
    )));
  }
  refetchQueries(n, e = {}) {
    const r = {
      ...e,
      cancelRefetch: e.cancelRefetch ?? !0
    }, o = ba.batch(
      () => W(this, Lr).findAll(n).filter((u) => !u.isDisabled() && !u.isStatic()).map((u) => {
        let c = u.fetch(void 0, r);
        return r.throwOnError || (c = c.catch(Oi)), u.state.fetchStatus === "paused" ? Promise.resolve() : c;
      })
    );
    return Promise.all(o).then(Oi);
  }
  fetchQuery(n) {
    const e = this.defaultQueryOptions(n);
    e.retry === void 0 && (e.retry = !1);
    const r = W(this, Lr).build(this, e);
    return r.isStaleByTime(
      od(e.staleTime, r)
    ) ? r.fetch(e) : Promise.resolve(r.state.data);
  }
  prefetchQuery(n) {
    return this.fetchQuery(n).then(Oi).catch(Oi);
  }
  fetchInfiniteQuery(n) {
    return n.behavior = XN(n.pages), this.fetchQuery(n);
  }
  prefetchInfiniteQuery(n) {
    return this.fetchInfiniteQuery(n).then(Oi).catch(Oi);
  }
  ensureInfiniteQueryData(n) {
    return n.behavior = XN(n.pages), this.ensureQueryData(n);
  }
  resumePausedMutations() {
    return Zw.isOnline() ? W(this, Qc).resumePausedMutations() : Promise.resolve();
  }
  getQueryCache() {
    return W(this, Lr);
  }
  getMutationCache() {
    return W(this, Qc);
  }
  getDefaultOptions() {
    return W(this, Jc);
  }
  setDefaultOptions(n) {
    Ye(this, Jc, n);
  }
  setQueryDefaults(n, e) {
    W(this, lm).set(Bf(n), {
      queryKey: n,
      defaultOptions: e
    });
  }
  getQueryDefaults(n) {
    const e = [...W(this, lm).values()], r = {};
    return e.forEach((o) => {
      Zg(n, o.queryKey) && Object.assign(r, o.defaultOptions);
    }), r;
  }
  setMutationDefaults(n, e) {
    W(this, um).set(Bf(n), {
      mutationKey: n,
      defaultOptions: e
    });
  }
  getMutationDefaults(n) {
    const e = [...W(this, um).values()], r = {};
    return e.forEach((o) => {
      Zg(n, o.mutationKey) && Object.assign(r, o.defaultOptions);
    }), r;
  }
  defaultQueryOptions(n) {
    if (n._defaulted)
      return n;
    const e = {
      ...W(this, Jc).queries,
      ...this.getQueryDefaults(n.queryKey),
      ...n,
      _defaulted: !0
    };
    return e.queryHash || (e.queryHash = tT(
      e.queryKey,
      e
    )), e.refetchOnReconnect === void 0 && (e.refetchOnReconnect = e.networkMode !== "always"), e.throwOnError === void 0 && (e.throwOnError = !!e.suspense), !e.networkMode && e.persister && (e.networkMode = "offlineFirst"), e.queryFn === Jw && (e.enabled = !1), e;
  }
  defaultMutationOptions(n) {
    return n != null && n._defaulted ? n : {
      ...W(this, Jc).mutations,
      ...(n == null ? void 0 : n.mutationKey) && this.getMutationDefaults(n.mutationKey),
      ...n,
      _defaulted: !0
    };
  }
  clear() {
    W(this, Lr).clear(), W(this, Qc).clear();
  }
}, Lr = new WeakMap(), Qc = new WeakMap(), Jc = new WeakMap(), lm = new WeakMap(), um = new WeakMap(), Zc = new WeakMap(), cm = new WeakMap(), dm = new WeakMap(), NA), no, un, fy, ki, Lf, fm, Xc, ed, hy, hm, pm, If, Uf, td, mm, jn, zg, r1, a1, i1, o1, s1, l1, u1, fP, jA, N5 = (jA = class extends km {
  constructor(e, r) {
    super();
    _t(this, jn);
    _t(this, no);
    _t(this, un);
    _t(this, fy);
    _t(this, ki);
    _t(this, Lf);
    _t(this, fm);
    _t(this, Xc);
    _t(this, ed);
    _t(this, hy);
    _t(this, hm);
    // This property keeps track of the last query with defined data.
    // It will be used to pass the previous data and query to the placeholder function between renders.
    _t(this, pm);
    _t(this, If);
    _t(this, Uf);
    _t(this, td);
    _t(this, mm, /* @__PURE__ */ new Set());
    this.options = r, Ye(this, no, e), Ye(this, ed, null), Ye(this, Xc, n1()), this.options.experimental_prefetchInRender || W(this, Xc).reject(
      new Error("experimental_prefetchInRender feature flag is not enabled")
    ), this.bindMethods(), this.setOptions(r);
  }
  bindMethods() {
    this.refetch = this.refetch.bind(this);
  }
  onSubscribe() {
    this.listeners.size === 1 && (W(this, un).addObserver(this), tj(W(this, un), this.options) ? qt(this, jn, zg).call(this) : this.updateResult(), qt(this, jn, o1).call(this));
  }
  onUnsubscribe() {
    this.hasListeners() || this.destroy();
  }
  shouldFetchOnReconnect() {
    return c1(
      W(this, un),
      this.options,
      this.options.refetchOnReconnect
    );
  }
  shouldFetchOnWindowFocus() {
    return c1(
      W(this, un),
      this.options,
      this.options.refetchOnWindowFocus
    );
  }
  destroy() {
    this.listeners = /* @__PURE__ */ new Set(), qt(this, jn, s1).call(this), qt(this, jn, l1).call(this), W(this, un).removeObserver(this);
  }
  setOptions(e) {
    const r = this.options, o = W(this, un);
    if (this.options = W(this, no).defaultQueryOptions(e), this.options.enabled !== void 0 && typeof this.options.enabled != "boolean" && typeof this.options.enabled != "function" && typeof Vo(this.options.enabled, W(this, un)) != "boolean")
      throw new Error(
        "Expected enabled to be a boolean or a callback that returns a boolean"
      );
    qt(this, jn, u1).call(this), W(this, un).setOptions(this.options), r._defaulted && !Qw(this.options, r) && W(this, no).getQueryCache().notify({
      type: "observerOptionsUpdated",
      query: W(this, un),
      observer: this
    });
    const u = this.hasListeners();
    u && nj(
      W(this, un),
      o,
      this.options,
      r
    ) && qt(this, jn, zg).call(this), this.updateResult(), u && (W(this, un) !== o || Vo(this.options.enabled, W(this, un)) !== Vo(r.enabled, W(this, un)) || od(this.options.staleTime, W(this, un)) !== od(r.staleTime, W(this, un))) && qt(this, jn, r1).call(this);
    const c = qt(this, jn, a1).call(this);
    u && (W(this, un) !== o || Vo(this.options.enabled, W(this, un)) !== Vo(r.enabled, W(this, un)) || c !== W(this, td)) && qt(this, jn, i1).call(this, c);
  }
  getOptimisticResult(e) {
    const r = W(this, no).getQueryCache().build(W(this, no), e), o = this.createResult(r, e);
    return A5(this, o) && (Ye(this, ki, o), Ye(this, fm, this.options), Ye(this, Lf, W(this, un).state)), o;
  }
  getCurrentResult() {
    return W(this, ki);
  }
  trackResult(e, r) {
    return new Proxy(e, {
      get: (o, u) => (this.trackProp(u), r == null || r(u), Reflect.get(o, u))
    });
  }
  trackProp(e) {
    W(this, mm).add(e);
  }
  getCurrentQuery() {
    return W(this, un);
  }
  refetch({ ...e } = {}) {
    return this.fetch({
      ...e
    });
  }
  fetchOptimistic(e) {
    const r = W(this, no).defaultQueryOptions(e), o = W(this, no).getQueryCache().build(W(this, no), r);
    return o.fetch().then(() => this.createResult(o, r));
  }
  fetch(e) {
    return qt(this, jn, zg).call(this, {
      ...e,
      cancelRefetch: e.cancelRefetch ?? !0
    }).then(() => (this.updateResult(), W(this, ki)));
  }
  createResult(e, r) {
    var Ce;
    const o = W(this, un), u = this.options, c = W(this, ki), f = W(this, Lf), m = W(this, fm), b = e !== o ? e.state : W(this, fy), { state: _ } = e;
    let T = { ..._ }, k = !1, C;
    if (r._optimisticResults) {
      const ke = this.hasListeners(), Ie = !ke && tj(e, r), Ne = ke && nj(e, o, r, u);
      (Ie || Ne) && (T = {
        ...T,
        ...cP(_.data, e.options)
      }), r._optimisticResults === "isRestoring" && (T.fetchStatus = "idle");
    }
    let { error: M, errorUpdatedAt: N, status: A } = T;
    C = T.data;
    let $ = !1;
    if (r.placeholderData !== void 0 && C === void 0 && A === "pending") {
      let ke;
      c != null && c.isPlaceholderData && r.placeholderData === (m == null ? void 0 : m.placeholderData) ? (ke = c.data, $ = !0) : ke = typeof r.placeholderData == "function" ? r.placeholderData(
        (Ce = W(this, pm)) == null ? void 0 : Ce.state.data,
        W(this, pm)
      ) : r.placeholderData, ke !== void 0 && (A = "success", C = t1(
        c == null ? void 0 : c.data,
        ke,
        r
      ), k = !0);
    }
    if (r.select && C !== void 0 && !$)
      if (c && C === (f == null ? void 0 : f.data) && r.select === W(this, hy))
        C = W(this, hm);
      else
        try {
          Ye(this, hy, r.select), C = r.select(C), C = t1(c == null ? void 0 : c.data, C, r), Ye(this, hm, C), Ye(this, ed, null);
        } catch (ke) {
          Ye(this, ed, ke);
        }
    W(this, ed) && (M = W(this, ed), C = W(this, hm), N = Date.now(), A = "error");
    const I = T.fetchStatus === "fetching", U = A === "pending", B = A === "error", K = U && I, te = C !== void 0, ve = {
      status: A,
      fetchStatus: T.fetchStatus,
      isPending: U,
      isSuccess: A === "success",
      isError: B,
      isInitialLoading: K,
      isLoading: K,
      data: C,
      dataUpdatedAt: T.dataUpdatedAt,
      error: M,
      errorUpdatedAt: N,
      failureCount: T.fetchFailureCount,
      failureReason: T.fetchFailureReason,
      errorUpdateCount: T.errorUpdateCount,
      isFetched: T.dataUpdateCount > 0 || T.errorUpdateCount > 0,
      isFetchedAfterMount: T.dataUpdateCount > b.dataUpdateCount || T.errorUpdateCount > b.errorUpdateCount,
      isFetching: I,
      isRefetching: I && !U,
      isLoadingError: B && !te,
      isPaused: T.fetchStatus === "paused",
      isPlaceholderData: k,
      isRefetchError: B && te,
      isStale: rT(e, r),
      refetch: this.refetch,
      promise: W(this, Xc),
      isEnabled: Vo(r.enabled, e) !== !1
    };
    if (this.options.experimental_prefetchInRender) {
      const ke = (Re) => {
        ve.status === "error" ? Re.reject(ve.error) : ve.data !== void 0 && Re.resolve(ve.data);
      }, Ie = () => {
        const Re = Ye(this, Xc, ve.promise = n1());
        ke(Re);
      }, Ne = W(this, Xc);
      switch (Ne.status) {
        case "pending":
          e.queryHash === o.queryHash && ke(Ne);
          break;
        case "fulfilled":
          (ve.status === "error" || ve.data !== Ne.value) && Ie();
          break;
        case "rejected":
          (ve.status !== "error" || ve.error !== Ne.reason) && Ie();
          break;
      }
    }
    return ve;
  }
  updateResult() {
    const e = W(this, ki), r = this.createResult(W(this, un), this.options);
    if (Ye(this, Lf, W(this, un).state), Ye(this, fm, this.options), W(this, Lf).data !== void 0 && Ye(this, pm, W(this, un)), Qw(r, e))
      return;
    Ye(this, ki, r);
    const o = () => {
      if (!e)
        return !0;
      const { notifyOnChangeProps: u } = this.options, c = typeof u == "function" ? u() : u;
      if (c === "all" || !c && !W(this, mm).size)
        return !0;
      const f = new Set(
        c ?? W(this, mm)
      );
      return this.options.throwOnError && f.add("error"), Object.keys(W(this, ki)).some((m) => {
        const y = m;
        return W(this, ki)[y] !== e[y] && f.has(y);
      });
    };
    qt(this, jn, fP).call(this, { listeners: o() });
  }
  onQueryUpdate() {
    this.updateResult(), this.hasListeners() && qt(this, jn, o1).call(this);
  }
}, no = new WeakMap(), un = new WeakMap(), fy = new WeakMap(), ki = new WeakMap(), Lf = new WeakMap(), fm = new WeakMap(), Xc = new WeakMap(), ed = new WeakMap(), hy = new WeakMap(), hm = new WeakMap(), pm = new WeakMap(), If = new WeakMap(), Uf = new WeakMap(), td = new WeakMap(), mm = new WeakMap(), jn = new WeakSet(), zg = function (e) {
  qt(this, jn, u1).call(this);
  let r = W(this, un).fetch(
    this.options,
    e
  );
  return e != null && e.throwOnError || (r = r.catch(Oi)), r;
}, r1 = function () {
  qt(this, jn, s1).call(this);
  const e = od(
    this.options.staleTime,
    W(this, un)
  );
  if (zf || W(this, ki).isStale || !ZC(e))
    return;
  const o = rP(W(this, ki).dataUpdatedAt, e) + 1;
  Ye(this, If, setTimeout(() => {
    W(this, ki).isStale || this.updateResult();
  }, o));
}, a1 = function () {
  return (typeof this.options.refetchInterval == "function" ? this.options.refetchInterval(W(this, un)) : this.options.refetchInterval) ?? !1;
}, i1 = function (e) {
  qt(this, jn, l1).call(this), Ye(this, td, e), !(zf || Vo(this.options.enabled, W(this, un)) === !1 || !ZC(W(this, td)) || W(this, td) === 0) && Ye(this, Uf, setInterval(() => {
    (this.options.refetchIntervalInBackground || nT.isFocused()) && qt(this, jn, zg).call(this);
  }, W(this, td)));
}, o1 = function () {
  qt(this, jn, r1).call(this), qt(this, jn, i1).call(this, qt(this, jn, a1).call(this));
}, s1 = function () {
  W(this, If) && (clearTimeout(W(this, If)), Ye(this, If, void 0));
}, l1 = function () {
  W(this, Uf) && (clearInterval(W(this, Uf)), Ye(this, Uf, void 0));
}, u1 = function () {
  const e = W(this, no).getQueryCache().build(W(this, no), this.options);
  if (e === W(this, un))
    return;
  const r = W(this, un);
  Ye(this, un, e), Ye(this, fy, e.state), this.hasListeners() && (r == null || r.removeObserver(this), e.addObserver(this));
}, fP = function (e) {
  ba.batch(() => {
    e.listeners && this.listeners.forEach((r) => {
      r(W(this, ki));
    }), W(this, no).getQueryCache().notify({
      query: W(this, un),
      type: "observerResultsUpdated"
    });
  });
}, jA);
function j5(n, e) {
  return Vo(e.enabled, n) !== !1 && n.state.data === void 0 && !(n.state.status === "error" && e.retryOnMount === !1);
}
function tj(n, e) {
  return j5(n, e) || n.state.data !== void 0 && c1(n, e, e.refetchOnMount);
}
function c1(n, e, r) {
  if (Vo(e.enabled, n) !== !1 && od(e.staleTime, n) !== "static") {
    const o = typeof r == "function" ? r(n) : r;
    return o === "always" || o !== !1 && rT(n, e);
  }
  return !1;
}
function nj(n, e, r, o) {
  return (n !== e || Vo(o.enabled, n) === !1) && (!r.suspense || n.state.status !== "error") && rT(n, r);
}
function rT(n, e) {
  return Vo(e.enabled, n) !== !1 && n.isStaleByTime(od(e.staleTime, n));
}
function A5(n, e) {
  return !Qw(n.getCurrentResult(), e);
}
var nd, rd, ro, Su, Eu, zw, d1, AA, D5 = (AA = class extends km {
  constructor(r, o) {
    super();
    _t(this, Eu);
    _t(this, nd);
    _t(this, rd);
    _t(this, ro);
    _t(this, Su);
    Ye(this, nd, r), this.setOptions(o), this.bindMethods(), qt(this, Eu, zw).call(this);
  }
  bindMethods() {
    this.mutate = this.mutate.bind(this), this.reset = this.reset.bind(this);
  }
  setOptions(r) {
    var u;
    const o = this.options;
    this.options = W(this, nd).defaultMutationOptions(r), Qw(this.options, o) || W(this, nd).getMutationCache().notify({
      type: "observerOptionsUpdated",
      mutation: W(this, ro),
      observer: this
    }), o != null && o.mutationKey && this.options.mutationKey && Bf(o.mutationKey) !== Bf(this.options.mutationKey) ? this.reset() : ((u = W(this, ro)) == null ? void 0 : u.state.status) === "pending" && W(this, ro).setOptions(this.options);
  }
  onUnsubscribe() {
    var r;
    this.hasListeners() || (r = W(this, ro)) == null || r.removeObserver(this);
  }
  onMutationUpdate(r) {
    qt(this, Eu, zw).call(this), qt(this, Eu, d1).call(this, r);
  }
  getCurrentResult() {
    return W(this, rd);
  }
  reset() {
    var r;
    (r = W(this, ro)) == null || r.removeObserver(this), Ye(this, ro, void 0), qt(this, Eu, zw).call(this), qt(this, Eu, d1).call(this);
  }
  mutate(r, o) {
    var u;
    return Ye(this, Su, o), (u = W(this, ro)) == null || u.removeObserver(this), Ye(this, ro, W(this, nd).getMutationCache().build(W(this, nd), this.options)), W(this, ro).addObserver(this), W(this, ro).execute(r);
  }
}, nd = new WeakMap(), rd = new WeakMap(), ro = new WeakMap(), Su = new WeakMap(), Eu = new WeakSet(), zw = function () {
  var o;
  const r = ((o = W(this, ro)) == null ? void 0 : o.state) ?? dP();
  Ye(this, rd, {
    ...r,
    isPending: r.status === "pending",
    isSuccess: r.status === "success",
    isError: r.status === "error",
    isIdle: r.status === "idle",
    mutate: this.mutate,
    reset: this.reset
  });
}, d1 = function (r) {
  ba.batch(() => {
    var o, u, c, f, m, y, b, _;
    if (W(this, Su) && this.hasListeners()) {
      const T = W(this, rd).variables, k = W(this, rd).context;
      (r == null ? void 0 : r.type) === "success" ? ((u = (o = W(this, Su)).onSuccess) == null || u.call(o, r.data, T, k), (f = (c = W(this, Su)).onSettled) == null || f.call(c, r.data, null, T, k)) : (r == null ? void 0 : r.type) === "error" && ((y = (m = W(this, Su)).onError) == null || y.call(m, r.error, T, k), (_ = (b = W(this, Su)).onSettled) == null || _.call(
        b,
        void 0,
        r.error,
        T,
        k
      ));
    }
    this.listeners.forEach((T) => {
      T(W(this, rd));
    });
  });
}, AA), hP = D.createContext(
  void 0
), aT = (n) => {
  const e = D.useContext(hP);
  if (!e)
    throw new Error("No QueryClient set, use QueryClientProvider to set one");
  return e;
}, P5 = ({
  client: n,
  children: e
}) => (D.useEffect(() => (n.mount(), () => {
  n.unmount();
}), [n]), /* @__PURE__ */ x.jsx(hP.Provider, { value: n, children: e })), pP = D.createContext(!1), M5 = () => D.useContext(pP);
pP.Provider;
function L5() {
  let n = !1;
  return {
    clearReset: () => {
      n = !1;
    },
    reset: () => {
      n = !0;
    },
    isReset: () => n
  };
}
var I5 = D.createContext(L5()), U5 = () => D.useContext(I5), F5 = (n, e) => {
  (n.suspense || n.throwOnError || n.experimental_prefetchInRender) && (e.isReset() || (n.retryOnMount = !1));
}, $5 = (n) => {
  D.useEffect(() => {
    n.clearReset();
  }, [n]);
}, z5 = ({
  result: n,
  errorResetBoundary: e,
  throwOnError: r,
  query: o,
  suspense: u
}) => n.isError && !e.isReset() && !n.isFetching && o && (u && n.data === void 0 || iP(r, [n.error, o])), B5 = (n) => {
  if (n.suspense) {
    const e = (o) => o === "static" ? o : Math.max(o ?? 1e3, 1e3), r = n.staleTime;
    n.staleTime = typeof r == "function" ? (...o) => e(r(...o)) : e(r), typeof n.gcTime == "number" && (n.gcTime = Math.max(n.gcTime, 1e3));
  }
}, V5 = (n, e) => n.isLoading && n.isFetching && !e, H5 = (n, e) => (n == null ? void 0 : n.suspense) && e.isPending, rj = (n, e, r) => e.fetchOptimistic(n).catch(() => {
  r.clearReset();
});
function W5(n, e, r) {
  var T, k, C, M, N;
  if (process.env.NODE_ENV !== "production" && (typeof n != "object" || Array.isArray(n)))
    throw new Error(
      'Bad argument type. Starting with v5, only the "Object" form is allowed when calling query related functions. Please use the error stack to find the culprit call. More info here: https://tanstack.com/query/latest/docs/react/guides/migrating-to-v5#supports-a-single-signature-one-object'
    );
  const o = M5(), u = U5(), c = aT(), f = c.defaultQueryOptions(n);
  (k = (T = c.getDefaultOptions().queries) == null ? void 0 : T._experimental_beforeQuery) == null || k.call(
    T,
    f
  ), process.env.NODE_ENV !== "production" && (f.queryFn || console.error(
    `[${f.queryHash}]: No queryFn was passed as an option, and no default queryFn was found. The queryFn parameter is only optional when using a default queryFn. More info here: https://tanstack.com/query/latest/docs/framework/react/guides/default-query-function`
  )), f._optimisticResults = o ? "isRestoring" : "optimistic", B5(f), F5(f, u), $5(u);
  const m = !c.getQueryCache().get(f.queryHash), [y] = D.useState(
    () => new e(
      c,
      f
    )
  ), b = y.getOptimisticResult(f), _ = !o && n.subscribed !== !1;
  if (D.useSyncExternalStore(
    D.useCallback(
      (A) => {
        const $ = _ ? y.subscribe(ba.batchCalls(A)) : Oi;
        return y.updateResult(), $;
      },
      [y, _]
    ),
    () => y.getCurrentResult(),
    () => y.getCurrentResult()
  ), D.useEffect(() => {
    y.setOptions(f);
  }, [f, y]), H5(f, b))
    throw rj(f, y, u);
  if (z5({
    result: b,
    errorResetBoundary: u,
    throwOnError: f.throwOnError,
    query: c.getQueryCache().get(f.queryHash),
    suspense: f.suspense
  }))
    throw b.error;
  if ((M = (C = c.getDefaultOptions().queries) == null ? void 0 : C._experimental_afterQuery) == null || M.call(
    C,
    f,
    b
  ), f.experimental_prefetchInRender && !zf && V5(b, o)) {
    const A = m ? (
      // Fetch immediately on render in order to ensure `.promise` is resolved even if the component is unmounted
      rj(f, y, u)
    ) : (
      // subscribe to the "cache promise" so that we can finalize the currentThenable once data comes in
      (N = c.getQueryCache().get(f.queryHash)) == null ? void 0 : N.promise
    );
    A == null || A.catch(Oi).finally(() => {
      y.updateResult();
    });
  }
  return f.notifyOnChangeProps ? b : y.trackResult(b);
}
function kl(n, e) {
  return W5(n, N5);
}
function aj(n, e) {
  const r = aT(), [o] = D.useState(
    () => new D5(
      r,
      n
    )
  );
  D.useEffect(() => {
    o.setOptions(n);
  }, [o, n]);
  const u = D.useSyncExternalStore(
    D.useCallback(
      (f) => o.subscribe(ba.batchCalls(f)),
      [o]
    ),
    () => o.getCurrentResult(),
    () => o.getCurrentResult()
  ), c = D.useCallback(
    (f, m) => {
      o.mutate(f, m).catch(Oi);
    },
    [o]
  );
  if (u.error && iP(o.options.throwOnError, [u.error]))
    throw u.error;
  return { ...u, mutate: c, mutateAsync: u.mutate };
}
/**
 * @remix-run/router v1.23.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function Xg() {
  return Xg = Object.assign ? Object.assign.bind() : function (n) {
    for (var e = 1; e < arguments.length; e++) {
      var r = arguments[e];
      for (var o in r)
        Object.prototype.hasOwnProperty.call(r, o) && (n[o] = r[o]);
    }
    return n;
  }, Xg.apply(this, arguments);
}
var ad;
(function (n) {
  n.Pop = "POP", n.Push = "PUSH", n.Replace = "REPLACE";
})(ad || (ad = {}));
const ij = "popstate";
function q5(n) {
  n === void 0 && (n = {});
  function e(o, u) {
    let {
      pathname: c,
      search: f,
      hash: m
    } = o.location;
    return f1(
      "",
      {
        pathname: c,
        search: f,
        hash: m
      },
      // state defaults to `null` because `window.history.state` does
      u.state && u.state.usr || null,
      u.state && u.state.key || "default"
    );
  }
  function r(o, u) {
    return typeof u == "string" ? u : ey(u);
  }
  return K5(e, r, null, n);
}
function $t(n, e) {
  if (n === !1 || n === null || typeof n > "u")
    throw new Error(e);
}
function Ms(n, e) {
  if (!n) {
    typeof console < "u" && console.warn(e);
    try {
      throw new Error(e);
    } catch {
    }
  }
}
function Y5() {
  return Math.random().toString(36).substr(2, 8);
}
function oj(n, e) {
  return {
    usr: n.state,
    key: n.key,
    idx: e
  };
}
function f1(n, e, r, o) {
  return r === void 0 && (r = null), Xg({
    pathname: typeof n == "string" ? n : n.pathname,
    search: "",
    hash: ""
  }, typeof e == "string" ? Om(e) : e, {
    state: r,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: e && e.key || o || Y5()
  });
}
function ey(n) {
  let {
    pathname: e = "/",
    search: r = "",
    hash: o = ""
  } = n;
  return r && r !== "?" && (e += r.charAt(0) === "?" ? r : "?" + r), o && o !== "#" && (e += o.charAt(0) === "#" ? o : "#" + o), e;
}
function Om(n) {
  let e = {};
  if (n) {
    let r = n.indexOf("#");
    r >= 0 && (e.hash = n.substr(r), n = n.substr(0, r));
    let o = n.indexOf("?");
    o >= 0 && (e.search = n.substr(o), n = n.substr(0, o)), n && (e.pathname = n);
  }
  return e;
}
function K5(n, e, r, o) {
  o === void 0 && (o = {});
  let {
    window: u = document.defaultView,
    v5Compat: c = !1
  } = o, f = u.history, m = ad.Pop, y = null, b = _();
  b == null && (b = 0, f.replaceState(Xg({}, f.state, {
    idx: b
  }), ""));
  function _() {
    return (f.state || {
      idx: null
    }).idx;
  }
  function T() {
    m = ad.Pop;
    let A = _(), $ = A == null ? null : A - b;
    b = A, y && y({
      action: m,
      location: N.location,
      delta: $
    });
  }
  function k(A, $) {
    m = ad.Push;
    let I = f1(N.location, A, $);
    b = _() + 1;
    let U = oj(I, b), B = N.createHref(I);
    try {
      f.pushState(U, "", B);
    } catch (K) {
      if (K instanceof DOMException && K.name === "DataCloneError")
        throw K;
      u.location.assign(B);
    }
    c && y && y({
      action: m,
      location: N.location,
      delta: 1
    });
  }
  function C(A, $) {
    m = ad.Replace;
    let I = f1(N.location, A, $);
    b = _();
    let U = oj(I, b), B = N.createHref(I);
    f.replaceState(U, "", B), c && y && y({
      action: m,
      location: N.location,
      delta: 0
    });
  }
  function M(A) {
    let $ = u.location.origin !== "null" ? u.location.origin : u.location.href, I = typeof A == "string" ? A : ey(A);
    return I = I.replace(/ $/, "%20"), $t($, "No window.location.(origin|href) available to create URL for href: " + I), new URL(I, $);
  }
  let N = {
    get action() {
      return m;
    },
    get location() {
      return n(u, f);
    },
    listen(A) {
      if (y)
        throw new Error("A history only accepts one active listener");
      return u.addEventListener(ij, T), y = A, () => {
        u.removeEventListener(ij, T), y = null;
      };
    },
    createHref(A) {
      return e(u, A);
    },
    createURL: M,
    encodeLocation(A) {
      let $ = M(A);
      return {
        pathname: $.pathname,
        search: $.search,
        hash: $.hash
      };
    },
    push: k,
    replace: C,
    go(A) {
      return f.go(A);
    }
  };
  return N;
}
var sj;
(function (n) {
  n.data = "data", n.deferred = "deferred", n.redirect = "redirect", n.error = "error";
})(sj || (sj = {}));
function G5(n, e, r) {
  return r === void 0 && (r = "/"), Q5(n, e, r, !1);
}
function Q5(n, e, r, o) {
  let u = typeof e == "string" ? Om(e) : e, c = cd(u.pathname || "/", r);
  if (c == null)
    return null;
  let f = mP(n);
  J5(f);
  let m = null;
  for (let y = 0; m == null && y < f.length; ++y) {
    let b = lH(c);
    m = oH(f[y], b, o);
  }
  return m;
}
function mP(n, e, r, o) {
  e === void 0 && (e = []), r === void 0 && (r = []), o === void 0 && (o = "");
  let u = (c, f, m) => {
    let y = {
      relativePath: m === void 0 ? c.path || "" : m,
      caseSensitive: c.caseSensitive === !0,
      childrenIndex: f,
      route: c
    };
    y.relativePath.startsWith("/") && ($t(y.relativePath.startsWith(o), 'Absolute route path "' + y.relativePath + '" nested under path ' + ('"' + o + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes."), y.relativePath = y.relativePath.slice(o.length));
    let b = _u([o, y.relativePath]), _ = r.concat(y);
    c.children && c.children.length > 0 && ($t(
      // Our types know better, but runtime JS may not!
      // @ts-expect-error
      c.index !== !0,
      "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + b + '".')
    ), mP(c.children, e, _, b)), !(c.path == null && !c.index) && e.push({
      path: b,
      score: aH(b, c.index),
      routesMeta: _
    });
  };
  return n.forEach((c, f) => {
    var m;
    if (c.path === "" || !((m = c.path) != null && m.includes("?")))
      u(c, f);
    else
      for (let y of vP(c.path))
        u(c, f, y);
  }), e;
}
function vP(n) {
  let e = n.split("/");
  if (e.length === 0) return [];
  let [r, ...o] = e, u = r.endsWith("?"), c = r.replace(/\?$/, "");
  if (o.length === 0)
    return u ? [c, ""] : [c];
  let f = vP(o.join("/")), m = [];
  return m.push(...f.map((y) => y === "" ? c : [c, y].join("/"))), u && m.push(...f), m.map((y) => n.startsWith("/") && y === "" ? "/" : y);
}
function J5(n) {
  n.sort((e, r) => e.score !== r.score ? r.score - e.score : iH(e.routesMeta.map((o) => o.childrenIndex), r.routesMeta.map((o) => o.childrenIndex)));
}
const Z5 = /^:[\w-]+$/, X5 = 3, eH = 2, tH = 1, nH = 10, rH = -2, lj = (n) => n === "*";
function aH(n, e) {
  let r = n.split("/"), o = r.length;
  return r.some(lj) && (o += rH), e && (o += eH), r.filter((u) => !lj(u)).reduce((u, c) => u + (Z5.test(c) ? X5 : c === "" ? tH : nH), o);
}
function iH(n, e) {
  return n.length === e.length && n.slice(0, -1).every((o, u) => o === e[u]) ? (
    // If two routes are siblings, we should try to match the earlier sibling
    // first. This allows people to have fine-grained control over the matching
    // behavior by simply putting routes with identical paths in the order they
    // want them tried.
    n[n.length - 1] - e[e.length - 1]
  ) : (
    // Otherwise, it doesn't really make sense to rank non-siblings by index,
    // so they sort equally.
    0
  );
}
function oH(n, e, r) {
  let {
    routesMeta: o
  } = n, u = {}, c = "/", f = [];
  for (let m = 0; m < o.length; ++m) {
    let y = o[m], b = m === o.length - 1, _ = c === "/" ? e : e.slice(c.length) || "/", T = Xw({
      path: y.relativePath,
      caseSensitive: y.caseSensitive,
      end: b
    }, _), k = y.route;
    if (!T && b && r && !o[o.length - 1].route.index && (T = Xw({
      path: y.relativePath,
      caseSensitive: y.caseSensitive,
      end: !1
    }, _)), !T)
      return null;
    Object.assign(u, T.params), f.push({
      // TODO: Can this as be avoided?
      params: u,
      pathname: _u([c, T.pathname]),
      pathnameBase: fH(_u([c, T.pathnameBase])),
      route: k
    }), T.pathnameBase !== "/" && (c = _u([c, T.pathnameBase]));
  }
  return f;
}
function Xw(n, e) {
  typeof n == "string" && (n = {
    path: n,
    caseSensitive: !1,
    end: !0
  });
  let [r, o] = sH(n.path, n.caseSensitive, n.end), u = e.match(r);
  if (!u) return null;
  let c = u[0], f = c.replace(/(.)\/+$/, "$1"), m = u.slice(1);
  return {
    params: o.reduce((b, _, T) => {
      let {
        paramName: k,
        isOptional: C
      } = _;
      if (k === "*") {
        let N = m[T] || "";
        f = c.slice(0, c.length - N.length).replace(/(.)\/+$/, "$1");
      }
      const M = m[T];
      return C && !M ? b[k] = void 0 : b[k] = (M || "").replace(/%2F/g, "/"), b;
    }, {}),
    pathname: c,
    pathnameBase: f,
    pattern: n
  };
}
function sH(n, e, r) {
  e === void 0 && (e = !1), r === void 0 && (r = !0), Ms(n === "*" || !n.endsWith("*") || n.endsWith("/*"), 'Route path "' + n + '" will be treated as if it were ' + ('"' + n.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + n.replace(/\*$/, "/*") + '".'));
  let o = [], u = "^" + n.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (f, m, y) => (o.push({
    paramName: m,
    isOptional: y != null
  }), y ? "/?([^\\/]+)?" : "/([^\\/]+)"));
  return n.endsWith("*") ? (o.push({
    paramName: "*"
  }), u += n === "*" || n === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : r ? u += "\\/*$" : n !== "" && n !== "/" && (u += "(?:(?=\\/|$))"), [new RegExp(u, e ? void 0 : "i"), o];
}
function lH(n) {
  try {
    return n.split("/").map((e) => decodeURIComponent(e).replace(/\//g, "%2F")).join("/");
  } catch (e) {
    return Ms(!1, 'The URL path "' + n + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + e + ").")), n;
  }
}
function cd(n, e) {
  if (e === "/") return n;
  if (!n.toLowerCase().startsWith(e.toLowerCase()))
    return null;
  let r = e.endsWith("/") ? e.length - 1 : e.length, o = n.charAt(r);
  return o && o !== "/" ? null : n.slice(r) || "/";
}
function uH(n, e) {
  e === void 0 && (e = "/");
  let {
    pathname: r,
    search: o = "",
    hash: u = ""
  } = typeof n == "string" ? Om(n) : n;
  return {
    pathname: r ? r.startsWith("/") ? r : cH(r, e) : e,
    search: hH(o),
    hash: pH(u)
  };
}
function cH(n, e) {
  let r = e.replace(/\/+$/, "").split("/");
  return n.split("/").forEach((u) => {
    u === ".." ? r.length > 1 && r.pop() : u !== "." && r.push(u);
  }), r.length > 1 ? r.join("/") : "/";
}
function yC(n, e, r, o) {
  return "Cannot include a '" + n + "' character in a manually specified " + ("`to." + e + "` field [" + JSON.stringify(o) + "].  Please separate it out to the ") + ("`to." + r + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.';
}
function dH(n) {
  return n.filter((e, r) => r === 0 || e.route.path && e.route.path.length > 0);
}
function iT(n, e) {
  let r = dH(n);
  return e ? r.map((o, u) => u === r.length - 1 ? o.pathname : o.pathnameBase) : r.map((o) => o.pathnameBase);
}
function oT(n, e, r, o) {
  o === void 0 && (o = !1);
  let u;
  typeof n == "string" ? u = Om(n) : (u = Xg({}, n), $t(!u.pathname || !u.pathname.includes("?"), yC("?", "pathname", "search", u)), $t(!u.pathname || !u.pathname.includes("#"), yC("#", "pathname", "hash", u)), $t(!u.search || !u.search.includes("#"), yC("#", "search", "hash", u)));
  let c = n === "" || u.pathname === "", f = c ? "/" : u.pathname, m;
  if (f == null)
    m = r;
  else {
    let T = e.length - 1;
    if (!o && f.startsWith("..")) {
      let k = f.split("/");
      for (; k[0] === "..";)
        k.shift(), T -= 1;
      u.pathname = k.join("/");
    }
    m = T >= 0 ? e[T] : "/";
  }
  let y = uH(u, m), b = f && f !== "/" && f.endsWith("/"), _ = (c || f === ".") && r.endsWith("/");
  return !y.pathname.endsWith("/") && (b || _) && (y.pathname += "/"), y;
}
const _u = (n) => n.join("/").replace(/\/\/+/g, "/"), fH = (n) => n.replace(/\/+$/, "").replace(/^\/*/, "/"), hH = (n) => !n || n === "?" ? "" : n.startsWith("?") ? n : "?" + n, pH = (n) => !n || n === "#" ? "" : n.startsWith("#") ? n : "#" + n;
function mH(n) {
  return n != null && typeof n.status == "number" && typeof n.statusText == "string" && typeof n.internal == "boolean" && "data" in n;
}
const gP = ["post", "put", "patch", "delete"];
new Set(gP);
const vH = ["get", ...gP];
new Set(vH);
/**
 * React Router v6.30.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function ty() {
  return ty = Object.assign ? Object.assign.bind() : function (n) {
    for (var e = 1; e < arguments.length; e++) {
      var r = arguments[e];
      for (var o in r)
        Object.prototype.hasOwnProperty.call(r, o) && (n[o] = r[o]);
    }
    return n;
  }, ty.apply(this, arguments);
}
const by = /* @__PURE__ */ D.createContext(null);
process.env.NODE_ENV !== "production" && (by.displayName = "DataRouter");
const sT = /* @__PURE__ */ D.createContext(null);
process.env.NODE_ENV !== "production" && (sT.displayName = "DataRouterState");
const gH = /* @__PURE__ */ D.createContext(null);
process.env.NODE_ENV !== "production" && (gH.displayName = "Await");
const Yo = /* @__PURE__ */ D.createContext(null);
process.env.NODE_ENV !== "production" && (Yo.displayName = "Navigation");
const wy = /* @__PURE__ */ D.createContext(null);
process.env.NODE_ENV !== "production" && (wy.displayName = "Location");
const Is = /* @__PURE__ */ D.createContext({
  outlet: null,
  matches: [],
  isDataRoute: !1
});
process.env.NODE_ENV !== "production" && (Is.displayName = "Route");
const lT = /* @__PURE__ */ D.createContext(null);
process.env.NODE_ENV !== "production" && (lT.displayName = "RouteError");
function yH(n, e) {
  let {
    relative: r
  } = e === void 0 ? {} : e;
  Nm() || (process.env.NODE_ENV !== "production" ? $t(
    !1,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useHref() may be used only in the context of a <Router> component."
  ) : $t(!1));
  let {
    basename: o,
    navigator: u
  } = D.useContext(Yo), {
    hash: c,
    pathname: f,
    search: m
  } = xy(n, {
    relative: r
  }), y = f;
  return o !== "/" && (y = f === "/" ? o : _u([o, f])), u.createHref({
    pathname: y,
    search: m,
    hash: c
  });
}
function Nm() {
  return D.useContext(wy) != null;
}
function ku() {
  return Nm() || (process.env.NODE_ENV !== "production" ? $t(
    !1,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useLocation() may be used only in the context of a <Router> component."
  ) : $t(!1)), D.useContext(wy).location;
}
const yP = "You should call navigate() in a React.useEffect(), not when your component is first rendered.";
function bP(n) {
  D.useContext(Yo).static || D.useLayoutEffect(n);
}
function _x() {
  let {
    isDataRoute: n
  } = D.useContext(Is);
  return n ? AH() : bH();
}
function bH() {
  Nm() || (process.env.NODE_ENV !== "production" ? $t(
    !1,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useNavigate() may be used only in the context of a <Router> component."
  ) : $t(!1));
  let n = D.useContext(by), {
    basename: e,
    future: r,
    navigator: o
  } = D.useContext(Yo), {
    matches: u
  } = D.useContext(Is), {
    pathname: c
  } = ku(), f = JSON.stringify(iT(u, r.v7_relativeSplatPath)), m = D.useRef(!1);
  return bP(() => {
    m.current = !0;
  }), D.useCallback(function (b, _) {
    if (_ === void 0 && (_ = {}), process.env.NODE_ENV !== "production" && Ms(m.current, yP), !m.current) return;
    if (typeof b == "number") {
      o.go(b);
      return;
    }
    let T = oT(b, JSON.parse(f), c, _.relative === "path");
    n == null && e !== "/" && (T.pathname = T.pathname === "/" ? e : _u([e, T.pathname])), (_.replace ? o.replace : o.push)(T, _.state, _);
  }, [e, o, f, c, n]);
}
function wP() {
  let {
    matches: n
  } = D.useContext(Is), e = n[n.length - 1];
  return e ? e.params : {};
}
function xy(n, e) {
  let {
    relative: r
  } = e === void 0 ? {} : e, {
    future: o
  } = D.useContext(Yo), {
    matches: u
  } = D.useContext(Is), {
    pathname: c
  } = ku(), f = JSON.stringify(iT(u, o.v7_relativeSplatPath));
  return D.useMemo(() => oT(n, JSON.parse(f), c, r === "path"), [n, f, c, r]);
}
function wH(n, e) {
  return xH(n, e);
}
function xH(n, e, r, o) {
  Nm() || (process.env.NODE_ENV !== "production" ? $t(
    !1,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useRoutes() may be used only in the context of a <Router> component."
  ) : $t(!1));
  let {
    navigator: u
  } = D.useContext(Yo), {
    matches: c
  } = D.useContext(Is), f = c[c.length - 1], m = f ? f.params : {}, y = f ? f.pathname : "/", b = f ? f.pathnameBase : "/", _ = f && f.route;
  if (process.env.NODE_ENV !== "production") {
    let I = _ && _.path || "";
    SP(y, !_ || I.endsWith("*"), "You rendered descendant <Routes> (or called `useRoutes()`) at " + ('"' + y + '" (under <Route path="' + I + '">) but the ') + `parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

` + ('Please change the parent <Route path="' + I + '"> to <Route ') + ('path="' + (I === "/" ? "*" : I + "/*") + '">.'));
  }
  let T = ku(), k;
  if (e) {
    var C;
    let I = typeof e == "string" ? Om(e) : e;
    b === "/" || (C = I.pathname) != null && C.startsWith(b) || (process.env.NODE_ENV !== "production" ? $t(!1, "When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, the location pathname must begin with the portion of the URL pathname that was " + ('matched by all parent routes. The current pathname base is "' + b + '" ') + ('but pathname "' + I.pathname + '" was given in the `location` prop.')) : $t(!1)), k = I;
  } else
    k = T;
  let M = k.pathname || "/", N = M;
  if (b !== "/") {
    let I = b.replace(/^\//, "").split("/");
    N = "/" + M.replace(/^\//, "").split("/").slice(I.length).join("/");
  }
  let A = G5(n, {
    pathname: N
  });
  process.env.NODE_ENV !== "production" && (process.env.NODE_ENV !== "production" && Ms(_ || A != null, 'No routes matched location "' + k.pathname + k.search + k.hash + '" '), process.env.NODE_ENV !== "production" && Ms(A == null || A[A.length - 1].route.element !== void 0 || A[A.length - 1].route.Component !== void 0 || A[A.length - 1].route.lazy !== void 0, 'Matched leaf route at location "' + k.pathname + k.search + k.hash + '" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.'));
  let $ = TH(A && A.map((I) => Object.assign({}, I, {
    params: Object.assign({}, m, I.params),
    pathname: _u([
      b,
      // Re-encode pathnames that were decoded inside matchRoutes
      u.encodeLocation ? u.encodeLocation(I.pathname).pathname : I.pathname
    ]),
    pathnameBase: I.pathnameBase === "/" ? b : _u([
      b,
      // Re-encode pathnames that were decoded inside matchRoutes
      u.encodeLocation ? u.encodeLocation(I.pathnameBase).pathname : I.pathnameBase
    ])
  })), c, r, o);
  return e && $ ? /* @__PURE__ */ D.createElement(wy.Provider, {
    value: {
      location: ty({
        pathname: "/",
        search: "",
        hash: "",
        state: null,
        key: "default"
      }, k),
      navigationType: ad.Pop
    }
  }, $) : $;
}
function SH() {
  let n = jH(), e = mH(n) ? n.status + " " + n.statusText : n instanceof Error ? n.message : JSON.stringify(n), r = n instanceof Error ? n.stack : null, o = "rgba(200,200,200, 0.5)", u = {
    padding: "0.5rem",
    backgroundColor: o
  }, c = {
    padding: "2px 4px",
    backgroundColor: o
  }, f = null;
  return process.env.NODE_ENV !== "production" && (console.error("Error handled by React Router default ErrorBoundary:", n), f = /* @__PURE__ */ D.createElement(D.Fragment, null, /* @__PURE__ */ D.createElement("p", null, " Hey developer "), /* @__PURE__ */ D.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", /* @__PURE__ */ D.createElement("code", {
    style: c
  }, "ErrorBoundary"), " or", " ", /* @__PURE__ */ D.createElement("code", {
    style: c
  }, "errorElement"), " prop on your route."))), /* @__PURE__ */ D.createElement(D.Fragment, null, /* @__PURE__ */ D.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ D.createElement("h3", {
    style: {
      fontStyle: "italic"
    }
  }, e), r ? /* @__PURE__ */ D.createElement("pre", {
    style: u
  }, r) : null, f);
}
const _H = /* @__PURE__ */ D.createElement(SH, null);
class EH extends D.Component {
  constructor(e) {
    super(e), this.state = {
      location: e.location,
      revalidation: e.revalidation,
      error: e.error
    };
  }
  static getDerivedStateFromError(e) {
    return {
      error: e
    };
  }
  static getDerivedStateFromProps(e, r) {
    return r.location !== e.location || r.revalidation !== "idle" && e.revalidation === "idle" ? {
      error: e.error,
      location: e.location,
      revalidation: e.revalidation
    } : {
      error: e.error !== void 0 ? e.error : r.error,
      location: r.location,
      revalidation: e.revalidation || r.revalidation
    };
  }
  componentDidCatch(e, r) {
    console.error("React Router caught the following error during render", e, r);
  }
  render() {
    return this.state.error !== void 0 ? /* @__PURE__ */ D.createElement(Is.Provider, {
      value: this.props.routeContext
    }, /* @__PURE__ */ D.createElement(lT.Provider, {
      value: this.state.error,
      children: this.props.component
    })) : this.props.children;
  }
}
function CH(n) {
  let {
    routeContext: e,
    match: r,
    children: o
  } = n, u = D.useContext(by);
  return u && u.static && u.staticContext && (r.route.errorElement || r.route.ErrorBoundary) && (u.staticContext._deepestRenderedBoundaryId = r.route.id), /* @__PURE__ */ D.createElement(Is.Provider, {
    value: e
  }, o);
}
function TH(n, e, r, o) {
  var u;
  if (e === void 0 && (e = []), r === void 0 && (r = null), o === void 0 && (o = null), n == null) {
    var c;
    if (!r)
      return null;
    if (r.errors)
      n = r.matches;
    else if ((c = o) != null && c.v7_partialHydration && e.length === 0 && !r.initialized && r.matches.length > 0)
      n = r.matches;
    else
      return null;
  }
  let f = n, m = (u = r) == null ? void 0 : u.errors;
  if (m != null) {
    let _ = f.findIndex((T) => T.route.id && (m == null ? void 0 : m[T.route.id]) !== void 0);
    _ >= 0 || (process.env.NODE_ENV !== "production" ? $t(!1, "Could not find a matching route for errors on route IDs: " + Object.keys(m).join(",")) : $t(!1)), f = f.slice(0, Math.min(f.length, _ + 1));
  }
  let y = !1, b = -1;
  if (r && o && o.v7_partialHydration)
    for (let _ = 0; _ < f.length; _++) {
      let T = f[_];
      if ((T.route.HydrateFallback || T.route.hydrateFallbackElement) && (b = _), T.route.id) {
        let {
          loaderData: k,
          errors: C
        } = r, M = T.route.loader && k[T.route.id] === void 0 && (!C || C[T.route.id] === void 0);
        if (T.route.lazy || M) {
          y = !0, b >= 0 ? f = f.slice(0, b + 1) : f = [f[0]];
          break;
        }
      }
    }
  return f.reduceRight((_, T, k) => {
    let C, M = !1, N = null, A = null;
    r && (C = m && T.route.id ? m[T.route.id] : void 0, N = T.route.errorElement || _H, y && (b < 0 && k === 0 ? (SP("route-fallback", !1, "No `HydrateFallback` element provided to render during initial hydration"), M = !0, A = null) : b === k && (M = !0, A = T.route.hydrateFallbackElement || null)));
    let $ = e.concat(f.slice(0, k + 1)), I = () => {
      let U;
      return C ? U = N : M ? U = A : T.route.Component ? U = /* @__PURE__ */ D.createElement(T.route.Component, null) : T.route.element ? U = T.route.element : U = _, /* @__PURE__ */ D.createElement(CH, {
        match: T,
        routeContext: {
          outlet: _,
          matches: $,
          isDataRoute: r != null
        },
        children: U
      });
    };
    return r && (T.route.ErrorBoundary || T.route.errorElement || k === 0) ? /* @__PURE__ */ D.createElement(EH, {
      location: r.location,
      revalidation: r.revalidation,
      component: N,
      error: C,
      children: I(),
      routeContext: {
        outlet: null,
        matches: $,
        isDataRoute: !0
      }
    }) : I();
  }, null);
}
var xP = /* @__PURE__ */ function (n) {
  return n.UseBlocker = "useBlocker", n.UseRevalidator = "useRevalidator", n.UseNavigateStable = "useNavigate", n;
}(xP || {}), ny = /* @__PURE__ */ function (n) {
  return n.UseBlocker = "useBlocker", n.UseLoaderData = "useLoaderData", n.UseActionData = "useActionData", n.UseRouteError = "useRouteError", n.UseNavigation = "useNavigation", n.UseRouteLoaderData = "useRouteLoaderData", n.UseMatches = "useMatches", n.UseRevalidator = "useRevalidator", n.UseNavigateStable = "useNavigate", n.UseRouteId = "useRouteId", n;
}(ny || {});
function uT(n) {
  return n + " must be used within a data router.  See https://reactrouter.com/v6/routers/picking-a-router.";
}
function RH(n) {
  let e = D.useContext(by);
  return e || (process.env.NODE_ENV !== "production" ? $t(!1, uT(n)) : $t(!1)), e;
}
function kH(n) {
  let e = D.useContext(sT);
  return e || (process.env.NODE_ENV !== "production" ? $t(!1, uT(n)) : $t(!1)), e;
}
function OH(n) {
  let e = D.useContext(Is);
  return e || (process.env.NODE_ENV !== "production" ? $t(!1, uT(n)) : $t(!1)), e;
}
function cT(n) {
  let e = OH(n), r = e.matches[e.matches.length - 1];
  return r.route.id || (process.env.NODE_ENV !== "production" ? $t(!1, n + ' can only be used on routes that contain a unique "id"') : $t(!1)), r.route.id;
}
function NH() {
  return cT(ny.UseRouteId);
}
function jH() {
  var n;
  let e = D.useContext(lT), r = kH(ny.UseRouteError), o = cT(ny.UseRouteError);
  return e !== void 0 ? e : (n = r.errors) == null ? void 0 : n[o];
}
function AH() {
  let {
    router: n
  } = RH(xP.UseNavigateStable), e = cT(ny.UseNavigateStable), r = D.useRef(!1);
  return bP(() => {
    r.current = !0;
  }), D.useCallback(function (u, c) {
    c === void 0 && (c = {}), process.env.NODE_ENV !== "production" && Ms(r.current, yP), r.current && (typeof u == "number" ? n.navigate(u) : n.navigate(u, ty({
      fromRouteId: e
    }, c)));
  }, [n, e]);
}
const uj = {};
function SP(n, e, r) {
  !e && !uj[n] && (uj[n] = !0, process.env.NODE_ENV !== "production" && Ms(!1, r));
}
const cj = {};
function DH(n, e) {
  process.env.NODE_ENV !== "production" && !cj[e] && (cj[e] = !0, console.warn(e));
}
const dj = (n, e, r) => DH(n, " React Router Future Flag Warning: " + e + ". " + ("You can use the `" + n + "` future flag to opt-in early. ") + ("For more information, see " + r + "."));
function PH(n, e) {
  (n == null ? void 0 : n.v7_startTransition) === void 0 && dj("v7_startTransition", "React Router will begin wrapping state updates in `React.startTransition` in v7", "https://reactrouter.com/v6/upgrading/future#v7_starttransition"), (n == null ? void 0 : n.v7_relativeSplatPath) === void 0 && !e && dj("v7_relativeSplatPath", "Relative route resolution within Splat routes is changing in v7", "https://reactrouter.com/v6/upgrading/future#v7_relativesplatpath");
}
function MH(n) {
  let {
    to: e,
    replace: r,
    state: o,
    relative: u
  } = n;
  Nm() || (process.env.NODE_ENV !== "production" ? $t(
    !1,
    // TODO: This error is probably because they somehow have 2 versions of
    // the router loaded. We can help them understand how to avoid that.
    "<Navigate> may be used only in the context of a <Router> component."
  ) : $t(!1));
  let {
    future: c,
    static: f
  } = D.useContext(Yo);
  process.env.NODE_ENV !== "production" && Ms(!f, "<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change.");
  let {
    matches: m
  } = D.useContext(Is), {
    pathname: y
  } = ku(), b = _x(), _ = oT(e, iT(m, c.v7_relativeSplatPath), y, u === "path"), T = JSON.stringify(_);
  return D.useEffect(() => b(JSON.parse(T), {
    replace: r,
    state: o,
    relative: u
  }), [b, T, u, r, o]), null;
}
function Cs(n) {
  process.env.NODE_ENV !== "production" ? $t(!1, "A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.") : $t(!1);
}
function LH(n) {
  let {
    basename: e = "/",
    children: r = null,
    location: o,
    navigationType: u = ad.Pop,
    navigator: c,
    static: f = !1,
    future: m
  } = n;
  Nm() && (process.env.NODE_ENV !== "production" ? $t(!1, "You cannot render a <Router> inside another <Router>. You should never have more than one in your app.") : $t(!1));
  let y = e.replace(/^\/*/, "/"), b = D.useMemo(() => ({
    basename: y,
    navigator: c,
    static: f,
    future: ty({
      v7_relativeSplatPath: !1
    }, m)
  }), [y, m, c, f]);
  typeof o == "string" && (o = Om(o));
  let {
    pathname: _ = "/",
    search: T = "",
    hash: k = "",
    state: C = null,
    key: M = "default"
  } = o, N = D.useMemo(() => {
    let A = cd(_, y);
    return A == null ? null : {
      location: {
        pathname: A,
        search: T,
        hash: k,
        state: C,
        key: M
      },
      navigationType: u
    };
  }, [y, _, T, k, C, M, u]);
  return process.env.NODE_ENV !== "production" && Ms(N != null, '<Router basename="' + y + '"> is not able to match the URL ' + ('"' + _ + T + k + '" because it does not start with the ') + "basename, so the <Router> won't render anything."), N == null ? null : /* @__PURE__ */ D.createElement(Yo.Provider, {
    value: b
  }, /* @__PURE__ */ D.createElement(wy.Provider, {
    children: r,
    value: N
  }));
}
function IH(n) {
  let {
    children: e,
    location: r
  } = n;
  return wH(h1(e), r);
}
new Promise(() => {
});
function h1(n, e) {
  e === void 0 && (e = []);
  let r = [];
  return D.Children.forEach(n, (o, u) => {
    if (!/* @__PURE__ */ D.isValidElement(o))
      return;
    let c = [...e, u];
    if (o.type === D.Fragment) {
      r.push.apply(r, h1(o.props.children, c));
      return;
    }
    o.type !== Cs && (process.env.NODE_ENV !== "production" ? $t(!1, "[" + (typeof o.type == "string" ? o.type : o.type.name) + "] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>") : $t(!1)), !o.props.index || !o.props.children || (process.env.NODE_ENV !== "production" ? $t(!1, "An index route cannot have child routes.") : $t(!1));
    let f = {
      id: o.props.id || c.join("-"),
      caseSensitive: o.props.caseSensitive,
      element: o.props.element,
      Component: o.props.Component,
      index: o.props.index,
      path: o.props.path,
      loader: o.props.loader,
      action: o.props.action,
      errorElement: o.props.errorElement,
      ErrorBoundary: o.props.ErrorBoundary,
      hasErrorBoundary: o.props.ErrorBoundary != null || o.props.errorElement != null,
      shouldRevalidate: o.props.shouldRevalidate,
      handle: o.props.handle,
      lazy: o.props.lazy
    };
    o.props.children && (f.children = h1(o.props.children, c)), r.push(f);
  }), r;
}
/**
 * React Router DOM v6.30.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function bm() {
  return bm = Object.assign ? Object.assign.bind() : function (n) {
    for (var e = 1; e < arguments.length; e++) {
      var r = arguments[e];
      for (var o in r)
        Object.prototype.hasOwnProperty.call(r, o) && (n[o] = r[o]);
    }
    return n;
  }, bm.apply(this, arguments);
}
function dT(n, e) {
  if (n == null) return {};
  var r = {}, o = Object.keys(n), u, c;
  for (c = 0; c < o.length; c++)
    u = o[c], !(e.indexOf(u) >= 0) && (r[u] = n[u]);
  return r;
}
const Bw = "get", Vw = "application/x-www-form-urlencoded";
function Ex(n) {
  return n != null && typeof n.tagName == "string";
}
function UH(n) {
  return Ex(n) && n.tagName.toLowerCase() === "button";
}
function FH(n) {
  return Ex(n) && n.tagName.toLowerCase() === "form";
}
function $H(n) {
  return Ex(n) && n.tagName.toLowerCase() === "input";
}
function zH(n) {
  return !!(n.metaKey || n.altKey || n.ctrlKey || n.shiftKey);
}
function BH(n, e) {
  return n.button === 0 && // Ignore everything but left clicks
    (!e || e === "_self") && // Let browser handle "target=_blank" etc.
    !zH(n);
}
let _w = null;
function VH() {
  if (_w === null)
    try {
      new FormData(
        document.createElement("form"),
        // @ts-expect-error if FormData supports the submitter parameter, this will throw
        0
      ), _w = !1;
    } catch {
      _w = !0;
    }
  return _w;
}
const HH = /* @__PURE__ */ new Set(["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]);
function bC(n) {
  return n != null && !HH.has(n) ? (process.env.NODE_ENV !== "production" && Ms(!1, '"' + n + '" is not a valid `encType` for `<Form>`/`<fetcher.Form>` ' + ('and will default to "' + Vw + '"')), null) : n;
}
function WH(n, e) {
  let r, o, u, c, f;
  if (FH(n)) {
    let m = n.getAttribute("action");
    o = m ? cd(m, e) : null, r = n.getAttribute("method") || Bw, u = bC(n.getAttribute("enctype")) || Vw, c = new FormData(n);
  } else if (UH(n) || $H(n) && (n.type === "submit" || n.type === "image")) {
    let m = n.form;
    if (m == null)
      throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');
    let y = n.getAttribute("formaction") || m.getAttribute("action");
    if (o = y ? cd(y, e) : null, r = n.getAttribute("formmethod") || m.getAttribute("method") || Bw, u = bC(n.getAttribute("formenctype")) || bC(m.getAttribute("enctype")) || Vw, c = new FormData(m, n), !VH()) {
      let {
        name: b,
        type: _,
        value: T
      } = n;
      if (_ === "image") {
        let k = b ? b + "." : "";
        c.append(k + "x", "0"), c.append(k + "y", "0");
      } else b && c.append(b, T);
    }
  } else {
    if (Ex(n))
      throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');
    r = Bw, o = null, u = Vw, f = n;
  }
  return c && u === "text/plain" && (f = c, c = void 0), {
    action: o,
    method: r.toLowerCase(),
    encType: u,
    formData: c,
    body: f
  };
}
const qH = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "viewTransition"], YH = ["aria-current", "caseSensitive", "className", "end", "style", "to", "viewTransition", "children"], KH = ["fetcherKey", "navigate", "reloadDocument", "replace", "state", "method", "action", "onSubmit", "relative", "preventScrollReset", "viewTransition"], GH = "6";
try {
  window.__reactRouterVersion = GH;
} catch {
}
const _P = /* @__PURE__ */ D.createContext({
  isTransitioning: !1
});
process.env.NODE_ENV !== "production" && (_P.displayName = "ViewTransition");
const QH = /* @__PURE__ */ D.createContext(/* @__PURE__ */ new Map());
process.env.NODE_ENV !== "production" && (QH.displayName = "Fetchers");
const JH = "startTransition", fj = I1[JH];
function ZH(n) {
  let {
    basename: e,
    children: r,
    future: o,
    window: u
  } = n, c = D.useRef();
  c.current == null && (c.current = q5({
    window: u,
    v5Compat: !0
  }));
  let f = c.current, [m, y] = D.useState({
    action: f.action,
    location: f.location
  }), {
    v7_startTransition: b
  } = o || {}, _ = D.useCallback((T) => {
    b && fj ? fj(() => y(T)) : y(T);
  }, [y, b]);
  return D.useLayoutEffect(() => f.listen(_), [f, _]), D.useEffect(() => PH(o), [o]), /* @__PURE__ */ D.createElement(LH, {
    basename: e,
    children: r,
    location: m.location,
    navigationType: m.action,
    navigator: f,
    future: o
  });
}
process.env.NODE_ENV;
const XH = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", e6 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, ka = /* @__PURE__ */ D.forwardRef(function (e, r) {
  let {
    onClick: o,
    relative: u,
    reloadDocument: c,
    replace: f,
    state: m,
    target: y,
    to: b,
    preventScrollReset: _,
    viewTransition: T
  } = e, k = dT(e, qH), {
    basename: C
  } = D.useContext(Yo), M, N = !1;
  if (typeof b == "string" && e6.test(b) && (M = b, XH))
    try {
      let U = new URL(window.location.href), B = b.startsWith("//") ? new URL(U.protocol + b) : new URL(b), K = cd(B.pathname, C);
      B.origin === U.origin && K != null ? b = K + B.search + B.hash : N = !0;
    } catch {
      process.env.NODE_ENV !== "production" && Ms(!1, '<Link to="' + b + '"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.');
    }
  let A = yH(b, {
    relative: u
  }), $ = a6(b, {
    replace: f,
    state: m,
    target: y,
    preventScrollReset: _,
    relative: u,
    viewTransition: T
  });
  function I(U) {
    o && o(U), U.defaultPrevented || $(U);
  }
  return (
    // eslint-disable-next-line jsx-a11y/anchor-has-content
    /* @__PURE__ */ D.createElement("a", bm({}, k, {
    href: M || A,
    onClick: N || c ? o : I,
    ref: r,
    target: y
  }))
  );
});
process.env.NODE_ENV !== "production" && (ka.displayName = "Link");
const t6 = /* @__PURE__ */ D.forwardRef(function (e, r) {
  let {
    "aria-current": o = "page",
    caseSensitive: u = !1,
    className: c = "",
    end: f = !1,
    style: m,
    to: y,
    viewTransition: b,
    children: _
  } = e, T = dT(e, YH), k = xy(y, {
    relative: T.relative
  }), C = ku(), M = D.useContext(sT), {
    navigator: N,
    basename: A
  } = D.useContext(Yo), $ = M != null && // Conditional usage is OK here because the usage of a data router is static
    // eslint-disable-next-line react-hooks/rules-of-hooks
    c6(k) && b === !0, I = N.encodeLocation ? N.encodeLocation(k).pathname : k.pathname, U = C.pathname, B = M && M.navigation && M.navigation.location ? M.navigation.location.pathname : null;
  u || (U = U.toLowerCase(), B = B ? B.toLowerCase() : null, I = I.toLowerCase()), B && A && (B = cd(B, A) || B);
  const K = I !== "/" && I.endsWith("/") ? I.length - 1 : I.length;
  let te = U === I || !f && U.startsWith(I) && U.charAt(K) === "/", re = B != null && (B === I || !f && B.startsWith(I) && B.charAt(I.length) === "/"), ve = {
    isActive: te,
    isPending: re,
    isTransitioning: $
  }, Ce = te ? o : void 0, ke;
  typeof c == "function" ? ke = c(ve) : ke = [c, te ? "active" : null, re ? "pending" : null, $ ? "transitioning" : null].filter(Boolean).join(" ");
  let Ie = typeof m == "function" ? m(ve) : m;
  return /* @__PURE__ */ D.createElement(ka, bm({}, T, {
    "aria-current": Ce,
    className: ke,
    ref: r,
    style: Ie,
    to: y,
    viewTransition: b
  }), typeof _ == "function" ? _(ve) : _);
});
process.env.NODE_ENV !== "production" && (t6.displayName = "NavLink");
const n6 = /* @__PURE__ */ D.forwardRef((n, e) => {
  let {
    fetcherKey: r,
    navigate: o,
    reloadDocument: u,
    replace: c,
    state: f,
    method: m = Bw,
    action: y,
    onSubmit: b,
    relative: _,
    preventScrollReset: T,
    viewTransition: k
  } = n, C = dT(n, KH), M = l6(), N = u6(y, {
    relative: _
  }), A = m.toLowerCase() === "get" ? "get" : "post", $ = (I) => {
    if (b && b(I), I.defaultPrevented) return;
    I.preventDefault();
    let U = I.nativeEvent.submitter, B = (U == null ? void 0 : U.getAttribute("formmethod")) || m;
    M(U || I.currentTarget, {
      fetcherKey: r,
      method: B,
      navigate: o,
      replace: c,
      state: f,
      relative: _,
      preventScrollReset: T,
      viewTransition: k
    });
  };
  return /* @__PURE__ */ D.createElement("form", bm({
    ref: e,
    method: A,
    action: N,
    onSubmit: u ? b : $
  }, C));
});
process.env.NODE_ENV !== "production" && (n6.displayName = "Form");
process.env.NODE_ENV;
var ex;
(function (n) {
  n.UseScrollRestoration = "useScrollRestoration", n.UseSubmit = "useSubmit", n.UseSubmitFetcher = "useSubmitFetcher", n.UseFetcher = "useFetcher", n.useViewTransitionState = "useViewTransitionState";
})(ex || (ex = {}));
var hj;
(function (n) {
  n.UseFetcher = "useFetcher", n.UseFetchers = "useFetchers", n.UseScrollRestoration = "useScrollRestoration";
})(hj || (hj = {}));
function r6(n) {
  return n + " must be used within a data router.  See https://reactrouter.com/v6/routers/picking-a-router.";
}
function EP(n) {
  let e = D.useContext(by);
  return e || (process.env.NODE_ENV !== "production" ? $t(!1, r6(n)) : $t(!1)), e;
}
function a6(n, e) {
  let {
    target: r,
    replace: o,
    state: u,
    preventScrollReset: c,
    relative: f,
    viewTransition: m
  } = e === void 0 ? {} : e, y = _x(), b = ku(), _ = xy(n, {
    relative: f
  });
  return D.useCallback((T) => {
    if (BH(T, r)) {
      T.preventDefault();
      let k = o !== void 0 ? o : ey(b) === ey(_);
      y(n, {
        replace: k,
        state: u,
        preventScrollReset: c,
        relative: f,
        viewTransition: m
      });
    }
  }, [b, y, _, o, u, r, n, c, f, m]);
}
function i6() {
  if (typeof document > "u")
    throw new Error("You are calling submit during the server render. Try calling submit within a `useEffect` or callback instead.");
}
let o6 = 0, s6 = () => "__" + String(++o6) + "__";
function l6() {
  let {
    router: n
  } = EP(ex.UseSubmit), {
    basename: e
  } = D.useContext(Yo), r = NH();
  return D.useCallback(function (o, u) {
    u === void 0 && (u = {}), i6();
    let {
      action: c,
      method: f,
      encType: m,
      formData: y,
      body: b
    } = WH(o, e);
    if (u.navigate === !1) {
      let _ = u.fetcherKey || s6();
      n.fetch(_, r, u.action || c, {
        preventScrollReset: u.preventScrollReset,
        formData: y,
        body: b,
        formMethod: u.method || f,
        formEncType: u.encType || m,
        flushSync: u.flushSync
      });
    } else
      n.navigate(u.action || c, {
        preventScrollReset: u.preventScrollReset,
        formData: y,
        body: b,
        formMethod: u.method || f,
        formEncType: u.encType || m,
        replace: u.replace,
        state: u.state,
        fromRouteId: r,
        flushSync: u.flushSync,
        viewTransition: u.viewTransition
      });
  }, [n, e, r]);
}
function u6(n, e) {
  let {
    relative: r
  } = e === void 0 ? {} : e, {
    basename: o
  } = D.useContext(Yo), u = D.useContext(Is);
  u || (process.env.NODE_ENV !== "production" ? $t(!1, "useFormAction must be used inside a RouteContext") : $t(!1));
  let [c] = u.matches.slice(-1), f = bm({}, xy(n || ".", {
    relative: r
  })), m = ku();
  if (n == null) {
    f.search = m.search;
    let y = new URLSearchParams(f.search), b = y.getAll("index");
    if (b.some((T) => T === "")) {
      y.delete("index"), b.filter((k) => k).forEach((k) => y.append("index", k));
      let T = y.toString();
      f.search = T ? "?" + T : "";
    }
  }
  return (!n || n === ".") && c.route.index && (f.search = f.search ? f.search.replace(/^\?/, "?index&") : "?index"), o !== "/" && (f.pathname = f.pathname === "/" ? o : _u([o, f.pathname])), ey(f);
}
function c6(n, e) {
  e === void 0 && (e = {});
  let r = D.useContext(_P);
  r == null && (process.env.NODE_ENV !== "production" ? $t(!1, "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?") : $t(!1));
  let {
    basename: o
  } = EP(ex.useViewTransitionState), u = xy(n, {
    relative: e.relative
  });
  if (!r.isTransitioning)
    return !1;
  let c = cd(r.currentLocation.pathname, o) || r.currentLocation.pathname, f = cd(r.nextLocation.pathname, o) || r.nextLocation.pathname;
  return Xw(u.pathname, f) != null || Xw(u.pathname, c) != null;
}
const d6 = gy(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline: "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline"
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
), Jn = D.forwardRef(
  ({ className: n, variant: e, size: r, asChild: o = !1, ...u }, c) => {
    const f = o ? e4 : "button";
    return /* @__PURE__ */ x.jsx(f, { className: tn(d6({ variant: e, size: r, className: n })), ref: c, ...u });
  }
);
Jn.displayName = "Button";
var wC = "focusScope.autoFocusOnMount", xC = "focusScope.autoFocusOnUnmount", pj = { bubbles: !1, cancelable: !0 }, f6 = "FocusScope", CP = D.forwardRef((n, e) => {
  const {
    loop: r = !1,
    trapped: o = !1,
    onMountAutoFocus: u,
    onUnmountAutoFocus: c,
    ...f
  } = n, [m, y] = D.useState(null), b = As(u), _ = As(c), T = D.useRef(null), k = pi(e, (N) => y(N)), C = D.useRef({
    paused: !1,
    pause() {
      this.paused = !0;
    },
    resume() {
      this.paused = !1;
    }
  }).current;
  D.useEffect(() => {
    if (o) {
      let N = function (U) {
        if (C.paused || !m) return;
        const B = U.target;
        m.contains(B) ? T.current = B : Wc(T.current, { select: !0 });
      }, A = function (U) {
        if (C.paused || !m) return;
        const B = U.relatedTarget;
        B !== null && (m.contains(B) || Wc(T.current, { select: !0 }));
      }, $ = function (U) {
        if (document.activeElement === document.body)
          for (const K of U)
            K.removedNodes.length > 0 && Wc(m);
      };
      document.addEventListener("focusin", N), document.addEventListener("focusout", A);
      const I = new MutationObserver($);
      return m && I.observe(m, { childList: !0, subtree: !0 }), () => {
        document.removeEventListener("focusin", N), document.removeEventListener("focusout", A), I.disconnect();
      };
    }
  }, [o, m, C.paused]), D.useEffect(() => {
    if (m) {
      vj.add(C);
      const N = document.activeElement;
      if (!m.contains(N)) {
        const $ = new CustomEvent(wC, pj);
        m.addEventListener(wC, b), m.dispatchEvent($), $.defaultPrevented || (h6(y6(TP(m)), { select: !0 }), document.activeElement === N && Wc(m));
      }
      return () => {
        m.removeEventListener(wC, b), setTimeout(() => {
          const $ = new CustomEvent(xC, pj);
          m.addEventListener(xC, _), m.dispatchEvent($), $.defaultPrevented || Wc(N ?? document.body, { select: !0 }), m.removeEventListener(xC, _), vj.remove(C);
        }, 0);
      };
    }
  }, [m, b, _, C]);
  const M = D.useCallback(
    (N) => {
      if (!r && !o || C.paused) return;
      const A = N.key === "Tab" && !N.altKey && !N.ctrlKey && !N.metaKey, $ = document.activeElement;
      if (A && $) {
        const I = N.currentTarget, [U, B] = p6(I);
        U && B ? !N.shiftKey && $ === B ? (N.preventDefault(), r && Wc(U, { select: !0 })) : N.shiftKey && $ === U && (N.preventDefault(), r && Wc(B, { select: !0 })) : $ === I && N.preventDefault();
      }
    },
    [r, o, C.paused]
  );
  return /* @__PURE__ */ x.jsx(Zn.div, { tabIndex: -1, ...f, ref: k, onKeyDown: M });
});
CP.displayName = f6;
function h6(n, { select: e = !1 } = {}) {
  const r = document.activeElement;
  for (const o of n)
    if (Wc(o, { select: e }), document.activeElement !== r) return;
}
function p6(n) {
  const e = TP(n), r = mj(e, n), o = mj(e.reverse(), n);
  return [r, o];
}
function TP(n) {
  const e = [], r = document.createTreeWalker(n, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (o) => {
      const u = o.tagName === "INPUT" && o.type === "hidden";
      return o.disabled || o.hidden || u ? NodeFilter.FILTER_SKIP : o.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; r.nextNode();) e.push(r.currentNode);
  return e;
}
function mj(n, e) {
  for (const r of n)
    if (!m6(r, { upTo: e })) return r;
}
function m6(n, { upTo: e }) {
  if (getComputedStyle(n).visibility === "hidden") return !0;
  for (; n;) {
    if (e !== void 0 && n === e) return !1;
    if (getComputedStyle(n).display === "none") return !0;
    n = n.parentElement;
  }
  return !1;
}
function v6(n) {
  return n instanceof HTMLInputElement && "select" in n;
}
function Wc(n, { select: e = !1 } = {}) {
  if (n && n.focus) {
    const r = document.activeElement;
    n.focus({ preventScroll: !0 }), n !== r && v6(n) && e && n.select();
  }
}
var vj = g6();
function g6() {
  let n = [];
  return {
    add(e) {
      const r = n[0];
      e !== r && (r == null || r.pause()), n = gj(n, e), n.unshift(e);
    },
    remove(e) {
      var r;
      n = gj(n, e), (r = n[0]) == null || r.resume();
    }
  };
}
function gj(n, e) {
  const r = [...n], o = r.indexOf(e);
  return o !== -1 && r.splice(o, 1), r;
}
function y6(n) {
  return n.filter((e) => e.tagName !== "A");
}
var SC = 0;
function b6() {
  D.useEffect(() => {
    const n = document.querySelectorAll("[data-radix-focus-guard]");
    return document.body.insertAdjacentElement("afterbegin", n[0] ?? yj()), document.body.insertAdjacentElement("beforeend", n[1] ?? yj()), SC++, () => {
      SC === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((e) => e.remove()), SC--;
    };
  }, []);
}
function yj() {
  const n = document.createElement("span");
  return n.setAttribute("data-radix-focus-guard", ""), n.tabIndex = 0, n.style.outline = "none", n.style.opacity = "0", n.style.position = "fixed", n.style.pointerEvents = "none", n;
}
var p1 = function (n, e) {
  return p1 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (r, o) {
    r.__proto__ = o;
  } || function (r, o) {
    for (var u in o) Object.prototype.hasOwnProperty.call(o, u) && (r[u] = o[u]);
  }, p1(n, e);
};
function RP(n, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
  p1(n, e);
  function r() {
    this.constructor = n;
  }
  n.prototype = e === null ? Object.create(e) : (r.prototype = e.prototype, new r());
}
var Ho = function () {
  return Ho = Object.assign || function (e) {
    for (var r, o = 1, u = arguments.length; o < u; o++) {
      r = arguments[o];
      for (var c in r) Object.prototype.hasOwnProperty.call(r, c) && (e[c] = r[c]);
    }
    return e;
  }, Ho.apply(this, arguments);
};
function pd(n, e) {
  var r = {};
  for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && e.indexOf(o) < 0 && (r[o] = n[o]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var u = 0, o = Object.getOwnPropertySymbols(n); u < o.length; u++)
      e.indexOf(o[u]) < 0 && Object.prototype.propertyIsEnumerable.call(n, o[u]) && (r[o[u]] = n[o[u]]);
  return r;
}
function kP(n, e, r, o) {
  var u = arguments.length, c = u < 3 ? e : o === null ? o = Object.getOwnPropertyDescriptor(e, r) : o, f;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") c = Reflect.decorate(n, e, r, o);
  else for (var m = n.length - 1; m >= 0; m--) (f = n[m]) && (c = (u < 3 ? f(c) : u > 3 ? f(e, r, c) : f(e, r)) || c);
  return u > 3 && c && Object.defineProperty(e, r, c), c;
}
function OP(n, e) {
  return function (r, o) {
    e(r, o, n);
  };
}
function NP(n, e, r, o, u, c) {
  function f($) {
    if ($ !== void 0 && typeof $ != "function") throw new TypeError("Function expected");
    return $;
  }
  for (var m = o.kind, y = m === "getter" ? "get" : m === "setter" ? "set" : "value", b = !e && n ? o.static ? n : n.prototype : null, _ = e || (b ? Object.getOwnPropertyDescriptor(b, o.name) : {}), T, k = !1, C = r.length - 1; C >= 0; C--) {
    var M = {};
    for (var N in o) M[N] = N === "access" ? {} : o[N];
    for (var N in o.access) M.access[N] = o.access[N];
    M.addInitializer = function ($) {
      if (k) throw new TypeError("Cannot add initializers after decoration has completed");
      c.push(f($ || null));
    };
    var A = (0, r[C])(m === "accessor" ? { get: _.get, set: _.set } : _[y], M);
    if (m === "accessor") {
      if (A === void 0) continue;
      if (A === null || typeof A != "object") throw new TypeError("Object expected");
      (T = f(A.get)) && (_.get = T), (T = f(A.set)) && (_.set = T), (T = f(A.init)) && u.unshift(T);
    } else (T = f(A)) && (m === "field" ? u.unshift(T) : _[y] = T);
  }
  b && Object.defineProperty(b, o.name, _), k = !0;
}
function jP(n, e, r) {
  for (var o = arguments.length > 2, u = 0; u < e.length; u++)
    r = o ? e[u].call(n, r) : e[u].call(n);
  return o ? r : void 0;
}
function AP(n) {
  return typeof n == "symbol" ? n : "".concat(n);
}
function DP(n, e, r) {
  return typeof e == "symbol" && (e = e.description ? "[".concat(e.description, "]") : ""), Object.defineProperty(n, "name", { configurable: !0, value: r ? "".concat(r, " ", e) : e });
}
function PP(n, e) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function") return Reflect.metadata(n, e);
}
function dt(n, e, r, o) {
  function u(c) {
    return c instanceof r ? c : new r(function (f) {
      f(c);
    });
  }
  return new (r || (r = Promise))(function (c, f) {
    function m(_) {
      try {
        b(o.next(_));
      } catch (T) {
        f(T);
      }
    }
    function y(_) {
      try {
        b(o.throw(_));
      } catch (T) {
        f(T);
      }
    }
    function b(_) {
      _.done ? c(_.value) : u(_.value).then(m, y);
    }
    b((o = o.apply(n, e || [])).next());
  });
}
function MP(n, e) {
  var r = {
    label: 0, sent: function () {
      if (c[0] & 1) throw c[1];
      return c[1];
    }, trys: [], ops: []
  }, o, u, c, f = Object.create((typeof Iterator == "function" ? Iterator : Object).prototype);
  return f.next = m(0), f.throw = m(1), f.return = m(2), typeof Symbol == "function" && (f[Symbol.iterator] = function () {
    return this;
  }), f;
  function m(b) {
    return function (_) {
      return y([b, _]);
    };
  }
  function y(b) {
    if (o) throw new TypeError("Generator is already executing.");
    for (; f && (f = 0, b[0] && (r = 0)), r;) try {
      if (o = 1, u && (c = b[0] & 2 ? u.return : b[0] ? u.throw || ((c = u.return) && c.call(u), 0) : u.next) && !(c = c.call(u, b[1])).done) return c;
      switch (u = 0, c && (b = [b[0] & 2, c.value]), b[0]) {
        case 0:
        case 1:
          c = b;
          break;
        case 4:
          return r.label++, { value: b[1], done: !1 };
        case 5:
          r.label++, u = b[1], b = [0];
          continue;
        case 7:
          b = r.ops.pop(), r.trys.pop();
          continue;
        default:
          if (c = r.trys, !(c = c.length > 0 && c[c.length - 1]) && (b[0] === 6 || b[0] === 2)) {
            r = 0;
            continue;
          }
          if (b[0] === 3 && (!c || b[1] > c[0] && b[1] < c[3])) {
            r.label = b[1];
            break;
          }
          if (b[0] === 6 && r.label < c[1]) {
            r.label = c[1], c = b;
            break;
          }
          if (c && r.label < c[2]) {
            r.label = c[2], r.ops.push(b);
            break;
          }
          c[2] && r.ops.pop(), r.trys.pop();
          continue;
      }
      b = e.call(n, r);
    } catch (_) {
      b = [6, _], u = 0;
    } finally {
      o = c = 0;
    }
    if (b[0] & 5) throw b[1];
    return { value: b[0] ? b[1] : void 0, done: !0 };
  }
}
var Cx = Object.create ? function (n, e, r, o) {
  o === void 0 && (o = r);
  var u = Object.getOwnPropertyDescriptor(e, r);
  (!u || ("get" in u ? !e.__esModule : u.writable || u.configurable)) && (u = {
    enumerable: !0, get: function () {
      return e[r];
    }
  }), Object.defineProperty(n, o, u);
} : function (n, e, r, o) {
  o === void 0 && (o = r), n[o] = e[r];
};
function LP(n, e) {
  for (var r in n) r !== "default" && !Object.prototype.hasOwnProperty.call(e, r) && Cx(e, n, r);
}
function tx(n) {
  var e = typeof Symbol == "function" && Symbol.iterator, r = e && n[e], o = 0;
  if (r) return r.call(n);
  if (n && typeof n.length == "number") return {
    next: function () {
      return n && o >= n.length && (n = void 0), { value: n && n[o++], done: !n };
    }
  };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function fT(n, e) {
  var r = typeof Symbol == "function" && n[Symbol.iterator];
  if (!r) return n;
  var o = r.call(n), u, c = [], f;
  try {
    for (; (e === void 0 || e-- > 0) && !(u = o.next()).done;) c.push(u.value);
  } catch (m) {
    f = { error: m };
  } finally {
    try {
      u && !u.done && (r = o.return) && r.call(o);
    } finally {
      if (f) throw f.error;
    }
  }
  return c;
}
function IP() {
  for (var n = [], e = 0; e < arguments.length; e++)
    n = n.concat(fT(arguments[e]));
  return n;
}
function UP() {
  for (var n = 0, e = 0, r = arguments.length; e < r; e++) n += arguments[e].length;
  for (var o = Array(n), u = 0, e = 0; e < r; e++)
    for (var c = arguments[e], f = 0, m = c.length; f < m; f++, u++)
      o[u] = c[f];
  return o;
}
function hT(n, e, r) {
  if (r || arguments.length === 2) for (var o = 0, u = e.length, c; o < u; o++)
    (c || !(o in e)) && (c || (c = Array.prototype.slice.call(e, 0, o)), c[o] = e[o]);
  return n.concat(c || Array.prototype.slice.call(e));
}
function wm(n) {
  return this instanceof wm ? (this.v = n, this) : new wm(n);
}
function FP(n, e, r) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var o = r.apply(n, e || []), u, c = [];
  return u = Object.create((typeof AsyncIterator == "function" ? AsyncIterator : Object).prototype), m("next"), m("throw"), m("return", f), u[Symbol.asyncIterator] = function () {
    return this;
  }, u;
  function f(C) {
    return function (M) {
      return Promise.resolve(M).then(C, T);
    };
  }
  function m(C, M) {
    o[C] && (u[C] = function (N) {
      return new Promise(function (A, $) {
        c.push([C, N, A, $]) > 1 || y(C, N);
      });
    }, M && (u[C] = M(u[C])));
  }
  function y(C, M) {
    try {
      b(o[C](M));
    } catch (N) {
      k(c[0][3], N);
    }
  }
  function b(C) {
    C.value instanceof wm ? Promise.resolve(C.value.v).then(_, T) : k(c[0][2], C);
  }
  function _(C) {
    y("next", C);
  }
  function T(C) {
    y("throw", C);
  }
  function k(C, M) {
    C(M), c.shift(), c.length && y(c[0][0], c[0][1]);
  }
}
function $P(n) {
  var e, r;
  return e = {}, o("next"), o("throw", function (u) {
    throw u;
  }), o("return"), e[Symbol.iterator] = function () {
    return this;
  }, e;
  function o(u, c) {
    e[u] = n[u] ? function (f) {
      return (r = !r) ? { value: wm(n[u](f)), done: !1 } : c ? c(f) : f;
    } : c;
  }
}
function zP(n) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var e = n[Symbol.asyncIterator], r;
  return e ? e.call(n) : (n = typeof tx == "function" ? tx(n) : n[Symbol.iterator](), r = {}, o("next"), o("throw"), o("return"), r[Symbol.asyncIterator] = function () {
    return this;
  }, r);
  function o(c) {
    r[c] = n[c] && function (f) {
      return new Promise(function (m, y) {
        f = n[c](f), u(m, y, f.done, f.value);
      });
    };
  }
  function u(c, f, m, y) {
    Promise.resolve(y).then(function (b) {
      c({ value: b, done: m });
    }, f);
  }
}
function BP(n, e) {
  return Object.defineProperty ? Object.defineProperty(n, "raw", { value: e }) : n.raw = e, n;
}
var w6 = Object.create ? function (n, e) {
  Object.defineProperty(n, "default", { enumerable: !0, value: e });
} : function (n, e) {
  n.default = e;
}, m1 = function (n) {
  return m1 = Object.getOwnPropertyNames || function (e) {
    var r = [];
    for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && (r[r.length] = o);
    return r;
  }, m1(n);
};
function VP(n) {
  if (n && n.__esModule) return n;
  var e = {};
  if (n != null) for (var r = m1(n), o = 0; o < r.length; o++) r[o] !== "default" && Cx(e, n, r[o]);
  return w6(e, n), e;
}
function HP(n) {
  return n && n.__esModule ? n : { default: n };
}
function WP(n, e, r, o) {
  if (r === "a" && !o) throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? n !== e || !o : !e.has(n)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return r === "m" ? o : r === "a" ? o.call(n) : o ? o.value : e.get(n);
}
function qP(n, e, r, o, u) {
  if (o === "m") throw new TypeError("Private method is not writable");
  if (o === "a" && !u) throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? n !== e || !u : !e.has(n)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return o === "a" ? u.call(n, r) : u ? u.value = r : e.set(n, r), r;
}
function YP(n, e) {
  if (e === null || typeof e != "object" && typeof e != "function") throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof n == "function" ? e === n : n.has(e);
}
function KP(n, e, r) {
  if (e != null) {
    if (typeof e != "object" && typeof e != "function") throw new TypeError("Object expected.");
    var o, u;
    if (r) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      o = e[Symbol.asyncDispose];
    }
    if (o === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      o = e[Symbol.dispose], r && (u = o);
    }
    if (typeof o != "function") throw new TypeError("Object not disposable.");
    u && (o = function () {
      try {
        u.call(this);
      } catch (c) {
        return Promise.reject(c);
      }
    }), n.stack.push({ value: e, dispose: o, async: r });
  } else r && n.stack.push({ async: !0 });
  return e;
}
var x6 = typeof SuppressedError == "function" ? SuppressedError : function (n, e, r) {
  var o = new Error(r);
  return o.name = "SuppressedError", o.error = n, o.suppressed = e, o;
};
function GP(n) {
  function e(c) {
    n.error = n.hasError ? new x6(c, n.error, "An error was suppressed during disposal.") : c, n.hasError = !0;
  }
  var r, o = 0;
  function u() {
    for (; r = n.stack.pop();)
      try {
        if (!r.async && o === 1) return o = 0, n.stack.push(r), Promise.resolve().then(u);
        if (r.dispose) {
          var c = r.dispose.call(r.value);
          if (r.async) return o |= 2, Promise.resolve(c).then(u, function (f) {
            return e(f), u();
          });
        } else o |= 1;
      } catch (f) {
        e(f);
      }
    if (o === 1) return n.hasError ? Promise.reject(n.error) : Promise.resolve();
    if (n.hasError) throw n.error;
  }
  return u();
}
function QP(n, e) {
  return typeof n == "string" && /^\.\.?\//.test(n) ? n.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function (r, o, u, c, f) {
    return o ? e ? ".jsx" : ".js" : u && (!c || !f) ? r : u + c + "." + f.toLowerCase() + "js";
  }) : n;
}
const S6 = {
  __extends: RP,
  __assign: Ho,
  __rest: pd,
  __decorate: kP,
  __param: OP,
  __esDecorate: NP,
  __runInitializers: jP,
  __propKey: AP,
  __setFunctionName: DP,
  __metadata: PP,
  __awaiter: dt,
  __generator: MP,
  __createBinding: Cx,
  __exportStar: LP,
  __values: tx,
  __read: fT,
  __spread: IP,
  __spreadArrays: UP,
  __spreadArray: hT,
  __await: wm,
  __asyncGenerator: FP,
  __asyncDelegator: $P,
  __asyncValues: zP,
  __makeTemplateObject: BP,
  __importStar: VP,
  __importDefault: HP,
  __classPrivateFieldGet: WP,
  __classPrivateFieldSet: qP,
  __classPrivateFieldIn: YP,
  __addDisposableResource: KP,
  __disposeResources: GP,
  __rewriteRelativeImportExtension: QP
}, _6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  __addDisposableResource: KP,
  get __assign() {
    return Ho;
  },
  __asyncDelegator: $P,
  __asyncGenerator: FP,
  __asyncValues: zP,
  __await: wm,
  __awaiter: dt,
  __classPrivateFieldGet: WP,
  __classPrivateFieldIn: YP,
  __classPrivateFieldSet: qP,
  __createBinding: Cx,
  __decorate: kP,
  __disposeResources: GP,
  __esDecorate: NP,
  __exportStar: LP,
  __extends: RP,
  __generator: MP,
  __importDefault: HP,
  __importStar: VP,
  __makeTemplateObject: BP,
  __metadata: PP,
  __param: OP,
  __propKey: AP,
  __read: fT,
  __rest: pd,
  __rewriteRelativeImportExtension: QP,
  __runInitializers: jP,
  __setFunctionName: DP,
  __spread: IP,
  __spreadArray: hT,
  __spreadArrays: UP,
  __values: tx,
  default: S6
}, Symbol.toStringTag, { value: "Module" }));
var Hw = "right-scroll-bar-position", Ww = "width-before-scroll-bar", E6 = "with-scroll-bars-hidden", C6 = "--removed-body-scroll-bar-size";
function _C(n, e) {
  return typeof n == "function" ? n(e) : n && (n.current = e), n;
}
function T6(n, e) {
  var r = D.useState(function () {
    return {
      // value
      value: n,
      // last callback
      callback: e,
      // "memoized" public interface
      facade: {
        get current() {
          return r.value;
        },
        set current(o) {
          var u = r.value;
          u !== o && (r.value = o, r.callback(o, u));
        }
      }
    };
  })[0];
  return r.callback = e, r.facade;
}
var R6 = typeof window < "u" ? D.useLayoutEffect : D.useEffect, bj = /* @__PURE__ */ new WeakMap();
function k6(n, e) {
  var r = T6(null, function (o) {
    return n.forEach(function (u) {
      return _C(u, o);
    });
  });
  return R6(function () {
    var o = bj.get(r);
    if (o) {
      var u = new Set(o), c = new Set(n), f = r.current;
      u.forEach(function (m) {
        c.has(m) || _C(m, null);
      }), c.forEach(function (m) {
        u.has(m) || _C(m, f);
      });
    }
    bj.set(r, n);
  }, [n]), r;
}
function O6(n) {
  return n;
}
function N6(n, e) {
  e === void 0 && (e = O6);
  var r = [], o = !1, u = {
    read: function () {
      if (o)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return r.length ? r[r.length - 1] : n;
    },
    useMedium: function (c) {
      var f = e(c, o);
      return r.push(f), function () {
        r = r.filter(function (m) {
          return m !== f;
        });
      };
    },
    assignSyncMedium: function (c) {
      for (o = !0; r.length;) {
        var f = r;
        r = [], f.forEach(c);
      }
      r = {
        push: function (m) {
          return c(m);
        },
        filter: function () {
          return r;
        }
      };
    },
    assignMedium: function (c) {
      o = !0;
      var f = [];
      if (r.length) {
        var m = r;
        r = [], m.forEach(c), f = r;
      }
      var y = function () {
        var _ = f;
        f = [], _.forEach(c);
      }, b = function () {
        return Promise.resolve().then(y);
      };
      b(), r = {
        push: function (_) {
          f.push(_), b();
        },
        filter: function (_) {
          return f = f.filter(_), r;
        }
      };
    }
  };
  return u;
}
function j6(n) {
  n === void 0 && (n = {});
  var e = N6(null);
  return e.options = Ho({ async: !0, ssr: !1 }, n), e;
}
var JP = function (n) {
  var e = n.sideCar, r = pd(n, ["sideCar"]);
  if (!e)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var o = e.read();
  if (!o)
    throw new Error("Sidecar medium not found");
  return D.createElement(o, Ho({}, r));
};
JP.isSideCarExport = !0;
function A6(n, e) {
  return n.useMedium(e), JP;
}
var ZP = j6(), EC = function () {
}, Tx = D.forwardRef(function (n, e) {
  var r = D.useRef(null), o = D.useState({
    onScrollCapture: EC,
    onWheelCapture: EC,
    onTouchMoveCapture: EC
  }), u = o[0], c = o[1], f = n.forwardProps, m = n.children, y = n.className, b = n.removeScrollBar, _ = n.enabled, T = n.shards, k = n.sideCar, C = n.noRelative, M = n.noIsolation, N = n.inert, A = n.allowPinchZoom, $ = n.as, I = $ === void 0 ? "div" : $, U = n.gapMode, B = pd(n, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noRelative", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), K = k, te = k6([r, e]), re = Ho(Ho({}, B), u);
  return D.createElement(
    D.Fragment,
    null,
    _ && D.createElement(K, { sideCar: ZP, removeScrollBar: b, shards: T, noRelative: C, noIsolation: M, inert: N, setCallbacks: c, allowPinchZoom: !!A, lockRef: r, gapMode: U }),
    f ? D.cloneElement(D.Children.only(m), Ho(Ho({}, re), { ref: te })) : D.createElement(I, Ho({}, re, { className: y, ref: te }), m)
  );
});
Tx.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
Tx.classNames = {
  fullWidth: Ww,
  zeroRight: Hw
};
var D6 = function () {
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function P6() {
  if (!document)
    return null;
  var n = document.createElement("style");
  n.type = "text/css";
  var e = D6();
  return e && n.setAttribute("nonce", e), n;
}
function M6(n, e) {
  n.styleSheet ? n.styleSheet.cssText = e : n.appendChild(document.createTextNode(e));
}
function L6(n) {
  var e = document.head || document.getElementsByTagName("head")[0];
  e.appendChild(n);
}
var I6 = function () {
  var n = 0, e = null;
  return {
    add: function (r) {
      n == 0 && (e = P6()) && (M6(e, r), L6(e)), n++;
    },
    remove: function () {
      n--, !n && e && (e.parentNode && e.parentNode.removeChild(e), e = null);
    }
  };
}, U6 = function () {
  var n = I6();
  return function (e, r) {
    D.useEffect(function () {
      return n.add(e), function () {
        n.remove();
      };
    }, [e && r]);
  };
}, XP = function () {
  var n = U6(), e = function (r) {
    var o = r.styles, u = r.dynamic;
    return n(o, u), null;
  };
  return e;
}, F6 = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
}, CC = function (n) {
  return parseInt(n || "", 10) || 0;
}, $6 = function (n) {
  var e = window.getComputedStyle(document.body), r = e[n === "padding" ? "paddingLeft" : "marginLeft"], o = e[n === "padding" ? "paddingTop" : "marginTop"], u = e[n === "padding" ? "paddingRight" : "marginRight"];
  return [CC(r), CC(o), CC(u)];
}, z6 = function (n) {
  if (n === void 0 && (n = "margin"), typeof window > "u")
    return F6;
  var e = $6(n), r = document.documentElement.clientWidth, o = window.innerWidth;
  return {
    left: e[0],
    top: e[1],
    right: e[2],
    gap: Math.max(0, o - r + e[2] - e[0])
  };
}, B6 = XP(), Xp = "data-scroll-locked", V6 = function (n, e, r, o) {
  var u = n.left, c = n.top, f = n.right, m = n.gap;
  return r === void 0 && (r = "margin"), `
  .`.concat(E6, ` {
   overflow: hidden `).concat(o, `;
   padding-right: `).concat(m, "px ").concat(o, `;
  }
  body[`).concat(Xp, `] {
    overflow: hidden `).concat(o, `;
    overscroll-behavior: contain;
    `).concat([
    e && "position: relative ".concat(o, ";"),
    r === "margin" && `
    padding-left: `.concat(u, `px;
    padding-top: `).concat(c, `px;
    padding-right: `).concat(f, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(m, "px ").concat(o, `;
    `),
    r === "padding" && "padding-right: ".concat(m, "px ").concat(o, ";")
  ].filter(Boolean).join(""), `
  }
  
  .`).concat(Hw, ` {
    right: `).concat(m, "px ").concat(o, `;
  }
  
  .`).concat(Ww, ` {
    margin-right: `).concat(m, "px ").concat(o, `;
  }
  
  .`).concat(Hw, " .").concat(Hw, ` {
    right: 0 `).concat(o, `;
  }
  
  .`).concat(Ww, " .").concat(Ww, ` {
    margin-right: 0 `).concat(o, `;
  }
  
  body[`).concat(Xp, `] {
    `).concat(C6, ": ").concat(m, `px;
  }
`);
}, wj = function () {
  var n = parseInt(document.body.getAttribute(Xp) || "0", 10);
  return isFinite(n) ? n : 0;
}, H6 = function () {
  D.useEffect(function () {
    return document.body.setAttribute(Xp, (wj() + 1).toString()), function () {
      var n = wj() - 1;
      n <= 0 ? document.body.removeAttribute(Xp) : document.body.setAttribute(Xp, n.toString());
    };
  }, []);
}, W6 = function (n) {
  var e = n.noRelative, r = n.noImportant, o = n.gapMode, u = o === void 0 ? "margin" : o;
  H6();
  var c = D.useMemo(function () {
    return z6(u);
  }, [u]);
  return D.createElement(B6, { styles: V6(c, !e, u, r ? "" : "!important") });
}, v1 = !1;
if (typeof window < "u")
  try {
    var Ew = Object.defineProperty({}, "passive", {
      get: function () {
        return v1 = !0, !0;
      }
    });
    window.addEventListener("test", Ew, Ew), window.removeEventListener("test", Ew, Ew);
  } catch {
    v1 = !1;
  }
var Fp = v1 ? { passive: !1 } : !1, q6 = function (n) {
  return n.tagName === "TEXTAREA";
}, eM = function (n, e) {
  if (!(n instanceof Element))
    return !1;
  var r = window.getComputedStyle(n);
  return (
    // not-not-scrollable
    r[e] !== "hidden" && // contains scroll inside self
    !(r.overflowY === r.overflowX && !q6(n) && r[e] === "visible")
  );
}, Y6 = function (n) {
  return eM(n, "overflowY");
}, K6 = function (n) {
  return eM(n, "overflowX");
}, xj = function (n, e) {
  var r = e.ownerDocument, o = e;
  do {
    typeof ShadowRoot < "u" && o instanceof ShadowRoot && (o = o.host);
    var u = tM(n, o);
    if (u) {
      var c = nM(n, o), f = c[1], m = c[2];
      if (f > m)
        return !0;
    }
    o = o.parentNode;
  } while (o && o !== r.body);
  return !1;
}, G6 = function (n) {
  var e = n.scrollTop, r = n.scrollHeight, o = n.clientHeight;
  return [
    e,
    r,
    o
  ];
}, Q6 = function (n) {
  var e = n.scrollLeft, r = n.scrollWidth, o = n.clientWidth;
  return [
    e,
    r,
    o
  ];
}, tM = function (n, e) {
  return n === "v" ? Y6(e) : K6(e);
}, nM = function (n, e) {
  return n === "v" ? G6(e) : Q6(e);
}, J6 = function (n, e) {
  return n === "h" && e === "rtl" ? -1 : 1;
}, Z6 = function (n, e, r, o, u) {
  var c = J6(n, window.getComputedStyle(e).direction), f = c * o, m = r.target, y = e.contains(m), b = !1, _ = f > 0, T = 0, k = 0;
  do {
    if (!m)
      break;
    var C = nM(n, m), M = C[0], N = C[1], A = C[2], $ = N - A - c * M;
    (M || $) && tM(n, m) && (T += $, k += M);
    var I = m.parentNode;
    m = I && I.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? I.host : I;
  } while (
    // portaled content
    !y && m !== document.body || // self content
    y && (e.contains(m) || e === m)
  );
  return (_ && (Math.abs(T) < 1 || !u) || !_ && (Math.abs(k) < 1 || !u)) && (b = !0), b;
}, Cw = function (n) {
  return "changedTouches" in n ? [n.changedTouches[0].clientX, n.changedTouches[0].clientY] : [0, 0];
}, Sj = function (n) {
  return [n.deltaX, n.deltaY];
}, _j = function (n) {
  return n && "current" in n ? n.current : n;
}, X6 = function (n, e) {
  return n[0] === e[0] && n[1] === e[1];
}, e8 = function (n) {
  return `
  .block-interactivity-`.concat(n, ` {pointer-events: none;}
  .allow-interactivity-`).concat(n, ` {pointer-events: all;}
`);
}, t8 = 0, $p = [];
function n8(n) {
  var e = D.useRef([]), r = D.useRef([0, 0]), o = D.useRef(), u = D.useState(t8++)[0], c = D.useState(XP)[0], f = D.useRef(n);
  D.useEffect(function () {
    f.current = n;
  }, [n]), D.useEffect(function () {
    if (n.inert) {
      document.body.classList.add("block-interactivity-".concat(u));
      var N = hT([n.lockRef.current], (n.shards || []).map(_j), !0).filter(Boolean);
      return N.forEach(function (A) {
        return A.classList.add("allow-interactivity-".concat(u));
      }), function () {
        document.body.classList.remove("block-interactivity-".concat(u)), N.forEach(function (A) {
          return A.classList.remove("allow-interactivity-".concat(u));
        });
      };
    }
  }, [n.inert, n.lockRef.current, n.shards]);
  var m = D.useCallback(function (N, A) {
    if ("touches" in N && N.touches.length === 2 || N.type === "wheel" && N.ctrlKey)
      return !f.current.allowPinchZoom;
    var $ = Cw(N), I = r.current, U = "deltaX" in N ? N.deltaX : I[0] - $[0], B = "deltaY" in N ? N.deltaY : I[1] - $[1], K, te = N.target, re = Math.abs(U) > Math.abs(B) ? "h" : "v";
    if ("touches" in N && re === "h" && te.type === "range")
      return !1;
    var ve = xj(re, te);
    if (!ve)
      return !0;
    if (ve ? K = re : (K = re === "v" ? "h" : "v", ve = xj(re, te)), !ve)
      return !1;
    if (!o.current && "changedTouches" in N && (U || B) && (o.current = K), !K)
      return !0;
    var Ce = o.current || K;
    return Z6(Ce, A, N, Ce === "h" ? U : B, !0);
  }, []), y = D.useCallback(function (N) {
    var A = N;
    if (!(!$p.length || $p[$p.length - 1] !== c)) {
      var $ = "deltaY" in A ? Sj(A) : Cw(A), I = e.current.filter(function (K) {
        return K.name === A.type && (K.target === A.target || A.target === K.shadowParent) && X6(K.delta, $);
      })[0];
      if (I && I.should) {
        A.cancelable && A.preventDefault();
        return;
      }
      if (!I) {
        var U = (f.current.shards || []).map(_j).filter(Boolean).filter(function (K) {
          return K.contains(A.target);
        }), B = U.length > 0 ? m(A, U[0]) : !f.current.noIsolation;
        B && A.cancelable && A.preventDefault();
      }
    }
  }, []), b = D.useCallback(function (N, A, $, I) {
    var U = { name: N, delta: A, target: $, should: I, shadowParent: r8($) };
    e.current.push(U), setTimeout(function () {
      e.current = e.current.filter(function (B) {
        return B !== U;
      });
    }, 1);
  }, []), _ = D.useCallback(function (N) {
    r.current = Cw(N), o.current = void 0;
  }, []), T = D.useCallback(function (N) {
    b(N.type, Sj(N), N.target, m(N, n.lockRef.current));
  }, []), k = D.useCallback(function (N) {
    b(N.type, Cw(N), N.target, m(N, n.lockRef.current));
  }, []);
  D.useEffect(function () {
    return $p.push(c), n.setCallbacks({
      onScrollCapture: T,
      onWheelCapture: T,
      onTouchMoveCapture: k
    }), document.addEventListener("wheel", y, Fp), document.addEventListener("touchmove", y, Fp), document.addEventListener("touchstart", _, Fp), function () {
      $p = $p.filter(function (N) {
        return N !== c;
      }), document.removeEventListener("wheel", y, Fp), document.removeEventListener("touchmove", y, Fp), document.removeEventListener("touchstart", _, Fp);
    };
  }, []);
  var C = n.removeScrollBar, M = n.inert;
  return D.createElement(
    D.Fragment,
    null,
    M ? D.createElement(c, { styles: e8(u) }) : null,
    C ? D.createElement(W6, { noRelative: n.noRelative, gapMode: n.gapMode }) : null
  );
}
function r8(n) {
  for (var e = null; n !== null;)
    n instanceof ShadowRoot && (e = n.host, n = n.host), n = n.parentNode;
  return e;
}
const a8 = A6(ZP, n8);
var rM = D.forwardRef(function (n, e) {
  return D.createElement(Tx, Ho({}, n, { ref: e, sideCar: a8 }));
});
rM.classNames = Tx.classNames;
var i8 = function (n) {
  if (typeof document > "u")
    return null;
  var e = Array.isArray(n) ? n[0] : n;
  return e.ownerDocument.body;
}, zp = /* @__PURE__ */ new WeakMap(), Tw = /* @__PURE__ */ new WeakMap(), Rw = {}, TC = 0, aM = function (n) {
  return n && (n.host || aM(n.parentNode));
}, o8 = function (n, e) {
  return e.map(function (r) {
    if (n.contains(r))
      return r;
    var o = aM(r);
    return o && n.contains(o) ? o : (console.error("aria-hidden", r, "in not contained inside", n, ". Doing nothing"), null);
  }).filter(function (r) {
    return !!r;
  });
}, s8 = function (n, e, r, o) {
  var u = o8(e, Array.isArray(n) ? n : [n]);
  Rw[r] || (Rw[r] = /* @__PURE__ */ new WeakMap());
  var c = Rw[r], f = [], m = /* @__PURE__ */ new Set(), y = new Set(u), b = function (T) {
    !T || m.has(T) || (m.add(T), b(T.parentNode));
  };
  u.forEach(b);
  var _ = function (T) {
    !T || y.has(T) || Array.prototype.forEach.call(T.children, function (k) {
      if (m.has(k))
        _(k);
      else
        try {
          var C = k.getAttribute(o), M = C !== null && C !== "false", N = (zp.get(k) || 0) + 1, A = (c.get(k) || 0) + 1;
          zp.set(k, N), c.set(k, A), f.push(k), N === 1 && M && Tw.set(k, !0), A === 1 && k.setAttribute(r, "true"), M || k.setAttribute(o, "true");
        } catch ($) {
          console.error("aria-hidden: cannot operate on ", k, $);
        }
    });
  };
  return _(e), m.clear(), TC++, function () {
    f.forEach(function (T) {
      var k = zp.get(T) - 1, C = c.get(T) - 1;
      zp.set(T, k), c.set(T, C), k || (Tw.has(T) || T.removeAttribute(o), Tw.delete(T)), C || T.removeAttribute(r);
    }), TC--, TC || (zp = /* @__PURE__ */ new WeakMap(), zp = /* @__PURE__ */ new WeakMap(), Tw = /* @__PURE__ */ new WeakMap(), Rw = {});
  };
}, l8 = function (n, e, r) {
  r === void 0 && (r = "data-aria-hidden");
  var o = Array.from(Array.isArray(n) ? n : [n]), u = i8(n);
  return u ? (o.push.apply(o, Array.from(u.querySelectorAll("[aria-live]"))), s8(o, u, r, "aria-hidden")) : function () {
    return null;
  };
}, Rx = "Dialog", [iM, iK] = Yf(Rx), [u8, Us] = iM(Rx), oM = (n) => {
  const {
    __scopeDialog: e,
    children: r,
    open: o,
    defaultOpen: u,
    onOpenChange: c,
    modal: f = !0
  } = n, m = D.useRef(null), y = D.useRef(null), [b, _] = mx({
    prop: o,
    defaultProp: u ?? !1,
    onChange: c,
    caller: Rx
  });
  return /* @__PURE__ */ x.jsx(
    u8,
    {
      scope: e,
      triggerRef: m,
      contentRef: y,
      contentId: Wg(),
      titleId: Wg(),
      descriptionId: Wg(),
      open: b,
      onOpenChange: _,
      onOpenToggle: D.useCallback(() => _((T) => !T), [_]),
      modal: f,
      children: r
    }
  );
};
oM.displayName = Rx;
var sM = "DialogTrigger", lM = D.forwardRef(
  (n, e) => {
    const { __scopeDialog: r, ...o } = n, u = Us(sM, r), c = pi(e, u.triggerRef);
    return /* @__PURE__ */ x.jsx(
      Zn.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": u.open,
        "aria-controls": u.contentId,
        "data-state": vT(u.open),
        ...o,
        ref: c,
        onClick: wn(n.onClick, u.onOpenToggle)
      }
    );
  }
);
lM.displayName = sM;
var pT = "DialogPortal", [c8, uM] = iM(pT, {
  forceMount: void 0
}), cM = (n) => {
  const { __scopeDialog: e, forceMount: r, children: o, container: u } = n, c = Us(pT, e);
  return /* @__PURE__ */ x.jsx(c8, { scope: e, forceMount: r, children: D.Children.map(o, (f) => /* @__PURE__ */ x.jsx(Kf, { present: r || c.open, children: /* @__PURE__ */ x.jsx(U1, { asChild: !0, container: u, children: f }) })) });
};
cM.displayName = pT;
var nx = "DialogOverlay", dM = D.forwardRef(
  (n, e) => {
    const r = uM(nx, n.__scopeDialog), { forceMount: o = r.forceMount, ...u } = n, c = Us(nx, n.__scopeDialog);
    return c.modal ? /* @__PURE__ */ x.jsx(Kf, { present: o || c.open, children: /* @__PURE__ */ x.jsx(f8, { ...u, ref: e }) }) : null;
  }
);
dM.displayName = nx;
var d8 = /* @__PURE__ */ Gg("DialogOverlay.RemoveScroll"), f8 = D.forwardRef(
  (n, e) => {
    const { __scopeDialog: r, ...o } = n, u = Us(nx, r);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      /* @__PURE__ */ x.jsx(rM, {
      as: d8, allowPinchZoom: !0, shards: [u.contentRef], children: /* @__PURE__ */ x.jsx(
        Zn.div,
        {
          "data-state": vT(u.open),
          ...o,
          ref: e,
          style: { pointerEvents: "auto", ...o.style }
        }
      )
    })
    );
  }
), Vf = "DialogContent", fM = D.forwardRef(
  (n, e) => {
    const r = uM(Vf, n.__scopeDialog), { forceMount: o = r.forceMount, ...u } = n, c = Us(Vf, n.__scopeDialog);
    return /* @__PURE__ */ x.jsx(Kf, { present: o || c.open, children: c.modal ? /* @__PURE__ */ x.jsx(h8, { ...u, ref: e }) : /* @__PURE__ */ x.jsx(p8, { ...u, ref: e }) });
  }
);
fM.displayName = Vf;
var h8 = D.forwardRef(
  (n, e) => {
    const r = Us(Vf, n.__scopeDialog), o = D.useRef(null), u = pi(e, r.contentRef, o);
    return D.useEffect(() => {
      const c = o.current;
      if (c) return l8(c);
    }, []), /* @__PURE__ */ x.jsx(
      hM,
      {
        ...n,
        ref: u,
        trapFocus: r.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: wn(n.onCloseAutoFocus, (c) => {
          var f;
          c.preventDefault(), (f = r.triggerRef.current) == null || f.focus();
        }),
        onPointerDownOutside: wn(n.onPointerDownOutside, (c) => {
          const f = c.detail.originalEvent, m = f.button === 0 && f.ctrlKey === !0;
          (f.button === 2 || m) && c.preventDefault();
        }),
        onFocusOutside: wn(
          n.onFocusOutside,
          (c) => c.preventDefault()
        )
      }
    );
  }
), p8 = D.forwardRef(
  (n, e) => {
    const r = Us(Vf, n.__scopeDialog), o = D.useRef(!1), u = D.useRef(!1);
    return /* @__PURE__ */ x.jsx(
      hM,
      {
        ...n,
        ref: e,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: (c) => {
          var f, m;
          (f = n.onCloseAutoFocus) == null || f.call(n, c), c.defaultPrevented || (o.current || (m = r.triggerRef.current) == null || m.focus(), c.preventDefault()), o.current = !1, u.current = !1;
        },
        onInteractOutside: (c) => {
          var y, b;
          (y = n.onInteractOutside) == null || y.call(n, c), c.defaultPrevented || (o.current = !0, c.detail.originalEvent.type === "pointerdown" && (u.current = !0));
          const f = c.target;
          ((b = r.triggerRef.current) == null ? void 0 : b.contains(f)) && c.preventDefault(), c.detail.originalEvent.type === "focusin" && u.current && c.preventDefault();
        }
      }
    );
  }
), hM = D.forwardRef(
  (n, e) => {
    const { __scopeDialog: r, trapFocus: o, onOpenAutoFocus: u, onCloseAutoFocus: c, ...f } = n, m = Us(Vf, r), y = D.useRef(null), b = pi(e, y);
    return b6(), /* @__PURE__ */ x.jsxs(x.Fragment, {
      children: [
      /* @__PURE__ */ x.jsx(
        CP,
        {
          asChild: !0,
          loop: !0,
          trapped: o,
          onMountAutoFocus: u,
          onUnmountAutoFocus: c,
          children: /* @__PURE__ */ x.jsx(
            px,
            {
              role: "dialog",
              id: m.contentId,
              "aria-describedby": m.descriptionId,
              "aria-labelledby": m.titleId,
              "data-state": vT(m.open),
              ...f,
              ref: b,
              onDismiss: () => m.onOpenChange(!1)
            }
          )
        }
      ),
      /* @__PURE__ */ x.jsxs(x.Fragment, {
        children: [
        /* @__PURE__ */ x.jsx(m8, { titleId: m.titleId }),
        /* @__PURE__ */ x.jsx(g8, { contentRef: y, descriptionId: m.descriptionId })
        ]
      })
      ]
    });
  }
), mT = "DialogTitle", pM = D.forwardRef(
  (n, e) => {
    const { __scopeDialog: r, ...o } = n, u = Us(mT, r);
    return /* @__PURE__ */ x.jsx(Zn.h2, { id: u.titleId, ...o, ref: e });
  }
);
pM.displayName = mT;
var mM = "DialogDescription", vM = D.forwardRef(
  (n, e) => {
    const { __scopeDialog: r, ...o } = n, u = Us(mM, r);
    return /* @__PURE__ */ x.jsx(Zn.p, { id: u.descriptionId, ...o, ref: e });
  }
);
vM.displayName = mM;
var gM = "DialogClose", yM = D.forwardRef(
  (n, e) => {
    const { __scopeDialog: r, ...o } = n, u = Us(gM, r);
    return /* @__PURE__ */ x.jsx(
      Zn.button,
      {
        type: "button",
        ...o,
        ref: e,
        onClick: wn(n.onClick, () => u.onOpenChange(!1))
      }
    );
  }
);
yM.displayName = gM;
function vT(n) {
  return n ? "open" : "closed";
}
var bM = "DialogTitleWarning", [oK, wM] = Zz(bM, {
  contentName: Vf,
  titleName: mT,
  docsSlug: "dialog"
}), m8 = ({ titleId: n }) => {
  const e = wM(bM), r = `\`${e.contentName}\` requires a \`${e.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${e.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${e.docsSlug}`;
  return D.useEffect(() => {
    n && (document.getElementById(n) || console.error(r));
  }, [r, n]), null;
}, v8 = "DialogDescriptionWarning", g8 = ({ contentRef: n, descriptionId: e }) => {
  const o = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${wM(v8).contentName}}.`;
  return D.useEffect(() => {
    var c;
    const u = (c = n.current) == null ? void 0 : c.getAttribute("aria-describedby");
    e && u && (document.getElementById(e) || console.warn(o));
  }, [o, n, e]), null;
}, xM = oM, SM = lM, _M = cM, kx = dM, Ox = fM, Nx = pM, jx = vM, EM = yM;
const CM = xM, TM = SM, y8 = _M, RM = D.forwardRef(({ className: n, ...e }, r) => /* @__PURE__ */ x.jsx(
  kx,
  {
    className: tn(
      "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      n
    ),
    ...e,
    ref: r
  }
));
RM.displayName = kx.displayName;
const b8 = gy(
  "fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
  {
    variants: {
      side: {
        top: "inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
        bottom: "inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
        left: "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
        right: "inset-y-0 right-0 h-full w-3/4  border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm"
      }
    },
    defaultVariants: {
      side: "right"
    }
  }
), gT = D.forwardRef(
  ({ side: n = "right", className: e, children: r, ...o }, u) => /* @__PURE__ */ x.jsxs(y8, {
    children: [
    /* @__PURE__ */ x.jsx(RM, {}),
    /* @__PURE__ */ x.jsxs(Ox, {
      ref: u, className: tn(b8({ side: n }), e), ...o, children: [
        r,
      /* @__PURE__ */ x.jsxs(EM, {
          className: "absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity data-[state=open]:bg-secondary hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none", children: [
        /* @__PURE__ */ x.jsx(H1, { className: "h-4 w-4" }),
        /* @__PURE__ */ x.jsx("span", { className: "sr-only", children: "Close" })
          ]
        })
      ]
    })
    ]
  })
);
gT.displayName = Ox.displayName;
const kM = ({ className: n, ...e }) => /* @__PURE__ */ x.jsx("div", { className: tn("flex flex-col space-y-2 text-center sm:text-left", n), ...e });
kM.displayName = "SheetHeader";
const OM = D.forwardRef(({ className: n, ...e }, r) => /* @__PURE__ */ x.jsx(Nx, { ref: r, className: tn("text-lg font-semibold text-foreground", n), ...e }));
OM.displayName = Nx.displayName;
const NM = D.forwardRef(({ className: n, ...e }, r) => /* @__PURE__ */ x.jsx(jx, { ref: r, className: tn("text-sm text-muted-foreground", n), ...e }));
NM.displayName = jx.displayName;
const w8 = gy(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default: "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary: "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive: "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
);
function yT({ className: n, variant: e, ...r }) {
  return /* @__PURE__ */ x.jsx("div", { className: tn(w8({ variant: e }), n), ...r });
}
const Ej = (n) => {
  let e;
  const r = /* @__PURE__ */ new Set(), o = (b, _) => {
    const T = typeof b == "function" ? b(e) : b;
    if (!Object.is(T, e)) {
      const k = e;
      e = _ ?? (typeof T != "object" || T === null) ? T : Object.assign({}, e, T), r.forEach((C) => C(e, k));
    }
  }, u = () => e, m = { setState: o, getState: u, getInitialState: () => y, subscribe: (b) => (r.add(b), () => r.delete(b)) }, y = e = n(o, u, m);
  return m;
}, x8 = (n) => n ? Ej(n) : Ej, S8 = (n) => n;
function _8(n, e = S8) {
  const r = Ae.useSyncExternalStore(
    n.subscribe,
    Ae.useCallback(() => e(n.getState()), [n, e]),
    Ae.useCallback(() => e(n.getInitialState()), [n, e])
  );
  return Ae.useDebugValue(r), r;
}
const E8 = (n) => {
  const e = x8(n), r = (o) => _8(e, o);
  return Object.assign(r, e), r;
}, C8 = (n) => E8;
function jM(n, e) {
  let r;
  try {
    r = n();
  } catch {
    return;
  }
  return {
    getItem: (u) => {
      var c;
      const f = (y) => y === null ? null : JSON.parse(y, void 0), m = (c = r.getItem(u)) != null ? c : null;
      return m instanceof Promise ? m.then(f) : f(m);
    },
    setItem: (u, c) => r.setItem(u, JSON.stringify(c, void 0)),
    removeItem: (u) => r.removeItem(u)
  };
}
const g1 = (n) => (e) => {
  try {
    const r = n(e);
    return r instanceof Promise ? r : {
      then(o) {
        return g1(o)(r);
      },
      catch(o) {
        return this;
      }
    };
  } catch (r) {
    return {
      then(o) {
        return this;
      },
      catch(o) {
        return g1(o)(r);
      }
    };
  }
}, T8 = (n, e) => (r, o, u) => {
  let c = {
    storage: jM(() => localStorage),
    partialize: (N) => N,
    version: 0,
    merge: (N, A) => ({
      ...A,
      ...N
    }),
    ...e
  }, f = !1;
  const m = /* @__PURE__ */ new Set(), y = /* @__PURE__ */ new Set();
  let b = c.storage;
  if (!b)
    return n(
      (...N) => {
        console.warn(
          `[zustand persist middleware] Unable to update item '${c.name}', the given storage is currently unavailable.`
        ), r(...N);
      },
      o,
      u
    );
  const _ = () => {
    const N = c.partialize({ ...o() });
    return b.setItem(c.name, {
      state: N,
      version: c.version
    });
  }, T = u.setState;
  u.setState = (N, A) => (T(N, A), _());
  const k = n(
    (...N) => (r(...N), _()),
    o,
    u
  );
  u.getInitialState = () => k;
  let C;
  const M = () => {
    var N, A;
    if (!b) return;
    f = !1, m.forEach((I) => {
      var U;
      return I((U = o()) != null ? U : k);
    });
    const $ = ((A = c.onRehydrateStorage) == null ? void 0 : A.call(c, (N = o()) != null ? N : k)) || void 0;
    return g1(b.getItem.bind(b))(c.name).then((I) => {
      if (I)
        if (typeof I.version == "number" && I.version !== c.version) {
          if (c.migrate) {
            const U = c.migrate(
              I.state,
              I.version
            );
            return U instanceof Promise ? U.then((B) => [!0, B]) : [!0, U];
          }
          console.error(
            "State loaded from storage couldn't be migrated since no migrate function was provided"
          );
        } else
          return [!1, I.state];
      return [!1, void 0];
    }).then((I) => {
      var U;
      const [B, K] = I;
      if (C = c.merge(
        K,
        (U = o()) != null ? U : k
      ), r(C, !0), B)
        return _();
    }).then(() => {
      $ == null || $(C, void 0), C = o(), f = !0, y.forEach((I) => I(C));
    }).catch((I) => {
      $ == null || $(void 0, I);
    });
  };
  return u.persist = {
    setOptions: (N) => {
      c = {
        ...c,
        ...N
      }, N.storage && (b = N.storage);
    },
    clearStorage: () => {
      b == null || b.removeItem(c.name);
    },
    getOptions: () => c,
    rehydrate: () => M(),
    hasHydrated: () => f,
    onHydrate: (N) => (m.add(N), () => {
      m.delete(N);
    }),
    onFinishHydration: (N) => (y.add(N), () => {
      y.delete(N);
    })
  }, c.skipHydration || M(), C || k;
}, R8 = T8, k8 = "2025-07", O8 = "belori-boutique-style-wnc7w.myshopify.com", N8 = `https://${O8}/api/${k8}/graphql.json`, j8 = "f9261efbff3cc511f0bbc740f924ea5a";
async function Sy(n, e = {}) {
  const r = await fetch(N8, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "X-Shopify-Storefront-Access-Token": j8
    },
    body: JSON.stringify({
      query: n,
      variables: e
    })
  });
  if (r.status === 402) {
    ya.error("Shopify: Pagamento necessrio", {
      description: "O acesso  API Shopify requer um plano de cobrana ativo. Visite admin.shopify.com para fazer upgrade."
    });
    return;
  }
  if (!r.ok)
    throw new Error(`HTTP error! status: ${r.status}`);
  const o = await r.json();
  if (o.errors)
    throw new Error(`Error calling Shopify: ${o.errors.map((u) => u.message).join(", ")}`);
  return o;
}
const bT = `
  query GetProducts($first: Int!) {
    products(first: $first) {
      edges {
        node {
          id
          title
          description
          handle
          priceRange {
            minVariantPrice {
              amount
              currencyCode
            }
          }
          images(first: 5) {
            edges {
              node {
                url
                altText
              }
            }
          }
          variants(first: 10) {
            edges {
              node {
                id
                title
                price {
                  amount
                  currencyCode
                }
                availableForSale
                selectedOptions {
                  name
                  value
                }
              }
            }
          }
          options {
            name
            values
          }
        }
      }
    }
  }
`, A8 = `
  mutation cartCreate($input: CartInput!) {
    cartCreate(input: $input) {
      cart {
        id
        checkoutUrl
        totalQuantity
        cost {
          totalAmount {
            amount
            currencyCode
          }
        }
        lines(first: 100) {
          edges {
            node {
              id
              quantity
              merchandise {
                ... on ProductVariant {
                  id
                  title
                  price {
                    amount
                    currencyCode
                  }
                  product {
                    title
                    handle
                  }
                }
              }
            }
          }
        }
      }
      userErrors {
        field
        message
      }
    }
  }
`;
async function D8(n) {
  try {
    const e = n.map((f) => ({
      quantity: f.quantity,
      merchandiseId: f.variantId
    })), r = await Sy(A8, {
      input: {
        lines: e
      }
    });
    if (r.data.cartCreate.userErrors.length > 0)
      throw new Error(`Cart creation failed: ${r.data.cartCreate.userErrors.map((f) => f.message).join(", ")}`);
    const o = r.data.cartCreate.cart;
    if (!o.checkoutUrl)
      throw new Error("No checkout URL returned from Shopify");
    const u = new URL(o.checkoutUrl);
    return u.searchParams.set("channel", "online_store"), u.toString();
  } catch (e) {
    throw console.error("Error creating storefront checkout:", e), e;
  }
}
const rx = C8()(
  R8(
    (n, e) => ({
      items: [],
      cartId: null,
      checkoutUrl: null,
      isLoading: !1,
      addItem: (r) => {
        const { items: o } = e(), u = o.find((c) => c.variantId === r.variantId);
        n(u ? {
          items: o.map(
            (c) => c.variantId === r.variantId ? { ...c, quantity: c.quantity + r.quantity } : c
          )
        } : { items: [...o, r] });
      },
      updateQuantity: (r, o) => {
        if (o <= 0) {
          e().removeItem(r);
          return;
        }
        n({
          items: e().items.map(
            (u) => u.variantId === r ? { ...u, quantity: o } : u
          )
        });
      },
      removeItem: (r) => {
        n({
          items: e().items.filter((o) => o.variantId !== r)
        });
      },
      clearCart: () => {
        n({ items: [], cartId: null, checkoutUrl: null });
      },
      setCartId: (r) => n({ cartId: r }),
      setCheckoutUrl: (r) => n({ checkoutUrl: r }),
      setLoading: (r) => n({ isLoading: r }),
      createCheckout: async () => {
        const { items: r, setLoading: o, setCheckoutUrl: u } = e();
        if (r.length !== 0) {
          o(!0);
          try {
            const c = await D8(r);
            u(c);
          } catch (c) {
            console.error("Failed to create checkout:", c);
          } finally {
            o(!1);
          }
        }
      }
    }),
    {
      name: "shopify-cart",
      storage: jM(() => localStorage)
    }
  )
), P8 = () => {
  const [n, e] = D.useState(!1), {
    items: r,
    isLoading: o,
    updateQuantity: u,
    removeItem: c,
    createCheckout: f
  } = rx(), m = r.reduce((_, T) => _ + T.quantity, 0), y = r.reduce((_, T) => _ + parseFloat(T.price.amount) * T.quantity, 0), b = async () => {
    try {
      await f();
      const _ = rx.getState().checkoutUrl;
      _ && (window.open(_, "_blank"), e(!1));
    } catch (_) {
      console.error("Checkout failed:", _);
    }
  };
  return /* @__PURE__ */ x.jsxs(CM, {
    open: n, onOpenChange: e, children: [
    /* @__PURE__ */ x.jsx(TM, {
      asChild: !0, children: /* @__PURE__ */ x.jsxs(Jn, {
        variant: "outline", size: "icon", className: "relative", children: [
      /* @__PURE__ */ x.jsx(vm, { className: "h-5 w-5" }),
          m > 0 && /* @__PURE__ */ x.jsx(yT, { className: "absolute -top-2 -right-2 h-5 w-5 rounded-full p-0 flex items-center justify-center text-xs bg-accent", children: m })
        ]
      })
    }),
    /* @__PURE__ */ x.jsxs(gT, {
      className: "w-full sm:max-w-lg flex flex-col h-full", children: [
      /* @__PURE__ */ x.jsxs(kM, {
        className: "flex-shrink-0", children: [
        /* @__PURE__ */ x.jsx(OM, { children: "Carrinho de Compras" }),
        /* @__PURE__ */ x.jsx(NM, { children: m === 0 ? "Seu carrinho est vazio" : `${m} ${m !== 1 ? "itens" : "item"} no carrinho` })
        ]
      }),
      /* @__PURE__ */ x.jsx("div", {
        className: "flex flex-col flex-1 pt-6 min-h-0", children: r.length === 0 ? /* @__PURE__ */ x.jsx("div", {
          className: "flex-1 flex items-center justify-center", children: /* @__PURE__ */ x.jsxs("div", {
            className: "text-center", children: [
        /* @__PURE__ */ x.jsx(vm, { className: "h-12 w-12 text-muted-foreground mx-auto mb-4" }),
        /* @__PURE__ */ x.jsx("p", { className: "text-muted-foreground", children: "Seu carrinho est vazio" })
            ]
          })
        }) : /* @__PURE__ */ x.jsxs(x.Fragment, {
          children: [
        /* @__PURE__ */ x.jsx("div", {
            className: "flex-1 overflow-y-auto pr-2 min-h-0", children: /* @__PURE__ */ x.jsx("div", {
              className: "space-y-4", children: r.map((_) => {
                var T, k, C;
                return /* @__PURE__ */ x.jsxs("div", {
                  className: "flex gap-4 p-2", children: [
            /* @__PURE__ */ x.jsx("div", {
                    className: "w-16 h-16 bg-secondary/20 rounded-md overflow-hidden flex-shrink-0", children: ((C = (k = (T = _.product.node.images) == null ? void 0 : T.edges) == null ? void 0 : k[0]) == null ? void 0 : C.node) && /* @__PURE__ */ x.jsx(
                      "img",
                      {
                        src: _.product.node.images.edges[0].node.url,
                        alt: _.product.node.title,
                        className: "w-full h-full object-cover"
                      }
                    )
                  }),
            /* @__PURE__ */ x.jsxs("div", {
                    className: "flex-1 min-w-0", children: [
              /* @__PURE__ */ x.jsx("h4", { className: "font-medium truncate", children: _.product.node.title }),
              /* @__PURE__ */ x.jsx("p", { className: "text-sm text-muted-foreground", children: _.selectedOptions.map((M) => M.value).join("  ") }),
              /* @__PURE__ */ x.jsx("p", { className: "font-semibold", children: Number(_.price.amount).toLocaleString("pt-BR", { style: "currency", currency: "BRL" }) })
                    ]
                  }),
            /* @__PURE__ */ x.jsxs("div", {
                    className: "flex flex-col items-end gap-2 flex-shrink-0", children: [
              /* @__PURE__ */ x.jsx(
                      Jn,
                      {
                        variant: "ghost",
                        size: "icon",
                        className: "h-6 w-6",
                        onClick: () => c(_.variantId),
                        children: /* @__PURE__ */ x.jsx(mD, { className: "h-3 w-3" })
                      }
                    ),
              /* @__PURE__ */ x.jsxs("div", {
                      className: "flex items-center gap-1", children: [
                /* @__PURE__ */ x.jsx(
                        Jn,
                        {
                          variant: "outline",
                          size: "icon",
                          className: "h-6 w-6",
                          onClick: () => u(_.variantId, _.quantity - 1),
                          children: /* @__PURE__ */ x.jsx(a3, { className: "h-3 w-3" })
                        }
                      ),
                /* @__PURE__ */ x.jsx("span", { className: "w-8 text-center text-sm", children: _.quantity }),
                /* @__PURE__ */ x.jsx(
                        Jn,
                        {
                          variant: "outline",
                          size: "icon",
                          className: "h-6 w-6",
                          onClick: () => u(_.variantId, _.quantity + 1),
                          children: /* @__PURE__ */ x.jsx(B1, { className: "h-3 w-3" })
                        }
                      )
                      ]
                    })
                    ]
                  })
                  ]
                }, _.variantId);
              })
            })
          }),
        /* @__PURE__ */ x.jsxs("div", {
            className: "flex-shrink-0 space-y-4 pt-4 border-t bg-background", children: [
          /* @__PURE__ */ x.jsxs("div", {
              className: "flex justify-between items-center", children: [
            /* @__PURE__ */ x.jsx("span", { className: "text-lg font-semibold", children: "Total" }),
            /* @__PURE__ */ x.jsx("span", { className: "text-xl font-bold", children: y.toLocaleString("pt-BR", { style: "currency", currency: "BRL" }) })
              ]
            }),
          /* @__PURE__ */ x.jsx(
              Jn,
              {
                onClick: b,
                className: "w-full",
                size: "lg",
                disabled: r.length === 0 || o,
                children: o ? /* @__PURE__ */ x.jsxs(x.Fragment, {
                  children: [
                /* @__PURE__ */ x.jsx(Ff, { className: "w-4 h-4 mr-2 animate-spin" }),
                    "Criando Checkout..."
                  ]
                }) : /* @__PURE__ */ x.jsxs(x.Fragment, {
                  children: [
                /* @__PURE__ */ x.jsx(hD, { className: "w-4 h-4 mr-2" }),
                    "Finalizar Compra"
                  ]
                })
              }
            )
            ]
          })
          ]
        })
      })
      ]
    })
    ]
  });
}, M8 = (n) => n ? (...e) => n(...e) : (...e) => fetch(...e);
class wT extends Error {
  constructor(e, r = "FunctionsError", o) {
    super(e), this.name = r, this.context = o;
  }
}
class Cj extends wT {
  constructor(e) {
    super("Failed to send a request to the Edge Function", "FunctionsFetchError", e);
  }
}
class Tj extends wT {
  constructor(e) {
    super("Relay Error invoking the Edge Function", "FunctionsRelayError", e);
  }
}
class Rj extends wT {
  constructor(e) {
    super("Edge Function returned a non-2xx status code", "FunctionsHttpError", e);
  }
}
var y1;
(function (n) {
  n.Any = "any", n.ApNortheast1 = "ap-northeast-1", n.ApNortheast2 = "ap-northeast-2", n.ApSouth1 = "ap-south-1", n.ApSoutheast1 = "ap-southeast-1", n.ApSoutheast2 = "ap-southeast-2", n.CaCentral1 = "ca-central-1", n.EuCentral1 = "eu-central-1", n.EuWest1 = "eu-west-1", n.EuWest2 = "eu-west-2", n.EuWest3 = "eu-west-3", n.SaEast1 = "sa-east-1", n.UsEast1 = "us-east-1", n.UsWest1 = "us-west-1", n.UsWest2 = "us-west-2";
})(y1 || (y1 = {}));
class L8 {
  constructor(e, { headers: r = {}, customFetch: o, region: u = y1.Any } = {}) {
    this.url = e, this.headers = r, this.region = u, this.fetch = M8(o);
  }
  /**
   * Updates the authorization header
   * @param token - the new jwt token sent in the authorisation header
   */
  setAuth(e) {
    this.headers.Authorization = `Bearer ${e}`;
  }
  /**
   * Invokes a function
   * @param functionName - The name of the Function to invoke.
   * @param options - Options for invoking the Function.
   */
  invoke(e) {
    return dt(this, arguments, void 0, function* (r, o = {}) {
      var u;
      try {
        const { headers: c, method: f, body: m, signal: y } = o;
        let b = {}, { region: _ } = o;
        _ || (_ = this.region);
        const T = new URL(`${this.url}/${r}`);
        _ && _ !== "any" && (b["x-region"] = _, T.searchParams.set("forceFunctionRegion", _));
        let k;
        m && (c && !Object.prototype.hasOwnProperty.call(c, "Content-Type") || !c) ? typeof Blob < "u" && m instanceof Blob || m instanceof ArrayBuffer ? (b["Content-Type"] = "application/octet-stream", k = m) : typeof m == "string" ? (b["Content-Type"] = "text/plain", k = m) : typeof FormData < "u" && m instanceof FormData ? k = m : (b["Content-Type"] = "application/json", k = JSON.stringify(m)) : k = m;
        const C = yield this.fetch(T.toString(), {
          method: f || "POST",
          // headers priority is (high to low):
          // 1. invoke-level headers
          // 2. client-level headers
          // 3. default Content-Type header
          headers: Object.assign(Object.assign(Object.assign({}, b), this.headers), c),
          body: k,
          signal: y
        }).catch(($) => {
          throw $.name === "AbortError" ? $ : new Cj($);
        }), M = C.headers.get("x-relay-error");
        if (M && M === "true")
          throw new Tj(C);
        if (!C.ok)
          throw new Rj(C);
        let N = ((u = C.headers.get("Content-Type")) !== null && u !== void 0 ? u : "text/plain").split(";")[0].trim(), A;
        return N === "application/json" ? A = yield C.json() : N === "application/octet-stream" || N === "application/pdf" ? A = yield C.blob() : N === "text/event-stream" ? A = C : N === "multipart/form-data" ? A = yield C.formData() : A = yield C.text(), { data: A, error: null, response: C };
      } catch (c) {
        return c instanceof Error && c.name === "AbortError" ? { data: null, error: new Cj(c) } : {
          data: null,
          error: c,
          response: c instanceof Rj || c instanceof Tj ? c.context : void 0
        };
      }
    });
  }
}
var Ni = {};
const jm = /* @__PURE__ */ Iz(_6);
var kw = {}, Ow = {}, Nw = {}, jw = {}, Aw = {}, Dw = {}, kj;
function AM() {
  if (kj) return Dw;
  kj = 1, Object.defineProperty(Dw, "__esModule", { value: !0 });
  class n extends Error {
    constructor(r) {
      super(r.message), this.name = "PostgrestError", this.details = r.details, this.hint = r.hint, this.code = r.code;
    }
  }
  return Dw.default = n, Dw;
}
var Oj;
function DM() {
  if (Oj) return Aw;
  Oj = 1, Object.defineProperty(Aw, "__esModule", { value: !0 });
  const e = jm.__importDefault(AM());
  class r {
    constructor(u) {
      var c, f;
      this.shouldThrowOnError = !1, this.method = u.method, this.url = u.url, this.headers = new Headers(u.headers), this.schema = u.schema, this.body = u.body, this.shouldThrowOnError = (c = u.shouldThrowOnError) !== null && c !== void 0 ? c : !1, this.signal = u.signal, this.isMaybeSingle = (f = u.isMaybeSingle) !== null && f !== void 0 ? f : !1, u.fetch ? this.fetch = u.fetch : this.fetch = fetch;
    }
    /**
     * If there's an error with the query, throwOnError will reject the promise by
     * throwing the error instead of returning it as part of a successful response.
     *
     * {@link https://github.com/supabase/supabase-js/issues/92}
     */
    throwOnError() {
      return this.shouldThrowOnError = !0, this;
    }
    /**
     * Set an HTTP header for the request.
     */
    setHeader(u, c) {
      return this.headers = new Headers(this.headers), this.headers.set(u, c), this;
    }
    then(u, c) {
      this.schema === void 0 || (["GET", "HEAD"].includes(this.method) ? this.headers.set("Accept-Profile", this.schema) : this.headers.set("Content-Profile", this.schema)), this.method !== "GET" && this.method !== "HEAD" && this.headers.set("Content-Type", "application/json");
      const f = this.fetch;
      let m = f(this.url.toString(), {
        method: this.method,
        headers: this.headers,
        body: JSON.stringify(this.body),
        signal: this.signal
      }).then(async (y) => {
        var b, _, T, k;
        let C = null, M = null, N = null, A = y.status, $ = y.statusText;
        if (y.ok) {
          if (this.method !== "HEAD") {
            const K = await y.text();
            K === "" || (this.headers.get("Accept") === "text/csv" || this.headers.get("Accept") && (!((b = this.headers.get("Accept")) === null || b === void 0) && b.includes("application/vnd.pgrst.plan+text")) ? M = K : M = JSON.parse(K));
          }
          const U = (_ = this.headers.get("Prefer")) === null || _ === void 0 ? void 0 : _.match(/count=(exact|planned|estimated)/), B = (T = y.headers.get("content-range")) === null || T === void 0 ? void 0 : T.split("/");
          U && B && B.length > 1 && (N = parseInt(B[1])), this.isMaybeSingle && this.method === "GET" && Array.isArray(M) && (M.length > 1 ? (C = {
            // https://github.com/PostgREST/postgrest/blob/a867d79c42419af16c18c3fb019eba8df992626f/src/PostgREST/Error.hs#L553
            code: "PGRST116",
            details: `Results contain ${M.length} rows, application/vnd.pgrst.object+json requires 1 row`,
            hint: null,
            message: "JSON object requested, multiple (or no) rows returned"
          }, M = null, N = null, A = 406, $ = "Not Acceptable") : M.length === 1 ? M = M[0] : M = null);
        } else {
          const U = await y.text();
          try {
            C = JSON.parse(U), Array.isArray(C) && y.status === 404 && (M = [], C = null, A = 200, $ = "OK");
          } catch {
            y.status === 404 && U === "" ? (A = 204, $ = "No Content") : C = {
              message: U
            };
          }
          if (C && this.isMaybeSingle && (!((k = C == null ? void 0 : C.details) === null || k === void 0) && k.includes("0 rows")) && (C = null, A = 200, $ = "OK"), C && this.shouldThrowOnError)
            throw new e.default(C);
        }
        return {
          error: C,
          data: M,
          count: N,
          status: A,
          statusText: $
        };
      });
      return this.shouldThrowOnError || (m = m.catch((y) => {
        var b, _, T;
        return {
          error: {
            message: `${(b = y == null ? void 0 : y.name) !== null && b !== void 0 ? b : "FetchError"}: ${y == null ? void 0 : y.message}`,
            details: `${(_ = y == null ? void 0 : y.stack) !== null && _ !== void 0 ? _ : ""}`,
            hint: "",
            code: `${(T = y == null ? void 0 : y.code) !== null && T !== void 0 ? T : ""}`
          },
          data: null,
          count: null,
          status: 0,
          statusText: ""
        };
      })), m.then(u, c);
    }
    /**
     * Override the type of the returned `data`.
     *
     * @typeParam NewResult - The new result type to override with
     * @deprecated Use overrideTypes<yourType, { merge: false }>() method at the end of your call chain instead
     */
    returns() {
      return this;
    }
    /**
     * Override the type of the returned `data` field in the response.
     *
     * @typeParam NewResult - The new type to cast the response data to
     * @typeParam Options - Optional type configuration (defaults to { merge: true })
     * @typeParam Options.merge - When true, merges the new type with existing return type. When false, replaces the existing types entirely (defaults to true)
     * @example
     * ```typescript
     * // Merge with existing types (default behavior)
     * const query = supabase
     *   .from('users')
     *   .select()
     *   .overrideTypes<{ custom_field: string }>()
     *
     * // Replace existing types completely
     * const replaceQuery = supabase
     *   .from('users')
     *   .select()
     *   .overrideTypes<{ id: number; name: string }, { merge: false }>()
     * ```
     * @returns A PostgrestBuilder instance with the new type
     */
    overrideTypes() {
      return this;
    }
  }
  return Aw.default = r, Aw;
}
var Nj;
function PM() {
  if (Nj) return jw;
  Nj = 1, Object.defineProperty(jw, "__esModule", { value: !0 });
  const e = jm.__importDefault(DM());
  class r extends e.default {
    /**
     * Perform a SELECT on the query result.
     *
     * By default, `.insert()`, `.update()`, `.upsert()`, and `.delete()` do not
     * return modified rows. By calling this method, modified rows are returned in
     * `data`.
     *
     * @param columns - The columns to retrieve, separated by commas
     */
    select(u) {
      let c = !1;
      const f = (u ?? "*").split("").map((m) => /\s/.test(m) && !c ? "" : (m === '"' && (c = !c), m)).join("");
      return this.url.searchParams.set("select", f), this.headers.append("Prefer", "return=representation"), this;
    }
    /**
     * Order the query result by `column`.
     *
     * You can call this method multiple times to order by multiple columns.
     *
     * You can order referenced tables, but it only affects the ordering of the
     * parent table if you use `!inner` in the query.
     *
     * @param column - The column to order by
     * @param options - Named parameters
     * @param options.ascending - If `true`, the result will be in ascending order
     * @param options.nullsFirst - If `true`, `null`s appear first. If `false`,
     * `null`s appear last.
     * @param options.referencedTable - Set this to order a referenced table by
     * its columns
     * @param options.foreignTable - Deprecated, use `options.referencedTable`
     * instead
     */
    order(u, { ascending: c = !0, nullsFirst: f, foreignTable: m, referencedTable: y = m } = {}) {
      const b = y ? `${y}.order` : "order", _ = this.url.searchParams.get(b);
      return this.url.searchParams.set(b, `${_ ? `${_},` : ""}${u}.${c ? "asc" : "desc"}${f === void 0 ? "" : f ? ".nullsfirst" : ".nullslast"}`), this;
    }
    /**
     * Limit the query result by `count`.
     *
     * @param count - The maximum number of rows to return
     * @param options - Named parameters
     * @param options.referencedTable - Set this to limit rows of referenced
     * tables instead of the parent table
     * @param options.foreignTable - Deprecated, use `options.referencedTable`
     * instead
     */
    limit(u, { foreignTable: c, referencedTable: f = c } = {}) {
      const m = typeof f > "u" ? "limit" : `${f}.limit`;
      return this.url.searchParams.set(m, `${u}`), this;
    }
    /**
     * Limit the query result by starting at an offset `from` and ending at the offset `to`.
     * Only records within this range are returned.
     * This respects the query order and if there is no order clause the range could behave unexpectedly.
     * The `from` and `to` values are 0-based and inclusive: `range(1, 3)` will include the second, third
     * and fourth rows of the query.
     *
     * @param from - The starting index from which to limit the result
     * @param to - The last index to which to limit the result
     * @param options - Named parameters
     * @param options.referencedTable - Set this to limit rows of referenced
     * tables instead of the parent table
     * @param options.foreignTable - Deprecated, use `options.referencedTable`
     * instead
     */
    range(u, c, { foreignTable: f, referencedTable: m = f } = {}) {
      const y = typeof m > "u" ? "offset" : `${m}.offset`, b = typeof m > "u" ? "limit" : `${m}.limit`;
      return this.url.searchParams.set(y, `${u}`), this.url.searchParams.set(b, `${c - u + 1}`), this;
    }
    /**
     * Set the AbortSignal for the fetch request.
     *
     * @param signal - The AbortSignal to use for the fetch request
     */
    abortSignal(u) {
      return this.signal = u, this;
    }
    /**
     * Return `data` as a single object instead of an array of objects.
     *
     * Query result must be one row (e.g. using `.limit(1)`), otherwise this
     * returns an error.
     */
    single() {
      return this.headers.set("Accept", "application/vnd.pgrst.object+json"), this;
    }
    /**
     * Return `data` as a single object instead of an array of objects.
     *
     * Query result must be zero or one row (e.g. using `.limit(1)`), otherwise
     * this returns an error.
     */
    maybeSingle() {
      return this.method === "GET" ? this.headers.set("Accept", "application/json") : this.headers.set("Accept", "application/vnd.pgrst.object+json"), this.isMaybeSingle = !0, this;
    }
    /**
     * Return `data` as a string in CSV format.
     */
    csv() {
      return this.headers.set("Accept", "text/csv"), this;
    }
    /**
     * Return `data` as an object in [GeoJSON](https://geojson.org) format.
     */
    geojson() {
      return this.headers.set("Accept", "application/geo+json"), this;
    }
    /**
     * Return `data` as the EXPLAIN plan for the query.
     *
     * You need to enable the
     * [db_plan_enabled](https://supabase.com/docs/guides/database/debugging-performance#enabling-explain)
     * setting before using this method.
     *
     * @param options - Named parameters
     *
     * @param options.analyze - If `true`, the query will be executed and the
     * actual run time will be returned
     *
     * @param options.verbose - If `true`, the query identifier will be returned
     * and `data` will include the output columns of the query
     *
     * @param options.settings - If `true`, include information on configuration
     * parameters that affect query planning
     *
     * @param options.buffers - If `true`, include information on buffer usage
     *
     * @param options.wal - If `true`, include information on WAL record generation
     *
     * @param options.format - The format of the output, can be `"text"` (default)
     * or `"json"`
     */
    explain({ analyze: u = !1, verbose: c = !1, settings: f = !1, buffers: m = !1, wal: y = !1, format: b = "text" } = {}) {
      var _;
      const T = [
        u ? "analyze" : null,
        c ? "verbose" : null,
        f ? "settings" : null,
        m ? "buffers" : null,
        y ? "wal" : null
      ].filter(Boolean).join("|"), k = (_ = this.headers.get("Accept")) !== null && _ !== void 0 ? _ : "application/json";
      return this.headers.set("Accept", `application/vnd.pgrst.plan+${b}; for="${k}"; options=${T};`), b === "json" ? this : this;
    }
    /**
     * Rollback the query.
     *
     * `data` will still be returned, but the query is not committed.
     */
    rollback() {
      return this.headers.append("Prefer", "tx=rollback"), this;
    }
    /**
     * Override the type of the returned `data`.
     *
     * @typeParam NewResult - The new result type to override with
     * @deprecated Use overrideTypes<yourType, { merge: false }>() method at the end of your call chain instead
     */
    returns() {
      return this;
    }
    /**
     * Set the maximum number of rows that can be affected by the query.
     * Only available in PostgREST v13+ and only works with PATCH and DELETE methods.
     *
     * @param value - The maximum number of rows that can be affected
     */
    maxAffected(u) {
      return this.headers.append("Prefer", "handling=strict"), this.headers.append("Prefer", `max-affected=${u}`), this;
    }
  }
  return jw.default = r, jw;
}
var jj;
function xT() {
  if (jj) return Nw;
  jj = 1, Object.defineProperty(Nw, "__esModule", { value: !0 });
  const e = jm.__importDefault(PM()), r = new RegExp("[,()]");
  class o extends e.default {
    /**
     * Match only rows where `column` is equal to `value`.
     *
     * To check if the value of `column` is NULL, you should use `.is()` instead.
     *
     * @param column - The column to filter on
     * @param value - The value to filter with
     */
    eq(c, f) {
      return this.url.searchParams.append(c, `eq.${f}`), this;
    }
    /**
     * Match only rows where `column` is not equal to `value`.
     *
     * @param column - The column to filter on
     * @param value - The value to filter with
     */
    neq(c, f) {
      return this.url.searchParams.append(c, `neq.${f}`), this;
    }
    /**
     * Match only rows where `column` is greater than `value`.
     *
     * @param column - The column to filter on
     * @param value - The value to filter with
     */
    gt(c, f) {
      return this.url.searchParams.append(c, `gt.${f}`), this;
    }
    /**
     * Match only rows where `column` is greater than or equal to `value`.
     *
     * @param column - The column to filter on
     * @param value - The value to filter with
     */
    gte(c, f) {
      return this.url.searchParams.append(c, `gte.${f}`), this;
    }
    /**
     * Match only rows where `column` is less than `value`.
     *
     * @param column - The column to filter on
     * @param value - The value to filter with
     */
    lt(c, f) {
      return this.url.searchParams.append(c, `lt.${f}`), this;
    }
    /**
     * Match only rows where `column` is less than or equal to `value`.
     *
     * @param column - The column to filter on
     * @param value - The value to filter with
     */
    lte(c, f) {
      return this.url.searchParams.append(c, `lte.${f}`), this;
    }
    /**
     * Match only rows where `column` matches `pattern` case-sensitively.
     *
     * @param column - The column to filter on
     * @param pattern - The pattern to match with
     */
    like(c, f) {
      return this.url.searchParams.append(c, `like.${f}`), this;
    }
    /**
     * Match only rows where `column` matches all of `patterns` case-sensitively.
     *
     * @param column - The column to filter on
     * @param patterns - The patterns to match with
     */
    likeAllOf(c, f) {
      return this.url.searchParams.append(c, `like(all).{${f.join(",")}}`), this;
    }
    /**
     * Match only rows where `column` matches any of `patterns` case-sensitively.
     *
     * @param column - The column to filter on
     * @param patterns - The patterns to match with
     */
    likeAnyOf(c, f) {
      return this.url.searchParams.append(c, `like(any).{${f.join(",")}}`), this;
    }
    /**
     * Match only rows where `column` matches `pattern` case-insensitively.
     *
     * @param column - The column to filter on
     * @param pattern - The pattern to match with
     */
    ilike(c, f) {
      return this.url.searchParams.append(c, `ilike.${f}`), this;
    }
    /**
     * Match only rows where `column` matches all of `patterns` case-insensitively.
     *
     * @param column - The column to filter on
     * @param patterns - The patterns to match with
     */
    ilikeAllOf(c, f) {
      return this.url.searchParams.append(c, `ilike(all).{${f.join(",")}}`), this;
    }
    /**
     * Match only rows where `column` matches any of `patterns` case-insensitively.
     *
     * @param column - The column to filter on
     * @param patterns - The patterns to match with
     */
    ilikeAnyOf(c, f) {
      return this.url.searchParams.append(c, `ilike(any).{${f.join(",")}}`), this;
    }
    /**
     * Match only rows where `column` IS `value`.
     *
     * For non-boolean columns, this is only relevant for checking if the value of
     * `column` is NULL by setting `value` to `null`.
     *
     * For boolean columns, you can also set `value` to `true` or `false` and it
     * will behave the same way as `.eq()`.
     *
     * @param column - The column to filter on
     * @param value - The value to filter with
     */
    is(c, f) {
      return this.url.searchParams.append(c, `is.${f}`), this;
    }
    /**
     * Match only rows where `column` is included in the `values` array.
     *
     * @param column - The column to filter on
     * @param values - The values array to filter with
     */
    in(c, f) {
      const m = Array.from(new Set(f)).map((y) => typeof y == "string" && r.test(y) ? `"${y}"` : `${y}`).join(",");
      return this.url.searchParams.append(c, `in.(${m})`), this;
    }
    /**
     * Only relevant for jsonb, array, and range columns. Match only rows where
     * `column` contains every element appearing in `value`.
     *
     * @param column - The jsonb, array, or range column to filter on
     * @param value - The jsonb, array, or range value to filter with
     */
    contains(c, f) {
      return typeof f == "string" ? this.url.searchParams.append(c, `cs.${f}`) : Array.isArray(f) ? this.url.searchParams.append(c, `cs.{${f.join(",")}}`) : this.url.searchParams.append(c, `cs.${JSON.stringify(f)}`), this;
    }
    /**
     * Only relevant for jsonb, array, and range columns. Match only rows where
     * every element appearing in `column` is contained by `value`.
     *
     * @param column - The jsonb, array, or range column to filter on
     * @param value - The jsonb, array, or range value to filter with
     */
    containedBy(c, f) {
      return typeof f == "string" ? this.url.searchParams.append(c, `cd.${f}`) : Array.isArray(f) ? this.url.searchParams.append(c, `cd.{${f.join(",")}}`) : this.url.searchParams.append(c, `cd.${JSON.stringify(f)}`), this;
    }
    /**
     * Only relevant for range columns. Match only rows where every element in
     * `column` is greater than any element in `range`.
     *
     * @param column - The range column to filter on
     * @param range - The range to filter with
     */
    rangeGt(c, f) {
      return this.url.searchParams.append(c, `sr.${f}`), this;
    }
    /**
     * Only relevant for range columns. Match only rows where every element in
     * `column` is either contained in `range` or greater than any element in
     * `range`.
     *
     * @param column - The range column to filter on
     * @param range - The range to filter with
     */
    rangeGte(c, f) {
      return this.url.searchParams.append(c, `nxl.${f}`), this;
    }
    /**
     * Only relevant for range columns. Match only rows where every element in
     * `column` is less than any element in `range`.
     *
     * @param column - The range column to filter on
     * @param range - The range to filter with
     */
    rangeLt(c, f) {
      return this.url.searchParams.append(c, `sl.${f}`), this;
    }
    /**
     * Only relevant for range columns. Match only rows where every element in
     * `column` is either contained in `range` or less than any element in
     * `range`.
     *
     * @param column - The range column to filter on
     * @param range - The range to filter with
     */
    rangeLte(c, f) {
      return this.url.searchParams.append(c, `nxr.${f}`), this;
    }
    /**
     * Only relevant for range columns. Match only rows where `column` is
     * mutually exclusive to `range` and there can be no element between the two
     * ranges.
     *
     * @param column - The range column to filter on
     * @param range - The range to filter with
     */
    rangeAdjacent(c, f) {
      return this.url.searchParams.append(c, `adj.${f}`), this;
    }
    /**
     * Only relevant for array and range columns. Match only rows where
     * `column` and `value` have an element in common.
     *
     * @param column - The array or range column to filter on
     * @param value - The array or range value to filter with
     */
    overlaps(c, f) {
      return typeof f == "string" ? this.url.searchParams.append(c, `ov.${f}`) : this.url.searchParams.append(c, `ov.{${f.join(",")}}`), this;
    }
    /**
     * Only relevant for text and tsvector columns. Match only rows where
     * `column` matches the query string in `query`.
     *
     * @param column - The text or tsvector column to filter on
     * @param query - The query text to match with
     * @param options - Named parameters
     * @param options.config - The text search configuration to use
     * @param options.type - Change how the `query` text is interpreted
     */
    textSearch(c, f, { config: m, type: y } = {}) {
      let b = "";
      y === "plain" ? b = "pl" : y === "phrase" ? b = "ph" : y === "websearch" && (b = "w");
      const _ = m === void 0 ? "" : `(${m})`;
      return this.url.searchParams.append(c, `${b}fts${_}.${f}`), this;
    }
    /**
     * Match only rows where each column in `query` keys is equal to its
     * associated value. Shorthand for multiple `.eq()`s.
     *
     * @param query - The object to filter with, with column names as keys mapped
     * to their filter values
     */
    match(c) {
      return Object.entries(c).forEach(([f, m]) => {
        this.url.searchParams.append(f, `eq.${m}`);
      }), this;
    }
    /**
     * Match only rows which doesn't satisfy the filter.
     *
     * Unlike most filters, `opearator` and `value` are used as-is and need to
     * follow [PostgREST
     * syntax](https://postgrest.org/en/stable/api.html#operators). You also need
     * to make sure they are properly sanitized.
     *
     * @param column - The column to filter on
     * @param operator - The operator to be negated to filter with, following
     * PostgREST syntax
     * @param value - The value to filter with, following PostgREST syntax
     */
    not(c, f, m) {
      return this.url.searchParams.append(c, `not.${f}.${m}`), this;
    }
    /**
     * Match only rows which satisfy at least one of the filters.
     *
     * Unlike most filters, `filters` is used as-is and needs to follow [PostgREST
     * syntax](https://postgrest.org/en/stable/api.html#operators). You also need
     * to make sure it's properly sanitized.
     *
     * It's currently not possible to do an `.or()` filter across multiple tables.
     *
     * @param filters - The filters to use, following PostgREST syntax
     * @param options - Named parameters
     * @param options.referencedTable - Set this to filter on referenced tables
     * instead of the parent table
     * @param options.foreignTable - Deprecated, use `referencedTable` instead
     */
    or(c, { foreignTable: f, referencedTable: m = f } = {}) {
      const y = m ? `${m}.or` : "or";
      return this.url.searchParams.append(y, `(${c})`), this;
    }
    /**
     * Match only rows which satisfy the filter. This is an escape hatch - you
     * should use the specific filter methods wherever possible.
     *
     * Unlike most filters, `opearator` and `value` are used as-is and need to
     * follow [PostgREST
     * syntax](https://postgrest.org/en/stable/api.html#operators). You also need
     * to make sure they are properly sanitized.
     *
     * @param column - The column to filter on
     * @param operator - The operator to filter with, following PostgREST syntax
     * @param value - The value to filter with, following PostgREST syntax
     */
    filter(c, f, m) {
      return this.url.searchParams.append(c, `${f}.${m}`), this;
    }
  }
  return Nw.default = o, Nw;
}
var Aj;
function MM() {
  if (Aj) return Ow;
  Aj = 1, Object.defineProperty(Ow, "__esModule", { value: !0 });
  const e = jm.__importDefault(xT());
  class r {
    constructor(u, { headers: c = {}, schema: f, fetch: m }) {
      this.url = u, this.headers = new Headers(c), this.schema = f, this.fetch = m;
    }
    /**
     * Perform a SELECT query on the table or view.
     *
     * @param columns - The columns to retrieve, separated by commas. Columns can be renamed when returned with `customName:columnName`
     *
     * @param options - Named parameters
     *
     * @param options.head - When set to `true`, `data` will not be returned.
     * Useful if you only need the count.
     *
     * @param options.count - Count algorithm to use to count rows in the table or view.
     *
     * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
     * hood.
     *
     * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
     * statistics under the hood.
     *
     * `"estimated"`: Uses exact count for low numbers and planned count for high
     * numbers.
     */
    select(u, c) {
      const { head: f = !1, count: m } = c ?? {}, y = f ? "HEAD" : "GET";
      let b = !1;
      const _ = (u ?? "*").split("").map((T) => /\s/.test(T) && !b ? "" : (T === '"' && (b = !b), T)).join("");
      return this.url.searchParams.set("select", _), m && this.headers.append("Prefer", `count=${m}`), new e.default({
        method: y,
        url: this.url,
        headers: this.headers,
        schema: this.schema,
        fetch: this.fetch
      });
    }
    /**
     * Perform an INSERT into the table or view.
     *
     * By default, inserted rows are not returned. To return it, chain the call
     * with `.select()`.
     *
     * @param values - The values to insert. Pass an object to insert a single row
     * or an array to insert multiple rows.
     *
     * @param options - Named parameters
     *
     * @param options.count - Count algorithm to use to count inserted rows.
     *
     * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
     * hood.
     *
     * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
     * statistics under the hood.
     *
     * `"estimated"`: Uses exact count for low numbers and planned count for high
     * numbers.
     *
     * @param options.defaultToNull - Make missing fields default to `null`.
     * Otherwise, use the default value for the column. Only applies for bulk
     * inserts.
     */
    insert(u, { count: c, defaultToNull: f = !0 } = {}) {
      var m;
      const y = "POST";
      if (c && this.headers.append("Prefer", `count=${c}`), f || this.headers.append("Prefer", "missing=default"), Array.isArray(u)) {
        const b = u.reduce((_, T) => _.concat(Object.keys(T)), []);
        if (b.length > 0) {
          const _ = [...new Set(b)].map((T) => `"${T}"`);
          this.url.searchParams.set("columns", _.join(","));
        }
      }
      return new e.default({
        method: y,
        url: this.url,
        headers: this.headers,
        schema: this.schema,
        body: u,
        fetch: (m = this.fetch) !== null && m !== void 0 ? m : fetch
      });
    }
    /**
     * Perform an UPSERT on the table or view. Depending on the column(s) passed
     * to `onConflict`, `.upsert()` allows you to perform the equivalent of
     * `.insert()` if a row with the corresponding `onConflict` columns doesn't
     * exist, or if it does exist, perform an alternative action depending on
     * `ignoreDuplicates`.
     *
     * By default, upserted rows are not returned. To return it, chain the call
     * with `.select()`.
     *
     * @param values - The values to upsert with. Pass an object to upsert a
     * single row or an array to upsert multiple rows.
     *
     * @param options - Named parameters
     *
     * @param options.onConflict - Comma-separated UNIQUE column(s) to specify how
     * duplicate rows are determined. Two rows are duplicates if all the
     * `onConflict` columns are equal.
     *
     * @param options.ignoreDuplicates - If `true`, duplicate rows are ignored. If
     * `false`, duplicate rows are merged with existing rows.
     *
     * @param options.count - Count algorithm to use to count upserted rows.
     *
     * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
     * hood.
     *
     * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
     * statistics under the hood.
     *
     * `"estimated"`: Uses exact count for low numbers and planned count for high
     * numbers.
     *
     * @param options.defaultToNull - Make missing fields default to `null`.
     * Otherwise, use the default value for the column. This only applies when
     * inserting new rows, not when merging with existing rows under
     * `ignoreDuplicates: false`. This also only applies when doing bulk upserts.
     */
    upsert(u, { onConflict: c, ignoreDuplicates: f = !1, count: m, defaultToNull: y = !0 } = {}) {
      var b;
      const _ = "POST";
      if (this.headers.append("Prefer", `resolution=${f ? "ignore" : "merge"}-duplicates`), c !== void 0 && this.url.searchParams.set("on_conflict", c), m && this.headers.append("Prefer", `count=${m}`), y || this.headers.append("Prefer", "missing=default"), Array.isArray(u)) {
        const T = u.reduce((k, C) => k.concat(Object.keys(C)), []);
        if (T.length > 0) {
          const k = [...new Set(T)].map((C) => `"${C}"`);
          this.url.searchParams.set("columns", k.join(","));
        }
      }
      return new e.default({
        method: _,
        url: this.url,
        headers: this.headers,
        schema: this.schema,
        body: u,
        fetch: (b = this.fetch) !== null && b !== void 0 ? b : fetch
      });
    }
    /**
     * Perform an UPDATE on the table or view.
     *
     * By default, updated rows are not returned. To return it, chain the call
     * with `.select()` after filters.
     *
     * @param values - The values to update with
     *
     * @param options - Named parameters
     *
     * @param options.count - Count algorithm to use to count updated rows.
     *
     * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
     * hood.
     *
     * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
     * statistics under the hood.
     *
     * `"estimated"`: Uses exact count for low numbers and planned count for high
     * numbers.
     */
    update(u, { count: c } = {}) {
      var f;
      const m = "PATCH";
      return c && this.headers.append("Prefer", `count=${c}`), new e.default({
        method: m,
        url: this.url,
        headers: this.headers,
        schema: this.schema,
        body: u,
        fetch: (f = this.fetch) !== null && f !== void 0 ? f : fetch
      });
    }
    /**
     * Perform a DELETE on the table or view.
     *
     * By default, deleted rows are not returned. To return it, chain the call
     * with `.select()` after filters.
     *
     * @param options - Named parameters
     *
     * @param options.count - Count algorithm to use to count deleted rows.
     *
     * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
     * hood.
     *
     * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
     * statistics under the hood.
     *
     * `"estimated"`: Uses exact count for low numbers and planned count for high
     * numbers.
     */
    delete({ count: u } = {}) {
      var c;
      const f = "DELETE";
      return u && this.headers.append("Prefer", `count=${u}`), new e.default({
        method: f,
        url: this.url,
        headers: this.headers,
        schema: this.schema,
        fetch: (c = this.fetch) !== null && c !== void 0 ? c : fetch
      });
    }
  }
  return Ow.default = r, Ow;
}
var Dj;
function I8() {
  if (Dj) return kw;
  Dj = 1, Object.defineProperty(kw, "__esModule", { value: !0 });
  const n = jm, e = n.__importDefault(MM()), r = n.__importDefault(xT());
  class o {
    // TODO: Add back shouldThrowOnError once we figure out the typings
    /**
     * Creates a PostgREST client.
     *
     * @param url - URL of the PostgREST endpoint
     * @param options - Named parameters
     * @param options.headers - Custom headers
     * @param options.schema - Postgres schema to switch to
     * @param options.fetch - Custom fetch
     */
    constructor(c, { headers: f = {}, schema: m, fetch: y } = {}) {
      this.url = c, this.headers = new Headers(f), this.schemaName = m, this.fetch = y;
    }
    /**
     * Perform a query on a table or a view.
     *
     * @param relation - The table or view name to query
     */
    from(c) {
      const f = new URL(`${this.url}/${c}`);
      return new e.default(f, {
        headers: new Headers(this.headers),
        schema: this.schemaName,
        fetch: this.fetch
      });
    }
    /**
     * Select a schema to query or perform an function (rpc) call.
     *
     * The schema needs to be on the list of exposed schemas inside Supabase.
     *
     * @param schema - The schema to query
     */
    schema(c) {
      return new o(this.url, {
        headers: this.headers,
        schema: c,
        fetch: this.fetch
      });
    }
    /**
     * Perform a function call.
     *
     * @param fn - The function name to call
     * @param args - The arguments to pass to the function call
     * @param options - Named parameters
     * @param options.head - When set to `true`, `data` will not be returned.
     * Useful if you only need the count.
     * @param options.get - When set to `true`, the function will be called with
     * read-only access mode.
     * @param options.count - Count algorithm to use to count rows returned by the
     * function. Only applicable for [set-returning
     * functions](https://www.postgresql.org/docs/current/functions-srf.html).
     *
     * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
     * hood.
     *
     * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
     * statistics under the hood.
     *
     * `"estimated"`: Uses exact count for low numbers and planned count for high
     * numbers.
     */
    rpc(c, f = {}, { head: m = !1, get: y = !1, count: b } = {}) {
      var _;
      let T;
      const k = new URL(`${this.url}/rpc/${c}`);
      let C;
      m || y ? (T = m ? "HEAD" : "GET", Object.entries(f).filter(([N, A]) => A !== void 0).map(([N, A]) => [N, Array.isArray(A) ? `{${A.join(",")}}` : `${A}`]).forEach(([N, A]) => {
        k.searchParams.append(N, A);
      })) : (T = "POST", C = f);
      const M = new Headers(this.headers);
      return b && M.set("Prefer", `count=${b}`), new r.default({
        method: T,
        url: k,
        headers: M,
        schema: this.schemaName,
        body: C,
        fetch: (_ = this.fetch) !== null && _ !== void 0 ? _ : fetch
      });
    }
  }
  return kw.default = o, kw;
}
Object.defineProperty(Ni, "__esModule", { value: !0 });
var LM = Ni.PostgrestError = qM = Ni.PostgrestBuilder = HM = Ni.PostgrestTransformBuilder = BM = Ni.PostgrestFilterBuilder = $M = Ni.PostgrestQueryBuilder = UM = Ni.PostgrestClient = void 0;
const Am = jm, IM = Am.__importDefault(I8());
var UM = Ni.PostgrestClient = IM.default;
const FM = Am.__importDefault(MM());
var $M = Ni.PostgrestQueryBuilder = FM.default;
const zM = Am.__importDefault(xT());
var BM = Ni.PostgrestFilterBuilder = zM.default;
const VM = Am.__importDefault(PM());
var HM = Ni.PostgrestTransformBuilder = VM.default;
const WM = Am.__importDefault(DM());
var qM = Ni.PostgrestBuilder = WM.default;
const YM = Am.__importDefault(AM());
LM = Ni.PostgrestError = YM.default;
var KM = Ni.default = {
  PostgrestClient: IM.default,
  PostgrestQueryBuilder: FM.default,
  PostgrestFilterBuilder: zM.default,
  PostgrestTransformBuilder: VM.default,
  PostgrestBuilder: WM.default,
  PostgrestError: YM.default
};
const U8 = /* @__PURE__ */ DA({
  __proto__: null,
  get PostgrestBuilder() {
    return qM;
  },
  get PostgrestClient() {
    return UM;
  },
  get PostgrestError() {
    return LM;
  },
  get PostgrestFilterBuilder() {
    return BM;
  },
  get PostgrestQueryBuilder() {
    return $M;
  },
  get PostgrestTransformBuilder() {
    return HM;
  },
  default: KM
}, [Ni]), {
  PostgrestClient: F8,
  PostgrestQueryBuilder: sK,
  PostgrestFilterBuilder: lK,
  PostgrestTransformBuilder: uK,
  PostgrestBuilder: cK,
  PostgrestError: dK
} = KM || U8;
class $8 {
  static detectEnvironment() {
    var e;
    if (typeof WebSocket < "u")
      return { type: "native", constructor: WebSocket };
    if (typeof globalThis < "u" && typeof globalThis.WebSocket < "u")
      return { type: "native", constructor: globalThis.WebSocket };
    if (typeof global < "u" && typeof global.WebSocket < "u")
      return { type: "native", constructor: global.WebSocket };
    if (typeof globalThis < "u" && typeof globalThis.WebSocketPair < "u" && typeof globalThis.WebSocket > "u")
      return {
        type: "cloudflare",
        error: "Cloudflare Workers detected. WebSocket clients are not supported in Cloudflare Workers.",
        workaround: "Use Cloudflare Workers WebSocket API for server-side WebSocket handling, or deploy to a different runtime."
      };
    if (typeof globalThis < "u" && globalThis.EdgeRuntime || typeof navigator < "u" && (!((e = navigator.userAgent) === null || e === void 0) && e.includes("Vercel-Edge")))
      return {
        type: "unsupported",
        error: "Edge runtime detected (Vercel Edge/Netlify Edge). WebSockets are not supported in edge functions.",
        workaround: "Use serverless functions or a different deployment target for WebSocket functionality."
      };
    if (typeof process < "u") {
      const r = process.versions;
      if (r && r.node) {
        const o = r.node, u = parseInt(o.replace(/^v/, "").split(".")[0]);
        return u >= 22 ? typeof globalThis.WebSocket < "u" ? { type: "native", constructor: globalThis.WebSocket } : {
          type: "unsupported",
          error: `Node.js ${u} detected but native WebSocket not found.`,
          workaround: "Provide a WebSocket implementation via the transport option."
        } : {
          type: "unsupported",
          error: `Node.js ${u} detected without native WebSocket support.`,
          workaround: `For Node.js < 22, install "ws" package and provide it via the transport option:
import ws from "ws"
new RealtimeClient(url, { transport: ws })`
        };
      }
    }
    return {
      type: "unsupported",
      error: "Unknown JavaScript runtime without WebSocket support.",
      workaround: "Ensure you're running in a supported environment (browser, Node.js, Deno) or provide a custom WebSocket implementation."
    };
  }
  static getWebSocketConstructor() {
    const e = this.detectEnvironment();
    if (e.constructor)
      return e.constructor;
    let r = e.error || "WebSocket not supported in this environment.";
    throw e.workaround && (r += `

Suggested solution: ${e.workaround}`), new Error(r);
  }
  static createWebSocket(e, r) {
    const o = this.getWebSocketConstructor();
    return new o(e, r);
  }
  static isWebSocketSupported() {
    try {
      const e = this.detectEnvironment();
      return e.type === "native" || e.type === "ws";
    } catch {
      return !1;
    }
  }
}
const z8 = "2.80.0", B8 = `realtime-js/${z8}`, V8 = "1.0.0", b1 = 1e4, H8 = 1e3, W8 = 100;
var qg;
(function (n) {
  n[n.connecting = 0] = "connecting", n[n.open = 1] = "open", n[n.closing = 2] = "closing", n[n.closed = 3] = "closed";
})(qg || (qg = {}));
var ga;
(function (n) {
  n.closed = "closed", n.errored = "errored", n.joined = "joined", n.joining = "joining", n.leaving = "leaving";
})(ga || (ga = {}));
var js;
(function (n) {
  n.close = "phx_close", n.error = "phx_error", n.join = "phx_join", n.reply = "phx_reply", n.leave = "phx_leave", n.access_token = "access_token";
})(js || (js = {}));
var w1;
(function (n) {
  n.websocket = "websocket";
})(w1 || (w1 = {}));
var Rf;
(function (n) {
  n.Connecting = "connecting", n.Open = "open", n.Closing = "closing", n.Closed = "closed";
})(Rf || (Rf = {}));
class q8 {
  constructor() {
    this.HEADER_LENGTH = 1;
  }
  decode(e, r) {
    return e.constructor === ArrayBuffer ? r(this._binaryDecode(e)) : r(typeof e == "string" ? JSON.parse(e) : {});
  }
  _binaryDecode(e) {
    const r = new DataView(e), o = new TextDecoder();
    return this._decodeBroadcast(e, r, o);
  }
  _decodeBroadcast(e, r, o) {
    const u = r.getUint8(1), c = r.getUint8(2);
    let f = this.HEADER_LENGTH + 2;
    const m = o.decode(e.slice(f, f + u));
    f = f + u;
    const y = o.decode(e.slice(f, f + c));
    f = f + c;
    const b = JSON.parse(o.decode(e.slice(f, e.byteLength)));
    return { ref: null, topic: m, event: y, payload: b };
  }
}
class GM {
  constructor(e, r) {
    this.callback = e, this.timerCalc = r, this.timer = void 0, this.tries = 0, this.callback = e, this.timerCalc = r;
  }
  reset() {
    this.tries = 0, clearTimeout(this.timer), this.timer = void 0;
  }
  // Cancels any previous scheduleTimeout and schedules callback
  scheduleTimeout() {
    clearTimeout(this.timer), this.timer = setTimeout(() => {
      this.tries = this.tries + 1, this.callback();
    }, this.timerCalc(this.tries + 1));
  }
}
var rr;
(function (n) {
  n.abstime = "abstime", n.bool = "bool", n.date = "date", n.daterange = "daterange", n.float4 = "float4", n.float8 = "float8", n.int2 = "int2", n.int4 = "int4", n.int4range = "int4range", n.int8 = "int8", n.int8range = "int8range", n.json = "json", n.jsonb = "jsonb", n.money = "money", n.numeric = "numeric", n.oid = "oid", n.reltime = "reltime", n.text = "text", n.time = "time", n.timestamp = "timestamp", n.timestamptz = "timestamptz", n.timetz = "timetz", n.tsrange = "tsrange", n.tstzrange = "tstzrange";
})(rr || (rr = {}));
const Pj = (n, e, r = {}) => {
  var o;
  const u = (o = r.skipTypes) !== null && o !== void 0 ? o : [];
  return e ? Object.keys(e).reduce((c, f) => (c[f] = Y8(f, n, e, u), c), {}) : {};
}, Y8 = (n, e, r, o) => {
  const u = e.find((m) => m.name === n), c = u == null ? void 0 : u.type, f = r[n];
  return c && !o.includes(c) ? QM(c, f) : x1(f);
}, QM = (n, e) => {
  if (n.charAt(0) === "_") {
    const r = n.slice(1, n.length);
    return J8(e, r);
  }
  switch (n) {
    case rr.bool:
      return K8(e);
    case rr.float4:
    case rr.float8:
    case rr.int2:
    case rr.int4:
    case rr.int8:
    case rr.numeric:
    case rr.oid:
      return G8(e);
    case rr.json:
    case rr.jsonb:
      return Q8(e);
    case rr.timestamp:
      return Z8(e);
    case rr.abstime:
    case rr.date:
    case rr.daterange:
    case rr.int4range:
    case rr.int8range:
    case rr.money:
    case rr.reltime:
    case rr.text:
    case rr.time:
    case rr.timestamptz:
    case rr.timetz:
    case rr.tsrange:
    case rr.tstzrange:
      return x1(e);
    default:
      return x1(e);
  }
}, x1 = (n) => n, K8 = (n) => {
  switch (n) {
    case "t":
      return !0;
    case "f":
      return !1;
    default:
      return n;
  }
}, G8 = (n) => {
  if (typeof n == "string") {
    const e = parseFloat(n);
    if (!Number.isNaN(e))
      return e;
  }
  return n;
}, Q8 = (n) => {
  if (typeof n == "string")
    try {
      return JSON.parse(n);
    } catch (e) {
      return console.log(`JSON parse error: ${e}`), n;
    }
  return n;
}, J8 = (n, e) => {
  if (typeof n != "string")
    return n;
  const r = n.length - 1, o = n[r];
  if (n[0] === "{" && o === "}") {
    let c;
    const f = n.slice(1, r);
    try {
      c = JSON.parse("[" + f + "]");
    } catch {
      c = f ? f.split(",") : [];
    }
    return c.map((m) => QM(e, m));
  }
  return n;
}, Z8 = (n) => typeof n == "string" ? n.replace(" ", "T") : n, JM = (n) => {
  const e = new URL(n);
  return e.protocol = e.protocol.replace(/^ws/i, "http"), e.pathname = e.pathname.replace(/\/+$/, "").replace(/\/socket\/websocket$/i, "").replace(/\/socket$/i, "").replace(/\/websocket$/i, ""), e.pathname === "" || e.pathname === "/" ? e.pathname = "/api/broadcast" : e.pathname = e.pathname + "/api/broadcast", e.href;
};
class RC {
  /**
   * Initializes the Push
   *
   * @param channel The Channel
   * @param event The event, for example `"phx_join"`
   * @param payload The payload, for example `{user_id: 123}`
   * @param timeout The push timeout in milliseconds
   */
  constructor(e, r, o = {}, u = b1) {
    this.channel = e, this.event = r, this.payload = o, this.timeout = u, this.sent = !1, this.timeoutTimer = void 0, this.ref = "", this.receivedResp = null, this.recHooks = [], this.refEvent = null;
  }
  resend(e) {
    this.timeout = e, this._cancelRefEvent(), this.ref = "", this.refEvent = null, this.receivedResp = null, this.sent = !1, this.send();
  }
  send() {
    this._hasReceived("timeout") || (this.startTimeout(), this.sent = !0, this.channel.socket.push({
      topic: this.channel.topic,
      event: this.event,
      payload: this.payload,
      ref: this.ref,
      join_ref: this.channel._joinRef()
    }));
  }
  updatePayload(e) {
    this.payload = Object.assign(Object.assign({}, this.payload), e);
  }
  receive(e, r) {
    var o;
    return this._hasReceived(e) && r((o = this.receivedResp) === null || o === void 0 ? void 0 : o.response), this.recHooks.push({ status: e, callback: r }), this;
  }
  startTimeout() {
    if (this.timeoutTimer)
      return;
    this.ref = this.channel.socket._makeRef(), this.refEvent = this.channel._replyEventName(this.ref);
    const e = (r) => {
      this._cancelRefEvent(), this._cancelTimeout(), this.receivedResp = r, this._matchReceive(r);
    };
    this.channel._on(this.refEvent, {}, e), this.timeoutTimer = setTimeout(() => {
      this.trigger("timeout", {});
    }, this.timeout);
  }
  trigger(e, r) {
    this.refEvent && this.channel._trigger(this.refEvent, { status: e, response: r });
  }
  destroy() {
    this._cancelRefEvent(), this._cancelTimeout();
  }
  _cancelRefEvent() {
    this.refEvent && this.channel._off(this.refEvent, {});
  }
  _cancelTimeout() {
    clearTimeout(this.timeoutTimer), this.timeoutTimer = void 0;
  }
  _matchReceive({ status: e, response: r }) {
    this.recHooks.filter((o) => o.status === e).forEach((o) => o.callback(r));
  }
  _hasReceived(e) {
    return this.receivedResp && this.receivedResp.status === e;
  }
}
var Mj;
(function (n) {
  n.SYNC = "sync", n.JOIN = "join", n.LEAVE = "leave";
})(Mj || (Mj = {}));
class Yg {
  /**
   * Initializes the Presence.
   *
   * @param channel - The RealtimeChannel
   * @param opts - The options,
   *        for example `{events: {state: 'state', diff: 'diff'}}`
   */
  constructor(e, r) {
    this.channel = e, this.state = {}, this.pendingDiffs = [], this.joinRef = null, this.enabled = !1, this.caller = {
      onJoin: () => {
      },
      onLeave: () => {
      },
      onSync: () => {
      }
    };
    const o = (r == null ? void 0 : r.events) || {
      state: "presence_state",
      diff: "presence_diff"
    };
    this.channel._on(o.state, {}, (u) => {
      const { onJoin: c, onLeave: f, onSync: m } = this.caller;
      this.joinRef = this.channel._joinRef(), this.state = Yg.syncState(this.state, u, c, f), this.pendingDiffs.forEach((y) => {
        this.state = Yg.syncDiff(this.state, y, c, f);
      }), this.pendingDiffs = [], m();
    }), this.channel._on(o.diff, {}, (u) => {
      const { onJoin: c, onLeave: f, onSync: m } = this.caller;
      this.inPendingSyncState() ? this.pendingDiffs.push(u) : (this.state = Yg.syncDiff(this.state, u, c, f), m());
    }), this.onJoin((u, c, f) => {
      this.channel._trigger("presence", {
        event: "join",
        key: u,
        currentPresences: c,
        newPresences: f
      });
    }), this.onLeave((u, c, f) => {
      this.channel._trigger("presence", {
        event: "leave",
        key: u,
        currentPresences: c,
        leftPresences: f
      });
    }), this.onSync(() => {
      this.channel._trigger("presence", { event: "sync" });
    });
  }
  /**
   * Used to sync the list of presences on the server with the
   * client's state.
   *
   * An optional `onJoin` and `onLeave` callback can be provided to
   * react to changes in the client's local presences across
   * disconnects and reconnects with the server.
   *
   * @internal
   */
  static syncState(e, r, o, u) {
    const c = this.cloneDeep(e), f = this.transformState(r), m = {}, y = {};
    return this.map(c, (b, _) => {
      f[b] || (y[b] = _);
    }), this.map(f, (b, _) => {
      const T = c[b];
      if (T) {
        const k = _.map((A) => A.presence_ref), C = T.map((A) => A.presence_ref), M = _.filter((A) => C.indexOf(A.presence_ref) < 0), N = T.filter((A) => k.indexOf(A.presence_ref) < 0);
        M.length > 0 && (m[b] = M), N.length > 0 && (y[b] = N);
      } else
        m[b] = _;
    }), this.syncDiff(c, { joins: m, leaves: y }, o, u);
  }
  /**
   * Used to sync a diff of presence join and leave events from the
   * server, as they happen.
   *
   * Like `syncState`, `syncDiff` accepts optional `onJoin` and
   * `onLeave` callbacks to react to a user joining or leaving from a
   * device.
   *
   * @internal
   */
  static syncDiff(e, r, o, u) {
    const { joins: c, leaves: f } = {
      joins: this.transformState(r.joins),
      leaves: this.transformState(r.leaves)
    };
    return o || (o = () => {
    }), u || (u = () => {
    }), this.map(c, (m, y) => {
      var b;
      const _ = (b = e[m]) !== null && b !== void 0 ? b : [];
      if (e[m] = this.cloneDeep(y), _.length > 0) {
        const T = e[m].map((C) => C.presence_ref), k = _.filter((C) => T.indexOf(C.presence_ref) < 0);
        e[m].unshift(...k);
      }
      o(m, _, y);
    }), this.map(f, (m, y) => {
      let b = e[m];
      if (!b)
        return;
      const _ = y.map((T) => T.presence_ref);
      b = b.filter((T) => _.indexOf(T.presence_ref) < 0), e[m] = b, u(m, b, y), b.length === 0 && delete e[m];
    }), e;
  }
  /** @internal */
  static map(e, r) {
    return Object.getOwnPropertyNames(e).map((o) => r(o, e[o]));
  }
  /**
   * Remove 'metas' key
   * Change 'phx_ref' to 'presence_ref'
   * Remove 'phx_ref' and 'phx_ref_prev'
   *
   * @example
   * // returns {
   *  abc123: [
   *    { presence_ref: '2', user_id: 1 },
   *    { presence_ref: '3', user_id: 2 }
   *  ]
   * }
   * RealtimePresence.transformState({
   *  abc123: {
   *    metas: [
   *      { phx_ref: '2', phx_ref_prev: '1' user_id: 1 },
   *      { phx_ref: '3', user_id: 2 }
   *    ]
   *  }
   * })
   *
   * @internal
   */
  static transformState(e) {
    return e = this.cloneDeep(e), Object.getOwnPropertyNames(e).reduce((r, o) => {
      const u = e[o];
      return "metas" in u ? r[o] = u.metas.map((c) => (c.presence_ref = c.phx_ref, delete c.phx_ref, delete c.phx_ref_prev, c)) : r[o] = u, r;
    }, {});
  }
  /** @internal */
  static cloneDeep(e) {
    return JSON.parse(JSON.stringify(e));
  }
  /** @internal */
  onJoin(e) {
    this.caller.onJoin = e;
  }
  /** @internal */
  onLeave(e) {
    this.caller.onLeave = e;
  }
  /** @internal */
  onSync(e) {
    this.caller.onSync = e;
  }
  /** @internal */
  inPendingSyncState() {
    return !this.joinRef || this.joinRef !== this.channel._joinRef();
  }
}
var Lj;
(function (n) {
  n.ALL = "*", n.INSERT = "INSERT", n.UPDATE = "UPDATE", n.DELETE = "DELETE";
})(Lj || (Lj = {}));
var Kg;
(function (n) {
  n.BROADCAST = "broadcast", n.PRESENCE = "presence", n.POSTGRES_CHANGES = "postgres_changes", n.SYSTEM = "system";
})(Kg || (Kg = {}));
var wu;
(function (n) {
  n.SUBSCRIBED = "SUBSCRIBED", n.TIMED_OUT = "TIMED_OUT", n.CLOSED = "CLOSED", n.CHANNEL_ERROR = "CHANNEL_ERROR";
})(wu || (wu = {}));
class ST {
  constructor(e, r = { config: {} }, o) {
    var u, c;
    if (this.topic = e, this.params = r, this.socket = o, this.bindings = {}, this.state = ga.closed, this.joinedOnce = !1, this.pushBuffer = [], this.subTopic = e.replace(/^realtime:/i, ""), this.params.config = Object.assign({
      broadcast: { ack: !1, self: !1 },
      presence: { key: "", enabled: !1 },
      private: !1
    }, r.config), this.timeout = this.socket.timeout, this.joinPush = new RC(this, js.join, this.params, this.timeout), this.rejoinTimer = new GM(() => this._rejoinUntilConnected(), this.socket.reconnectAfterMs), this.joinPush.receive("ok", () => {
      this.state = ga.joined, this.rejoinTimer.reset(), this.pushBuffer.forEach((f) => f.send()), this.pushBuffer = [];
    }), this._onClose(() => {
      this.rejoinTimer.reset(), this.socket.log("channel", `close ${this.topic} ${this._joinRef()}`), this.state = ga.closed, this.socket._remove(this);
    }), this._onError((f) => {
      this._isLeaving() || this._isClosed() || (this.socket.log("channel", `error ${this.topic}`, f), this.state = ga.errored, this.rejoinTimer.scheduleTimeout());
    }), this.joinPush.receive("timeout", () => {
      this._isJoining() && (this.socket.log("channel", `timeout ${this.topic}`, this.joinPush.timeout), this.state = ga.errored, this.rejoinTimer.scheduleTimeout());
    }), this.joinPush.receive("error", (f) => {
      this._isLeaving() || this._isClosed() || (this.socket.log("channel", `error ${this.topic}`, f), this.state = ga.errored, this.rejoinTimer.scheduleTimeout());
    }), this._on(js.reply, {}, (f, m) => {
      this._trigger(this._replyEventName(m), f);
    }), this.presence = new Yg(this), this.broadcastEndpointURL = JM(this.socket.endPoint), this.private = this.params.config.private || !1, !this.private && (!((c = (u = this.params.config) === null || u === void 0 ? void 0 : u.broadcast) === null || c === void 0) && c.replay))
      throw `tried to use replay on public channel '${this.topic}'. It must be a private channel.`;
  }
  /** Subscribe registers your client with the server */
  subscribe(e, r = this.timeout) {
    var o, u, c;
    if (this.socket.isConnected() || this.socket.connect(), this.state == ga.closed) {
      const { config: { broadcast: f, presence: m, private: y } } = this.params, b = (u = (o = this.bindings.postgres_changes) === null || o === void 0 ? void 0 : o.map((C) => C.filter)) !== null && u !== void 0 ? u : [], _ = !!this.bindings[Kg.PRESENCE] && this.bindings[Kg.PRESENCE].length > 0 || ((c = this.params.config.presence) === null || c === void 0 ? void 0 : c.enabled) === !0, T = {}, k = {
        broadcast: f,
        presence: Object.assign(Object.assign({}, m), { enabled: _ }),
        postgres_changes: b,
        private: y
      };
      this.socket.accessTokenValue && (T.access_token = this.socket.accessTokenValue), this._onError((C) => e == null ? void 0 : e(wu.CHANNEL_ERROR, C)), this._onClose(() => e == null ? void 0 : e(wu.CLOSED)), this.updateJoinPayload(Object.assign({ config: k }, T)), this.joinedOnce = !0, this._rejoin(r), this.joinPush.receive("ok", async ({ postgres_changes: C }) => {
        var M;
        if (this.socket.setAuth(), C === void 0) {
          e == null || e(wu.SUBSCRIBED);
          return;
        } else {
          const N = this.bindings.postgres_changes, A = (M = N == null ? void 0 : N.length) !== null && M !== void 0 ? M : 0, $ = [];
          for (let I = 0; I < A; I++) {
            const U = N[I], { filter: { event: B, schema: K, table: te, filter: re } } = U, ve = C && C[I];
            if (ve && ve.event === B && ve.schema === K && ve.table === te && ve.filter === re)
              $.push(Object.assign(Object.assign({}, U), { id: ve.id }));
            else {
              this.unsubscribe(), this.state = ga.errored, e == null || e(wu.CHANNEL_ERROR, new Error("mismatch between server and client bindings for postgres changes"));
              return;
            }
          }
          this.bindings.postgres_changes = $, e && e(wu.SUBSCRIBED);
          return;
        }
      }).receive("error", (C) => {
        this.state = ga.errored, e == null || e(wu.CHANNEL_ERROR, new Error(JSON.stringify(Object.values(C).join(", ") || "error")));
      }).receive("timeout", () => {
        e == null || e(wu.TIMED_OUT);
      });
    }
    return this;
  }
  presenceState() {
    return this.presence.state;
  }
  async track(e, r = {}) {
    return await this.send({
      type: "presence",
      event: "track",
      payload: e
    }, r.timeout || this.timeout);
  }
  async untrack(e = {}) {
    return await this.send({
      type: "presence",
      event: "untrack"
    }, e);
  }
  on(e, r, o) {
    return this.state === ga.joined && e === Kg.PRESENCE && (this.socket.log("channel", `resubscribe to ${this.topic} due to change in presence callbacks on joined channel`), this.unsubscribe().then(() => this.subscribe())), this._on(e, r, o);
  }
  /**
   * Sends a broadcast message explicitly via REST API.
   *
   * This method always uses the REST API endpoint regardless of WebSocket connection state.
   * Useful when you want to guarantee REST delivery or when gradually migrating from implicit REST fallback.
   *
   * @param event The name of the broadcast event
   * @param payload Payload to be sent (required)
   * @param opts Options including timeout
   * @returns Promise resolving to object with success status, and error details if failed
   */
  async httpSend(e, r, o = {}) {
    var u;
    const c = this.socket.accessTokenValue ? `Bearer ${this.socket.accessTokenValue}` : "";
    if (r == null)
      return Promise.reject("Payload is required for httpSend()");
    const f = {
      method: "POST",
      headers: {
        Authorization: c,
        apikey: this.socket.apiKey ? this.socket.apiKey : "",
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        messages: [
          {
            topic: this.subTopic,
            event: e,
            payload: r,
            private: this.private
          }
        ]
      })
    }, m = await this._fetchWithTimeout(this.broadcastEndpointURL, f, (u = o.timeout) !== null && u !== void 0 ? u : this.timeout);
    if (m.status === 202)
      return { success: !0 };
    let y = m.statusText;
    try {
      const b = await m.json();
      y = b.error || b.message || y;
    } catch {
    }
    return Promise.reject(new Error(y));
  }
  /**
   * Sends a message into the channel.
   *
   * @param args Arguments to send to channel
   * @param args.type The type of event to send
   * @param args.event The name of the event being sent
   * @param args.payload Payload to be sent
   * @param opts Options to be used during the send process
   */
  async send(e, r = {}) {
    var o, u;
    if (!this._canPush() && e.type === "broadcast") {
      console.warn("Realtime send() is automatically falling back to REST API. This behavior will be deprecated in the future. Please use httpSend() explicitly for REST delivery.");
      const { event: c, payload: f } = e, y = {
        method: "POST",
        headers: {
          Authorization: this.socket.accessTokenValue ? `Bearer ${this.socket.accessTokenValue}` : "",
          apikey: this.socket.apiKey ? this.socket.apiKey : "",
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          messages: [
            {
              topic: this.subTopic,
              event: c,
              payload: f,
              private: this.private
            }
          ]
        })
      };
      try {
        const b = await this._fetchWithTimeout(this.broadcastEndpointURL, y, (o = r.timeout) !== null && o !== void 0 ? o : this.timeout);
        return await ((u = b.body) === null || u === void 0 ? void 0 : u.cancel()), b.ok ? "ok" : "error";
      } catch (b) {
        return b.name === "AbortError" ? "timed out" : "error";
      }
    } else
      return new Promise((c) => {
        var f, m, y;
        const b = this._push(e.type, e, r.timeout || this.timeout);
        e.type === "broadcast" && !(!((y = (m = (f = this.params) === null || f === void 0 ? void 0 : f.config) === null || m === void 0 ? void 0 : m.broadcast) === null || y === void 0) && y.ack) && c("ok"), b.receive("ok", () => c("ok")), b.receive("error", () => c("error")), b.receive("timeout", () => c("timed out"));
      });
  }
  updateJoinPayload(e) {
    this.joinPush.updatePayload(e);
  }
  /**
   * Leaves the channel.
   *
   * Unsubscribes from server events, and instructs channel to terminate on server.
   * Triggers onClose() hooks.
   *
   * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:
   * channel.unsubscribe().receive("ok", () => alert("left!") )
   */
  unsubscribe(e = this.timeout) {
    this.state = ga.leaving;
    const r = () => {
      this.socket.log("channel", `leave ${this.topic}`), this._trigger(js.close, "leave", this._joinRef());
    };
    this.joinPush.destroy();
    let o = null;
    return new Promise((u) => {
      o = new RC(this, js.leave, {}, e), o.receive("ok", () => {
        r(), u("ok");
      }).receive("timeout", () => {
        r(), u("timed out");
      }).receive("error", () => {
        u("error");
      }), o.send(), this._canPush() || o.trigger("ok", {});
    }).finally(() => {
      o == null || o.destroy();
    });
  }
  /**
   * Teardown the channel.
   *
   * Destroys and stops related timers.
   */
  teardown() {
    this.pushBuffer.forEach((e) => e.destroy()), this.pushBuffer = [], this.rejoinTimer.reset(), this.joinPush.destroy(), this.state = ga.closed, this.bindings = {};
  }
  /** @internal */
  async _fetchWithTimeout(e, r, o) {
    const u = new AbortController(), c = setTimeout(() => u.abort(), o), f = await this.socket.fetch(e, Object.assign(Object.assign({}, r), { signal: u.signal }));
    return clearTimeout(c), f;
  }
  /** @internal */
  _push(e, r, o = this.timeout) {
    if (!this.joinedOnce)
      throw `tried to push '${e}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;
    let u = new RC(this, e, r, o);
    return this._canPush() ? u.send() : this._addToPushBuffer(u), u;
  }
  /** @internal */
  _addToPushBuffer(e) {
    if (e.startTimeout(), this.pushBuffer.push(e), this.pushBuffer.length > W8) {
      const r = this.pushBuffer.shift();
      r && (r.destroy(), this.socket.log("channel", `discarded push due to buffer overflow: ${r.event}`, r.payload));
    }
  }
  /**
   * Overridable message hook
   *
   * Receives all events for specialized message handling before dispatching to the channel callbacks.
   * Must return the payload, modified or unmodified.
   *
   * @internal
   */
  _onMessage(e, r, o) {
    return r;
  }
  /** @internal */
  _isMember(e) {
    return this.topic === e;
  }
  /** @internal */
  _joinRef() {
    return this.joinPush.ref;
  }
  /** @internal */
  _trigger(e, r, o) {
    var u, c;
    const f = e.toLocaleLowerCase(), { close: m, error: y, leave: b, join: _ } = js;
    if (o && [m, y, b, _].indexOf(f) >= 0 && o !== this._joinRef())
      return;
    let k = this._onMessage(f, r, o);
    if (r && !k)
      throw "channel onMessage callbacks must return the payload, modified or unmodified";
    ["insert", "update", "delete"].includes(f) ? (u = this.bindings.postgres_changes) === null || u === void 0 || u.filter((C) => {
      var M, N, A;
      return ((M = C.filter) === null || M === void 0 ? void 0 : M.event) === "*" || ((A = (N = C.filter) === null || N === void 0 ? void 0 : N.event) === null || A === void 0 ? void 0 : A.toLocaleLowerCase()) === f;
    }).map((C) => C.callback(k, o)) : (c = this.bindings[f]) === null || c === void 0 || c.filter((C) => {
      var M, N, A, $, I, U;
      if (["broadcast", "presence", "postgres_changes"].includes(f))
        if ("id" in C) {
          const B = C.id, K = (M = C.filter) === null || M === void 0 ? void 0 : M.event;
          return B && ((N = r.ids) === null || N === void 0 ? void 0 : N.includes(B)) && (K === "*" || (K == null ? void 0 : K.toLocaleLowerCase()) === ((A = r.data) === null || A === void 0 ? void 0 : A.type.toLocaleLowerCase()));
        } else {
          const B = (I = ($ = C == null ? void 0 : C.filter) === null || $ === void 0 ? void 0 : $.event) === null || I === void 0 ? void 0 : I.toLocaleLowerCase();
          return B === "*" || B === ((U = r == null ? void 0 : r.event) === null || U === void 0 ? void 0 : U.toLocaleLowerCase());
        }
      else
        return C.type.toLocaleLowerCase() === f;
    }).map((C) => {
      if (typeof k == "object" && "ids" in k) {
        const M = k.data, { schema: N, table: A, commit_timestamp: $, type: I, errors: U } = M;
        k = Object.assign(Object.assign({}, {
          schema: N,
          table: A,
          commit_timestamp: $,
          eventType: I,
          new: {},
          old: {},
          errors: U
        }), this._getPayloadRecords(M));
      }
      C.callback(k, o);
    });
  }
  /** @internal */
  _isClosed() {
    return this.state === ga.closed;
  }
  /** @internal */
  _isJoined() {
    return this.state === ga.joined;
  }
  /** @internal */
  _isJoining() {
    return this.state === ga.joining;
  }
  /** @internal */
  _isLeaving() {
    return this.state === ga.leaving;
  }
  /** @internal */
  _replyEventName(e) {
    return `chan_reply_${e}`;
  }
  /** @internal */
  _on(e, r, o) {
    const u = e.toLocaleLowerCase(), c = {
      type: u,
      filter: r,
      callback: o
    };
    return this.bindings[u] ? this.bindings[u].push(c) : this.bindings[u] = [c], this;
  }
  /** @internal */
  _off(e, r) {
    const o = e.toLocaleLowerCase();
    return this.bindings[o] && (this.bindings[o] = this.bindings[o].filter((u) => {
      var c;
      return !(((c = u.type) === null || c === void 0 ? void 0 : c.toLocaleLowerCase()) === o && ST.isEqual(u.filter, r));
    })), this;
  }
  /** @internal */
  static isEqual(e, r) {
    if (Object.keys(e).length !== Object.keys(r).length)
      return !1;
    for (const o in e)
      if (e[o] !== r[o])
        return !1;
    return !0;
  }
  /** @internal */
  _rejoinUntilConnected() {
    this.rejoinTimer.scheduleTimeout(), this.socket.isConnected() && this._rejoin();
  }
  /**
   * Registers a callback that will be executed when the channel closes.
   *
   * @internal
   */
  _onClose(e) {
    this._on(js.close, {}, e);
  }
  /**
   * Registers a callback that will be executed when the channel encounteres an error.
   *
   * @internal
   */
  _onError(e) {
    this._on(js.error, {}, (r) => e(r));
  }
  /**
   * Returns `true` if the socket is connected and the channel has been joined.
   *
   * @internal
   */
  _canPush() {
    return this.socket.isConnected() && this._isJoined();
  }
  /** @internal */
  _rejoin(e = this.timeout) {
    this._isLeaving() || (this.socket._leaveOpenTopic(this.topic), this.state = ga.joining, this.joinPush.resend(e));
  }
  /** @internal */
  _getPayloadRecords(e) {
    const r = {
      new: {},
      old: {}
    };
    return (e.type === "INSERT" || e.type === "UPDATE") && (r.new = Pj(e.columns, e.record)), (e.type === "UPDATE" || e.type === "DELETE") && (r.old = Pj(e.columns, e.old_record)), r;
  }
}
const kC = () => {
}, Pw = {
  HEARTBEAT_INTERVAL: 25e3,
  RECONNECT_DELAY: 10,
  HEARTBEAT_TIMEOUT_FALLBACK: 100
}, X8 = [1e3, 2e3, 5e3, 1e4], eW = 1e4, tW = `
  addEventListener("message", (e) => {
    if (e.data.event === "start") {
      setInterval(() => postMessage({ event: "keepAlive" }), e.data.interval);
    }
  });`;
class nW {
  /**
   * Initializes the Socket.
   *
   * @param endPoint The string WebSocket endpoint, ie, "ws://example.com/socket", "wss://example.com", "/socket" (inherited host & protocol)
   * @param httpEndpoint The string HTTP endpoint, ie, "https://example.com", "/" (inherited host & protocol)
   * @param options.transport The Websocket Transport, for example WebSocket. This can be a custom implementation
   * @param options.timeout The default timeout in milliseconds to trigger push timeouts.
   * @param options.params The optional params to pass when connecting.
   * @param options.headers Deprecated: headers cannot be set on websocket connections and this option will be removed in the future.
   * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.
   * @param options.heartbeatCallback The optional function to handle heartbeat status.
   * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }
   * @param options.logLevel Sets the log level for Realtime
   * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))
   * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.
   * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.
   * @param options.worker Use Web Worker to set a side flow. Defaults to false.
   * @param options.workerUrl The URL of the worker script. Defaults to https://realtime.supabase.com/worker.js that includes a heartbeat event call to keep the connection alive.
   */
  constructor(e, r) {
    var o;
    if (this.accessTokenValue = null, this.apiKey = null, this.channels = new Array(), this.endPoint = "", this.httpEndpoint = "", this.headers = {}, this.params = {}, this.timeout = b1, this.transport = null, this.heartbeatIntervalMs = Pw.HEARTBEAT_INTERVAL, this.heartbeatTimer = void 0, this.pendingHeartbeatRef = null, this.heartbeatCallback = kC, this.ref = 0, this.reconnectTimer = null, this.logger = kC, this.conn = null, this.sendBuffer = [], this.serializer = new q8(), this.stateChangeCallbacks = {
      open: [],
      close: [],
      error: [],
      message: []
    }, this.accessToken = null, this._connectionState = "disconnected", this._wasManualDisconnect = !1, this._authPromise = null, this._resolveFetch = (u) => u ? (...c) => u(...c) : (...c) => fetch(...c), !(!((o = r == null ? void 0 : r.params) === null || o === void 0) && o.apikey))
      throw new Error("API key is required to connect to Realtime");
    this.apiKey = r.params.apikey, this.endPoint = `${e}/${w1.websocket}`, this.httpEndpoint = JM(e), this._initializeOptions(r), this._setupReconnectionTimer(), this.fetch = this._resolveFetch(r == null ? void 0 : r.fetch);
  }
  /**
   * Connects the socket, unless already connected.
   */
  connect() {
    if (!(this.isConnecting() || this.isDisconnecting() || this.conn !== null && this.isConnected())) {
      if (this._setConnectionState("connecting"), this._setAuthSafely("connect"), this.transport)
        this.conn = new this.transport(this.endpointURL());
      else
        try {
          this.conn = $8.createWebSocket(this.endpointURL());
        } catch (e) {
          this._setConnectionState("disconnected");
          const r = e.message;
          throw r.includes("Node.js") ? new Error(`${r}

To use Realtime in Node.js, you need to provide a WebSocket implementation:

Option 1: Use Node.js 22+ which has native WebSocket support
Option 2: Install and provide the "ws" package:

  npm install ws

  import ws from "ws"
  const client = new RealtimeClient(url, {
    ...options,
    transport: ws
  })`) : new Error(`WebSocket not available: ${r}`);
        }
      this._setupConnectionHandlers();
    }
  }
  /**
   * Returns the URL of the websocket.
   * @returns string The URL of the websocket.
   */
  endpointURL() {
    return this._appendParams(this.endPoint, Object.assign({}, this.params, { vsn: V8 }));
  }
  /**
   * Disconnects the socket.
   *
   * @param code A numeric status code to send on disconnect.
   * @param reason A custom reason for the disconnect.
   */
  disconnect(e, r) {
    if (!this.isDisconnecting())
      if (this._setConnectionState("disconnecting", !0), this.conn) {
        const o = setTimeout(() => {
          this._setConnectionState("disconnected");
        }, 100);
        this.conn.onclose = () => {
          clearTimeout(o), this._setConnectionState("disconnected");
        }, e ? this.conn.close(e, r ?? "") : this.conn.close(), this._teardownConnection();
      } else
        this._setConnectionState("disconnected");
  }
  /**
   * Returns all created channels
   */
  getChannels() {
    return this.channels;
  }
  /**
   * Unsubscribes and removes a single channel
   * @param channel A RealtimeChannel instance
   */
  async removeChannel(e) {
    const r = await e.unsubscribe();
    return this.channels.length === 0 && this.disconnect(), r;
  }
  /**
   * Unsubscribes and removes all channels
   */
  async removeAllChannels() {
    const e = await Promise.all(this.channels.map((r) => r.unsubscribe()));
    return this.channels = [], this.disconnect(), e;
  }
  /**
   * Logs the message.
   *
   * For customized logging, `this.logger` can be overridden.
   */
  log(e, r, o) {
    this.logger(e, r, o);
  }
  /**
   * Returns the current state of the socket.
   */
  connectionState() {
    switch (this.conn && this.conn.readyState) {
      case qg.connecting:
        return Rf.Connecting;
      case qg.open:
        return Rf.Open;
      case qg.closing:
        return Rf.Closing;
      default:
        return Rf.Closed;
    }
  }
  /**
   * Returns `true` is the connection is open.
   */
  isConnected() {
    return this.connectionState() === Rf.Open;
  }
  /**
   * Returns `true` if the connection is currently connecting.
   */
  isConnecting() {
    return this._connectionState === "connecting";
  }
  /**
   * Returns `true` if the connection is currently disconnecting.
   */
  isDisconnecting() {
    return this._connectionState === "disconnecting";
  }
  channel(e, r = { config: {} }) {
    const o = `realtime:${e}`, u = this.getChannels().find((c) => c.topic === o);
    if (u)
      return u;
    {
      const c = new ST(`realtime:${e}`, r, this);
      return this.channels.push(c), c;
    }
  }
  /**
   * Push out a message if the socket is connected.
   *
   * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.
   */
  push(e) {
    const { topic: r, event: o, payload: u, ref: c } = e, f = () => {
      this.encode(e, (m) => {
        var y;
        (y = this.conn) === null || y === void 0 || y.send(m);
      });
    };
    this.log("push", `${r} ${o} (${c})`, u), this.isConnected() ? f() : this.sendBuffer.push(f);
  }
  /**
   * Sets the JWT access token used for channel subscription authorization and Realtime RLS.
   *
   * If param is null it will use the `accessToken` callback function or the token set on the client.
   *
   * On callback used, it will set the value of the token internal to the client.
   *
   * @param token A JWT string to override the token set on the client.
   */
  async setAuth(e = null) {
    this._authPromise = this._performAuth(e);
    try {
      await this._authPromise;
    } finally {
      this._authPromise = null;
    }
  }
  /**
   * Sends a heartbeat message if the socket is connected.
   */
  async sendHeartbeat() {
    var e;
    if (!this.isConnected()) {
      try {
        this.heartbeatCallback("disconnected");
      } catch (r) {
        this.log("error", "error in heartbeat callback", r);
      }
      return;
    }
    if (this.pendingHeartbeatRef) {
      this.pendingHeartbeatRef = null, this.log("transport", "heartbeat timeout. Attempting to re-establish connection");
      try {
        this.heartbeatCallback("timeout");
      } catch (r) {
        this.log("error", "error in heartbeat callback", r);
      }
      this._wasManualDisconnect = !1, (e = this.conn) === null || e === void 0 || e.close(H8, "heartbeat timeout"), setTimeout(() => {
        var r;
        this.isConnected() || (r = this.reconnectTimer) === null || r === void 0 || r.scheduleTimeout();
      }, Pw.HEARTBEAT_TIMEOUT_FALLBACK);
      return;
    }
    this.pendingHeartbeatRef = this._makeRef(), this.push({
      topic: "phoenix",
      event: "heartbeat",
      payload: {},
      ref: this.pendingHeartbeatRef
    });
    try {
      this.heartbeatCallback("sent");
    } catch (r) {
      this.log("error", "error in heartbeat callback", r);
    }
    this._setAuthSafely("heartbeat");
  }
  onHeartbeat(e) {
    this.heartbeatCallback = e;
  }
  /**
   * Flushes send buffer
   */
  flushSendBuffer() {
    this.isConnected() && this.sendBuffer.length > 0 && (this.sendBuffer.forEach((e) => e()), this.sendBuffer = []);
  }
  /**
   * Return the next message ref, accounting for overflows
   *
   * @internal
   */
  _makeRef() {
    let e = this.ref + 1;
    return e === this.ref ? this.ref = 0 : this.ref = e, this.ref.toString();
  }
  /**
   * Unsubscribe from channels with the specified topic.
   *
   * @internal
   */
  _leaveOpenTopic(e) {
    let r = this.channels.find((o) => o.topic === e && (o._isJoined() || o._isJoining()));
    r && (this.log("transport", `leaving duplicate topic "${e}"`), r.unsubscribe());
  }
  /**
   * Removes a subscription from the socket.
   *
   * @param channel An open subscription.
   *
   * @internal
   */
  _remove(e) {
    this.channels = this.channels.filter((r) => r.topic !== e.topic);
  }
  /** @internal */
  _onConnMessage(e) {
    this.decode(e.data, (r) => {
      if (r.topic === "phoenix" && r.event === "phx_reply")
        try {
          this.heartbeatCallback(r.payload.status === "ok" ? "ok" : "error");
        } catch (b) {
          this.log("error", "error in heartbeat callback", b);
        }
      r.ref && r.ref === this.pendingHeartbeatRef && (this.pendingHeartbeatRef = null);
      const { topic: o, event: u, payload: c, ref: f } = r, m = f ? `(${f})` : "", y = c.status || "";
      this.log("receive", `${y} ${o} ${u} ${m}`.trim(), c), this.channels.filter((b) => b._isMember(o)).forEach((b) => b._trigger(u, c, f)), this._triggerStateCallbacks("message", r);
    });
  }
  /**
   * Clear specific timer
   * @internal
   */
  _clearTimer(e) {
    var r;
    e === "heartbeat" && this.heartbeatTimer ? (clearInterval(this.heartbeatTimer), this.heartbeatTimer = void 0) : e === "reconnect" && ((r = this.reconnectTimer) === null || r === void 0 || r.reset());
  }
  /**
   * Clear all timers
   * @internal
   */
  _clearAllTimers() {
    this._clearTimer("heartbeat"), this._clearTimer("reconnect");
  }
  /**
   * Setup connection handlers for WebSocket events
   * @internal
   */
  _setupConnectionHandlers() {
    this.conn && ("binaryType" in this.conn && (this.conn.binaryType = "arraybuffer"), this.conn.onopen = () => this._onConnOpen(), this.conn.onerror = (e) => this._onConnError(e), this.conn.onmessage = (e) => this._onConnMessage(e), this.conn.onclose = (e) => this._onConnClose(e));
  }
  /**
   * Teardown connection and cleanup resources
   * @internal
   */
  _teardownConnection() {
    this.conn && (this.conn.onopen = null, this.conn.onerror = null, this.conn.onmessage = null, this.conn.onclose = null, this.conn = null), this._clearAllTimers(), this.channels.forEach((e) => e.teardown());
  }
  /** @internal */
  _onConnOpen() {
    this._setConnectionState("connected"), this.log("transport", `connected to ${this.endpointURL()}`), this.flushSendBuffer(), this._clearTimer("reconnect"), this.worker ? this.workerRef || this._startWorkerHeartbeat() : this._startHeartbeat(), this._triggerStateCallbacks("open");
  }
  /** @internal */
  _startHeartbeat() {
    this.heartbeatTimer && clearInterval(this.heartbeatTimer), this.heartbeatTimer = setInterval(() => this.sendHeartbeat(), this.heartbeatIntervalMs);
  }
  /** @internal */
  _startWorkerHeartbeat() {
    this.workerUrl ? this.log("worker", `starting worker for from ${this.workerUrl}`) : this.log("worker", "starting default worker");
    const e = this._workerObjectUrl(this.workerUrl);
    this.workerRef = new Worker(e), this.workerRef.onerror = (r) => {
      this.log("worker", "worker error", r.message), this.workerRef.terminate();
    }, this.workerRef.onmessage = (r) => {
      r.data.event === "keepAlive" && this.sendHeartbeat();
    }, this.workerRef.postMessage({
      event: "start",
      interval: this.heartbeatIntervalMs
    });
  }
  /** @internal */
  _onConnClose(e) {
    var r;
    this._setConnectionState("disconnected"), this.log("transport", "close", e), this._triggerChanError(), this._clearTimer("heartbeat"), this._wasManualDisconnect || (r = this.reconnectTimer) === null || r === void 0 || r.scheduleTimeout(), this._triggerStateCallbacks("close", e);
  }
  /** @internal */
  _onConnError(e) {
    this._setConnectionState("disconnected"), this.log("transport", `${e}`), this._triggerChanError(), this._triggerStateCallbacks("error", e);
  }
  /** @internal */
  _triggerChanError() {
    this.channels.forEach((e) => e._trigger(js.error));
  }
  /** @internal */
  _appendParams(e, r) {
    if (Object.keys(r).length === 0)
      return e;
    const o = e.match(/\?/) ? "&" : "?", u = new URLSearchParams(r);
    return `${e}${o}${u}`;
  }
  _workerObjectUrl(e) {
    let r;
    if (e)
      r = e;
    else {
      const o = new Blob([tW], { type: "application/javascript" });
      r = URL.createObjectURL(o);
    }
    return r;
  }
  /**
   * Set connection state with proper state management
   * @internal
   */
  _setConnectionState(e, r = !1) {
    this._connectionState = e, e === "connecting" ? this._wasManualDisconnect = !1 : e === "disconnecting" && (this._wasManualDisconnect = r);
  }
  /**
   * Perform the actual auth operation
   * @internal
   */
  async _performAuth(e = null) {
    let r;
    e ? r = e : this.accessToken ? r = await this.accessToken() : r = this.accessTokenValue, this.accessTokenValue != r && (this.accessTokenValue = r, this.channels.forEach((o) => {
      const u = {
        access_token: r,
        version: B8
      };
      r && o.updateJoinPayload(u), o.joinedOnce && o._isJoined() && o._push(js.access_token, {
        access_token: r
      });
    }));
  }
  /**
   * Wait for any in-flight auth operations to complete
   * @internal
   */
  async _waitForAuthIfNeeded() {
    this._authPromise && await this._authPromise;
  }
  /**
   * Safely call setAuth with standardized error handling
   * @internal
   */
  _setAuthSafely(e = "general") {
    this.setAuth().catch((r) => {
      this.log("error", `error setting auth in ${e}`, r);
    });
  }
  /**
   * Trigger state change callbacks with proper error handling
   * @internal
   */
  _triggerStateCallbacks(e, r) {
    try {
      this.stateChangeCallbacks[e].forEach((o) => {
        try {
          o(r);
        } catch (u) {
          this.log("error", `error in ${e} callback`, u);
        }
      });
    } catch (o) {
      this.log("error", `error triggering ${e} callbacks`, o);
    }
  }
  /**
   * Setup reconnection timer with proper configuration
   * @internal
   */
  _setupReconnectionTimer() {
    this.reconnectTimer = new GM(async () => {
      setTimeout(async () => {
        await this._waitForAuthIfNeeded(), this.isConnected() || this.connect();
      }, Pw.RECONNECT_DELAY);
    }, this.reconnectAfterMs);
  }
  /**
   * Initialize client options with defaults
   * @internal
   */
  _initializeOptions(e) {
    var r, o, u, c, f, m, y, b, _;
    if (this.transport = (r = e == null ? void 0 : e.transport) !== null && r !== void 0 ? r : null, this.timeout = (o = e == null ? void 0 : e.timeout) !== null && o !== void 0 ? o : b1, this.heartbeatIntervalMs = (u = e == null ? void 0 : e.heartbeatIntervalMs) !== null && u !== void 0 ? u : Pw.HEARTBEAT_INTERVAL, this.worker = (c = e == null ? void 0 : e.worker) !== null && c !== void 0 ? c : !1, this.accessToken = (f = e == null ? void 0 : e.accessToken) !== null && f !== void 0 ? f : null, this.heartbeatCallback = (m = e == null ? void 0 : e.heartbeatCallback) !== null && m !== void 0 ? m : kC, e != null && e.params && (this.params = e.params), e != null && e.logger && (this.logger = e.logger), (e != null && e.logLevel || e != null && e.log_level) && (this.logLevel = e.logLevel || e.log_level, this.params = Object.assign(Object.assign({}, this.params), { log_level: this.logLevel })), this.reconnectAfterMs = (y = e == null ? void 0 : e.reconnectAfterMs) !== null && y !== void 0 ? y : (T) => X8[T - 1] || eW, this.encode = (b = e == null ? void 0 : e.encode) !== null && b !== void 0 ? b : (T, k) => k(JSON.stringify(T)), this.decode = (_ = e == null ? void 0 : e.decode) !== null && _ !== void 0 ? _ : this.serializer.decode.bind(this.serializer), this.worker) {
      if (typeof window < "u" && !window.Worker)
        throw new Error("Web Worker is not supported");
      this.workerUrl = e == null ? void 0 : e.workerUrl;
    }
  }
}
class _T extends Error {
  constructor(e) {
    super(e), this.__isStorageError = !0, this.name = "StorageError";
  }
}
function Tr(n) {
  return typeof n == "object" && n !== null && "__isStorageError" in n;
}
class rW extends _T {
  constructor(e, r, o) {
    super(e), this.name = "StorageApiError", this.status = r, this.statusCode = o;
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status,
      statusCode: this.statusCode
    };
  }
}
class S1 extends _T {
  constructor(e, r) {
    super(e), this.name = "StorageUnknownError", this.originalError = r;
  }
}
const ET = (n) => n ? (...e) => n(...e) : (...e) => fetch(...e), aW = () => Response, _1 = (n) => {
  if (Array.isArray(n))
    return n.map((r) => _1(r));
  if (typeof n == "function" || n !== Object(n))
    return n;
  const e = {};
  return Object.entries(n).forEach(([r, o]) => {
    const u = r.replace(/([-_][a-z])/gi, (c) => c.toUpperCase().replace(/[-_]/g, ""));
    e[u] = _1(o);
  }), e;
}, iW = (n) => {
  if (typeof n != "object" || n === null)
    return !1;
  const e = Object.getPrototypeOf(n);
  return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(Symbol.toStringTag in n) && !(Symbol.iterator in n);
}, OC = (n) => {
  var e;
  return n.msg || n.message || n.error_description || (typeof n.error == "string" ? n.error : (e = n.error) === null || e === void 0 ? void 0 : e.message) || JSON.stringify(n);
}, oW = (n, e, r) => dt(void 0, void 0, void 0, function* () {
  const o = yield aW();
  n instanceof o && !(r != null && r.noResolveJson) ? n.json().then((u) => {
    const c = n.status || 500, f = (u == null ? void 0 : u.statusCode) || c + "";
    e(new rW(OC(u), c, f));
  }).catch((u) => {
    e(new S1(OC(u), u));
  }) : e(new S1(OC(n), n));
}), sW = (n, e, r, o) => {
  const u = { method: n, headers: (e == null ? void 0 : e.headers) || {} };
  return n === "GET" || !o ? u : (iW(o) ? (u.headers = Object.assign({ "Content-Type": "application/json" }, e == null ? void 0 : e.headers), u.body = JSON.stringify(o)) : u.body = o, e != null && e.duplex && (u.duplex = e.duplex), Object.assign(Object.assign({}, u), r));
};
function _y(n, e, r, o, u, c) {
  return dt(this, void 0, void 0, function* () {
    return new Promise((f, m) => {
      n(r, sW(e, o, u, c)).then((y) => {
        if (!y.ok)
          throw y;
        return o != null && o.noResolveJson ? y : y.json();
      }).then((y) => f(y)).catch((y) => oW(y, m, o));
    });
  });
}
function ry(n, e, r, o) {
  return dt(this, void 0, void 0, function* () {
    return _y(n, "GET", e, r, o);
  });
}
function ks(n, e, r, o, u) {
  return dt(this, void 0, void 0, function* () {
    return _y(n, "POST", e, o, u, r);
  });
}
function E1(n, e, r, o, u) {
  return dt(this, void 0, void 0, function* () {
    return _y(n, "PUT", e, o, u, r);
  });
}
function lW(n, e, r, o) {
  return dt(this, void 0, void 0, function* () {
    return _y(n, "HEAD", e, Object.assign(Object.assign({}, r), { noResolveJson: !0 }), o);
  });
}
function CT(n, e, r, o, u) {
  return dt(this, void 0, void 0, function* () {
    return _y(n, "DELETE", e, o, u, r);
  });
}
class uW {
  constructor(e, r) {
    this.downloadFn = e, this.shouldThrowOnError = r;
  }
  then(e, r) {
    return this.execute().then(e, r);
  }
  execute() {
    return dt(this, void 0, void 0, function* () {
      try {
        return {
          data: (yield this.downloadFn()).body,
          error: null
        };
      } catch (e) {
        if (this.shouldThrowOnError)
          throw e;
        if (Tr(e))
          return { data: null, error: e };
        throw e;
      }
    });
  }
}
var ZM;
class cW {
  constructor(e, r) {
    this.downloadFn = e, this.shouldThrowOnError = r, this[ZM] = "BlobDownloadBuilder", this.promise = null;
  }
  asStream() {
    return new uW(this.downloadFn, this.shouldThrowOnError);
  }
  then(e, r) {
    return this.getPromise().then(e, r);
  }
  catch(e) {
    return this.getPromise().catch(e);
  }
  finally(e) {
    return this.getPromise().finally(e);
  }
  getPromise() {
    return this.promise || (this.promise = this.execute()), this.promise;
  }
  execute() {
    return dt(this, void 0, void 0, function* () {
      try {
        return {
          data: yield (yield this.downloadFn()).blob(),
          error: null
        };
      } catch (e) {
        if (this.shouldThrowOnError)
          throw e;
        if (Tr(e))
          return { data: null, error: e };
        throw e;
      }
    });
  }
}
ZM = Symbol.toStringTag;
const dW = {
  limit: 100,
  offset: 0,
  sortBy: {
    column: "name",
    order: "asc"
  }
}, Ij = {
  cacheControl: "3600",
  contentType: "text/plain;charset=UTF-8",
  upsert: !1
};
class fW {
  constructor(e, r = {}, o, u) {
    this.shouldThrowOnError = !1, this.url = e, this.headers = r, this.bucketId = o, this.fetch = ET(u);
  }
  /**
   * Enable throwing errors instead of returning them.
   */
  throwOnError() {
    return this.shouldThrowOnError = !0, this;
  }
  /**
   * Uploads a file to an existing bucket or replaces an existing file at the specified path with a new one.
   *
   * @param method HTTP method.
   * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.
   * @param fileBody The body of the file to be stored in the bucket.
   */
  uploadOrUpdate(e, r, o, u) {
    return dt(this, void 0, void 0, function* () {
      try {
        let c;
        const f = Object.assign(Object.assign({}, Ij), u);
        let m = Object.assign(Object.assign({}, this.headers), e === "POST" && { "x-upsert": String(f.upsert) });
        const y = f.metadata;
        typeof Blob < "u" && o instanceof Blob ? (c = new FormData(), c.append("cacheControl", f.cacheControl), y && c.append("metadata", this.encodeMetadata(y)), c.append("", o)) : typeof FormData < "u" && o instanceof FormData ? (c = o, c.has("cacheControl") || c.append("cacheControl", f.cacheControl), y && !c.has("metadata") && c.append("metadata", this.encodeMetadata(y))) : (c = o, m["cache-control"] = `max-age=${f.cacheControl}`, m["content-type"] = f.contentType, y && (m["x-metadata"] = this.toBase64(this.encodeMetadata(y))), (typeof ReadableStream < "u" && c instanceof ReadableStream || c && typeof c == "object" && "pipe" in c && typeof c.pipe == "function") && !f.duplex && (f.duplex = "half")), u != null && u.headers && (m = Object.assign(Object.assign({}, m), u.headers));
        const b = this._removeEmptyFolders(r), _ = this._getFinalPath(b), T = yield (e == "PUT" ? E1 : ks)(this.fetch, `${this.url}/object/${_}`, c, Object.assign({ headers: m }, f != null && f.duplex ? { duplex: f.duplex } : {}));
        return {
          data: { path: b, id: T.Id, fullPath: T.Key },
          error: null
        };
      } catch (c) {
        if (this.shouldThrowOnError)
          throw c;
        if (Tr(c))
          return { data: null, error: c };
        throw c;
      }
    });
  }
  /**
   * Uploads a file to an existing bucket.
   *
   * @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.
   * @param fileBody The body of the file to be stored in the bucket.
   */
  upload(e, r, o) {
    return dt(this, void 0, void 0, function* () {
      return this.uploadOrUpdate("POST", e, r, o);
    });
  }
  /**
   * Upload a file with a token generated from `createSignedUploadUrl`.
   * @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.
   * @param token The token generated from `createSignedUploadUrl`
   * @param fileBody The body of the file to be stored in the bucket.
   */
  uploadToSignedUrl(e, r, o, u) {
    return dt(this, void 0, void 0, function* () {
      const c = this._removeEmptyFolders(e), f = this._getFinalPath(c), m = new URL(this.url + `/object/upload/sign/${f}`);
      m.searchParams.set("token", r);
      try {
        let y;
        const b = Object.assign({ upsert: Ij.upsert }, u), _ = Object.assign(Object.assign({}, this.headers), { "x-upsert": String(b.upsert) });
        typeof Blob < "u" && o instanceof Blob ? (y = new FormData(), y.append("cacheControl", b.cacheControl), y.append("", o)) : typeof FormData < "u" && o instanceof FormData ? (y = o, y.append("cacheControl", b.cacheControl)) : (y = o, _["cache-control"] = `max-age=${b.cacheControl}`, _["content-type"] = b.contentType);
        const T = yield E1(this.fetch, m.toString(), y, { headers: _ });
        return {
          data: { path: c, fullPath: T.Key },
          error: null
        };
      } catch (y) {
        if (this.shouldThrowOnError)
          throw y;
        if (Tr(y))
          return { data: null, error: y };
        throw y;
      }
    });
  }
  /**
   * Creates a signed upload URL.
   * Signed upload URLs can be used to upload files to the bucket without further authentication.
   * They are valid for 2 hours.
   * @param path The file path, including the current file name. For example `folder/image.png`.
   * @param options.upsert If set to true, allows the file to be overwritten if it already exists.
   */
  createSignedUploadUrl(e, r) {
    return dt(this, void 0, void 0, function* () {
      try {
        let o = this._getFinalPath(e);
        const u = Object.assign({}, this.headers);
        r != null && r.upsert && (u["x-upsert"] = "true");
        const c = yield ks(this.fetch, `${this.url}/object/upload/sign/${o}`, {}, { headers: u }), f = new URL(this.url + c.url), m = f.searchParams.get("token");
        if (!m)
          throw new _T("No token returned by API");
        return { data: { signedUrl: f.toString(), path: e, token: m }, error: null };
      } catch (o) {
        if (this.shouldThrowOnError)
          throw o;
        if (Tr(o))
          return { data: null, error: o };
        throw o;
      }
    });
  }
  /**
   * Replaces an existing file at the specified path with a new one.
   *
   * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to update.
   * @param fileBody The body of the file to be stored in the bucket.
   */
  update(e, r, o) {
    return dt(this, void 0, void 0, function* () {
      return this.uploadOrUpdate("PUT", e, r, o);
    });
  }
  /**
   * Moves an existing file to a new path in the same bucket.
   *
   * @param fromPath The original file path, including the current file name. For example `folder/image.png`.
   * @param toPath The new file path, including the new file name. For example `folder/image-new.png`.
   * @param options The destination options.
   */
  move(e, r, o) {
    return dt(this, void 0, void 0, function* () {
      try {
        return {
          data: yield ks(this.fetch, `${this.url}/object/move`, {
            bucketId: this.bucketId,
            sourceKey: e,
            destinationKey: r,
            destinationBucket: o == null ? void 0 : o.destinationBucket
          }, { headers: this.headers }), error: null
        };
      } catch (u) {
        if (this.shouldThrowOnError)
          throw u;
        if (Tr(u))
          return { data: null, error: u };
        throw u;
      }
    });
  }
  /**
   * Copies an existing file to a new path in the same bucket.
   *
   * @param fromPath The original file path, including the current file name. For example `folder/image.png`.
   * @param toPath The new file path, including the new file name. For example `folder/image-copy.png`.
   * @param options The destination options.
   */
  copy(e, r, o) {
    return dt(this, void 0, void 0, function* () {
      try {
        return {
          data: {
            path: (yield ks(this.fetch, `${this.url}/object/copy`, {
              bucketId: this.bucketId,
              sourceKey: e,
              destinationKey: r,
              destinationBucket: o == null ? void 0 : o.destinationBucket
            }, { headers: this.headers })).Key
          }, error: null
        };
      } catch (u) {
        if (this.shouldThrowOnError)
          throw u;
        if (Tr(u))
          return { data: null, error: u };
        throw u;
      }
    });
  }
  /**
   * Creates a signed URL. Use a signed URL to share a file for a fixed amount of time.
   *
   * @param path The file path, including the current file name. For example `folder/image.png`.
   * @param expiresIn The number of seconds until the signed URL expires. For example, `60` for a URL which is valid for one minute.
   * @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.
   * @param options.transform Transform the asset before serving it to the client.
   */
  createSignedUrl(e, r, o) {
    return dt(this, void 0, void 0, function* () {
      try {
        let u = this._getFinalPath(e), c = yield ks(this.fetch, `${this.url}/object/sign/${u}`, Object.assign({ expiresIn: r }, o != null && o.transform ? { transform: o.transform } : {}), { headers: this.headers });
        const f = o != null && o.download ? `&download=${o.download === !0 ? "" : o.download}` : "";
        return c = { signedUrl: encodeURI(`${this.url}${c.signedURL}${f}`) }, { data: c, error: null };
      } catch (u) {
        if (this.shouldThrowOnError)
          throw u;
        if (Tr(u))
          return { data: null, error: u };
        throw u;
      }
    });
  }
  /**
   * Creates multiple signed URLs. Use a signed URL to share a file for a fixed amount of time.
   *
   * @param paths The file paths to be downloaded, including the current file names. For example `['folder/image.png', 'folder2/image2.png']`.
   * @param expiresIn The number of seconds until the signed URLs expire. For example, `60` for URLs which are valid for one minute.
   * @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.
   */
  createSignedUrls(e, r, o) {
    return dt(this, void 0, void 0, function* () {
      try {
        const u = yield ks(this.fetch, `${this.url}/object/sign/${this.bucketId}`, { expiresIn: r, paths: e }, { headers: this.headers }), c = o != null && o.download ? `&download=${o.download === !0 ? "" : o.download}` : "";
        return {
          data: u.map((f) => Object.assign(Object.assign({}, f), { signedUrl: f.signedURL ? encodeURI(`${this.url}${f.signedURL}${c}`) : null })),
          error: null
        };
      } catch (u) {
        if (this.shouldThrowOnError)
          throw u;
        if (Tr(u))
          return { data: null, error: u };
        throw u;
      }
    });
  }
  /**
   * Downloads a file from a private bucket. For public buckets, make a request to the URL returned from `getPublicUrl` instead.
   *
   * @param path The full path and file name of the file to be downloaded. For example `folder/image.png`.
   * @param options.transform Transform the asset before serving it to the client.
   */
  download(e, r) {
    const u = typeof (r == null ? void 0 : r.transform) < "u" ? "render/image/authenticated" : "object", c = this.transformOptsToQueryString((r == null ? void 0 : r.transform) || {}), f = c ? `?${c}` : "", m = this._getFinalPath(e), y = () => ry(this.fetch, `${this.url}/${u}/${m}${f}`, {
      headers: this.headers,
      noResolveJson: !0
    });
    return new cW(y, this.shouldThrowOnError);
  }
  /**
   * Retrieves the details of an existing file.
   * @param path
   */
  info(e) {
    return dt(this, void 0, void 0, function* () {
      const r = this._getFinalPath(e);
      try {
        const o = yield ry(this.fetch, `${this.url}/object/info/${r}`, {
          headers: this.headers
        });
        return { data: _1(o), error: null };
      } catch (o) {
        if (this.shouldThrowOnError)
          throw o;
        if (Tr(o))
          return { data: null, error: o };
        throw o;
      }
    });
  }
  /**
   * Checks the existence of a file.
   * @param path
   */
  exists(e) {
    return dt(this, void 0, void 0, function* () {
      const r = this._getFinalPath(e);
      try {
        return yield lW(this.fetch, `${this.url}/object/${r}`, {
          headers: this.headers
        }), { data: !0, error: null };
      } catch (o) {
        if (this.shouldThrowOnError)
          throw o;
        if (Tr(o) && o instanceof S1) {
          const u = o.originalError;
          if ([400, 404].includes(u == null ? void 0 : u.status))
            return { data: !1, error: o };
        }
        throw o;
      }
    });
  }
  /**
   * A simple convenience function to get the URL for an asset in a public bucket. If you do not want to use this function, you can construct the public URL by concatenating the bucket URL with the path to the asset.
   * This function does not verify if the bucket is public. If a public URL is created for a bucket which is not public, you will not be able to download the asset.
   *
   * @param path The path and name of the file to generate the public URL for. For example `folder/image.png`.
   * @param options.download Triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.
   * @param options.transform Transform the asset before serving it to the client.
   */
  getPublicUrl(e, r) {
    const o = this._getFinalPath(e), u = [], c = r != null && r.download ? `download=${r.download === !0 ? "" : r.download}` : "";
    c !== "" && u.push(c);
    const m = typeof (r == null ? void 0 : r.transform) < "u" ? "render/image" : "object", y = this.transformOptsToQueryString((r == null ? void 0 : r.transform) || {});
    y !== "" && u.push(y);
    let b = u.join("&");
    return b !== "" && (b = `?${b}`), {
      data: { publicUrl: encodeURI(`${this.url}/${m}/public/${o}${b}`) }
    };
  }
  /**
   * Deletes files within the same bucket
   *
   * @param paths An array of files to delete, including the path and file name. For example [`'folder/image.png'`].
   */
  remove(e) {
    return dt(this, void 0, void 0, function* () {
      try {
        return { data: yield CT(this.fetch, `${this.url}/object/${this.bucketId}`, { prefixes: e }, { headers: this.headers }), error: null };
      } catch (r) {
        if (this.shouldThrowOnError)
          throw r;
        if (Tr(r))
          return { data: null, error: r };
        throw r;
      }
    });
  }
  /**
   * Get file metadata
   * @param id the file id to retrieve metadata
   */
  // async getMetadata(
  //   id: string
  // ): Promise<
  //   | {
  //       data: Metadata
  //       error: null
  //     }
  //   | {
  //       data: null
  //       error: StorageError
  //     }
  // > {
  //   try {
  //     const data = await get(this.fetch, `${this.url}/metadata/${id}`, { headers: this.headers })
  //     return { data, error: null }
  //   } catch (error) {
  //     if (isStorageError(error)) {
  //       return { data: null, error }
  //     }
  //     throw error
  //   }
  // }
  /**
   * Update file metadata
   * @param id the file id to update metadata
   * @param meta the new file metadata
   */
  // async updateMetadata(
  //   id: string,
  //   meta: Metadata
  // ): Promise<
  //   | {
  //       data: Metadata
  //       error: null
  //     }
  //   | {
  //       data: null
  //       error: StorageError
  //     }
  // > {
  //   try {
  //     const data = await post(
  //       this.fetch,
  //       `${this.url}/metadata/${id}`,
  //       { ...meta },
  //       { headers: this.headers }
  //     )
  //     return { data, error: null }
  //   } catch (error) {
  //     if (isStorageError(error)) {
  //       return { data: null, error }
  //     }
  //     throw error
  //   }
  // }
  /**
   * Lists all the files and folders within a path of the bucket.
   * @param path The folder path.
   * @param options Search options including limit (defaults to 100), offset, sortBy, and search
   */
  list(e, r, o) {
    return dt(this, void 0, void 0, function* () {
      try {
        const u = Object.assign(Object.assign(Object.assign({}, dW), r), { prefix: e || "" });
        return { data: yield ks(this.fetch, `${this.url}/object/list/${this.bucketId}`, u, { headers: this.headers }, o), error: null };
      } catch (u) {
        if (this.shouldThrowOnError)
          throw u;
        if (Tr(u))
          return { data: null, error: u };
        throw u;
      }
    });
  }
  /**
   * @experimental this method signature might change in the future
   * @param options search options
   * @param parameters
   */
  listV2(e, r) {
    return dt(this, void 0, void 0, function* () {
      try {
        const o = Object.assign({}, e);
        return { data: yield ks(this.fetch, `${this.url}/object/list-v2/${this.bucketId}`, o, { headers: this.headers }, r), error: null };
      } catch (o) {
        if (this.shouldThrowOnError)
          throw o;
        if (Tr(o))
          return { data: null, error: o };
        throw o;
      }
    });
  }
  encodeMetadata(e) {
    return JSON.stringify(e);
  }
  toBase64(e) {
    return typeof Buffer < "u" ? Buffer.from(e).toString("base64") : btoa(e);
  }
  _getFinalPath(e) {
    return `${this.bucketId}/${e.replace(/^\/+/, "")}`;
  }
  _removeEmptyFolders(e) {
    return e.replace(/^\/|\/$/g, "").replace(/\/+/g, "/");
  }
  transformOptsToQueryString(e) {
    const r = [];
    return e.width && r.push(`width=${e.width}`), e.height && r.push(`height=${e.height}`), e.resize && r.push(`resize=${e.resize}`), e.format && r.push(`format=${e.format}`), e.quality && r.push(`quality=${e.quality}`), r.join("&");
  }
}
const XM = "2.80.0", e2 = {
  "X-Client-Info": `storage-js/${XM}`
};
class hW {
  constructor(e, r = {}, o, u) {
    this.shouldThrowOnError = !1;
    const c = new URL(e);
    u != null && u.useNewHostname && /supabase\.(co|in|red)$/.test(c.hostname) && !c.hostname.includes("storage.supabase.") && (c.hostname = c.hostname.replace("supabase.", "storage.supabase.")), this.url = c.href.replace(/\/$/, ""), this.headers = Object.assign(Object.assign({}, e2), r), this.fetch = ET(o);
  }
  /**
   * Enable throwing errors instead of returning them.
   */
  throwOnError() {
    return this.shouldThrowOnError = !0, this;
  }
  /**
   * Retrieves the details of all Storage buckets within an existing project.
   */
  listBuckets(e) {
    return dt(this, void 0, void 0, function* () {
      try {
        const r = this.listBucketOptionsToQueryString(e);
        return {
          data: yield ry(this.fetch, `${this.url}/bucket${r}`, {
            headers: this.headers
          }), error: null
        };
      } catch (r) {
        if (this.shouldThrowOnError)
          throw r;
        if (Tr(r))
          return { data: null, error: r };
        throw r;
      }
    });
  }
  /**
   * Retrieves the details of an existing Storage bucket.
   *
   * @param id The unique identifier of the bucket you would like to retrieve.
   */
  getBucket(e) {
    return dt(this, void 0, void 0, function* () {
      try {
        return { data: yield ry(this.fetch, `${this.url}/bucket/${e}`, { headers: this.headers }), error: null };
      } catch (r) {
        if (this.shouldThrowOnError)
          throw r;
        if (Tr(r))
          return { data: null, error: r };
        throw r;
      }
    });
  }
  /**
   * Creates a new Storage bucket
   *
   * @param id A unique identifier for the bucket you are creating.
   * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations. By default, buckets are private.
   * @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.
   * The global file size limit takes precedence over this value.
   * The default value is null, which doesn't set a per bucket file size limit.
   * @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.
   * The default value is null, which allows files with all mime types to be uploaded.
   * Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.
   * @returns newly created bucket id
   * @param options.type (private-beta) specifies the bucket type. see `BucketType` for more details.
   *   - default bucket type is `STANDARD`
   */
  createBucket(e) {
    return dt(this, arguments, void 0, function* (r, o = {
      public: !1
    }) {
      try {
        return {
          data: yield ks(this.fetch, `${this.url}/bucket`, {
            id: r,
            name: r,
            type: o.type,
            public: o.public,
            file_size_limit: o.fileSizeLimit,
            allowed_mime_types: o.allowedMimeTypes
          }, { headers: this.headers }), error: null
        };
      } catch (u) {
        if (this.shouldThrowOnError)
          throw u;
        if (Tr(u))
          return { data: null, error: u };
        throw u;
      }
    });
  }
  /**
   * Updates a Storage bucket
   *
   * @param id A unique identifier for the bucket you are updating.
   * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations.
   * @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.
   * The global file size limit takes precedence over this value.
   * The default value is null, which doesn't set a per bucket file size limit.
   * @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.
   * The default value is null, which allows files with all mime types to be uploaded.
   * Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.
   */
  updateBucket(e, r) {
    return dt(this, void 0, void 0, function* () {
      try {
        return {
          data: yield E1(this.fetch, `${this.url}/bucket/${e}`, {
            id: e,
            name: e,
            public: r.public,
            file_size_limit: r.fileSizeLimit,
            allowed_mime_types: r.allowedMimeTypes
          }, { headers: this.headers }), error: null
        };
      } catch (o) {
        if (this.shouldThrowOnError)
          throw o;
        if (Tr(o))
          return { data: null, error: o };
        throw o;
      }
    });
  }
  /**
   * Removes all objects inside a single bucket.
   *
   * @param id The unique identifier of the bucket you would like to empty.
   */
  emptyBucket(e) {
    return dt(this, void 0, void 0, function* () {
      try {
        return { data: yield ks(this.fetch, `${this.url}/bucket/${e}/empty`, {}, { headers: this.headers }), error: null };
      } catch (r) {
        if (this.shouldThrowOnError)
          throw r;
        if (Tr(r))
          return { data: null, error: r };
        throw r;
      }
    });
  }
  /**
   * Deletes an existing bucket. A bucket can't be deleted with existing objects inside it.
   * You must first `empty()` the bucket.
   *
   * @param id The unique identifier of the bucket you would like to delete.
   */
  deleteBucket(e) {
    return dt(this, void 0, void 0, function* () {
      try {
        return { data: yield CT(this.fetch, `${this.url}/bucket/${e}`, {}, { headers: this.headers }), error: null };
      } catch (r) {
        if (this.shouldThrowOnError)
          throw r;
        if (Tr(r))
          return { data: null, error: r };
        throw r;
      }
    });
  }
  listBucketOptionsToQueryString(e) {
    const r = {};
    return e && ("limit" in e && (r.limit = String(e.limit)), "offset" in e && (r.offset = String(e.offset)), e.search && (r.search = e.search), e.sortColumn && (r.sortColumn = e.sortColumn), e.sortOrder && (r.sortOrder = e.sortOrder)), Object.keys(r).length > 0 ? "?" + new URLSearchParams(r).toString() : "";
  }
}
class pW {
  /**
   * Creates a new StorageAnalyticsApi instance
   * @param url - The base URL for the storage API
   * @param headers - HTTP headers to include in requests
   * @param fetch - Optional custom fetch implementation
   */
  constructor(e, r = {}, o) {
    this.shouldThrowOnError = !1, this.url = e.replace(/\/$/, ""), this.headers = Object.assign(Object.assign({}, e2), r), this.fetch = ET(o);
  }
  /**
   * Enable throwing errors instead of returning them in the response
   * When enabled, failed operations will throw instead of returning { data: null, error }
   *
   * @returns This instance for method chaining
   */
  throwOnError() {
    return this.shouldThrowOnError = !0, this;
  }
  /**
   * Creates a new analytics bucket using Iceberg tables
   * Analytics buckets are optimized for analytical queries and data processing
   *
   * @param name A unique name for the bucket you are creating
   * @returns Promise with newly created bucket name or error
   *
   * @example
   * ```typescript
   * const { data, error } = await storage.analytics.createBucket('analytics-data')
   * if (error) {
   *   console.error('Failed to create analytics bucket:', error.message)
   * } else {
   *   console.log('Created bucket:', data.name)
   * }
   * ```
   */
  createBucket(e) {
    return dt(this, void 0, void 0, function* () {
      try {
        return { data: yield ks(this.fetch, `${this.url}/bucket`, { name: e }, { headers: this.headers }), error: null };
      } catch (r) {
        if (this.shouldThrowOnError)
          throw r;
        if (Tr(r))
          return { data: null, error: r };
        throw r;
      }
    });
  }
  /**
   * Retrieves the details of all Analytics Storage buckets within an existing project
   * Only returns buckets of type 'ANALYTICS'
   *
   * @param options Query parameters for listing buckets
   * @param options.limit Maximum number of buckets to return
   * @param options.offset Number of buckets to skip
   * @param options.sortColumn Column to sort by ('id', 'name', 'created_at', 'updated_at')
   * @param options.sortOrder Sort order ('asc' or 'desc')
   * @param options.search Search term to filter bucket names
   * @returns Promise with list of analytics buckets or error
   *
   * @example
   * ```typescript
   * const { data, error } = await storage.analytics.listBuckets({
   *   limit: 10,
   *   offset: 0,
   *   sortColumn: 'created_at',
   *   sortOrder: 'desc',
   *   search: 'analytics'
   * })
   * if (data) {
   *   console.log('Found analytics buckets:', data.length)
   *   data.forEach(bucket => console.log(`- ${bucket.name}`))
   * }
   * ```
   */
  listBuckets(e) {
    return dt(this, void 0, void 0, function* () {
      try {
        const r = new URLSearchParams();
        (e == null ? void 0 : e.limit) !== void 0 && r.set("limit", e.limit.toString()), (e == null ? void 0 : e.offset) !== void 0 && r.set("offset", e.offset.toString()), e != null && e.sortColumn && r.set("sortColumn", e.sortColumn), e != null && e.sortOrder && r.set("sortOrder", e.sortOrder), e != null && e.search && r.set("search", e.search);
        const o = r.toString(), u = o ? `${this.url}/bucket?${o}` : `${this.url}/bucket`;
        return { data: yield ry(this.fetch, u, { headers: this.headers }), error: null };
      } catch (r) {
        if (this.shouldThrowOnError)
          throw r;
        if (Tr(r))
          return { data: null, error: r };
        throw r;
      }
    });
  }
  /**
   * Deletes an existing analytics bucket
   * A bucket can't be deleted with existing objects inside it
   * You must first empty the bucket before deletion
   *
   * @param bucketId The unique identifier of the bucket you would like to delete
   * @returns Promise with success message or error
   *
   * @example
   * ```typescript
   * const { data, error } = await analyticsApi.deleteBucket('old-analytics-bucket')
   * if (error) {
   *   console.error('Failed to delete bucket:', error.message)
   * } else {
   *   console.log('Bucket deleted successfully:', data.message)
   * }
   * ```
   */
  deleteBucket(e) {
    return dt(this, void 0, void 0, function* () {
      try {
        return { data: yield CT(this.fetch, `${this.url}/bucket/${e}`, {}, { headers: this.headers }), error: null };
      } catch (r) {
        if (this.shouldThrowOnError)
          throw r;
        if (Tr(r))
          return { data: null, error: r };
        throw r;
      }
    });
  }
}
const TT = {
  "X-Client-Info": `storage-js/${XM}`,
  "Content-Type": "application/json"
};
class t2 extends Error {
  constructor(e) {
    super(e), this.__isStorageVectorsError = !0, this.name = "StorageVectorsError";
  }
}
function yo(n) {
  return typeof n == "object" && n !== null && "__isStorageVectorsError" in n;
}
class NC extends t2 {
  constructor(e, r, o) {
    super(e), this.name = "StorageVectorsApiError", this.status = r, this.statusCode = o;
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status,
      statusCode: this.statusCode
    };
  }
}
class mW extends t2 {
  constructor(e, r) {
    super(e), this.name = "StorageVectorsUnknownError", this.originalError = r;
  }
}
var Uj;
(function (n) {
  n.InternalError = "InternalError", n.S3VectorConflictException = "S3VectorConflictException", n.S3VectorNotFoundException = "S3VectorNotFoundException", n.S3VectorBucketNotEmpty = "S3VectorBucketNotEmpty", n.S3VectorMaxBucketsExceeded = "S3VectorMaxBucketsExceeded", n.S3VectorMaxIndexesExceeded = "S3VectorMaxIndexesExceeded";
})(Uj || (Uj = {}));
const RT = (n) => n ? (...e) => n(...e) : (...e) => fetch(...e), vW = (n) => {
  if (typeof n != "object" || n === null)
    return !1;
  const e = Object.getPrototypeOf(n);
  return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(Symbol.toStringTag in n) && !(Symbol.iterator in n);
}, Fj = (n) => n.msg || n.message || n.error_description || n.error || JSON.stringify(n), gW = (n, e, r) => dt(void 0, void 0, void 0, function* () {
  if (n && typeof n == "object" && "status" in n && "ok" in n && typeof n.status == "number" && !(r != null && r.noResolveJson)) {
    const u = n.status || 500, c = n;
    if (typeof c.json == "function")
      c.json().then((f) => {
        const m = (f == null ? void 0 : f.statusCode) || (f == null ? void 0 : f.code) || u + "";
        e(new NC(Fj(f), u, m));
      }).catch(() => {
        const f = u + "", m = c.statusText || `HTTP ${u} error`;
        e(new NC(m, u, f));
      });
    else {
      const f = u + "", m = c.statusText || `HTTP ${u} error`;
      e(new NC(m, u, f));
    }
  } else
    e(new mW(Fj(n), n));
}), yW = (n, e, r, o) => {
  const u = { method: n, headers: (e == null ? void 0 : e.headers) || {} };
  return o ? (vW(o) ? (u.headers = Object.assign({ "Content-Type": "application/json" }, e == null ? void 0 : e.headers), u.body = JSON.stringify(o)) : u.body = o, Object.assign(Object.assign({}, u), r)) : u;
};
function bW(n, e, r, o, u, c) {
  return dt(this, void 0, void 0, function* () {
    return new Promise((f, m) => {
      n(r, yW(e, o, u, c)).then((y) => {
        if (!y.ok)
          throw y;
        if (o != null && o.noResolveJson)
          return y;
        const b = y.headers.get("content-type");
        return !b || !b.includes("application/json") ? {} : y.json();
      }).then((y) => f(y)).catch((y) => gW(y, m, o));
    });
  });
}
function bo(n, e, r, o, u) {
  return dt(this, void 0, void 0, function* () {
    return bW(n, "POST", e, o, u, r);
  });
}
class wW {
  constructor(e, r = {}, o) {
    this.shouldThrowOnError = !1, this.url = e.replace(/\/$/, ""), this.headers = Object.assign(Object.assign({}, TT), r), this.fetch = RT(o);
  }
  /**
   * Enable throwing errors instead of returning them in the response
   * When enabled, failed operations will throw instead of returning { data: null, error }
   *
   * @returns This instance for method chaining
   * @example
   * ```typescript
   * const client = new VectorIndexApi(url, headers)
   * client.throwOnError()
   * const { data } = await client.createIndex(options) // throws on error
   * ```
   */
  throwOnError() {
    return this.shouldThrowOnError = !0, this;
  }
  /**
   * Creates a new vector index within a bucket
   * Defines the schema for vectors including dimensionality, distance metric, and metadata config
   *
   * @param options - Index configuration
   * @param options.vectorBucketName - Name of the parent vector bucket
   * @param options.indexName - Unique name for the index within the bucket
   * @param options.dataType - Data type for vector components (currently only 'float32')
   * @param options.dimension - Dimensionality of vectors (e.g., 384, 768, 1536)
   * @param options.distanceMetric - Similarity metric ('cosine', 'euclidean', 'dotproduct')
   * @param options.metadataConfiguration - Optional config for non-filterable metadata keys
   * @returns Promise with empty response on success or error
   *
   * @throws {StorageVectorsApiError} With code:
   * - `S3VectorConflictException` if index already exists (HTTP 409)
   * - `S3VectorMaxIndexesExceeded` if quota exceeded (HTTP 400)
   * - `S3VectorNotFoundException` if bucket doesn't exist (HTTP 404)
   * - `InternalError` for server errors (HTTP 500)
   *
   * @example
   * ```typescript
   * const { data, error } = await client.createIndex({
   *   vectorBucketName: 'embeddings-prod',
   *   indexName: 'documents-openai-small',
   *   dataType: 'float32',
   *   dimension: 1536,
   *   distanceMetric: 'cosine',
   *   metadataConfiguration: {
   *     nonFilterableMetadataKeys: ['raw_text', 'internal_id']
   *   }
   * })
   * ```
   */
  createIndex(e) {
    return dt(this, void 0, void 0, function* () {
      try {
        return {
          data: (yield bo(this.fetch, `${this.url}/CreateIndex`, e, {
            headers: this.headers
          })) || {}, error: null
        };
      } catch (r) {
        if (this.shouldThrowOnError)
          throw r;
        if (yo(r))
          return { data: null, error: r };
        throw r;
      }
    });
  }
  /**
   * Retrieves metadata for a specific vector index
   * Returns index configuration including dimension, distance metric, and metadata settings
   *
   * @param vectorBucketName - Name of the parent vector bucket
   * @param indexName - Name of the index to retrieve
   * @returns Promise with index metadata or error
   *
   * @throws {StorageVectorsApiError} With code:
   * - `S3VectorNotFoundException` if index or bucket doesn't exist (HTTP 404)
   * - `InternalError` for server errors (HTTP 500)
   *
   * @example
   * ```typescript
   * const { data, error } = await client.getIndex('embeddings-prod', 'documents-openai-small')
   * if (data) {
   *   console.log('Index dimension:', data.index.dimension)
   *   console.log('Distance metric:', data.index.distanceMetric)
   * }
   * ```
   */
  getIndex(e, r) {
    return dt(this, void 0, void 0, function* () {
      try {
        return { data: yield bo(this.fetch, `${this.url}/GetIndex`, { vectorBucketName: e, indexName: r }, { headers: this.headers }), error: null };
      } catch (o) {
        if (this.shouldThrowOnError)
          throw o;
        if (yo(o))
          return { data: null, error: o };
        throw o;
      }
    });
  }
  /**
   * Lists vector indexes within a bucket with optional filtering and pagination
   * Supports prefix-based filtering and paginated results
   *
   * @param options - Listing options
   * @param options.vectorBucketName - Name of the parent vector bucket
   * @param options.prefix - Filter indexes by name prefix
   * @param options.maxResults - Maximum results per page (default: 100)
   * @param options.nextToken - Pagination token from previous response
   * @returns Promise with list of indexes and pagination token
   *
   * @throws {StorageVectorsApiError} With code:
   * - `S3VectorNotFoundException` if bucket doesn't exist (HTTP 404)
   * - `InternalError` for server errors (HTTP 500)
   *
   * @example
   * ```typescript
   * // List all indexes in a bucket
   * const { data, error } = await client.listIndexes({
   *   vectorBucketName: 'embeddings-prod',
   *   prefix: 'documents-'
   * })
   * if (data) {
   *   console.log('Found indexes:', data.indexes.map(i => i.indexName))
   *   // Fetch next page if available
   *   if (data.nextToken) {
   *     const next = await client.listIndexes({
   *       vectorBucketName: 'embeddings-prod',
   *       nextToken: data.nextToken
   *     })
   *   }
   * }
   * ```
   */
  listIndexes(e) {
    return dt(this, void 0, void 0, function* () {
      try {
        return {
          data: yield bo(this.fetch, `${this.url}/ListIndexes`, e, {
            headers: this.headers
          }), error: null
        };
      } catch (r) {
        if (this.shouldThrowOnError)
          throw r;
        if (yo(r))
          return { data: null, error: r };
        throw r;
      }
    });
  }
  /**
   * Deletes a vector index and all its data
   * This operation removes the index schema and all vectors stored in the index
   *
   * @param vectorBucketName - Name of the parent vector bucket
   * @param indexName - Name of the index to delete
   * @returns Promise with empty response on success or error
   *
   * @throws {StorageVectorsApiError} With code:
   * - `S3VectorNotFoundException` if index or bucket doesn't exist (HTTP 404)
   * - `InternalError` for server errors (HTTP 500)
   *
   * @example
   * ```typescript
   * // Delete an index and all its vectors
   * const { error } = await client.deleteIndex('embeddings-prod', 'old-index')
   * if (!error) {
   *   console.log('Index deleted successfully')
   * }
   * ```
   */
  deleteIndex(e, r) {
    return dt(this, void 0, void 0, function* () {
      try {
        return { data: (yield bo(this.fetch, `${this.url}/DeleteIndex`, { vectorBucketName: e, indexName: r }, { headers: this.headers })) || {}, error: null };
      } catch (o) {
        if (this.shouldThrowOnError)
          throw o;
        if (yo(o))
          return { data: null, error: o };
        throw o;
      }
    });
  }
}
class xW {
  constructor(e, r = {}, o) {
    this.shouldThrowOnError = !1, this.url = e.replace(/\/$/, ""), this.headers = Object.assign(Object.assign({}, TT), r), this.fetch = RT(o);
  }
  /**
   * Enable throwing errors instead of returning them in the response
   * When enabled, failed operations will throw instead of returning { data: null, error }
   *
   * @returns This instance for method chaining
   * @example
   * ```typescript
   * const client = new VectorDataApi(url, headers)
   * client.throwOnError()
   * const { data } = await client.putVectors(options) // throws on error
   * ```
   */
  throwOnError() {
    return this.shouldThrowOnError = !0, this;
  }
  /**
   * Inserts or updates vectors in batch (upsert operation)
   * Accepts 1-500 vectors per request. Larger batches should be split
   *
   * @param options - Vector insertion options
   * @param options.vectorBucketName - Name of the parent vector bucket
   * @param options.indexName - Name of the target index
   * @param options.vectors - Array of vectors to insert/update (1-500 items)
   * @returns Promise with empty response on success or error
   *
   * @throws {StorageVectorsApiError} With code:
   * - `S3VectorConflictException` if duplicate key conflict occurs (HTTP 409)
   * - `S3VectorNotFoundException` if bucket or index doesn't exist (HTTP 404)
   * - `InternalError` for server errors (HTTP 500)
   *
   * @example
   * ```typescript
   * const { data, error } = await client.putVectors({
   *   vectorBucketName: 'embeddings-prod',
   *   indexName: 'documents-openai-small',
   *   vectors: [
   *     {
   *       key: 'doc-1',
   *       data: { float32: [0.1, 0.2, 0.3, ...] }, // 1536 dimensions
   *       metadata: { title: 'Introduction', page: 1 }
   *     },
   *     {
   *       key: 'doc-2',
   *       data: { float32: [0.4, 0.5, 0.6, ...] },
   *       metadata: { title: 'Conclusion', page: 42 }
   *     }
   *   ]
   * })
   * ```
   */
  putVectors(e) {
    return dt(this, void 0, void 0, function* () {
      try {
        if (e.vectors.length < 1 || e.vectors.length > 500)
          throw new Error("Vector batch size must be between 1 and 500 items");
        return {
          data: (yield bo(this.fetch, `${this.url}/PutVectors`, e, {
            headers: this.headers
          })) || {}, error: null
        };
      } catch (r) {
        if (this.shouldThrowOnError)
          throw r;
        if (yo(r))
          return { data: null, error: r };
        throw r;
      }
    });
  }
  /**
   * Retrieves vectors by their keys in batch
   * Optionally includes vector data and/or metadata in response
   * Additional permissions required when returning data or metadata
   *
   * @param options - Vector retrieval options
   * @param options.vectorBucketName - Name of the parent vector bucket
   * @param options.indexName - Name of the index
   * @param options.keys - Array of vector keys to retrieve
   * @param options.returnData - Whether to include vector embeddings (requires permission)
   * @param options.returnMetadata - Whether to include metadata (requires permission)
   * @returns Promise with array of vectors or error
   *
   * @throws {StorageVectorsApiError} With code:
   * - `S3VectorNotFoundException` if bucket or index doesn't exist (HTTP 404)
   * - `InternalError` for server errors (HTTP 500)
   *
   * @example
   * ```typescript
   * const { data, error } = await client.getVectors({
   *   vectorBucketName: 'embeddings-prod',
   *   indexName: 'documents-openai-small',
   *   keys: ['doc-1', 'doc-2', 'doc-3'],
   *   returnData: false,     // Don't return embeddings
   *   returnMetadata: true   // Return metadata only
   * })
   * if (data) {
   *   data.vectors.forEach(v => console.log(v.key, v.metadata))
   * }
   * ```
   */
  getVectors(e) {
    return dt(this, void 0, void 0, function* () {
      try {
        return {
          data: yield bo(this.fetch, `${this.url}/GetVectors`, e, {
            headers: this.headers
          }), error: null
        };
      } catch (r) {
        if (this.shouldThrowOnError)
          throw r;
        if (yo(r))
          return { data: null, error: r };
        throw r;
      }
    });
  }
  /**
   * Lists/scans vectors in an index with pagination
   * Supports parallel scanning via segment configuration for high-throughput scenarios
   * Additional permissions required when returning data or metadata
   *
   * @param options - Vector listing options
   * @param options.vectorBucketName - Name of the parent vector bucket
   * @param options.indexName - Name of the index
   * @param options.maxResults - Maximum results per page (default: 500, max: 1000)
   * @param options.nextToken - Pagination token from previous response
   * @param options.returnData - Whether to include vector embeddings (requires permission)
   * @param options.returnMetadata - Whether to include metadata (requires permission)
   * @param options.segmentCount - Total parallel segments (1-16) for distributed scanning
   * @param options.segmentIndex - Zero-based segment index (0 to segmentCount-1)
   * @returns Promise with array of vectors, pagination token, or error
   *
   * @throws {StorageVectorsApiError} With code:
   * - `S3VectorNotFoundException` if bucket or index doesn't exist (HTTP 404)
   * - `InternalError` for server errors (HTTP 500)
   *
   * @example
   * ```typescript
   * // Simple pagination
   * let nextToken: string | undefined
   * do {
   *   const { data, error } = await client.listVectors({
   *     vectorBucketName: 'embeddings-prod',
   *     indexName: 'documents-openai-small',
   *     maxResults: 500,
   *     nextToken,
   *     returnMetadata: true
   *   })
   *   if (error) break
   *   console.log('Batch:', data.vectors.length)
   *   nextToken = data.nextToken
   * } while (nextToken)
   *
   * // Parallel scanning (4 concurrent workers)
   * const workers = [0, 1, 2, 3].map(async (segmentIndex) => {
   *   const { data } = await client.listVectors({
   *     vectorBucketName: 'embeddings-prod',
   *     indexName: 'documents-openai-small',
   *     segmentCount: 4,
   *     segmentIndex,
   *     returnMetadata: true
   *   })
   *   return data?.vectors || []
   * })
   * const results = await Promise.all(workers)
   * ```
   */
  listVectors(e) {
    return dt(this, void 0, void 0, function* () {
      try {
        if (e.segmentCount !== void 0) {
          if (e.segmentCount < 1 || e.segmentCount > 16)
            throw new Error("segmentCount must be between 1 and 16");
          if (e.segmentIndex !== void 0 && (e.segmentIndex < 0 || e.segmentIndex >= e.segmentCount))
            throw new Error(`segmentIndex must be between 0 and ${e.segmentCount - 1}`);
        }
        return {
          data: yield bo(this.fetch, `${this.url}/ListVectors`, e, {
            headers: this.headers
          }), error: null
        };
      } catch (r) {
        if (this.shouldThrowOnError)
          throw r;
        if (yo(r))
          return { data: null, error: r };
        throw r;
      }
    });
  }
  /**
   * Queries for similar vectors using approximate nearest neighbor (ANN) search
   * Returns top-K most similar vectors based on the configured distance metric
   * Supports optional metadata filtering (requires GetVectors permission)
   *
   * @param options - Query options
   * @param options.vectorBucketName - Name of the parent vector bucket
   * @param options.indexName - Name of the index
   * @param options.queryVector - Query embedding to find similar vectors
   * @param options.topK - Number of nearest neighbors to return (default: 10)
   * @param options.filter - Optional JSON filter for metadata (requires GetVectors permission)
   * @param options.returnDistance - Whether to include similarity distances
   * @param options.returnMetadata - Whether to include metadata (requires GetVectors permission)
   * @returns Promise with array of similar vectors ordered by distance
   *
   * @throws {StorageVectorsApiError} With code:
   * - `S3VectorNotFoundException` if bucket or index doesn't exist (HTTP 404)
   * - `InternalError` for server errors (HTTP 500)
   *
   * @example
   * ```typescript
   * // Semantic search with filtering
   * const { data, error } = await client.queryVectors({
   *   vectorBucketName: 'embeddings-prod',
   *   indexName: 'documents-openai-small',
   *   queryVector: { float32: [0.1, 0.2, 0.3, ...] }, // 1536 dimensions
   *   topK: 5,
   *   filter: {
   *     category: 'technical',
   *     published: true
   *   },
   *   returnDistance: true,
   *   returnMetadata: true
   * })
   * if (data) {
   *   data.matches.forEach(match => {
   *     console.log(`${match.key}: distance=${match.distance}`)
   *     console.log('Metadata:', match.metadata)
   *   })
   * }
   * ```
   */
  queryVectors(e) {
    return dt(this, void 0, void 0, function* () {
      try {
        return {
          data: yield bo(this.fetch, `${this.url}/QueryVectors`, e, {
            headers: this.headers
          }), error: null
        };
      } catch (r) {
        if (this.shouldThrowOnError)
          throw r;
        if (yo(r))
          return { data: null, error: r };
        throw r;
      }
    });
  }
  /**
   * Deletes vectors by their keys in batch
   * Accepts 1-500 keys per request
   *
   * @param options - Vector deletion options
   * @param options.vectorBucketName - Name of the parent vector bucket
   * @param options.indexName - Name of the index
   * @param options.keys - Array of vector keys to delete (1-500 items)
   * @returns Promise with empty response on success or error
   *
   * @throws {StorageVectorsApiError} With code:
   * - `S3VectorNotFoundException` if bucket or index doesn't exist (HTTP 404)
   * - `InternalError` for server errors (HTTP 500)
   *
   * @example
   * ```typescript
   * const { error } = await client.deleteVectors({
   *   vectorBucketName: 'embeddings-prod',
   *   indexName: 'documents-openai-small',
   *   keys: ['doc-1', 'doc-2', 'doc-3']
   * })
   * if (!error) {
   *   console.log('Vectors deleted successfully')
   * }
   * ```
   */
  deleteVectors(e) {
    return dt(this, void 0, void 0, function* () {
      try {
        if (e.keys.length < 1 || e.keys.length > 500)
          throw new Error("Keys batch size must be between 1 and 500 items");
        return {
          data: (yield bo(this.fetch, `${this.url}/DeleteVectors`, e, {
            headers: this.headers
          })) || {}, error: null
        };
      } catch (r) {
        if (this.shouldThrowOnError)
          throw r;
        if (yo(r))
          return { data: null, error: r };
        throw r;
      }
    });
  }
}
class SW {
  /**
   * Creates a new VectorBucketApi instance
   * @param url - The base URL for the storage vectors API
   * @param headers - HTTP headers to include in requests
   * @param fetch - Optional custom fetch implementation
   */
  constructor(e, r = {}, o) {
    this.shouldThrowOnError = !1, this.url = e.replace(/\/$/, ""), this.headers = Object.assign(Object.assign({}, TT), r), this.fetch = RT(o);
  }
  /**
   * Enable throwing errors instead of returning them in the response
   * When enabled, failed operations will throw instead of returning { data: null, error }
   *
   * @returns This instance for method chaining
   * @example
   * ```typescript
   * const client = new VectorBucketApi(url, headers)
   * client.throwOnError()
   * const { data } = await client.createBucket('my-bucket') // throws on error
   * ```
   */
  throwOnError() {
    return this.shouldThrowOnError = !0, this;
  }
  /**
   * Creates a new vector bucket
   * Vector buckets are containers for vector indexes and their data
   *
   * @param vectorBucketName - Unique name for the vector bucket
   * @returns Promise with empty response on success or error
   *
   * @throws {StorageVectorsApiError} With code:
   * - `S3VectorConflictException` if bucket already exists (HTTP 409)
   * - `S3VectorMaxBucketsExceeded` if quota exceeded (HTTP 400)
   * - `InternalError` for server errors (HTTP 500)
   *
   * @example
   * ```typescript
   * const { data, error } = await client.createBucket('embeddings-prod')
   * if (error) {
   *   console.error('Failed to create bucket:', error.message)
   * }
   * ```
   */
  createBucket(e) {
    return dt(this, void 0, void 0, function* () {
      try {
        return { data: (yield bo(this.fetch, `${this.url}/CreateVectorBucket`, { vectorBucketName: e }, { headers: this.headers })) || {}, error: null };
      } catch (r) {
        if (this.shouldThrowOnError)
          throw r;
        if (yo(r))
          return { data: null, error: r };
        throw r;
      }
    });
  }
  /**
   * Retrieves metadata for a specific vector bucket
   * Returns bucket configuration including encryption settings and creation time
   *
   * @param vectorBucketName - Name of the vector bucket to retrieve
   * @returns Promise with bucket metadata or error
   *
   * @throws {StorageVectorsApiError} With code:
   * - `S3VectorNotFoundException` if bucket doesn't exist (HTTP 404)
   * - `InternalError` for server errors (HTTP 500)
   *
   * @example
   * ```typescript
   * const { data, error } = await client.getBucket('embeddings-prod')
   * if (data) {
   *   console.log('Bucket created at:', new Date(data.vectorBucket.creationTime! * 1000))
   * }
   * ```
   */
  getBucket(e) {
    return dt(this, void 0, void 0, function* () {
      try {
        return { data: yield bo(this.fetch, `${this.url}/GetVectorBucket`, { vectorBucketName: e }, { headers: this.headers }), error: null };
      } catch (r) {
        if (this.shouldThrowOnError)
          throw r;
        if (yo(r))
          return { data: null, error: r };
        throw r;
      }
    });
  }
  /**
   * Lists vector buckets with optional filtering and pagination
   * Supports prefix-based filtering and paginated results
   *
   * @param options - Listing options
   * @param options.prefix - Filter buckets by name prefix
   * @param options.maxResults - Maximum results per page (default: 100)
   * @param options.nextToken - Pagination token from previous response
   * @returns Promise with list of buckets and pagination token
   *
   * @throws {StorageVectorsApiError} With code:
   * - `InternalError` for server errors (HTTP 500)
   *
   * @example
   * ```typescript
   * // List all buckets with prefix 'prod-'
   * const { data, error } = await client.listBuckets({ prefix: 'prod-' })
   * if (data) {
   *   console.log('Found buckets:', data.buckets.length)
   *   // Fetch next page if available
   *   if (data.nextToken) {
   *     const next = await client.listBuckets({ nextToken: data.nextToken })
   *   }
   * }
   * ```
   */
  listBuckets() {
    return dt(this, arguments, void 0, function* (e = {}) {
      try {
        return {
          data: yield bo(this.fetch, `${this.url}/ListVectorBuckets`, e, {
            headers: this.headers
          }), error: null
        };
      } catch (r) {
        if (this.shouldThrowOnError)
          throw r;
        if (yo(r))
          return { data: null, error: r };
        throw r;
      }
    });
  }
  /**
   * Deletes a vector bucket
   * Bucket must be empty before deletion (all indexes must be removed first)
   *
   * @param vectorBucketName - Name of the vector bucket to delete
   * @returns Promise with empty response on success or error
   *
   * @throws {StorageVectorsApiError} With code:
   * - `S3VectorBucketNotEmpty` if bucket contains indexes (HTTP 400)
   * - `S3VectorNotFoundException` if bucket doesn't exist (HTTP 404)
   * - `InternalError` for server errors (HTTP 500)
   *
   * @example
   * ```typescript
   * // Delete all indexes first, then delete bucket
   * const { error } = await client.deleteBucket('old-bucket')
   * if (error?.statusCode === 'S3VectorBucketNotEmpty') {
   *   console.error('Must delete all indexes first')
   * }
   * ```
   */
  deleteBucket(e) {
    return dt(this, void 0, void 0, function* () {
      try {
        return { data: (yield bo(this.fetch, `${this.url}/DeleteVectorBucket`, { vectorBucketName: e }, { headers: this.headers })) || {}, error: null };
      } catch (r) {
        if (this.shouldThrowOnError)
          throw r;
        if (yo(r))
          return { data: null, error: r };
        throw r;
      }
    });
  }
}
class _W extends SW {
  constructor(e, r = {}) {
    super(e, r.headers || {}, r.fetch);
  }
  /**
   * Access operations for a specific vector bucket
   * Returns a scoped client for index and vector operations within the bucket
   *
   * @param vectorBucketName - Name of the vector bucket
   * @returns Bucket-scoped client with index and vector operations
   *
   * @example
   * ```typescript
   * const bucket = client.bucket('embeddings-prod')
   *
   * // Create an index in this bucket
   * await bucket.createIndex({
   *   indexName: 'documents-openai',
   *   dataType: 'float32',
   *   dimension: 1536,
   *   distanceMetric: 'cosine'
   * })
   *
   * // List indexes in this bucket
   * const { data } = await bucket.listIndexes()
   * ```
   */
  from(e) {
    return new EW(this.url, this.headers, e, this.fetch);
  }
}
class EW extends wW {
  constructor(e, r, o, u) {
    super(e, r, u), this.vectorBucketName = o;
  }
  /**
   * Creates a new vector index in this bucket
   * Convenience method that automatically includes the bucket name
   *
   * @param options - Index configuration (vectorBucketName is automatically set)
   * @returns Promise with empty response on success or error
   *
   * @example
   * ```typescript
   * const bucket = client.bucket('embeddings-prod')
   * await bucket.createIndex({
   *   indexName: 'documents-openai',
   *   dataType: 'float32',
   *   dimension: 1536,
   *   distanceMetric: 'cosine',
   *   metadataConfiguration: {
   *     nonFilterableMetadataKeys: ['raw_text']
   *   }
   * })
   * ```
   */
  createIndex(e) {
    const r = Object.create(null, {
      createIndex: { get: () => super.createIndex }
    });
    return dt(this, void 0, void 0, function* () {
      return r.createIndex.call(this, Object.assign(Object.assign({}, e), { vectorBucketName: this.vectorBucketName }));
    });
  }
  /**
   * Lists indexes in this bucket
   * Convenience method that automatically includes the bucket name
   *
   * @param options - Listing options (vectorBucketName is automatically set)
   * @returns Promise with list of indexes or error
   *
   * @example
   * ```typescript
   * const bucket = client.bucket('embeddings-prod')
   * const { data } = await bucket.listIndexes({ prefix: 'documents-' })
   * ```
   */
  listIndexes() {
    const e = Object.create(null, {
      listIndexes: { get: () => super.listIndexes }
    });
    return dt(this, arguments, void 0, function* (r = {}) {
      return e.listIndexes.call(this, Object.assign(Object.assign({}, r), { vectorBucketName: this.vectorBucketName }));
    });
  }
  /**
   * Retrieves metadata for a specific index in this bucket
   * Convenience method that automatically includes the bucket name
   *
   * @param indexName - Name of the index to retrieve
   * @returns Promise with index metadata or error
   *
   * @example
   * ```typescript
   * const bucket = client.bucket('embeddings-prod')
   * const { data } = await bucket.getIndex('documents-openai')
   * console.log('Dimension:', data?.index.dimension)
   * ```
   */
  getIndex(e) {
    const r = Object.create(null, {
      getIndex: { get: () => super.getIndex }
    });
    return dt(this, void 0, void 0, function* () {
      return r.getIndex.call(this, this.vectorBucketName, e);
    });
  }
  /**
   * Deletes an index from this bucket
   * Convenience method that automatically includes the bucket name
   *
   * @param indexName - Name of the index to delete
   * @returns Promise with empty response on success or error
   *
   * @example
   * ```typescript
   * const bucket = client.bucket('embeddings-prod')
   * await bucket.deleteIndex('old-index')
   * ```
   */
  deleteIndex(e) {
    const r = Object.create(null, {
      deleteIndex: { get: () => super.deleteIndex }
    });
    return dt(this, void 0, void 0, function* () {
      return r.deleteIndex.call(this, this.vectorBucketName, e);
    });
  }
  /**
   * Access operations for a specific index within this bucket
   * Returns a scoped client for vector data operations
   *
   * @param indexName - Name of the index
   * @returns Index-scoped client with vector data operations
   *
   * @example
   * ```typescript
   * const index = client.bucket('embeddings-prod').index('documents-openai')
   *
   * // Insert vectors
   * await index.putVectors({
   *   vectors: [
   *     { key: 'doc-1', data: { float32: [...] }, metadata: { title: 'Intro' } }
   *   ]
   * })
   *
   * // Query similar vectors
   * const { data } = await index.queryVectors({
   *   queryVector: { float32: [...] },
   *   topK: 5
   * })
   * ```
   */
  index(e) {
    return new CW(this.url, this.headers, this.vectorBucketName, e, this.fetch);
  }
}
class CW extends xW {
  constructor(e, r, o, u, c) {
    super(e, r, c), this.vectorBucketName = o, this.indexName = u;
  }
  /**
   * Inserts or updates vectors in this index
   * Convenience method that automatically includes bucket and index names
   *
   * @param options - Vector insertion options (bucket and index names automatically set)
   * @returns Promise with empty response on success or error
   *
   * @example
   * ```typescript
   * const index = client.bucket('embeddings-prod').index('documents-openai')
   * await index.putVectors({
   *   vectors: [
   *     {
   *       key: 'doc-1',
   *       data: { float32: [0.1, 0.2, ...] },
   *       metadata: { title: 'Introduction', page: 1 }
   *     }
   *   ]
   * })
   * ```
   */
  putVectors(e) {
    const r = Object.create(null, {
      putVectors: { get: () => super.putVectors }
    });
    return dt(this, void 0, void 0, function* () {
      return r.putVectors.call(this, Object.assign(Object.assign({}, e), { vectorBucketName: this.vectorBucketName, indexName: this.indexName }));
    });
  }
  /**
   * Retrieves vectors by keys from this index
   * Convenience method that automatically includes bucket and index names
   *
   * @param options - Vector retrieval options (bucket and index names automatically set)
   * @returns Promise with array of vectors or error
   *
   * @example
   * ```typescript
   * const index = client.bucket('embeddings-prod').index('documents-openai')
   * const { data } = await index.getVectors({
   *   keys: ['doc-1', 'doc-2'],
   *   returnMetadata: true
   * })
   * ```
   */
  getVectors(e) {
    const r = Object.create(null, {
      getVectors: { get: () => super.getVectors }
    });
    return dt(this, void 0, void 0, function* () {
      return r.getVectors.call(this, Object.assign(Object.assign({}, e), { vectorBucketName: this.vectorBucketName, indexName: this.indexName }));
    });
  }
  /**
   * Lists vectors in this index with pagination
   * Convenience method that automatically includes bucket and index names
   *
   * @param options - Listing options (bucket and index names automatically set)
   * @returns Promise with array of vectors and pagination token
   *
   * @example
   * ```typescript
   * const index = client.bucket('embeddings-prod').index('documents-openai')
   * const { data } = await index.listVectors({
   *   maxResults: 500,
   *   returnMetadata: true
   * })
   * ```
   */
  listVectors() {
    const e = Object.create(null, {
      listVectors: { get: () => super.listVectors }
    });
    return dt(this, arguments, void 0, function* (r = {}) {
      return e.listVectors.call(this, Object.assign(Object.assign({}, r), { vectorBucketName: this.vectorBucketName, indexName: this.indexName }));
    });
  }
  /**
   * Queries for similar vectors in this index
   * Convenience method that automatically includes bucket and index names
   *
   * @param options - Query options (bucket and index names automatically set)
   * @returns Promise with array of similar vectors ordered by distance
   *
   * @example
   * ```typescript
   * const index = client.bucket('embeddings-prod').index('documents-openai')
   * const { data } = await index.queryVectors({
   *   queryVector: { float32: [0.1, 0.2, ...] },
   *   topK: 5,
   *   filter: { category: 'technical' },
   *   returnDistance: true,
   *   returnMetadata: true
   * })
   * ```
   */
  queryVectors(e) {
    const r = Object.create(null, {
      queryVectors: { get: () => super.queryVectors }
    });
    return dt(this, void 0, void 0, function* () {
      return r.queryVectors.call(this, Object.assign(Object.assign({}, e), { vectorBucketName: this.vectorBucketName, indexName: this.indexName }));
    });
  }
  /**
   * Deletes vectors by keys from this index
   * Convenience method that automatically includes bucket and index names
   *
   * @param options - Deletion options (bucket and index names automatically set)
   * @returns Promise with empty response on success or error
   *
   * @example
   * ```typescript
   * const index = client.bucket('embeddings-prod').index('documents-openai')
   * await index.deleteVectors({
   *   keys: ['doc-1', 'doc-2', 'doc-3']
   * })
   * ```
   */
  deleteVectors(e) {
    const r = Object.create(null, {
      deleteVectors: { get: () => super.deleteVectors }
    });
    return dt(this, void 0, void 0, function* () {
      return r.deleteVectors.call(this, Object.assign(Object.assign({}, e), { vectorBucketName: this.vectorBucketName, indexName: this.indexName }));
    });
  }
}
class TW extends hW {
  constructor(e, r = {}, o, u) {
    super(e, r, o, u);
  }
  /**
   * Perform file operation in a bucket.
   *
   * @param id The bucket id to operate on.
   */
  from(e) {
    return new fW(this.url, this.headers, e, this.fetch);
  }
  /**
   * Access vector storage operations.
   *
   * @returns A StorageVectorsClient instance configured with the current storage settings.
   */
  get vectors() {
    return new _W(this.url + "/vector", {
      headers: this.headers,
      fetch: this.fetch
    });
  }
  /**
   * Access analytics storage operations using Iceberg tables.
   *
   * @returns A StorageAnalyticsApi instance configured with the current storage settings.
   * @example
   * ```typescript
   * const client = createClient(url, key)
   * const analytics = client.storage.analytics
   *
   * // Create an analytics bucket
   * await analytics.createBucket('my-analytics-bucket')
   *
   * // List all analytics buckets
   * const { data: buckets } = await analytics.listBuckets()
   *
   * // Delete an analytics bucket
   * await analytics.deleteBucket('old-analytics-bucket')
   * ```
   */
  get analytics() {
    return new pW(this.url + "/iceberg", this.headers, this.fetch);
  }
}
const RW = "2.80.0";
let Bg = "";
typeof Deno < "u" ? Bg = "deno" : typeof document < "u" ? Bg = "web" : typeof navigator < "u" && navigator.product === "ReactNative" ? Bg = "react-native" : Bg = "node";
const kW = { "X-Client-Info": `supabase-js-${Bg}/${RW}` }, OW = {
  headers: kW
}, NW = {
  schema: "public"
}, jW = {
  autoRefreshToken: !0,
  persistSession: !0,
  detectSessionInUrl: !0,
  flowType: "implicit"
}, AW = {}, DW = (n) => n ? (...e) => n(...e) : (...e) => fetch(...e), PW = () => Headers, MW = (n, e, r) => {
  const o = DW(r), u = PW();
  return async (c, f) => {
    var m;
    const y = (m = await e()) !== null && m !== void 0 ? m : n;
    let b = new u(f == null ? void 0 : f.headers);
    return b.has("apikey") || b.set("apikey", n), b.has("Authorization") || b.set("Authorization", `Bearer ${y}`), o(c, Object.assign(Object.assign({}, f), { headers: b }));
  };
};
function LW(n) {
  return n.endsWith("/") ? n : n + "/";
}
function IW(n, e) {
  var r, o;
  const { db: u, auth: c, realtime: f, global: m } = n, { db: y, auth: b, realtime: _, global: T } = e, k = {
    db: Object.assign(Object.assign({}, y), u),
    auth: Object.assign(Object.assign({}, b), c),
    realtime: Object.assign(Object.assign({}, _), f),
    storage: {},
    global: Object.assign(Object.assign(Object.assign({}, T), m), { headers: Object.assign(Object.assign({}, (r = T == null ? void 0 : T.headers) !== null && r !== void 0 ? r : {}), (o = m == null ? void 0 : m.headers) !== null && o !== void 0 ? o : {}) }),
    accessToken: async () => ""
  };
  return n.accessToken ? k.accessToken = n.accessToken : delete k.accessToken, k;
}
function UW(n) {
  const e = n == null ? void 0 : n.trim();
  if (!e)
    throw new Error("supabaseUrl is required.");
  if (!e.match(/^https?:\/\//i))
    throw new Error("Invalid supabaseUrl: Must be a valid HTTP or HTTPS URL.");
  try {
    return new URL(LW(e));
  } catch {
    throw Error("Invalid supabaseUrl: Provided URL is malformed.");
  }
}
const n2 = "2.80.0", Kp = 30 * 1e3, C1 = 3, jC = C1 * Kp, FW = "http://localhost:9999", $W = "supabase.auth.token", zW = { "X-Client-Info": `gotrue-js/${n2}` }, T1 = "X-Supabase-Api-Version", r2 = {
  "2024-01-01": {
    timestamp: Date.parse("2024-01-01T00:00:00.0Z"),
    name: "2024-01-01"
  }
}, BW = /^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}$|[a-z0-9_-]{2}$)$/i, VW = 10 * 60 * 1e3;
class ay extends Error {
  constructor(e, r, o) {
    super(e), this.__isAuthError = !0, this.name = "AuthError", this.status = r, this.code = o;
  }
}
function mt(n) {
  return typeof n == "object" && n !== null && "__isAuthError" in n;
}
class HW extends ay {
  constructor(e, r, o) {
    super(e, r, o), this.name = "AuthApiError", this.status = r, this.code = o;
  }
}
function WW(n) {
  return mt(n) && n.name === "AuthApiError";
}
class kf extends ay {
  constructor(e, r) {
    super(e), this.name = "AuthUnknownError", this.originalError = r;
  }
}
class md extends ay {
  constructor(e, r, o, u) {
    super(e, o, u), this.name = r, this.status = o;
  }
}
class Ts extends md {
  constructor() {
    super("Auth session missing!", "AuthSessionMissingError", 400, void 0);
  }
}
function qW(n) {
  return mt(n) && n.name === "AuthSessionMissingError";
}
class Bp extends md {
  constructor() {
    super("Auth session or user missing", "AuthInvalidTokenResponseError", 500, void 0);
  }
}
class Mw extends md {
  constructor(e) {
    super(e, "AuthInvalidCredentialsError", 400, void 0);
  }
}
class Lw extends md {
  constructor(e, r = null) {
    super(e, "AuthImplicitGrantRedirectError", 500, void 0), this.details = null, this.details = r;
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status,
      details: this.details
    };
  }
}
function YW(n) {
  return mt(n) && n.name === "AuthImplicitGrantRedirectError";
}
class $j extends md {
  constructor(e, r = null) {
    super(e, "AuthPKCEGrantCodeExchangeError", 500, void 0), this.details = null, this.details = r;
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status,
      details: this.details
    };
  }
}
class R1 extends md {
  constructor(e, r) {
    super(e, "AuthRetryableFetchError", r, void 0);
  }
}
function AC(n) {
  return mt(n) && n.name === "AuthRetryableFetchError";
}
class zj extends md {
  constructor(e, r, o) {
    super(e, "AuthWeakPasswordError", r, "weak_password"), this.reasons = o;
  }
}
class k1 extends md {
  constructor(e) {
    super(e, "AuthInvalidJwtError", 400, "invalid_jwt");
  }
}
const ax = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_".split(""), Bj = ` 	
\r=`.split(""), KW = (() => {
    const n = new Array(128);
    for (let e = 0; e < n.length; e += 1)
      n[e] = -1;
    for (let e = 0; e < Bj.length; e += 1)
      n[Bj[e].charCodeAt(0)] = -2;
    for (let e = 0; e < ax.length; e += 1)
      n[ax[e].charCodeAt(0)] = e;
    return n;
  })();
function Vj(n, e, r) {
  if (n !== null)
    for (e.queue = e.queue << 8 | n, e.queuedBits += 8; e.queuedBits >= 6;) {
      const o = e.queue >> e.queuedBits - 6 & 63;
      r(ax[o]), e.queuedBits -= 6;
    }
  else if (e.queuedBits > 0)
    for (e.queue = e.queue << 6 - e.queuedBits, e.queuedBits = 6; e.queuedBits >= 6;) {
      const o = e.queue >> e.queuedBits - 6 & 63;
      r(ax[o]), e.queuedBits -= 6;
    }
}
function a2(n, e, r) {
  const o = KW[n];
  if (o > -1)
    for (e.queue = e.queue << 6 | o, e.queuedBits += 6; e.queuedBits >= 8;)
      r(e.queue >> e.queuedBits - 8 & 255), e.queuedBits -= 8;
  else {
    if (o === -2)
      return;
    throw new Error(`Invalid Base64-URL character "${String.fromCharCode(n)}"`);
  }
}
function Hj(n) {
  const e = [], r = (f) => {
    e.push(String.fromCodePoint(f));
  }, o = {
    utf8seq: 0,
    codepoint: 0
  }, u = { queue: 0, queuedBits: 0 }, c = (f) => {
    JW(f, o, r);
  };
  for (let f = 0; f < n.length; f += 1)
    a2(n.charCodeAt(f), u, c);
  return e.join("");
}
function GW(n, e) {
  if (n <= 127) {
    e(n);
    return;
  } else if (n <= 2047) {
    e(192 | n >> 6), e(128 | n & 63);
    return;
  } else if (n <= 65535) {
    e(224 | n >> 12), e(128 | n >> 6 & 63), e(128 | n & 63);
    return;
  } else if (n <= 1114111) {
    e(240 | n >> 18), e(128 | n >> 12 & 63), e(128 | n >> 6 & 63), e(128 | n & 63);
    return;
  }
  throw new Error(`Unrecognized Unicode codepoint: ${n.toString(16)}`);
}
function QW(n, e) {
  for (let r = 0; r < n.length; r += 1) {
    let o = n.charCodeAt(r);
    if (o > 55295 && o <= 56319) {
      const u = (o - 55296) * 1024 & 65535;
      o = (n.charCodeAt(r + 1) - 56320 & 65535 | u) + 65536, r += 1;
    }
    GW(o, e);
  }
}
function JW(n, e, r) {
  if (e.utf8seq === 0) {
    if (n <= 127) {
      r(n);
      return;
    }
    for (let o = 1; o < 6; o += 1)
      if (!(n >> 7 - o & 1)) {
        e.utf8seq = o;
        break;
      }
    if (e.utf8seq === 2)
      e.codepoint = n & 31;
    else if (e.utf8seq === 3)
      e.codepoint = n & 15;
    else if (e.utf8seq === 4)
      e.codepoint = n & 7;
    else
      throw new Error("Invalid UTF-8 sequence");
    e.utf8seq -= 1;
  } else if (e.utf8seq > 0) {
    if (n <= 127)
      throw new Error("Invalid UTF-8 sequence");
    e.codepoint = e.codepoint << 6 | n & 63, e.utf8seq -= 1, e.utf8seq === 0 && r(e.codepoint);
  }
}
function em(n) {
  const e = [], r = { queue: 0, queuedBits: 0 }, o = (u) => {
    e.push(u);
  };
  for (let u = 0; u < n.length; u += 1)
    a2(n.charCodeAt(u), r, o);
  return new Uint8Array(e);
}
function ZW(n) {
  const e = [];
  return QW(n, (r) => e.push(r)), new Uint8Array(e);
}
function Of(n) {
  const e = [], r = { queue: 0, queuedBits: 0 }, o = (u) => {
    e.push(u);
  };
  return n.forEach((u) => Vj(u, r, o)), Vj(null, r, o), e.join("");
}
function XW(n) {
  return Math.round(Date.now() / 1e3) + n;
}
function eq() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (n) {
    const e = Math.random() * 16 | 0;
    return (n == "x" ? e : e & 3 | 8).toString(16);
  });
}
const di = () => typeof window < "u" && typeof document < "u", _f = {
  tested: !1,
  writable: !1
}, i2 = () => {
  if (!di())
    return !1;
  try {
    if (typeof globalThis.localStorage != "object")
      return !1;
  } catch {
    return !1;
  }
  if (_f.tested)
    return _f.writable;
  const n = `lswt-${Math.random()}${Math.random()}`;
  try {
    globalThis.localStorage.setItem(n, n), globalThis.localStorage.removeItem(n), _f.tested = !0, _f.writable = !0;
  } catch {
    _f.tested = !0, _f.writable = !1;
  }
  return _f.writable;
};
function tq(n) {
  const e = {}, r = new URL(n);
  if (r.hash && r.hash[0] === "#")
    try {
      new URLSearchParams(r.hash.substring(1)).forEach((u, c) => {
        e[c] = u;
      });
    } catch {
    }
  return r.searchParams.forEach((o, u) => {
    e[u] = o;
  }), e;
}
const o2 = (n) => n ? (...e) => n(...e) : (...e) => fetch(...e), nq = (n) => typeof n == "object" && n !== null && "status" in n && "ok" in n && "json" in n && typeof n.json == "function", Gp = async (n, e, r) => {
  await n.setItem(e, JSON.stringify(r));
}, Ef = async (n, e) => {
  const r = await n.getItem(e);
  if (!r)
    return null;
  try {
    return JSON.parse(r);
  } catch {
    return r;
  }
}, Bc = async (n, e) => {
  await n.removeItem(e);
};
class Ax {
  constructor() {
    this.promise = new Ax.promiseConstructor((e, r) => {
      this.resolve = e, this.reject = r;
    });
  }
}
Ax.promiseConstructor = Promise;
function DC(n) {
  const e = n.split(".");
  if (e.length !== 3)
    throw new k1("Invalid JWT structure");
  for (let o = 0; o < e.length; o++)
    if (!BW.test(e[o]))
      throw new k1("JWT not in base64url format");
  return {
    // using base64url lib
    header: JSON.parse(Hj(e[0])),
    payload: JSON.parse(Hj(e[1])),
    signature: em(e[2]),
    raw: {
      header: e[0],
      payload: e[1]
    }
  };
}
async function rq(n) {
  return await new Promise((e) => {
    setTimeout(() => e(null), n);
  });
}
function aq(n, e) {
  return new Promise((o, u) => {
    (async () => {
      for (let c = 0; c < 1 / 0; c++)
        try {
          const f = await n(c);
          if (!e(c, null, f)) {
            o(f);
            return;
          }
        } catch (f) {
          if (!e(c, f)) {
            u(f);
            return;
          }
        }
    })();
  });
}
function iq(n) {
  return ("0" + n.toString(16)).substr(-2);
}
function oq() {
  const e = new Uint32Array(56);
  if (typeof crypto > "u") {
    const r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~", o = r.length;
    let u = "";
    for (let c = 0; c < 56; c++)
      u += r.charAt(Math.floor(Math.random() * o));
    return u;
  }
  return crypto.getRandomValues(e), Array.from(e, iq).join("");
}
async function sq(n) {
  const r = new TextEncoder().encode(n), o = await crypto.subtle.digest("SHA-256", r), u = new Uint8Array(o);
  return Array.from(u).map((c) => String.fromCharCode(c)).join("");
}
async function lq(n) {
  if (!(typeof crypto < "u" && typeof crypto.subtle < "u" && typeof TextEncoder < "u"))
    return console.warn("WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256."), n;
  const r = await sq(n);
  return btoa(r).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}
async function Vp(n, e, r = !1) {
  const o = oq();
  let u = o;
  r && (u += "/PASSWORD_RECOVERY"), await Gp(n, `${e}-code-verifier`, u);
  const c = await lq(o);
  return [c, o === c ? "plain" : "s256"];
}
const uq = /^2[0-9]{3}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])$/i;
function cq(n) {
  const e = n.headers.get(T1);
  if (!e || !e.match(uq))
    return null;
  try {
    return /* @__PURE__ */ new Date(`${e}T00:00:00.0Z`);
  } catch {
    return null;
  }
}
function dq(n) {
  if (!n)
    throw new Error("Missing exp claim");
  const e = Math.floor(Date.now() / 1e3);
  if (n <= e)
    throw new Error("JWT has expired");
}
function fq(n) {
  switch (n) {
    case "RS256":
      return {
        name: "RSASSA-PKCS1-v1_5",
        hash: { name: "SHA-256" }
      };
    case "ES256":
      return {
        name: "ECDSA",
        namedCurve: "P-256",
        hash: { name: "SHA-256" }
      };
    default:
      throw new Error("Invalid alg claim");
  }
}
const hq = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;
function Hp(n) {
  if (!hq.test(n))
    throw new Error("@supabase/auth-js: Expected parameter to be UUID but is not");
}
function PC() {
  const n = {};
  return new Proxy(n, {
    get: (e, r) => {
      if (r === "__isUserNotAvailableProxy")
        return !0;
      if (typeof r == "symbol") {
        const o = r.toString();
        if (o === "Symbol(Symbol.toPrimitive)" || o === "Symbol(Symbol.toStringTag)" || o === "Symbol(util.inspect.custom)")
          return;
      }
      throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Accessing the "${r}" property of the session object is not supported. Please use getUser() instead.`);
    },
    set: (e, r) => {
      throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Setting the "${r}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`);
    },
    deleteProperty: (e, r) => {
      throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Deleting the "${r}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`);
    }
  });
}
function pq(n, e) {
  return new Proxy(n, {
    get: (r, o, u) => {
      if (o === "__isInsecureUserWarningProxy")
        return !0;
      if (typeof o == "symbol") {
        const c = o.toString();
        if (c === "Symbol(Symbol.toPrimitive)" || c === "Symbol(Symbol.toStringTag)" || c === "Symbol(util.inspect.custom)" || c === "Symbol(nodejs.util.inspect.custom)")
          return Reflect.get(r, o, u);
      }
      return !e.value && typeof o == "string" && (console.warn("Using the user object as returned from supabase.auth.getSession() or from some supabase.auth.onAuthStateChange() events could be insecure! This value comes directly from the storage medium (usually cookies on the server) and may not be authentic. Use supabase.auth.getUser() instead which authenticates the data by contacting the Supabase Auth server."), e.value = !0), Reflect.get(r, o, u);
    }
  });
}
function Wj(n) {
  return JSON.parse(JSON.stringify(n));
}
const Cf = (n) => n.msg || n.message || n.error_description || n.error || JSON.stringify(n), mq = [502, 503, 504];
async function qj(n) {
  var e;
  if (!nq(n))
    throw new R1(Cf(n), 0);
  if (mq.includes(n.status))
    throw new R1(Cf(n), n.status);
  let r;
  try {
    r = await n.json();
  } catch (c) {
    throw new kf(Cf(c), c);
  }
  let o;
  const u = cq(n);
  if (u && u.getTime() >= r2["2024-01-01"].timestamp && typeof r == "object" && r && typeof r.code == "string" ? o = r.code : typeof r == "object" && r && typeof r.error_code == "string" && (o = r.error_code), o) {
    if (o === "weak_password")
      throw new zj(Cf(r), n.status, ((e = r.weak_password) === null || e === void 0 ? void 0 : e.reasons) || []);
    if (o === "session_not_found")
      throw new Ts();
  } else if (typeof r == "object" && r && typeof r.weak_password == "object" && r.weak_password && Array.isArray(r.weak_password.reasons) && r.weak_password.reasons.length && r.weak_password.reasons.reduce((c, f) => c && typeof f == "string", !0))
    throw new zj(Cf(r), n.status, r.weak_password.reasons);
  throw new HW(Cf(r), n.status || 500, o);
}
const vq = (n, e, r, o) => {
  const u = { method: n, headers: (e == null ? void 0 : e.headers) || {} };
  return n === "GET" ? u : (u.headers = Object.assign({ "Content-Type": "application/json;charset=UTF-8" }, e == null ? void 0 : e.headers), u.body = JSON.stringify(o), Object.assign(Object.assign({}, u), r));
};
async function jt(n, e, r, o) {
  var u;
  const c = Object.assign({}, o == null ? void 0 : o.headers);
  c[T1] || (c[T1] = r2["2024-01-01"].name), o != null && o.jwt && (c.Authorization = `Bearer ${o.jwt}`);
  const f = (u = o == null ? void 0 : o.query) !== null && u !== void 0 ? u : {};
  o != null && o.redirectTo && (f.redirect_to = o.redirectTo);
  const m = Object.keys(f).length ? "?" + new URLSearchParams(f).toString() : "", y = await gq(n, e, r + m, {
    headers: c,
    noResolveJson: o == null ? void 0 : o.noResolveJson
  }, {}, o == null ? void 0 : o.body);
  return o != null && o.xform ? o == null ? void 0 : o.xform(y) : { data: Object.assign({}, y), error: null };
}
async function gq(n, e, r, o, u, c) {
  const f = vq(e, o, u, c);
  let m;
  try {
    m = await n(r, Object.assign({}, f));
  } catch (y) {
    throw console.error(y), new R1(Cf(y), 0);
  }
  if (m.ok || await qj(m), o != null && o.noResolveJson)
    return m;
  try {
    return await m.json();
  } catch (y) {
    await qj(y);
  }
}
function Rs(n) {
  var e;
  let r = null;
  wq(n) && (r = Object.assign({}, n), n.expires_at || (r.expires_at = XW(n.expires_in)));
  const o = (e = n.user) !== null && e !== void 0 ? e : n;
  return { data: { session: r, user: o }, error: null };
}
function Yj(n) {
  const e = Rs(n);
  return !e.error && n.weak_password && typeof n.weak_password == "object" && Array.isArray(n.weak_password.reasons) && n.weak_password.reasons.length && n.weak_password.message && typeof n.weak_password.message == "string" && n.weak_password.reasons.reduce((r, o) => r && typeof o == "string", !0) && (e.data.weak_password = n.weak_password), e;
}
function Yc(n) {
  var e;
  return { data: { user: (e = n.user) !== null && e !== void 0 ? e : n }, error: null };
}
function yq(n) {
  return { data: n, error: null };
}
function bq(n) {
  const { action_link: e, email_otp: r, hashed_token: o, redirect_to: u, verification_type: c } = n, f = pd(n, ["action_link", "email_otp", "hashed_token", "redirect_to", "verification_type"]), m = {
    action_link: e,
    email_otp: r,
    hashed_token: o,
    redirect_to: u,
    verification_type: c
  }, y = Object.assign({}, f);
  return {
    data: {
      properties: m,
      user: y
    },
    error: null
  };
}
function Kj(n) {
  return n;
}
function wq(n) {
  return n.access_token && n.refresh_token && n.expires_in;
}
const MC = ["global", "local", "others"];
class xq {
  constructor({ url: e = "", headers: r = {}, fetch: o }) {
    this.url = e, this.headers = r, this.fetch = o2(o), this.mfa = {
      listFactors: this._listFactors.bind(this),
      deleteFactor: this._deleteFactor.bind(this)
    }, this.oauth = {
      listClients: this._listOAuthClients.bind(this),
      createClient: this._createOAuthClient.bind(this),
      getClient: this._getOAuthClient.bind(this),
      updateClient: this._updateOAuthClient.bind(this),
      deleteClient: this._deleteOAuthClient.bind(this),
      regenerateClientSecret: this._regenerateOAuthClientSecret.bind(this)
    };
  }
  /**
   * Removes a logged-in session.
   * @param jwt A valid, logged-in JWT.
   * @param scope The logout sope.
   */
  async signOut(e, r = MC[0]) {
    if (MC.indexOf(r) < 0)
      throw new Error(`@supabase/auth-js: Parameter scope must be one of ${MC.join(", ")}`);
    try {
      return await jt(this.fetch, "POST", `${this.url}/logout?scope=${r}`, {
        headers: this.headers,
        jwt: e,
        noResolveJson: !0
      }), { data: null, error: null };
    } catch (o) {
      if (mt(o))
        return { data: null, error: o };
      throw o;
    }
  }
  /**
   * Sends an invite link to an email address.
   * @param email The email address of the user.
   * @param options Additional options to be included when inviting.
   */
  async inviteUserByEmail(e, r = {}) {
    try {
      return await jt(this.fetch, "POST", `${this.url}/invite`, {
        body: { email: e, data: r.data },
        headers: this.headers,
        redirectTo: r.redirectTo,
        xform: Yc
      });
    } catch (o) {
      if (mt(o))
        return { data: { user: null }, error: o };
      throw o;
    }
  }
  /**
   * Generates email links and OTPs to be sent via a custom email provider.
   * @param email The user's email.
   * @param options.password User password. For signup only.
   * @param options.data Optional user metadata. For signup only.
   * @param options.redirectTo The redirect url which should be appended to the generated link
   */
  async generateLink(e) {
    try {
      const { options: r } = e, o = pd(e, ["options"]), u = Object.assign(Object.assign({}, o), r);
      return "newEmail" in o && (u.new_email = o == null ? void 0 : o.newEmail, delete u.newEmail), await jt(this.fetch, "POST", `${this.url}/admin/generate_link`, {
        body: u,
        headers: this.headers,
        xform: bq,
        redirectTo: r == null ? void 0 : r.redirectTo
      });
    } catch (r) {
      if (mt(r))
        return {
          data: {
            properties: null,
            user: null
          },
          error: r
        };
      throw r;
    }
  }
  // User Admin API
  /**
   * Creates a new user.
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async createUser(e) {
    try {
      return await jt(this.fetch, "POST", `${this.url}/admin/users`, {
        body: e,
        headers: this.headers,
        xform: Yc
      });
    } catch (r) {
      if (mt(r))
        return { data: { user: null }, error: r };
      throw r;
    }
  }
  /**
   * Get a list of users.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   * @param params An object which supports `page` and `perPage` as numbers, to alter the paginated results.
   */
  async listUsers(e) {
    var r, o, u, c, f, m, y;
    try {
      const b = { nextPage: null, lastPage: 0, total: 0 }, _ = await jt(this.fetch, "GET", `${this.url}/admin/users`, {
        headers: this.headers,
        noResolveJson: !0,
        query: {
          page: (o = (r = e == null ? void 0 : e.page) === null || r === void 0 ? void 0 : r.toString()) !== null && o !== void 0 ? o : "",
          per_page: (c = (u = e == null ? void 0 : e.perPage) === null || u === void 0 ? void 0 : u.toString()) !== null && c !== void 0 ? c : ""
        },
        xform: Kj
      });
      if (_.error)
        throw _.error;
      const T = await _.json(), k = (f = _.headers.get("x-total-count")) !== null && f !== void 0 ? f : 0, C = (y = (m = _.headers.get("link")) === null || m === void 0 ? void 0 : m.split(",")) !== null && y !== void 0 ? y : [];
      return C.length > 0 && (C.forEach((M) => {
        const N = parseInt(M.split(";")[0].split("=")[1].substring(0, 1)), A = JSON.parse(M.split(";")[1].split("=")[1]);
        b[`${A}Page`] = N;
      }), b.total = parseInt(k)), { data: Object.assign(Object.assign({}, T), b), error: null };
    } catch (b) {
      if (mt(b))
        return { data: { users: [] }, error: b };
      throw b;
    }
  }
  /**
   * Get user by id.
   *
   * @param uid The user's unique identifier
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async getUserById(e) {
    Hp(e);
    try {
      return await jt(this.fetch, "GET", `${this.url}/admin/users/${e}`, {
        headers: this.headers,
        xform: Yc
      });
    } catch (r) {
      if (mt(r))
        return { data: { user: null }, error: r };
      throw r;
    }
  }
  /**
   * Updates the user data.
   *
   * @param attributes The data you want to update.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async updateUserById(e, r) {
    Hp(e);
    try {
      return await jt(this.fetch, "PUT", `${this.url}/admin/users/${e}`, {
        body: r,
        headers: this.headers,
        xform: Yc
      });
    } catch (o) {
      if (mt(o))
        return { data: { user: null }, error: o };
      throw o;
    }
  }
  /**
   * Delete a user. Requires a `service_role` key.
   *
   * @param id The user id you want to remove.
   * @param shouldSoftDelete If true, then the user will be soft-deleted from the auth schema. Soft deletion allows user identification from the hashed user ID but is not reversible.
   * Defaults to false for backward compatibility.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async deleteUser(e, r = !1) {
    Hp(e);
    try {
      return await jt(this.fetch, "DELETE", `${this.url}/admin/users/${e}`, {
        headers: this.headers,
        body: {
          should_soft_delete: r
        },
        xform: Yc
      });
    } catch (o) {
      if (mt(o))
        return { data: { user: null }, error: o };
      throw o;
    }
  }
  async _listFactors(e) {
    Hp(e.userId);
    try {
      const { data: r, error: o } = await jt(this.fetch, "GET", `${this.url}/admin/users/${e.userId}/factors`, {
        headers: this.headers,
        xform: (u) => ({ data: { factors: u }, error: null })
      });
      return { data: r, error: o };
    } catch (r) {
      if (mt(r))
        return { data: null, error: r };
      throw r;
    }
  }
  async _deleteFactor(e) {
    Hp(e.userId), Hp(e.id);
    try {
      return {
        data: await jt(this.fetch, "DELETE", `${this.url}/admin/users/${e.userId}/factors/${e.id}`, {
          headers: this.headers
        }), error: null
      };
    } catch (r) {
      if (mt(r))
        return { data: null, error: r };
      throw r;
    }
  }
  /**
   * Lists all OAuth clients with optional pagination.
   * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async _listOAuthClients(e) {
    var r, o, u, c, f, m, y;
    try {
      const b = { nextPage: null, lastPage: 0, total: 0 }, _ = await jt(this.fetch, "GET", `${this.url}/admin/oauth/clients`, {
        headers: this.headers,
        noResolveJson: !0,
        query: {
          page: (o = (r = e == null ? void 0 : e.page) === null || r === void 0 ? void 0 : r.toString()) !== null && o !== void 0 ? o : "",
          per_page: (c = (u = e == null ? void 0 : e.perPage) === null || u === void 0 ? void 0 : u.toString()) !== null && c !== void 0 ? c : ""
        },
        xform: Kj
      });
      if (_.error)
        throw _.error;
      const T = await _.json(), k = (f = _.headers.get("x-total-count")) !== null && f !== void 0 ? f : 0, C = (y = (m = _.headers.get("link")) === null || m === void 0 ? void 0 : m.split(",")) !== null && y !== void 0 ? y : [];
      return C.length > 0 && (C.forEach((M) => {
        const N = parseInt(M.split(";")[0].split("=")[1].substring(0, 1)), A = JSON.parse(M.split(";")[1].split("=")[1]);
        b[`${A}Page`] = N;
      }), b.total = parseInt(k)), { data: Object.assign(Object.assign({}, T), b), error: null };
    } catch (b) {
      if (mt(b))
        return { data: { clients: [] }, error: b };
      throw b;
    }
  }
  /**
   * Creates a new OAuth client.
   * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async _createOAuthClient(e) {
    try {
      return await jt(this.fetch, "POST", `${this.url}/admin/oauth/clients`, {
        body: e,
        headers: this.headers,
        xform: (r) => ({ data: r, error: null })
      });
    } catch (r) {
      if (mt(r))
        return { data: null, error: r };
      throw r;
    }
  }
  /**
   * Gets details of a specific OAuth client.
   * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async _getOAuthClient(e) {
    try {
      return await jt(this.fetch, "GET", `${this.url}/admin/oauth/clients/${e}`, {
        headers: this.headers,
        xform: (r) => ({ data: r, error: null })
      });
    } catch (r) {
      if (mt(r))
        return { data: null, error: r };
      throw r;
    }
  }
  /**
   * Updates an existing OAuth client.
   * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async _updateOAuthClient(e, r) {
    try {
      return await jt(this.fetch, "PUT", `${this.url}/admin/oauth/clients/${e}`, {
        body: r,
        headers: this.headers,
        xform: (o) => ({ data: o, error: null })
      });
    } catch (o) {
      if (mt(o))
        return { data: null, error: o };
      throw o;
    }
  }
  /**
   * Deletes an OAuth client.
   * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async _deleteOAuthClient(e) {
    try {
      return await jt(this.fetch, "DELETE", `${this.url}/admin/oauth/clients/${e}`, {
        headers: this.headers,
        noResolveJson: !0
      }), { data: null, error: null };
    } catch (r) {
      if (mt(r))
        return { data: null, error: r };
      throw r;
    }
  }
  /**
   * Regenerates the secret for an OAuth client.
   * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async _regenerateOAuthClientSecret(e) {
    try {
      return await jt(this.fetch, "POST", `${this.url}/admin/oauth/clients/${e}/regenerate_secret`, {
        headers: this.headers,
        xform: (r) => ({ data: r, error: null })
      });
    } catch (r) {
      if (mt(r))
        return { data: null, error: r };
      throw r;
    }
  }
}
function Gj(n = {}) {
  return {
    getItem: (e) => n[e] || null,
    setItem: (e, r) => {
      n[e] = r;
    },
    removeItem: (e) => {
      delete n[e];
    }
  };
}
const Wp = {
  /**
   * @experimental
   */
  debug: !!(globalThis && i2() && globalThis.localStorage && globalThis.localStorage.getItem("supabase.gotrue-js.locks.debug") === "true")
};
class s2 extends Error {
  constructor(e) {
    super(e), this.isAcquireTimeout = !0;
  }
}
class Sq extends s2 {
}
async function _q(n, e, r) {
  Wp.debug && console.log("@supabase/gotrue-js: navigatorLock: acquire lock", n, e);
  const o = new globalThis.AbortController();
  return e > 0 && setTimeout(() => {
    o.abort(), Wp.debug && console.log("@supabase/gotrue-js: navigatorLock acquire timed out", n);
  }, e), await Promise.resolve().then(() => globalThis.navigator.locks.request(n, e === 0 ? {
    mode: "exclusive",
    ifAvailable: !0
  } : {
    mode: "exclusive",
    signal: o.signal
  }, async (u) => {
    if (u) {
      Wp.debug && console.log("@supabase/gotrue-js: navigatorLock: acquired", n, u.name);
      try {
        return await r();
      } finally {
        Wp.debug && console.log("@supabase/gotrue-js: navigatorLock: released", n, u.name);
      }
    } else {
      if (e === 0)
        throw Wp.debug && console.log("@supabase/gotrue-js: navigatorLock: not immediately available", n), new Sq(`Acquiring an exclusive Navigator LockManager lock "${n}" immediately failed`);
      if (Wp.debug)
        try {
          const c = await globalThis.navigator.locks.query();
          console.log("@supabase/gotrue-js: Navigator LockManager state", JSON.stringify(c, null, "  "));
        } catch (c) {
          console.warn("@supabase/gotrue-js: Error when querying Navigator LockManager state", c);
        }
      return console.warn("@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request"), await r();
    }
  }));
}
function Eq() {
  if (typeof globalThis != "object")
    try {
      Object.defineProperty(Object.prototype, "__magic__", {
        get: function () {
          return this;
        },
        configurable: !0
      }), __magic__.globalThis = __magic__, delete Object.prototype.__magic__;
    } catch {
      typeof self < "u" && (self.globalThis = self);
    }
}
function l2(n) {
  if (!/^0x[a-fA-F0-9]{40}$/.test(n))
    throw new Error(`@supabase/auth-js: Address "${n}" is invalid.`);
  return n.toLowerCase();
}
function Cq(n) {
  return parseInt(n, 16);
}
function Tq(n) {
  const e = new TextEncoder().encode(n);
  return "0x" + Array.from(e, (o) => o.toString(16).padStart(2, "0")).join("");
}
function Rq(n) {
  var e;
  const { chainId: r, domain: o, expirationTime: u, issuedAt: c = /* @__PURE__ */ new Date(), nonce: f, notBefore: m, requestId: y, resources: b, scheme: _, uri: T, version: k } = n;
  {
    if (!Number.isInteger(r))
      throw new Error(`@supabase/auth-js: Invalid SIWE message field "chainId". Chain ID must be a EIP-155 chain ID. Provided value: ${r}`);
    if (!o)
      throw new Error('@supabase/auth-js: Invalid SIWE message field "domain". Domain must be provided.');
    if (f && f.length < 8)
      throw new Error(`@supabase/auth-js: Invalid SIWE message field "nonce". Nonce must be at least 8 characters. Provided value: ${f}`);
    if (!T)
      throw new Error('@supabase/auth-js: Invalid SIWE message field "uri". URI must be provided.');
    if (k !== "1")
      throw new Error(`@supabase/auth-js: Invalid SIWE message field "version". Version must be '1'. Provided value: ${k}`);
    if (!((e = n.statement) === null || e === void 0) && e.includes(`
`))
      throw new Error(`@supabase/auth-js: Invalid SIWE message field "statement". Statement must not include '\\n'. Provided value: ${n.statement}`);
  }
  const C = l2(n.address), M = _ ? `${_}://${o}` : o, N = n.statement ? `${n.statement}
` : "", A = `${M} wants you to sign in with your Ethereum account:
${C}

${N}`;
  let $ = `URI: ${T}
Version: ${k}
Chain ID: ${r}${f ? `
Nonce: ${f}` : ""}
Issued At: ${c.toISOString()}`;
  if (u && ($ += `
Expiration Time: ${u.toISOString()}`), m && ($ += `
Not Before: ${m.toISOString()}`), y && ($ += `
Request ID: ${y}`), b) {
    let I = `
Resources:`;
    for (const U of b) {
      if (!U || typeof U != "string")
        throw new Error(`@supabase/auth-js: Invalid SIWE message field "resources". Every resource must be a valid string. Provided value: ${U}`);
      I += `
- ${U}`;
    }
    $ += I;
  }
  return `${A}
${$}`;
}
class ra extends Error {
  constructor({ message: e, code: r, cause: o, name: u }) {
    var c;
    super(e, { cause: o }), this.__isWebAuthnError = !0, this.name = (c = u ?? (o instanceof Error ? o.name : void 0)) !== null && c !== void 0 ? c : "Unknown Error", this.code = r;
  }
}
class ix extends ra {
  constructor(e, r) {
    super({
      code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
      cause: r,
      message: e
    }), this.name = "WebAuthnUnknownError", this.originalError = r;
  }
}
function kq({ error: n, options: e }) {
  var r, o, u;
  const { publicKey: c } = e;
  if (!c)
    throw Error("options was missing required publicKey property");
  if (n.name === "AbortError") {
    if (e.signal instanceof AbortSignal)
      return new ra({
        message: "Registration ceremony was sent an abort signal",
        code: "ERROR_CEREMONY_ABORTED",
        cause: n
      });
  } else if (n.name === "ConstraintError") {
    if (((r = c.authenticatorSelection) === null || r === void 0 ? void 0 : r.requireResidentKey) === !0)
      return new ra({
        message: "Discoverable credentials were required but no available authenticator supported it",
        code: "ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT",
        cause: n
      });
    if (
      // @ts-ignore: `mediation` doesn't yet exist on CredentialCreationOptions but it's possible as of Sept 2024
      e.mediation === "conditional" && ((o = c.authenticatorSelection) === null || o === void 0 ? void 0 : o.userVerification) === "required"
    )
      return new ra({
        message: "User verification was required during automatic registration but it could not be performed",
        code: "ERROR_AUTO_REGISTER_USER_VERIFICATION_FAILURE",
        cause: n
      });
    if (((u = c.authenticatorSelection) === null || u === void 0 ? void 0 : u.userVerification) === "required")
      return new ra({
        message: "User verification was required but no available authenticator supported it",
        code: "ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT",
        cause: n
      });
  } else {
    if (n.name === "InvalidStateError")
      return new ra({
        message: "The authenticator was previously registered",
        code: "ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED",
        cause: n
      });
    if (n.name === "NotAllowedError")
      return new ra({
        message: n.message,
        code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
        cause: n
      });
    if (n.name === "NotSupportedError")
      return c.pubKeyCredParams.filter((m) => m.type === "public-key").length === 0 ? new ra({
        message: 'No entry in pubKeyCredParams was of type "public-key"',
        code: "ERROR_MALFORMED_PUBKEYCREDPARAMS",
        cause: n
      }) : new ra({
        message: "No available authenticator supported any of the specified pubKeyCredParams algorithms",
        code: "ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG",
        cause: n
      });
    if (n.name === "SecurityError") {
      const f = window.location.hostname;
      if (u2(f)) {
        if (c.rp.id !== f)
          return new ra({
            message: `The RP ID "${c.rp.id}" is invalid for this domain`,
            code: "ERROR_INVALID_RP_ID",
            cause: n
          });
      } else return new ra({
        message: `${window.location.hostname} is an invalid domain`,
        code: "ERROR_INVALID_DOMAIN",
        cause: n
      });
    } else if (n.name === "TypeError") {
      if (c.user.id.byteLength < 1 || c.user.id.byteLength > 64)
        return new ra({
          message: "User ID was not between 1 and 64 characters",
          code: "ERROR_INVALID_USER_ID_LENGTH",
          cause: n
        });
    } else if (n.name === "UnknownError")
      return new ra({
        message: "The authenticator was unable to process the specified options, or could not create a new credential",
        code: "ERROR_AUTHENTICATOR_GENERAL_ERROR",
        cause: n
      });
  }
  return new ra({
    message: "a Non-Webauthn related error has occurred",
    code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
    cause: n
  });
}
function Oq({ error: n, options: e }) {
  const { publicKey: r } = e;
  if (!r)
    throw Error("options was missing required publicKey property");
  if (n.name === "AbortError") {
    if (e.signal instanceof AbortSignal)
      return new ra({
        message: "Authentication ceremony was sent an abort signal",
        code: "ERROR_CEREMONY_ABORTED",
        cause: n
      });
  } else {
    if (n.name === "NotAllowedError")
      return new ra({
        message: n.message,
        code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
        cause: n
      });
    if (n.name === "SecurityError") {
      const o = window.location.hostname;
      if (u2(o)) {
        if (r.rpId !== o)
          return new ra({
            message: `The RP ID "${r.rpId}" is invalid for this domain`,
            code: "ERROR_INVALID_RP_ID",
            cause: n
          });
      } else return new ra({
        message: `${window.location.hostname} is an invalid domain`,
        code: "ERROR_INVALID_DOMAIN",
        cause: n
      });
    } else if (n.name === "UnknownError")
      return new ra({
        message: "The authenticator was unable to process the specified options, or could not create a new assertion signature",
        code: "ERROR_AUTHENTICATOR_GENERAL_ERROR",
        cause: n
      });
  }
  return new ra({
    message: "a Non-Webauthn related error has occurred",
    code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
    cause: n
  });
}
class Nq {
  /**
   * Create an abort signal for a new WebAuthn operation.
   * Automatically cancels any existing operation.
   *
   * @returns {AbortSignal} Signal to pass to navigator.credentials.create() or .get()
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal MDN - AbortSignal}
   */
  createNewAbortSignal() {
    if (this.controller) {
      const r = new Error("Cancelling existing WebAuthn API call for new one");
      r.name = "AbortError", this.controller.abort(r);
    }
    const e = new AbortController();
    return this.controller = e, e.signal;
  }
  /**
   * Manually cancel the current WebAuthn operation.
   * Useful for cleaning up when user cancels or navigates away.
   *
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortController/abort MDN - AbortController.abort}
   */
  cancelCeremony() {
    if (this.controller) {
      const e = new Error("Manually cancelling existing WebAuthn API call");
      e.name = "AbortError", this.controller.abort(e), this.controller = void 0;
    }
  }
}
const jq = new Nq();
function Aq(n) {
  if (!n)
    throw new Error("Credential creation options are required");
  if (typeof PublicKeyCredential < "u" && "parseCreationOptionsFromJSON" in PublicKeyCredential && typeof PublicKeyCredential.parseCreationOptionsFromJSON == "function")
    return PublicKeyCredential.parseCreationOptionsFromJSON(
      /** we assert the options here as typescript still doesn't know about future webauthn types */
      n
    );
  const { challenge: e, user: r, excludeCredentials: o } = n, u = pd(
    n,
    ["challenge", "user", "excludeCredentials"]
  ), c = em(e).buffer, f = Object.assign(Object.assign({}, r), { id: em(r.id).buffer }), m = Object.assign(Object.assign({}, u), {
    challenge: c,
    user: f
  });
  if (o && o.length > 0) {
    m.excludeCredentials = new Array(o.length);
    for (let y = 0; y < o.length; y++) {
      const b = o[y];
      m.excludeCredentials[y] = Object.assign(Object.assign({}, b), {
        id: em(b.id).buffer,
        type: b.type || "public-key",
        // Cast transports to handle future transport types like "cable"
        transports: b.transports
      });
    }
  }
  return m;
}
function Dq(n) {
  if (!n)
    throw new Error("Credential request options are required");
  if (typeof PublicKeyCredential < "u" && "parseRequestOptionsFromJSON" in PublicKeyCredential && typeof PublicKeyCredential.parseRequestOptionsFromJSON == "function")
    return PublicKeyCredential.parseRequestOptionsFromJSON(n);
  const { challenge: e, allowCredentials: r } = n, o = pd(
    n,
    ["challenge", "allowCredentials"]
  ), u = em(e).buffer, c = Object.assign(Object.assign({}, o), { challenge: u });
  if (r && r.length > 0) {
    c.allowCredentials = new Array(r.length);
    for (let f = 0; f < r.length; f++) {
      const m = r[f];
      c.allowCredentials[f] = Object.assign(Object.assign({}, m), {
        id: em(m.id).buffer,
        type: m.type || "public-key",
        // Cast transports to handle future transport types like "cable"
        transports: m.transports
      });
    }
  }
  return c;
}
function Pq(n) {
  var e;
  if ("toJSON" in n && typeof n.toJSON == "function")
    return n.toJSON();
  const r = n;
  return {
    id: n.id,
    rawId: n.id,
    response: {
      attestationObject: Of(new Uint8Array(n.response.attestationObject)),
      clientDataJSON: Of(new Uint8Array(n.response.clientDataJSON))
    },
    type: "public-key",
    clientExtensionResults: n.getClientExtensionResults(),
    // Convert null to undefined and cast to AuthenticatorAttachment type
    authenticatorAttachment: (e = r.authenticatorAttachment) !== null && e !== void 0 ? e : void 0
  };
}
function Mq(n) {
  var e;
  if ("toJSON" in n && typeof n.toJSON == "function")
    return n.toJSON();
  const r = n, o = n.getClientExtensionResults(), u = n.response;
  return {
    id: n.id,
    rawId: n.id,
    // W3C spec expects rawId to match id for JSON format
    response: {
      authenticatorData: Of(new Uint8Array(u.authenticatorData)),
      clientDataJSON: Of(new Uint8Array(u.clientDataJSON)),
      signature: Of(new Uint8Array(u.signature)),
      userHandle: u.userHandle ? Of(new Uint8Array(u.userHandle)) : void 0
    },
    type: "public-key",
    clientExtensionResults: o,
    // Convert null to undefined and cast to AuthenticatorAttachment type
    authenticatorAttachment: (e = r.authenticatorAttachment) !== null && e !== void 0 ? e : void 0
  };
}
function u2(n) {
  return (
    // Consider localhost valid as well since it's okay wrt Secure Contexts
    n === "localhost" || /^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(n)
  );
}
function Qj() {
  var n, e;
  return !!(di() && "PublicKeyCredential" in window && window.PublicKeyCredential && "credentials" in navigator && typeof ((n = navigator == null ? void 0 : navigator.credentials) === null || n === void 0 ? void 0 : n.create) == "function" && typeof ((e = navigator == null ? void 0 : navigator.credentials) === null || e === void 0 ? void 0 : e.get) == "function");
}
async function Lq(n) {
  try {
    const e = await navigator.credentials.create(
      /** we assert the type here until typescript types are updated */
      n
    );
    return e ? e instanceof PublicKeyCredential ? { data: e, error: null } : {
      data: null,
      error: new ix("Browser returned unexpected credential type", e)
    } : {
      data: null,
      error: new ix("Empty credential response", e)
    };
  } catch (e) {
    return {
      data: null,
      error: kq({
        error: e,
        options: n
      })
    };
  }
}
async function Iq(n) {
  try {
    const e = await navigator.credentials.get(
      /** we assert the type here until typescript types are updated */
      n
    );
    return e ? e instanceof PublicKeyCredential ? { data: e, error: null } : {
      data: null,
      error: new ix("Browser returned unexpected credential type", e)
    } : {
      data: null,
      error: new ix("Empty credential response", e)
    };
  } catch (e) {
    return {
      data: null,
      error: Oq({
        error: e,
        options: n
      })
    };
  }
}
const Uq = {
  hints: ["security-key"],
  authenticatorSelection: {
    authenticatorAttachment: "cross-platform",
    requireResidentKey: !1,
    /** set to preferred because older yubikeys don't have PIN/Biometric */
    userVerification: "preferred",
    residentKey: "discouraged"
  },
  attestation: "none"
}, Fq = {
  /** set to preferred because older yubikeys don't have PIN/Biometric */
  userVerification: "preferred",
  hints: ["security-key"]
};
function ox(...n) {
  const e = (u) => u !== null && typeof u == "object" && !Array.isArray(u), r = (u) => u instanceof ArrayBuffer || ArrayBuffer.isView(u), o = {};
  for (const u of n)
    if (u)
      for (const c in u) {
        const f = u[c];
        if (f !== void 0)
          if (Array.isArray(f))
            o[c] = f;
          else if (r(f))
            o[c] = f;
          else if (e(f)) {
            const m = o[c];
            e(m) ? o[c] = ox(m, f) : o[c] = ox(f);
          } else
            o[c] = f;
      }
  return o;
}
function $q(n, e) {
  return ox(Uq, n, e || {});
}
function zq(n, e) {
  return ox(Fq, n, e || {});
}
class Bq {
  constructor(e) {
    this.client = e, this.enroll = this._enroll.bind(this), this.challenge = this._challenge.bind(this), this.verify = this._verify.bind(this), this.authenticate = this._authenticate.bind(this), this.register = this._register.bind(this);
  }
  /**
   * Enroll a new WebAuthn factor.
   * Creates an unverified WebAuthn factor that must be verified with a credential.
   *
   * @experimental This method is experimental and may change in future releases
   * @param {Omit<MFAEnrollWebauthnParams, 'factorType'>} params - Enrollment parameters (friendlyName required)
   * @returns {Promise<AuthMFAEnrollWebauthnResponse>} Enrolled factor details or error
   * @see {@link https://w3c.github.io/webauthn/#sctn-registering-a-new-credential W3C WebAuthn Spec - Registering a New Credential}
   */
  async _enroll(e) {
    return this.client.mfa.enroll(Object.assign(Object.assign({}, e), { factorType: "webauthn" }));
  }
  /**
   * Challenge for WebAuthn credential creation or authentication.
   * Combines server challenge with browser credential operations.
   * Handles both registration (create) and authentication (request) flows.
   *
   * @experimental This method is experimental and may change in future releases
   * @param {MFAChallengeWebauthnParams & { friendlyName?: string; signal?: AbortSignal }} params - Challenge parameters including factorId
   * @param {Object} overrides - Allows you to override the parameters passed to navigator.credentials
   * @param {PublicKeyCredentialCreationOptionsFuture} overrides.create - Override options for credential creation
   * @param {PublicKeyCredentialRequestOptionsFuture} overrides.request - Override options for credential request
   * @returns {Promise<RequestResult>} Challenge response with credential or error
   * @see {@link https://w3c.github.io/webauthn/#sctn-credential-creation W3C WebAuthn Spec - Credential Creation}
   * @see {@link https://w3c.github.io/webauthn/#sctn-verifying-assertion W3C WebAuthn Spec - Verifying Assertion}
   */
  async _challenge({ factorId: e, webauthn: r, friendlyName: o, signal: u }, c) {
    try {
      const { data: f, error: m } = await this.client.mfa.challenge({
        factorId: e,
        webauthn: r
      });
      if (!f)
        return { data: null, error: m };
      const y = u ?? jq.createNewAbortSignal();
      if (f.webauthn.type === "create") {
        const { user: b } = f.webauthn.credential_options.publicKey;
        b.name || (b.name = `${b.id}:${o}`), b.displayName || (b.displayName = b.name);
      }
      switch (f.webauthn.type) {
        case "create": {
          const b = $q(f.webauthn.credential_options.publicKey, c == null ? void 0 : c.create), { data: _, error: T } = await Lq({
            publicKey: b,
            signal: y
          });
          return _ ? {
            data: {
              factorId: e,
              challengeId: f.id,
              webauthn: {
                type: f.webauthn.type,
                credential_response: _
              }
            },
            error: null
          } : { data: null, error: T };
        }
        case "request": {
          const b = zq(f.webauthn.credential_options.publicKey, c == null ? void 0 : c.request), { data: _, error: T } = await Iq(Object.assign(Object.assign({}, f.webauthn.credential_options), { publicKey: b, signal: y }));
          return _ ? {
            data: {
              factorId: e,
              challengeId: f.id,
              webauthn: {
                type: f.webauthn.type,
                credential_response: _
              }
            },
            error: null
          } : { data: null, error: T };
        }
      }
    } catch (f) {
      return mt(f) ? { data: null, error: f } : {
        data: null,
        error: new kf("Unexpected error in challenge", f)
      };
    }
  }
  /**
   * Verify a WebAuthn credential with the server.
   * Completes the WebAuthn ceremony by sending the credential to the server for verification.
   *
   * @experimental This method is experimental and may change in future releases
   * @param {Object} params - Verification parameters
   * @param {string} params.challengeId - ID of the challenge being verified
   * @param {string} params.factorId - ID of the WebAuthn factor
   * @param {MFAVerifyWebauthnParams<T>['webauthn']} params.webauthn - WebAuthn credential response
   * @returns {Promise<AuthMFAVerifyResponse>} Verification result with session or error
   * @see {@link https://w3c.github.io/webauthn/#sctn-verifying-assertion W3C WebAuthn Spec - Verifying an Authentication Assertion}
   * */
  async _verify({ challengeId: e, factorId: r, webauthn: o }) {
    return this.client.mfa.verify({
      factorId: r,
      challengeId: e,
      webauthn: o
    });
  }
  /**
   * Complete WebAuthn authentication flow.
   * Performs challenge and verification in a single operation for existing credentials.
   *
   * @experimental This method is experimental and may change in future releases
   * @param {Object} params - Authentication parameters
   * @param {string} params.factorId - ID of the WebAuthn factor to authenticate with
   * @param {Object} params.webauthn - WebAuthn configuration
   * @param {string} params.webauthn.rpId - Relying Party ID (defaults to current hostname)
   * @param {string[]} params.webauthn.rpOrigins - Allowed origins (defaults to current origin)
   * @param {AbortSignal} params.webauthn.signal - Optional abort signal
   * @param {PublicKeyCredentialRequestOptionsFuture} overrides - Override options for navigator.credentials.get
   * @returns {Promise<RequestResult<AuthMFAVerifyResponseData, WebAuthnError | AuthError>>} Authentication result
   * @see {@link https://w3c.github.io/webauthn/#sctn-authentication W3C WebAuthn Spec - Authentication Ceremony}
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialRequestOptions MDN - PublicKeyCredentialRequestOptions}
   */
  async _authenticate({ factorId: e, webauthn: { rpId: r = typeof window < "u" ? window.location.hostname : void 0, rpOrigins: o = typeof window < "u" ? [window.location.origin] : void 0, signal: u } }, c) {
    if (!r)
      return {
        data: null,
        error: new ay("rpId is required for WebAuthn authentication")
      };
    try {
      if (!Qj())
        return {
          data: null,
          error: new kf("Browser does not support WebAuthn", null)
        };
      const { data: f, error: m } = await this.challenge({
        factorId: e,
        webauthn: { rpId: r, rpOrigins: o },
        signal: u
      }, { request: c });
      if (!f)
        return { data: null, error: m };
      const { webauthn: y } = f;
      return this._verify({
        factorId: e,
        challengeId: f.challengeId,
        webauthn: {
          type: y.type,
          rpId: r,
          rpOrigins: o,
          credential_response: y.credential_response
        }
      });
    } catch (f) {
      return mt(f) ? { data: null, error: f } : {
        data: null,
        error: new kf("Unexpected error in authenticate", f)
      };
    }
  }
  /**
   * Complete WebAuthn registration flow.
   * Performs enrollment, challenge, and verification in a single operation for new credentials.
   *
   * @experimental This method is experimental and may change in future releases
   * @param {Object} params - Registration parameters
   * @param {string} params.friendlyName - User-friendly name for the credential
   * @param {string} params.rpId - Relying Party ID (defaults to current hostname)
   * @param {string[]} params.rpOrigins - Allowed origins (defaults to current origin)
   * @param {AbortSignal} params.signal - Optional abort signal
   * @param {PublicKeyCredentialCreationOptionsFuture} overrides - Override options for navigator.credentials.create
   * @returns {Promise<RequestResult<AuthMFAVerifyResponseData, WebAuthnError | AuthError>>} Registration result
   * @see {@link https://w3c.github.io/webauthn/#sctn-registering-a-new-credential W3C WebAuthn Spec - Registration Ceremony}
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialCreationOptions MDN - PublicKeyCredentialCreationOptions}
   */
  async _register({ friendlyName: e, rpId: r = typeof window < "u" ? window.location.hostname : void 0, rpOrigins: o = typeof window < "u" ? [window.location.origin] : void 0, signal: u }, c) {
    if (!r)
      return {
        data: null,
        error: new ay("rpId is required for WebAuthn registration")
      };
    try {
      if (!Qj())
        return {
          data: null,
          error: new kf("Browser does not support WebAuthn", null)
        };
      const { data: f, error: m } = await this._enroll({
        friendlyName: e
      });
      if (!f)
        return await this.client.mfa.listFactors().then((_) => {
          var T;
          return (T = _.data) === null || T === void 0 ? void 0 : T.all.find((k) => k.factor_type === "webauthn" && k.friendly_name === e && k.status !== "unverified");
        }).then((_) => _ ? this.client.mfa.unenroll({ factorId: _ == null ? void 0 : _.id }) : void 0), { data: null, error: m };
      const { data: y, error: b } = await this._challenge({
        factorId: f.id,
        friendlyName: f.friendly_name,
        webauthn: { rpId: r, rpOrigins: o },
        signal: u
      }, {
        create: c
      });
      return y ? this._verify({
        factorId: f.id,
        challengeId: y.challengeId,
        webauthn: {
          rpId: r,
          rpOrigins: o,
          type: y.webauthn.type,
          credential_response: y.webauthn.credential_response
        }
      }) : { data: null, error: b };
    } catch (f) {
      return mt(f) ? { data: null, error: f } : {
        data: null,
        error: new kf("Unexpected error in register", f)
      };
    }
  }
}
Eq();
const Vq = {
  url: FW,
  storageKey: $W,
  autoRefreshToken: !0,
  persistSession: !0,
  detectSessionInUrl: !0,
  headers: zW,
  flowType: "implicit",
  debug: !1,
  hasCustomAuthorizationHeader: !1,
  throwOnError: !1
};
async function Jj(n, e, r) {
  return await r();
}
const qp = {};
class iy {
  /**
   * The JWKS used for verifying asymmetric JWTs
   */
  get jwks() {
    var e, r;
    return (r = (e = qp[this.storageKey]) === null || e === void 0 ? void 0 : e.jwks) !== null && r !== void 0 ? r : { keys: [] };
  }
  set jwks(e) {
    qp[this.storageKey] = Object.assign(Object.assign({}, qp[this.storageKey]), { jwks: e });
  }
  get jwks_cached_at() {
    var e, r;
    return (r = (e = qp[this.storageKey]) === null || e === void 0 ? void 0 : e.cachedAt) !== null && r !== void 0 ? r : Number.MIN_SAFE_INTEGER;
  }
  set jwks_cached_at(e) {
    qp[this.storageKey] = Object.assign(Object.assign({}, qp[this.storageKey]), { cachedAt: e });
  }
  /**
   * Create a new client for use in the browser.
   */
  constructor(e) {
    var r, o, u;
    this.userStorage = null, this.memoryStorage = null, this.stateChangeEmitters = /* @__PURE__ */ new Map(), this.autoRefreshTicker = null, this.visibilityChangedCallback = null, this.refreshingDeferred = null, this.initializePromise = null, this.detectSessionInUrl = !0, this.hasCustomAuthorizationHeader = !1, this.suppressGetSessionWarning = !1, this.lockAcquired = !1, this.pendingInLock = [], this.broadcastChannel = null, this.logger = console.log;
    const c = Object.assign(Object.assign({}, Vq), e);
    if (this.storageKey = c.storageKey, this.instanceID = (r = iy.nextInstanceID[this.storageKey]) !== null && r !== void 0 ? r : 0, iy.nextInstanceID[this.storageKey] = this.instanceID + 1, this.logDebugMessages = !!c.debug, typeof c.debug == "function" && (this.logger = c.debug), this.instanceID > 0 && di()) {
      const f = `${this._logPrefix()} Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.`;
      console.warn(f), this.logDebugMessages && console.trace(f);
    }
    if (this.persistSession = c.persistSession, this.autoRefreshToken = c.autoRefreshToken, this.admin = new xq({
      url: c.url,
      headers: c.headers,
      fetch: c.fetch
    }), this.url = c.url, this.headers = c.headers, this.fetch = o2(c.fetch), this.lock = c.lock || Jj, this.detectSessionInUrl = c.detectSessionInUrl, this.flowType = c.flowType, this.hasCustomAuthorizationHeader = c.hasCustomAuthorizationHeader, this.throwOnError = c.throwOnError, c.lock ? this.lock = c.lock : di() && (!((o = globalThis == null ? void 0 : globalThis.navigator) === null || o === void 0) && o.locks) ? this.lock = _q : this.lock = Jj, this.jwks || (this.jwks = { keys: [] }, this.jwks_cached_at = Number.MIN_SAFE_INTEGER), this.mfa = {
      verify: this._verify.bind(this),
      enroll: this._enroll.bind(this),
      unenroll: this._unenroll.bind(this),
      challenge: this._challenge.bind(this),
      listFactors: this._listFactors.bind(this),
      challengeAndVerify: this._challengeAndVerify.bind(this),
      getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this),
      webauthn: new Bq(this)
    }, this.oauth = {
      getAuthorizationDetails: this._getAuthorizationDetails.bind(this),
      approveAuthorization: this._approveAuthorization.bind(this),
      denyAuthorization: this._denyAuthorization.bind(this)
    }, this.persistSession ? (c.storage ? this.storage = c.storage : i2() ? this.storage = globalThis.localStorage : (this.memoryStorage = {}, this.storage = Gj(this.memoryStorage)), c.userStorage && (this.userStorage = c.userStorage)) : (this.memoryStorage = {}, this.storage = Gj(this.memoryStorage)), di() && globalThis.BroadcastChannel && this.persistSession && this.storageKey) {
      try {
        this.broadcastChannel = new globalThis.BroadcastChannel(this.storageKey);
      } catch (f) {
        console.error("Failed to create a new BroadcastChannel, multi-tab state changes will not be available", f);
      }
      (u = this.broadcastChannel) === null || u === void 0 || u.addEventListener("message", async (f) => {
        this._debug("received broadcast notification from other tab or client", f), await this._notifyAllSubscribers(f.data.event, f.data.session, !1);
      });
    }
    this.initialize();
  }
  /**
   * Returns whether error throwing mode is enabled for this client.
   */
  isThrowOnErrorEnabled() {
    return this.throwOnError;
  }
  /**
   * Centralizes return handling with optional error throwing. When `throwOnError` is enabled
   * and the provided result contains a non-nullish error, the error is thrown instead of
   * being returned. This ensures consistent behavior across all public API methods.
   */
  _returnResult(e) {
    if (this.throwOnError && e && e.error)
      throw e.error;
    return e;
  }
  _logPrefix() {
    return `GoTrueClient@${this.storageKey}:${this.instanceID} (${n2}) ${(/* @__PURE__ */ new Date()).toISOString()}`;
  }
  _debug(...e) {
    return this.logDebugMessages && this.logger(this._logPrefix(), ...e), this;
  }
  /**
   * Initializes the client session either from the url or from storage.
   * This method is automatically called when instantiating the client, but should also be called
   * manually when checking for an error from an auth redirect (oauth, magiclink, password recovery, etc).
   */
  async initialize() {
    return this.initializePromise ? await this.initializePromise : (this.initializePromise = (async () => await this._acquireLock(-1, async () => await this._initialize()))(), await this.initializePromise);
  }
  /**
   * IMPORTANT:
   * 1. Never throw in this method, as it is called from the constructor
   * 2. Never return a session from this method as it would be cached over
   *    the whole lifetime of the client
   */
  async _initialize() {
    var e;
    try {
      let r = {}, o = "none";
      if (di() && (r = tq(window.location.href), this._isImplicitGrantCallback(r) ? o = "implicit" : await this._isPKCECallback(r) && (o = "pkce")), di() && this.detectSessionInUrl && o !== "none") {
        const { data: u, error: c } = await this._getSessionFromURL(r, o);
        if (c) {
          if (this._debug("#_initialize()", "error detecting session from URL", c), YW(c)) {
            const y = (e = c.details) === null || e === void 0 ? void 0 : e.code;
            if (y === "identity_already_exists" || y === "identity_not_found" || y === "single_identity_not_deletable")
              return { error: c };
          }
          return await this._removeSession(), { error: c };
        }
        const { session: f, redirectType: m } = u;
        return this._debug("#_initialize()", "detected session in URL", f, "redirect type", m), await this._saveSession(f), setTimeout(async () => {
          m === "recovery" ? await this._notifyAllSubscribers("PASSWORD_RECOVERY", f) : await this._notifyAllSubscribers("SIGNED_IN", f);
        }, 0), { error: null };
      }
      return await this._recoverAndRefresh(), { error: null };
    } catch (r) {
      return mt(r) ? this._returnResult({ error: r }) : this._returnResult({
        error: new kf("Unexpected error during initialization", r)
      });
    } finally {
      await this._handleVisibilityChange(), this._debug("#_initialize()", "end");
    }
  }
  /**
   * Creates a new anonymous user.
   *
   * @returns A session where the is_anonymous claim in the access token JWT set to true
   */
  async signInAnonymously(e) {
    var r, o, u;
    try {
      const c = await jt(this.fetch, "POST", `${this.url}/signup`, {
        headers: this.headers,
        body: {
          data: (o = (r = e == null ? void 0 : e.options) === null || r === void 0 ? void 0 : r.data) !== null && o !== void 0 ? o : {},
          gotrue_meta_security: { captcha_token: (u = e == null ? void 0 : e.options) === null || u === void 0 ? void 0 : u.captchaToken }
        },
        xform: Rs
      }), { data: f, error: m } = c;
      if (m || !f)
        return this._returnResult({ data: { user: null, session: null }, error: m });
      const y = f.session, b = f.user;
      return f.session && (await this._saveSession(f.session), await this._notifyAllSubscribers("SIGNED_IN", y)), this._returnResult({ data: { user: b, session: y }, error: null });
    } catch (c) {
      if (mt(c))
        return this._returnResult({ data: { user: null, session: null }, error: c });
      throw c;
    }
  }
  /**
   * Creates a new user.
   *
   * Be aware that if a user account exists in the system you may get back an
   * error message that attempts to hide this information from the user.
   * This method has support for PKCE via email signups. The PKCE flow cannot be used when autoconfirm is enabled.
   *
   * @returns A logged-in session if the server has "autoconfirm" ON
   * @returns A user if the server has "autoconfirm" OFF
   */
  async signUp(e) {
    var r, o, u;
    try {
      let c;
      if ("email" in e) {
        const { email: _, password: T, options: k } = e;
        let C = null, M = null;
        this.flowType === "pkce" && ([C, M] = await Vp(this.storage, this.storageKey)), c = await jt(this.fetch, "POST", `${this.url}/signup`, {
          headers: this.headers,
          redirectTo: k == null ? void 0 : k.emailRedirectTo,
          body: {
            email: _,
            password: T,
            data: (r = k == null ? void 0 : k.data) !== null && r !== void 0 ? r : {},
            gotrue_meta_security: { captcha_token: k == null ? void 0 : k.captchaToken },
            code_challenge: C,
            code_challenge_method: M
          },
          xform: Rs
        });
      } else if ("phone" in e) {
        const { phone: _, password: T, options: k } = e;
        c = await jt(this.fetch, "POST", `${this.url}/signup`, {
          headers: this.headers,
          body: {
            phone: _,
            password: T,
            data: (o = k == null ? void 0 : k.data) !== null && o !== void 0 ? o : {},
            channel: (u = k == null ? void 0 : k.channel) !== null && u !== void 0 ? u : "sms",
            gotrue_meta_security: { captcha_token: k == null ? void 0 : k.captchaToken }
          },
          xform: Rs
        });
      } else
        throw new Mw("You must provide either an email or phone number and a password");
      const { data: f, error: m } = c;
      if (m || !f)
        return this._returnResult({ data: { user: null, session: null }, error: m });
      const y = f.session, b = f.user;
      return f.session && (await this._saveSession(f.session), await this._notifyAllSubscribers("SIGNED_IN", y)), this._returnResult({ data: { user: b, session: y }, error: null });
    } catch (c) {
      if (mt(c))
        return this._returnResult({ data: { user: null, session: null }, error: c });
      throw c;
    }
  }
  /**
   * Log in an existing user with an email and password or phone and password.
   *
   * Be aware that you may get back an error message that will not distinguish
   * between the cases where the account does not exist or that the
   * email/phone and password combination is wrong or that the account can only
   * be accessed via social login.
   */
  async signInWithPassword(e) {
    try {
      let r;
      if ("email" in e) {
        const { email: c, password: f, options: m } = e;
        r = await jt(this.fetch, "POST", `${this.url}/token?grant_type=password`, {
          headers: this.headers,
          body: {
            email: c,
            password: f,
            gotrue_meta_security: { captcha_token: m == null ? void 0 : m.captchaToken }
          },
          xform: Yj
        });
      } else if ("phone" in e) {
        const { phone: c, password: f, options: m } = e;
        r = await jt(this.fetch, "POST", `${this.url}/token?grant_type=password`, {
          headers: this.headers,
          body: {
            phone: c,
            password: f,
            gotrue_meta_security: { captcha_token: m == null ? void 0 : m.captchaToken }
          },
          xform: Yj
        });
      } else
        throw new Mw("You must provide either an email or phone number and a password");
      const { data: o, error: u } = r;
      if (u)
        return this._returnResult({ data: { user: null, session: null }, error: u });
      if (!o || !o.session || !o.user) {
        const c = new Bp();
        return this._returnResult({ data: { user: null, session: null }, error: c });
      }
      return o.session && (await this._saveSession(o.session), await this._notifyAllSubscribers("SIGNED_IN", o.session)), this._returnResult({
        data: Object.assign({ user: o.user, session: o.session }, o.weak_password ? { weakPassword: o.weak_password } : null),
        error: u
      });
    } catch (r) {
      if (mt(r))
        return this._returnResult({ data: { user: null, session: null }, error: r });
      throw r;
    }
  }
  /**
   * Log in an existing user via a third-party provider.
   * This method supports the PKCE flow.
   */
  async signInWithOAuth(e) {
    var r, o, u, c;
    return await this._handleProviderSignIn(e.provider, {
      redirectTo: (r = e.options) === null || r === void 0 ? void 0 : r.redirectTo,
      scopes: (o = e.options) === null || o === void 0 ? void 0 : o.scopes,
      queryParams: (u = e.options) === null || u === void 0 ? void 0 : u.queryParams,
      skipBrowserRedirect: (c = e.options) === null || c === void 0 ? void 0 : c.skipBrowserRedirect
    });
  }
  /**
   * Log in an existing user by exchanging an Auth Code issued during the PKCE flow.
   */
  async exchangeCodeForSession(e) {
    return await this.initializePromise, this._acquireLock(-1, async () => this._exchangeCodeForSession(e));
  }
  /**
   * Signs in a user by verifying a message signed by the user's private key.
   * Supports Ethereum (via Sign-In-With-Ethereum) & Solana (Sign-In-With-Solana) standards,
   * both of which derive from the EIP-4361 standard
   * With slight variation on Solana's side.
   * @reference https://eips.ethereum.org/EIPS/eip-4361
   */
  async signInWithWeb3(e) {
    const { chain: r } = e;
    switch (r) {
      case "ethereum":
        return await this.signInWithEthereum(e);
      case "solana":
        return await this.signInWithSolana(e);
      default:
        throw new Error(`@supabase/auth-js: Unsupported chain "${r}"`);
    }
  }
  async signInWithEthereum(e) {
    var r, o, u, c, f, m, y, b, _, T, k;
    let C, M;
    if ("message" in e)
      C = e.message, M = e.signature;
    else {
      const { chain: N, wallet: A, statement: $, options: I } = e;
      let U;
      if (di())
        if (typeof A == "object")
          U = A;
        else {
          const Ce = window;
          if ("ethereum" in Ce && typeof Ce.ethereum == "object" && "request" in Ce.ethereum && typeof Ce.ethereum.request == "function")
            U = Ce.ethereum;
          else
            throw new Error("@supabase/auth-js: No compatible Ethereum wallet interface on the window object (window.ethereum) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'ethereum', wallet: resolvedUserWallet }) instead.");
        }
      else {
        if (typeof A != "object" || !(I != null && I.url))
          throw new Error("@supabase/auth-js: Both wallet and url must be specified in non-browser environments.");
        U = A;
      }
      const B = new URL((r = I == null ? void 0 : I.url) !== null && r !== void 0 ? r : window.location.href), K = await U.request({
        method: "eth_requestAccounts"
      }).then((Ce) => Ce).catch(() => {
        throw new Error("@supabase/auth-js: Wallet method eth_requestAccounts is missing or invalid");
      });
      if (!K || K.length === 0)
        throw new Error("@supabase/auth-js: No accounts available. Please ensure the wallet is connected.");
      const te = l2(K[0]);
      let re = (o = I == null ? void 0 : I.signInWithEthereum) === null || o === void 0 ? void 0 : o.chainId;
      if (!re) {
        const Ce = await U.request({
          method: "eth_chainId"
        });
        re = Cq(Ce);
      }
      const ve = {
        domain: B.host,
        address: te,
        statement: $,
        uri: B.href,
        version: "1",
        chainId: re,
        nonce: (u = I == null ? void 0 : I.signInWithEthereum) === null || u === void 0 ? void 0 : u.nonce,
        issuedAt: (f = (c = I == null ? void 0 : I.signInWithEthereum) === null || c === void 0 ? void 0 : c.issuedAt) !== null && f !== void 0 ? f : /* @__PURE__ */ new Date(),
        expirationTime: (m = I == null ? void 0 : I.signInWithEthereum) === null || m === void 0 ? void 0 : m.expirationTime,
        notBefore: (y = I == null ? void 0 : I.signInWithEthereum) === null || y === void 0 ? void 0 : y.notBefore,
        requestId: (b = I == null ? void 0 : I.signInWithEthereum) === null || b === void 0 ? void 0 : b.requestId,
        resources: (_ = I == null ? void 0 : I.signInWithEthereum) === null || _ === void 0 ? void 0 : _.resources
      };
      C = Rq(ve), M = await U.request({
        method: "personal_sign",
        params: [Tq(C), te]
      });
    }
    try {
      const { data: N, error: A } = await jt(this.fetch, "POST", `${this.url}/token?grant_type=web3`, {
        headers: this.headers,
        body: Object.assign({
          chain: "ethereum",
          message: C,
          signature: M
        }, !((T = e.options) === null || T === void 0) && T.captchaToken ? { gotrue_meta_security: { captcha_token: (k = e.options) === null || k === void 0 ? void 0 : k.captchaToken } } : null),
        xform: Rs
      });
      if (A)
        throw A;
      if (!N || !N.session || !N.user) {
        const $ = new Bp();
        return this._returnResult({ data: { user: null, session: null }, error: $ });
      }
      return N.session && (await this._saveSession(N.session), await this._notifyAllSubscribers("SIGNED_IN", N.session)), this._returnResult({ data: Object.assign({}, N), error: A });
    } catch (N) {
      if (mt(N))
        return this._returnResult({ data: { user: null, session: null }, error: N });
      throw N;
    }
  }
  async signInWithSolana(e) {
    var r, o, u, c, f, m, y, b, _, T, k, C;
    let M, N;
    if ("message" in e)
      M = e.message, N = e.signature;
    else {
      const { chain: A, wallet: $, statement: I, options: U } = e;
      let B;
      if (di())
        if (typeof $ == "object")
          B = $;
        else {
          const te = window;
          if ("solana" in te && typeof te.solana == "object" && ("signIn" in te.solana && typeof te.solana.signIn == "function" || "signMessage" in te.solana && typeof te.solana.signMessage == "function"))
            B = te.solana;
          else
            throw new Error("@supabase/auth-js: No compatible Solana wallet interface on the window object (window.solana) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'solana', wallet: resolvedUserWallet }) instead.");
        }
      else {
        if (typeof $ != "object" || !(U != null && U.url))
          throw new Error("@supabase/auth-js: Both wallet and url must be specified in non-browser environments.");
        B = $;
      }
      const K = new URL((r = U == null ? void 0 : U.url) !== null && r !== void 0 ? r : window.location.href);
      if ("signIn" in B && B.signIn) {
        const te = await B.signIn(Object.assign(Object.assign(Object.assign({ issuedAt: (/* @__PURE__ */ new Date()).toISOString() }, U == null ? void 0 : U.signInWithSolana), {
          // non-overridable properties
          version: "1",
          domain: K.host,
          uri: K.href
        }), I ? { statement: I } : null));
        let re;
        if (Array.isArray(te) && te[0] && typeof te[0] == "object")
          re = te[0];
        else if (te && typeof te == "object" && "signedMessage" in te && "signature" in te)
          re = te;
        else
          throw new Error("@supabase/auth-js: Wallet method signIn() returned unrecognized value");
        if ("signedMessage" in re && "signature" in re && (typeof re.signedMessage == "string" || re.signedMessage instanceof Uint8Array) && re.signature instanceof Uint8Array)
          M = typeof re.signedMessage == "string" ? re.signedMessage : new TextDecoder().decode(re.signedMessage), N = re.signature;
        else
          throw new Error("@supabase/auth-js: Wallet method signIn() API returned object without signedMessage and signature fields");
      } else {
        if (!("signMessage" in B) || typeof B.signMessage != "function" || !("publicKey" in B) || typeof B != "object" || !B.publicKey || !("toBase58" in B.publicKey) || typeof B.publicKey.toBase58 != "function")
          throw new Error("@supabase/auth-js: Wallet does not have a compatible signMessage() and publicKey.toBase58() API");
        M = [
          `${K.host} wants you to sign in with your Solana account:`,
          B.publicKey.toBase58(),
          ...I ? ["", I, ""] : [""],
          "Version: 1",
          `URI: ${K.href}`,
          `Issued At: ${(u = (o = U == null ? void 0 : U.signInWithSolana) === null || o === void 0 ? void 0 : o.issuedAt) !== null && u !== void 0 ? u : (/* @__PURE__ */ new Date()).toISOString()}`,
          ...!((c = U == null ? void 0 : U.signInWithSolana) === null || c === void 0) && c.notBefore ? [`Not Before: ${U.signInWithSolana.notBefore}`] : [],
          ...!((f = U == null ? void 0 : U.signInWithSolana) === null || f === void 0) && f.expirationTime ? [`Expiration Time: ${U.signInWithSolana.expirationTime}`] : [],
          ...!((m = U == null ? void 0 : U.signInWithSolana) === null || m === void 0) && m.chainId ? [`Chain ID: ${U.signInWithSolana.chainId}`] : [],
          ...!((y = U == null ? void 0 : U.signInWithSolana) === null || y === void 0) && y.nonce ? [`Nonce: ${U.signInWithSolana.nonce}`] : [],
          ...!((b = U == null ? void 0 : U.signInWithSolana) === null || b === void 0) && b.requestId ? [`Request ID: ${U.signInWithSolana.requestId}`] : [],
          ...!((T = (_ = U == null ? void 0 : U.signInWithSolana) === null || _ === void 0 ? void 0 : _.resources) === null || T === void 0) && T.length ? [
            "Resources",
            ...U.signInWithSolana.resources.map((re) => `- ${re}`)
          ] : []
        ].join(`
`);
        const te = await B.signMessage(new TextEncoder().encode(M), "utf8");
        if (!te || !(te instanceof Uint8Array))
          throw new Error("@supabase/auth-js: Wallet signMessage() API returned an recognized value");
        N = te;
      }
    }
    try {
      const { data: A, error: $ } = await jt(this.fetch, "POST", `${this.url}/token?grant_type=web3`, {
        headers: this.headers,
        body: Object.assign({ chain: "solana", message: M, signature: Of(N) }, !((k = e.options) === null || k === void 0) && k.captchaToken ? { gotrue_meta_security: { captcha_token: (C = e.options) === null || C === void 0 ? void 0 : C.captchaToken } } : null),
        xform: Rs
      });
      if ($)
        throw $;
      if (!A || !A.session || !A.user) {
        const I = new Bp();
        return this._returnResult({ data: { user: null, session: null }, error: I });
      }
      return A.session && (await this._saveSession(A.session), await this._notifyAllSubscribers("SIGNED_IN", A.session)), this._returnResult({ data: Object.assign({}, A), error: $ });
    } catch (A) {
      if (mt(A))
        return this._returnResult({ data: { user: null, session: null }, error: A });
      throw A;
    }
  }
  async _exchangeCodeForSession(e) {
    const r = await Ef(this.storage, `${this.storageKey}-code-verifier`), [o, u] = (r ?? "").split("/");
    try {
      const { data: c, error: f } = await jt(this.fetch, "POST", `${this.url}/token?grant_type=pkce`, {
        headers: this.headers,
        body: {
          auth_code: e,
          code_verifier: o
        },
        xform: Rs
      });
      if (await Bc(this.storage, `${this.storageKey}-code-verifier`), f)
        throw f;
      if (!c || !c.session || !c.user) {
        const m = new Bp();
        return this._returnResult({
          data: { user: null, session: null, redirectType: null },
          error: m
        });
      }
      return c.session && (await this._saveSession(c.session), await this._notifyAllSubscribers("SIGNED_IN", c.session)), this._returnResult({ data: Object.assign(Object.assign({}, c), { redirectType: u ?? null }), error: f });
    } catch (c) {
      if (mt(c))
        return this._returnResult({
          data: { user: null, session: null, redirectType: null },
          error: c
        });
      throw c;
    }
  }
  /**
   * Allows signing in with an OIDC ID token. The authentication provider used
   * should be enabled and configured.
   */
  async signInWithIdToken(e) {
    try {
      const { options: r, provider: o, token: u, access_token: c, nonce: f } = e, m = await jt(this.fetch, "POST", `${this.url}/token?grant_type=id_token`, {
        headers: this.headers,
        body: {
          provider: o,
          id_token: u,
          access_token: c,
          nonce: f,
          gotrue_meta_security: { captcha_token: r == null ? void 0 : r.captchaToken }
        },
        xform: Rs
      }), { data: y, error: b } = m;
      if (b)
        return this._returnResult({ data: { user: null, session: null }, error: b });
      if (!y || !y.session || !y.user) {
        const _ = new Bp();
        return this._returnResult({ data: { user: null, session: null }, error: _ });
      }
      return y.session && (await this._saveSession(y.session), await this._notifyAllSubscribers("SIGNED_IN", y.session)), this._returnResult({ data: y, error: b });
    } catch (r) {
      if (mt(r))
        return this._returnResult({ data: { user: null, session: null }, error: r });
      throw r;
    }
  }
  /**
   * Log in a user using magiclink or a one-time password (OTP).
   *
   * If the `{{ .ConfirmationURL }}` variable is specified in the email template, a magiclink will be sent.
   * If the `{{ .Token }}` variable is specified in the email template, an OTP will be sent.
   * If you're using phone sign-ins, only an OTP will be sent. You won't be able to send a magiclink for phone sign-ins.
   *
   * Be aware that you may get back an error message that will not distinguish
   * between the cases where the account does not exist or, that the account
   * can only be accessed via social login.
   *
   * Do note that you will need to configure a Whatsapp sender on Twilio
   * if you are using phone sign in with the 'whatsapp' channel. The whatsapp
   * channel is not supported on other providers
   * at this time.
   * This method supports PKCE when an email is passed.
   */
  async signInWithOtp(e) {
    var r, o, u, c, f;
    try {
      if ("email" in e) {
        const { email: m, options: y } = e;
        let b = null, _ = null;
        this.flowType === "pkce" && ([b, _] = await Vp(this.storage, this.storageKey));
        const { error: T } = await jt(this.fetch, "POST", `${this.url}/otp`, {
          headers: this.headers,
          body: {
            email: m,
            data: (r = y == null ? void 0 : y.data) !== null && r !== void 0 ? r : {},
            create_user: (o = y == null ? void 0 : y.shouldCreateUser) !== null && o !== void 0 ? o : !0,
            gotrue_meta_security: { captcha_token: y == null ? void 0 : y.captchaToken },
            code_challenge: b,
            code_challenge_method: _
          },
          redirectTo: y == null ? void 0 : y.emailRedirectTo
        });
        return this._returnResult({ data: { user: null, session: null }, error: T });
      }
      if ("phone" in e) {
        const { phone: m, options: y } = e, { data: b, error: _ } = await jt(this.fetch, "POST", `${this.url}/otp`, {
          headers: this.headers,
          body: {
            phone: m,
            data: (u = y == null ? void 0 : y.data) !== null && u !== void 0 ? u : {},
            create_user: (c = y == null ? void 0 : y.shouldCreateUser) !== null && c !== void 0 ? c : !0,
            gotrue_meta_security: { captcha_token: y == null ? void 0 : y.captchaToken },
            channel: (f = y == null ? void 0 : y.channel) !== null && f !== void 0 ? f : "sms"
          }
        });
        return this._returnResult({
          data: { user: null, session: null, messageId: b == null ? void 0 : b.message_id },
          error: _
        });
      }
      throw new Mw("You must provide either an email or phone number.");
    } catch (m) {
      if (mt(m))
        return this._returnResult({ data: { user: null, session: null }, error: m });
      throw m;
    }
  }
  /**
   * Log in a user given a User supplied OTP or TokenHash received through mobile or email.
   */
  async verifyOtp(e) {
    var r, o;
    try {
      let u, c;
      "options" in e && (u = (r = e.options) === null || r === void 0 ? void 0 : r.redirectTo, c = (o = e.options) === null || o === void 0 ? void 0 : o.captchaToken);
      const { data: f, error: m } = await jt(this.fetch, "POST", `${this.url}/verify`, {
        headers: this.headers,
        body: Object.assign(Object.assign({}, e), { gotrue_meta_security: { captcha_token: c } }),
        redirectTo: u,
        xform: Rs
      });
      if (m)
        throw m;
      if (!f)
        throw new Error("An error occurred on token verification.");
      const y = f.session, b = f.user;
      return y != null && y.access_token && (await this._saveSession(y), await this._notifyAllSubscribers(e.type == "recovery" ? "PASSWORD_RECOVERY" : "SIGNED_IN", y)), this._returnResult({ data: { user: b, session: y }, error: null });
    } catch (u) {
      if (mt(u))
        return this._returnResult({ data: { user: null, session: null }, error: u });
      throw u;
    }
  }
  /**
   * Attempts a single-sign on using an enterprise Identity Provider. A
   * successful SSO attempt will redirect the current page to the identity
   * provider authorization page. The redirect URL is implementation and SSO
   * protocol specific.
   *
   * You can use it by providing a SSO domain. Typically you can extract this
   * domain by asking users for their email address. If this domain is
   * registered on the Auth instance the redirect will use that organization's
   * currently active SSO Identity Provider for the login.
   *
   * If you have built an organization-specific login page, you can use the
   * organization's SSO Identity Provider UUID directly instead.
   */
  async signInWithSSO(e) {
    var r, o, u;
    try {
      let c = null, f = null;
      this.flowType === "pkce" && ([c, f] = await Vp(this.storage, this.storageKey));
      const m = await jt(this.fetch, "POST", `${this.url}/sso`, {
        body: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, "providerId" in e ? { provider_id: e.providerId } : null), "domain" in e ? { domain: e.domain } : null), { redirect_to: (o = (r = e.options) === null || r === void 0 ? void 0 : r.redirectTo) !== null && o !== void 0 ? o : void 0 }), !((u = e == null ? void 0 : e.options) === null || u === void 0) && u.captchaToken ? { gotrue_meta_security: { captcha_token: e.options.captchaToken } } : null), { skip_http_redirect: !0, code_challenge: c, code_challenge_method: f }),
        headers: this.headers,
        xform: yq
      });
      return this._returnResult(m);
    } catch (c) {
      if (mt(c))
        return this._returnResult({ data: null, error: c });
      throw c;
    }
  }
  /**
   * Sends a reauthentication OTP to the user's email or phone number.
   * Requires the user to be signed-in.
   */
  async reauthenticate() {
    return await this.initializePromise, await this._acquireLock(-1, async () => await this._reauthenticate());
  }
  async _reauthenticate() {
    try {
      return await this._useSession(async (e) => {
        const { data: { session: r }, error: o } = e;
        if (o)
          throw o;
        if (!r)
          throw new Ts();
        const { error: u } = await jt(this.fetch, "GET", `${this.url}/reauthenticate`, {
          headers: this.headers,
          jwt: r.access_token
        });
        return this._returnResult({ data: { user: null, session: null }, error: u });
      });
    } catch (e) {
      if (mt(e))
        return this._returnResult({ data: { user: null, session: null }, error: e });
      throw e;
    }
  }
  /**
   * Resends an existing signup confirmation email, email change email, SMS OTP or phone change OTP.
   */
  async resend(e) {
    try {
      const r = `${this.url}/resend`;
      if ("email" in e) {
        const { email: o, type: u, options: c } = e, { error: f } = await jt(this.fetch, "POST", r, {
          headers: this.headers,
          body: {
            email: o,
            type: u,
            gotrue_meta_security: { captcha_token: c == null ? void 0 : c.captchaToken }
          },
          redirectTo: c == null ? void 0 : c.emailRedirectTo
        });
        return this._returnResult({ data: { user: null, session: null }, error: f });
      } else if ("phone" in e) {
        const { phone: o, type: u, options: c } = e, { data: f, error: m } = await jt(this.fetch, "POST", r, {
          headers: this.headers,
          body: {
            phone: o,
            type: u,
            gotrue_meta_security: { captcha_token: c == null ? void 0 : c.captchaToken }
          }
        });
        return this._returnResult({
          data: { user: null, session: null, messageId: f == null ? void 0 : f.message_id },
          error: m
        });
      }
      throw new Mw("You must provide either an email or phone number and a type");
    } catch (r) {
      if (mt(r))
        return this._returnResult({ data: { user: null, session: null }, error: r });
      throw r;
    }
  }
  /**
   * Returns the session, refreshing it if necessary.
   *
   * The session returned can be null if the session is not detected which can happen in the event a user is not signed-in or has logged out.
   *
   * **IMPORTANT:** This method loads values directly from the storage attached
   * to the client. If that storage is based on request cookies for example,
   * the values in it may not be authentic and therefore it's strongly advised
   * against using this method and its results in such circumstances. A warning
   * will be emitted if this is detected. Use {@link #getUser()} instead.
   */
  async getSession() {
    return await this.initializePromise, await this._acquireLock(-1, async () => this._useSession(async (r) => r));
  }
  /**
   * Acquires a global lock based on the storage key.
   */
  async _acquireLock(e, r) {
    this._debug("#_acquireLock", "begin", e);
    try {
      if (this.lockAcquired) {
        const o = this.pendingInLock.length ? this.pendingInLock[this.pendingInLock.length - 1] : Promise.resolve(), u = (async () => (await o, await r()))();
        return this.pendingInLock.push((async () => {
          try {
            await u;
          } catch {
          }
        })()), u;
      }
      return await this.lock(`lock:${this.storageKey}`, e, async () => {
        this._debug("#_acquireLock", "lock acquired for storage key", this.storageKey);
        try {
          this.lockAcquired = !0;
          const o = r();
          for (this.pendingInLock.push((async () => {
            try {
              await o;
            } catch {
            }
          })()), await o; this.pendingInLock.length;) {
            const u = [...this.pendingInLock];
            await Promise.all(u), this.pendingInLock.splice(0, u.length);
          }
          return await o;
        } finally {
          this._debug("#_acquireLock", "lock released for storage key", this.storageKey), this.lockAcquired = !1;
        }
      });
    } finally {
      this._debug("#_acquireLock", "end");
    }
  }
  /**
   * Use instead of {@link #getSession} inside the library. It is
   * semantically usually what you want, as getting a session involves some
   * processing afterwards that requires only one client operating on the
   * session at once across multiple tabs or processes.
   */
  async _useSession(e) {
    this._debug("#_useSession", "begin");
    try {
      const r = await this.__loadSession();
      return await e(r);
    } finally {
      this._debug("#_useSession", "end");
    }
  }
  /**
   * NEVER USE DIRECTLY!
   *
   * Always use {@link #_useSession}.
   */
  async __loadSession() {
    this._debug("#__loadSession()", "begin"), this.lockAcquired || this._debug("#__loadSession()", "used outside of an acquired lock!", new Error().stack);
    try {
      let e = null;
      const r = await Ef(this.storage, this.storageKey);
      if (this._debug("#getSession()", "session from storage", r), r !== null && (this._isValidSession(r) ? e = r : (this._debug("#getSession()", "session from storage is not valid"), await this._removeSession())), !e)
        return { data: { session: null }, error: null };
      const o = e.expires_at ? e.expires_at * 1e3 - Date.now() < jC : !1;
      if (this._debug("#__loadSession()", `session has${o ? "" : " not"} expired`, "expires_at", e.expires_at), !o) {
        if (this.userStorage) {
          const f = await Ef(this.userStorage, this.storageKey + "-user");
          f != null && f.user ? e.user = f.user : e.user = PC();
        }
        if (this.storage.isServer && e.user && !e.user.__isUserNotAvailableProxy) {
          const f = { value: this.suppressGetSessionWarning };
          e.user = pq(e.user, f), f.value && (this.suppressGetSessionWarning = !0);
        }
        return { data: { session: e }, error: null };
      }
      const { data: u, error: c } = await this._callRefreshToken(e.refresh_token);
      return c ? this._returnResult({ data: { session: null }, error: c }) : this._returnResult({ data: { session: u }, error: null });
    } finally {
      this._debug("#__loadSession()", "end");
    }
  }
  /**
   * Gets the current user details if there is an existing session. This method
   * performs a network request to the Supabase Auth server, so the returned
   * value is authentic and can be used to base authorization rules on.
   *
   * @param jwt Takes in an optional access token JWT. If no JWT is provided, the JWT from the current session is used.
   */
  async getUser(e) {
    return e ? await this._getUser(e) : (await this.initializePromise, await this._acquireLock(-1, async () => await this._getUser()));
  }
  async _getUser(e) {
    try {
      return e ? await jt(this.fetch, "GET", `${this.url}/user`, {
        headers: this.headers,
        jwt: e,
        xform: Yc
      }) : await this._useSession(async (r) => {
        var o, u, c;
        const { data: f, error: m } = r;
        if (m)
          throw m;
        return !(!((o = f.session) === null || o === void 0) && o.access_token) && !this.hasCustomAuthorizationHeader ? { data: { user: null }, error: new Ts() } : await jt(this.fetch, "GET", `${this.url}/user`, {
          headers: this.headers,
          jwt: (c = (u = f.session) === null || u === void 0 ? void 0 : u.access_token) !== null && c !== void 0 ? c : void 0,
          xform: Yc
        });
      });
    } catch (r) {
      if (mt(r))
        return qW(r) && (await this._removeSession(), await Bc(this.storage, `${this.storageKey}-code-verifier`)), this._returnResult({ data: { user: null }, error: r });
      throw r;
    }
  }
  /**
   * Updates user data for a logged in user.
   */
  async updateUser(e, r = {}) {
    return await this.initializePromise, await this._acquireLock(-1, async () => await this._updateUser(e, r));
  }
  async _updateUser(e, r = {}) {
    try {
      return await this._useSession(async (o) => {
        const { data: u, error: c } = o;
        if (c)
          throw c;
        if (!u.session)
          throw new Ts();
        const f = u.session;
        let m = null, y = null;
        this.flowType === "pkce" && e.email != null && ([m, y] = await Vp(this.storage, this.storageKey));
        const { data: b, error: _ } = await jt(this.fetch, "PUT", `${this.url}/user`, {
          headers: this.headers,
          redirectTo: r == null ? void 0 : r.emailRedirectTo,
          body: Object.assign(Object.assign({}, e), { code_challenge: m, code_challenge_method: y }),
          jwt: f.access_token,
          xform: Yc
        });
        if (_)
          throw _;
        return f.user = b.user, await this._saveSession(f), await this._notifyAllSubscribers("USER_UPDATED", f), this._returnResult({ data: { user: f.user }, error: null });
      });
    } catch (o) {
      if (mt(o))
        return this._returnResult({ data: { user: null }, error: o });
      throw o;
    }
  }
  /**
   * Sets the session data from the current session. If the current session is expired, setSession will take care of refreshing it to obtain a new session.
   * If the refresh token or access token in the current session is invalid, an error will be thrown.
   * @param currentSession The current session that minimally contains an access token and refresh token.
   */
  async setSession(e) {
    return await this.initializePromise, await this._acquireLock(-1, async () => await this._setSession(e));
  }
  async _setSession(e) {
    try {
      if (!e.access_token || !e.refresh_token)
        throw new Ts();
      const r = Date.now() / 1e3;
      let o = r, u = !0, c = null;
      const { payload: f } = DC(e.access_token);
      if (f.exp && (o = f.exp, u = o <= r), u) {
        const { data: m, error: y } = await this._callRefreshToken(e.refresh_token);
        if (y)
          return this._returnResult({ data: { user: null, session: null }, error: y });
        if (!m)
          return { data: { user: null, session: null }, error: null };
        c = m;
      } else {
        const { data: m, error: y } = await this._getUser(e.access_token);
        if (y)
          throw y;
        c = {
          access_token: e.access_token,
          refresh_token: e.refresh_token,
          user: m.user,
          token_type: "bearer",
          expires_in: o - r,
          expires_at: o
        }, await this._saveSession(c), await this._notifyAllSubscribers("SIGNED_IN", c);
      }
      return this._returnResult({ data: { user: c.user, session: c }, error: null });
    } catch (r) {
      if (mt(r))
        return this._returnResult({ data: { session: null, user: null }, error: r });
      throw r;
    }
  }
  /**
   * Returns a new session, regardless of expiry status.
   * Takes in an optional current session. If not passed in, then refreshSession() will attempt to retrieve it from getSession().
   * If the current session's refresh token is invalid, an error will be thrown.
   * @param currentSession The current session. If passed in, it must contain a refresh token.
   */
  async refreshSession(e) {
    return await this.initializePromise, await this._acquireLock(-1, async () => await this._refreshSession(e));
  }
  async _refreshSession(e) {
    try {
      return await this._useSession(async (r) => {
        var o;
        if (!e) {
          const { data: f, error: m } = r;
          if (m)
            throw m;
          e = (o = f.session) !== null && o !== void 0 ? o : void 0;
        }
        if (!(e != null && e.refresh_token))
          throw new Ts();
        const { data: u, error: c } = await this._callRefreshToken(e.refresh_token);
        return c ? this._returnResult({ data: { user: null, session: null }, error: c }) : u ? this._returnResult({ data: { user: u.user, session: u }, error: null }) : this._returnResult({ data: { user: null, session: null }, error: null });
      });
    } catch (r) {
      if (mt(r))
        return this._returnResult({ data: { user: null, session: null }, error: r });
      throw r;
    }
  }
  /**
   * Gets the session data from a URL string
   */
  async _getSessionFromURL(e, r) {
    try {
      if (!di())
        throw new Lw("No browser detected.");
      if (e.error || e.error_description || e.error_code)
        throw new Lw(e.error_description || "Error in URL with unspecified error_description", {
          error: e.error || "unspecified_error",
          code: e.error_code || "unspecified_code"
        });
      switch (r) {
        case "implicit":
          if (this.flowType === "pkce")
            throw new $j("Not a valid PKCE flow url.");
          break;
        case "pkce":
          if (this.flowType === "implicit")
            throw new Lw("Not a valid implicit grant flow url.");
          break;
        default:
      }
      if (r === "pkce") {
        if (this._debug("#_initialize()", "begin", "is PKCE flow", !0), !e.code)
          throw new $j("No code detected.");
        const { data: I, error: U } = await this._exchangeCodeForSession(e.code);
        if (U)
          throw U;
        const B = new URL(window.location.href);
        return B.searchParams.delete("code"), window.history.replaceState(window.history.state, "", B.toString()), { data: { session: I.session, redirectType: null }, error: null };
      }
      const { provider_token: o, provider_refresh_token: u, access_token: c, refresh_token: f, expires_in: m, expires_at: y, token_type: b } = e;
      if (!c || !m || !f || !b)
        throw new Lw("No session defined in URL");
      const _ = Math.round(Date.now() / 1e3), T = parseInt(m);
      let k = _ + T;
      y && (k = parseInt(y));
      const C = k - _;
      C * 1e3 <= Kp && console.warn(`@supabase/gotrue-js: Session as retrieved from URL expires in ${C}s, should have been closer to ${T}s`);
      const M = k - T;
      _ - M >= 120 ? console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued over 120s ago, URL could be stale", M, k, _) : _ - M < 0 && console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued in the future? Check the device clock for skew", M, k, _);
      const { data: N, error: A } = await this._getUser(c);
      if (A)
        throw A;
      const $ = {
        provider_token: o,
        provider_refresh_token: u,
        access_token: c,
        expires_in: T,
        expires_at: k,
        refresh_token: f,
        token_type: b,
        user: N.user
      };
      return window.location.hash = "", this._debug("#_getSessionFromURL()", "clearing window.location.hash"), this._returnResult({ data: { session: $, redirectType: e.type }, error: null });
    } catch (o) {
      if (mt(o))
        return this._returnResult({ data: { session: null, redirectType: null }, error: o });
      throw o;
    }
  }
  /**
   * Checks if the current URL contains parameters given by an implicit oauth grant flow (https://www.rfc-editor.org/rfc/rfc6749.html#section-4.2)
   */
  _isImplicitGrantCallback(e) {
    return !!(e.access_token || e.error_description);
  }
  /**
   * Checks if the current URL and backing storage contain parameters given by a PKCE flow
   */
  async _isPKCECallback(e) {
    const r = await Ef(this.storage, `${this.storageKey}-code-verifier`);
    return !!(e.code && r);
  }
  /**
   * Inside a browser context, `signOut()` will remove the logged in user from the browser session and log them out - removing all items from localstorage and then trigger a `"SIGNED_OUT"` event.
   *
   * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`.
   * There is no way to revoke a user's access token jwt until it expires. It is recommended to set a shorter expiry on the jwt for this reason.
   *
   * If using `others` scope, no `SIGNED_OUT` event is fired!
   */
  async signOut(e = { scope: "global" }) {
    return await this.initializePromise, await this._acquireLock(-1, async () => await this._signOut(e));
  }
  async _signOut({ scope: e } = { scope: "global" }) {
    return await this._useSession(async (r) => {
      var o;
      const { data: u, error: c } = r;
      if (c)
        return this._returnResult({ error: c });
      const f = (o = u.session) === null || o === void 0 ? void 0 : o.access_token;
      if (f) {
        const { error: m } = await this.admin.signOut(f, e);
        if (m && !(WW(m) && (m.status === 404 || m.status === 401 || m.status === 403)))
          return this._returnResult({ error: m });
      }
      return e !== "others" && (await this._removeSession(), await Bc(this.storage, `${this.storageKey}-code-verifier`)), this._returnResult({ error: null });
    });
  }
  onAuthStateChange(e) {
    const r = eq(), o = {
      id: r,
      callback: e,
      unsubscribe: () => {
        this._debug("#unsubscribe()", "state change callback with id removed", r), this.stateChangeEmitters.delete(r);
      }
    };
    return this._debug("#onAuthStateChange()", "registered callback with id", r), this.stateChangeEmitters.set(r, o), (async () => (await this.initializePromise, await this._acquireLock(-1, async () => {
      this._emitInitialSession(r);
    })))(), { data: { subscription: o } };
  }
  async _emitInitialSession(e) {
    return await this._useSession(async (r) => {
      var o, u;
      try {
        const { data: { session: c }, error: f } = r;
        if (f)
          throw f;
        await ((o = this.stateChangeEmitters.get(e)) === null || o === void 0 ? void 0 : o.callback("INITIAL_SESSION", c)), this._debug("INITIAL_SESSION", "callback id", e, "session", c);
      } catch (c) {
        await ((u = this.stateChangeEmitters.get(e)) === null || u === void 0 ? void 0 : u.callback("INITIAL_SESSION", null)), this._debug("INITIAL_SESSION", "callback id", e, "error", c), console.error(c);
      }
    });
  }
  /**
   * Sends a password reset request to an email address. This method supports the PKCE flow.
   *
   * @param email The email address of the user.
   * @param options.redirectTo The URL to send the user to after they click the password reset link.
   * @param options.captchaToken Verification token received when the user completes the captcha on the site.
   */
  async resetPasswordForEmail(e, r = {}) {
    let o = null, u = null;
    this.flowType === "pkce" && ([o, u] = await Vp(
      this.storage,
      this.storageKey,
      !0
      // isPasswordRecovery
    ));
    try {
      return await jt(this.fetch, "POST", `${this.url}/recover`, {
        body: {
          email: e,
          code_challenge: o,
          code_challenge_method: u,
          gotrue_meta_security: { captcha_token: r.captchaToken }
        },
        headers: this.headers,
        redirectTo: r.redirectTo
      });
    } catch (c) {
      if (mt(c))
        return this._returnResult({ data: null, error: c });
      throw c;
    }
  }
  /**
   * Gets all the identities linked to a user.
   */
  async getUserIdentities() {
    var e;
    try {
      const { data: r, error: o } = await this.getUser();
      if (o)
        throw o;
      return this._returnResult({ data: { identities: (e = r.user.identities) !== null && e !== void 0 ? e : [] }, error: null });
    } catch (r) {
      if (mt(r))
        return this._returnResult({ data: null, error: r });
      throw r;
    }
  }
  async linkIdentity(e) {
    return "token" in e ? this.linkIdentityIdToken(e) : this.linkIdentityOAuth(e);
  }
  async linkIdentityOAuth(e) {
    var r;
    try {
      const { data: o, error: u } = await this._useSession(async (c) => {
        var f, m, y, b, _;
        const { data: T, error: k } = c;
        if (k)
          throw k;
        const C = await this._getUrlForProvider(`${this.url}/user/identities/authorize`, e.provider, {
          redirectTo: (f = e.options) === null || f === void 0 ? void 0 : f.redirectTo,
          scopes: (m = e.options) === null || m === void 0 ? void 0 : m.scopes,
          queryParams: (y = e.options) === null || y === void 0 ? void 0 : y.queryParams,
          skipBrowserRedirect: !0
        });
        return await jt(this.fetch, "GET", C, {
          headers: this.headers,
          jwt: (_ = (b = T.session) === null || b === void 0 ? void 0 : b.access_token) !== null && _ !== void 0 ? _ : void 0
        });
      });
      if (u)
        throw u;
      return di() && !(!((r = e.options) === null || r === void 0) && r.skipBrowserRedirect) && window.location.assign(o == null ? void 0 : o.url), this._returnResult({
        data: { provider: e.provider, url: o == null ? void 0 : o.url },
        error: null
      });
    } catch (o) {
      if (mt(o))
        return this._returnResult({ data: { provider: e.provider, url: null }, error: o });
      throw o;
    }
  }
  async linkIdentityIdToken(e) {
    return await this._useSession(async (r) => {
      var o;
      try {
        const { error: u, data: { session: c } } = r;
        if (u)
          throw u;
        const { options: f, provider: m, token: y, access_token: b, nonce: _ } = e, T = await jt(this.fetch, "POST", `${this.url}/token?grant_type=id_token`, {
          headers: this.headers,
          jwt: (o = c == null ? void 0 : c.access_token) !== null && o !== void 0 ? o : void 0,
          body: {
            provider: m,
            id_token: y,
            access_token: b,
            nonce: _,
            link_identity: !0,
            gotrue_meta_security: { captcha_token: f == null ? void 0 : f.captchaToken }
          },
          xform: Rs
        }), { data: k, error: C } = T;
        return C ? this._returnResult({ data: { user: null, session: null }, error: C }) : !k || !k.session || !k.user ? this._returnResult({
          data: { user: null, session: null },
          error: new Bp()
        }) : (k.session && (await this._saveSession(k.session), await this._notifyAllSubscribers("USER_UPDATED", k.session)), this._returnResult({ data: k, error: C }));
      } catch (u) {
        if (mt(u))
          return this._returnResult({ data: { user: null, session: null }, error: u });
        throw u;
      }
    });
  }
  /**
   * Unlinks an identity from a user by deleting it. The user will no longer be able to sign in with that identity once it's unlinked.
   */
  async unlinkIdentity(e) {
    try {
      return await this._useSession(async (r) => {
        var o, u;
        const { data: c, error: f } = r;
        if (f)
          throw f;
        return await jt(this.fetch, "DELETE", `${this.url}/user/identities/${e.identity_id}`, {
          headers: this.headers,
          jwt: (u = (o = c.session) === null || o === void 0 ? void 0 : o.access_token) !== null && u !== void 0 ? u : void 0
        });
      });
    } catch (r) {
      if (mt(r))
        return this._returnResult({ data: null, error: r });
      throw r;
    }
  }
  /**
   * Generates a new JWT.
   * @param refreshToken A valid refresh token that was returned on login.
   */
  async _refreshAccessToken(e) {
    const r = `#_refreshAccessToken(${e.substring(0, 5)}...)`;
    this._debug(r, "begin");
    try {
      const o = Date.now();
      return await aq(async (u) => (u > 0 && await rq(200 * Math.pow(2, u - 1)), this._debug(r, "refreshing attempt", u), await jt(this.fetch, "POST", `${this.url}/token?grant_type=refresh_token`, {
        body: { refresh_token: e },
        headers: this.headers,
        xform: Rs
      })), (u, c) => {
        const f = 200 * Math.pow(2, u);
        return c && AC(c) && // retryable only if the request can be sent before the backoff overflows the tick duration
          Date.now() + f - o < Kp;
      });
    } catch (o) {
      if (this._debug(r, "error", o), mt(o))
        return this._returnResult({ data: { session: null, user: null }, error: o });
      throw o;
    } finally {
      this._debug(r, "end");
    }
  }
  _isValidSession(e) {
    return typeof e == "object" && e !== null && "access_token" in e && "refresh_token" in e && "expires_at" in e;
  }
  async _handleProviderSignIn(e, r) {
    const o = await this._getUrlForProvider(`${this.url}/authorize`, e, {
      redirectTo: r.redirectTo,
      scopes: r.scopes,
      queryParams: r.queryParams
    });
    return this._debug("#_handleProviderSignIn()", "provider", e, "options", r, "url", o), di() && !r.skipBrowserRedirect && window.location.assign(o), { data: { provider: e, url: o }, error: null };
  }
  /**
   * Recovers the session from LocalStorage and refreshes the token
   * Note: this method is async to accommodate for AsyncStorage e.g. in React native.
   */
  async _recoverAndRefresh() {
    var e, r;
    const o = "#_recoverAndRefresh()";
    this._debug(o, "begin");
    try {
      const u = await Ef(this.storage, this.storageKey);
      if (u && this.userStorage) {
        let f = await Ef(this.userStorage, this.storageKey + "-user");
        !this.storage.isServer && Object.is(this.storage, this.userStorage) && !f && (f = { user: u.user }, await Gp(this.userStorage, this.storageKey + "-user", f)), u.user = (e = f == null ? void 0 : f.user) !== null && e !== void 0 ? e : PC();
      } else if (u && !u.user && !u.user) {
        const f = await Ef(this.storage, this.storageKey + "-user");
        f && (f != null && f.user) ? (u.user = f.user, await Bc(this.storage, this.storageKey + "-user"), await Gp(this.storage, this.storageKey, u)) : u.user = PC();
      }
      if (this._debug(o, "session from storage", u), !this._isValidSession(u)) {
        this._debug(o, "session is not valid"), u !== null && await this._removeSession();
        return;
      }
      const c = ((r = u.expires_at) !== null && r !== void 0 ? r : 1 / 0) * 1e3 - Date.now() < jC;
      if (this._debug(o, `session has${c ? "" : " not"} expired with margin of ${jC}s`), c) {
        if (this.autoRefreshToken && u.refresh_token) {
          const { error: f } = await this._callRefreshToken(u.refresh_token);
          f && (console.error(f), AC(f) || (this._debug(o, "refresh failed with a non-retryable error, removing the session", f), await this._removeSession()));
        }
      } else if (u.user && u.user.__isUserNotAvailableProxy === !0)
        try {
          const { data: f, error: m } = await this._getUser(u.access_token);
          !m && (f != null && f.user) ? (u.user = f.user, await this._saveSession(u), await this._notifyAllSubscribers("SIGNED_IN", u)) : this._debug(o, "could not get user data, skipping SIGNED_IN notification");
        } catch (f) {
          console.error("Error getting user data:", f), this._debug(o, "error getting user data, skipping SIGNED_IN notification", f);
        }
      else
        await this._notifyAllSubscribers("SIGNED_IN", u);
    } catch (u) {
      this._debug(o, "error", u), console.error(u);
      return;
    } finally {
      this._debug(o, "end");
    }
  }
  async _callRefreshToken(e) {
    var r, o;
    if (!e)
      throw new Ts();
    if (this.refreshingDeferred)
      return this.refreshingDeferred.promise;
    const u = `#_callRefreshToken(${e.substring(0, 5)}...)`;
    this._debug(u, "begin");
    try {
      this.refreshingDeferred = new Ax();
      const { data: c, error: f } = await this._refreshAccessToken(e);
      if (f)
        throw f;
      if (!c.session)
        throw new Ts();
      await this._saveSession(c.session), await this._notifyAllSubscribers("TOKEN_REFRESHED", c.session);
      const m = { data: c.session, error: null };
      return this.refreshingDeferred.resolve(m), m;
    } catch (c) {
      if (this._debug(u, "error", c), mt(c)) {
        const f = { data: null, error: c };
        return AC(c) || await this._removeSession(), (r = this.refreshingDeferred) === null || r === void 0 || r.resolve(f), f;
      }
      throw (o = this.refreshingDeferred) === null || o === void 0 || o.reject(c), c;
    } finally {
      this.refreshingDeferred = null, this._debug(u, "end");
    }
  }
  async _notifyAllSubscribers(e, r, o = !0) {
    const u = `#_notifyAllSubscribers(${e})`;
    this._debug(u, "begin", r, `broadcast = ${o}`);
    try {
      this.broadcastChannel && o && this.broadcastChannel.postMessage({ event: e, session: r });
      const c = [], f = Array.from(this.stateChangeEmitters.values()).map(async (m) => {
        try {
          await m.callback(e, r);
        } catch (y) {
          c.push(y);
        }
      });
      if (await Promise.all(f), c.length > 0) {
        for (let m = 0; m < c.length; m += 1)
          console.error(c[m]);
        throw c[0];
      }
    } finally {
      this._debug(u, "end");
    }
  }
  /**
   * set currentSession and currentUser
   * process to _startAutoRefreshToken if possible
   */
  async _saveSession(e) {
    this._debug("#_saveSession()", e), this.suppressGetSessionWarning = !0;
    const r = Object.assign({}, e), o = r.user && r.user.__isUserNotAvailableProxy === !0;
    if (this.userStorage) {
      !o && r.user && await Gp(this.userStorage, this.storageKey + "-user", {
        user: r.user
      });
      const u = Object.assign({}, r);
      delete u.user;
      const c = Wj(u);
      await Gp(this.storage, this.storageKey, c);
    } else {
      const u = Wj(r);
      await Gp(this.storage, this.storageKey, u);
    }
  }
  async _removeSession() {
    this._debug("#_removeSession()"), await Bc(this.storage, this.storageKey), await Bc(this.storage, this.storageKey + "-code-verifier"), await Bc(this.storage, this.storageKey + "-user"), this.userStorage && await Bc(this.userStorage, this.storageKey + "-user"), await this._notifyAllSubscribers("SIGNED_OUT", null);
  }
  /**
   * Removes any registered visibilitychange callback.
   *
   * {@see #startAutoRefresh}
   * {@see #stopAutoRefresh}
   */
  _removeVisibilityChangedCallback() {
    this._debug("#_removeVisibilityChangedCallback()");
    const e = this.visibilityChangedCallback;
    this.visibilityChangedCallback = null;
    try {
      e && di() && (window != null && window.removeEventListener) && window.removeEventListener("visibilitychange", e);
    } catch (r) {
      console.error("removing visibilitychange callback failed", r);
    }
  }
  /**
   * This is the private implementation of {@link #startAutoRefresh}. Use this
   * within the library.
   */
  async _startAutoRefresh() {
    await this._stopAutoRefresh(), this._debug("#_startAutoRefresh()");
    const e = setInterval(() => this._autoRefreshTokenTick(), Kp);
    this.autoRefreshTicker = e, e && typeof e == "object" && typeof e.unref == "function" ? e.unref() : typeof Deno < "u" && typeof Deno.unrefTimer == "function" && Deno.unrefTimer(e), setTimeout(async () => {
      await this.initializePromise, await this._autoRefreshTokenTick();
    }, 0);
  }
  /**
   * This is the private implementation of {@link #stopAutoRefresh}. Use this
   * within the library.
   */
  async _stopAutoRefresh() {
    this._debug("#_stopAutoRefresh()");
    const e = this.autoRefreshTicker;
    this.autoRefreshTicker = null, e && clearInterval(e);
  }
  /**
   * Starts an auto-refresh process in the background. The session is checked
   * every few seconds. Close to the time of expiration a process is started to
   * refresh the session. If refreshing fails it will be retried for as long as
   * necessary.
   *
   * If you set the {@link GoTrueClientOptions#autoRefreshToken} you don't need
   * to call this function, it will be called for you.
   *
   * On browsers the refresh process works only when the tab/window is in the
   * foreground to conserve resources as well as prevent race conditions and
   * flooding auth with requests. If you call this method any managed
   * visibility change callback will be removed and you must manage visibility
   * changes on your own.
   *
   * On non-browser platforms the refresh process works *continuously* in the
   * background, which may not be desirable. You should hook into your
   * platform's foreground indication mechanism and call these methods
   * appropriately to conserve resources.
   *
   * {@see #stopAutoRefresh}
   */
  async startAutoRefresh() {
    this._removeVisibilityChangedCallback(), await this._startAutoRefresh();
  }
  /**
   * Stops an active auto refresh process running in the background (if any).
   *
   * If you call this method any managed visibility change callback will be
   * removed and you must manage visibility changes on your own.
   *
   * See {@link #startAutoRefresh} for more details.
   */
  async stopAutoRefresh() {
    this._removeVisibilityChangedCallback(), await this._stopAutoRefresh();
  }
  /**
   * Runs the auto refresh token tick.
   */
  async _autoRefreshTokenTick() {
    this._debug("#_autoRefreshTokenTick()", "begin");
    try {
      await this._acquireLock(0, async () => {
        try {
          const e = Date.now();
          try {
            return await this._useSession(async (r) => {
              const { data: { session: o } } = r;
              if (!o || !o.refresh_token || !o.expires_at) {
                this._debug("#_autoRefreshTokenTick()", "no session");
                return;
              }
              const u = Math.floor((o.expires_at * 1e3 - e) / Kp);
              this._debug("#_autoRefreshTokenTick()", `access token expires in ${u} ticks, a tick lasts ${Kp}ms, refresh threshold is ${C1} ticks`), u <= C1 && await this._callRefreshToken(o.refresh_token);
            });
          } catch (r) {
            console.error("Auto refresh tick failed with error. This is likely a transient error.", r);
          }
        } finally {
          this._debug("#_autoRefreshTokenTick()", "end");
        }
      });
    } catch (e) {
      if (e.isAcquireTimeout || e instanceof s2)
        this._debug("auto refresh token tick lock not available");
      else
        throw e;
    }
  }
  /**
   * Registers callbacks on the browser / platform, which in-turn run
   * algorithms when the browser window/tab are in foreground. On non-browser
   * platforms it assumes always foreground.
   */
  async _handleVisibilityChange() {
    if (this._debug("#_handleVisibilityChange()"), !di() || !(window != null && window.addEventListener))
      return this.autoRefreshToken && this.startAutoRefresh(), !1;
    try {
      this.visibilityChangedCallback = async () => await this._onVisibilityChanged(!1), window == null || window.addEventListener("visibilitychange", this.visibilityChangedCallback), await this._onVisibilityChanged(!0);
    } catch (e) {
      console.error("_handleVisibilityChange", e);
    }
  }
  /**
   * Callback registered with `window.addEventListener('visibilitychange')`.
   */
  async _onVisibilityChanged(e) {
    const r = `#_onVisibilityChanged(${e})`;
    this._debug(r, "visibilityState", document.visibilityState), document.visibilityState === "visible" ? (this.autoRefreshToken && this._startAutoRefresh(), e || (await this.initializePromise, await this._acquireLock(-1, async () => {
      if (document.visibilityState !== "visible") {
        this._debug(r, "acquired the lock to recover the session, but the browser visibilityState is no longer visible, aborting");
        return;
      }
      await this._recoverAndRefresh();
    }))) : document.visibilityState === "hidden" && this.autoRefreshToken && this._stopAutoRefresh();
  }
  /**
   * Generates the relevant login URL for a third-party provider.
   * @param options.redirectTo A URL or mobile address to send the user to after they are confirmed.
   * @param options.scopes A space-separated list of scopes granted to the OAuth application.
   * @param options.queryParams An object of key-value pairs containing query parameters granted to the OAuth application.
   */
  async _getUrlForProvider(e, r, o) {
    const u = [`provider=${encodeURIComponent(r)}`];
    if (o != null && o.redirectTo && u.push(`redirect_to=${encodeURIComponent(o.redirectTo)}`), o != null && o.scopes && u.push(`scopes=${encodeURIComponent(o.scopes)}`), this.flowType === "pkce") {
      const [c, f] = await Vp(this.storage, this.storageKey), m = new URLSearchParams({
        code_challenge: `${encodeURIComponent(c)}`,
        code_challenge_method: `${encodeURIComponent(f)}`
      });
      u.push(m.toString());
    }
    if (o != null && o.queryParams) {
      const c = new URLSearchParams(o.queryParams);
      u.push(c.toString());
    }
    return o != null && o.skipBrowserRedirect && u.push(`skip_http_redirect=${o.skipBrowserRedirect}`), `${e}?${u.join("&")}`;
  }
  async _unenroll(e) {
    try {
      return await this._useSession(async (r) => {
        var o;
        const { data: u, error: c } = r;
        return c ? this._returnResult({ data: null, error: c }) : await jt(this.fetch, "DELETE", `${this.url}/factors/${e.factorId}`, {
          headers: this.headers,
          jwt: (o = u == null ? void 0 : u.session) === null || o === void 0 ? void 0 : o.access_token
        });
      });
    } catch (r) {
      if (mt(r))
        return this._returnResult({ data: null, error: r });
      throw r;
    }
  }
  async _enroll(e) {
    try {
      return await this._useSession(async (r) => {
        var o, u;
        const { data: c, error: f } = r;
        if (f)
          return this._returnResult({ data: null, error: f });
        const m = Object.assign({ friendly_name: e.friendlyName, factor_type: e.factorType }, e.factorType === "phone" ? { phone: e.phone } : e.factorType === "totp" ? { issuer: e.issuer } : {}), { data: y, error: b } = await jt(this.fetch, "POST", `${this.url}/factors`, {
          body: m,
          headers: this.headers,
          jwt: (o = c == null ? void 0 : c.session) === null || o === void 0 ? void 0 : o.access_token
        });
        return b ? this._returnResult({ data: null, error: b }) : (e.factorType === "totp" && y.type === "totp" && (!((u = y == null ? void 0 : y.totp) === null || u === void 0) && u.qr_code) && (y.totp.qr_code = `data:image/svg+xml;utf-8,${y.totp.qr_code}`), this._returnResult({ data: y, error: null }));
      });
    } catch (r) {
      if (mt(r))
        return this._returnResult({ data: null, error: r });
      throw r;
    }
  }
  async _verify(e) {
    return this._acquireLock(-1, async () => {
      try {
        return await this._useSession(async (r) => {
          var o;
          const { data: u, error: c } = r;
          if (c)
            return this._returnResult({ data: null, error: c });
          const f = Object.assign({ challenge_id: e.challengeId }, "webauthn" in e ? {
            webauthn: Object.assign(Object.assign({}, e.webauthn), { credential_response: e.webauthn.type === "create" ? Pq(e.webauthn.credential_response) : Mq(e.webauthn.credential_response) })
          } : { code: e.code }), { data: m, error: y } = await jt(this.fetch, "POST", `${this.url}/factors/${e.factorId}/verify`, {
            body: f,
            headers: this.headers,
            jwt: (o = u == null ? void 0 : u.session) === null || o === void 0 ? void 0 : o.access_token
          });
          return y ? this._returnResult({ data: null, error: y }) : (await this._saveSession(Object.assign({ expires_at: Math.round(Date.now() / 1e3) + m.expires_in }, m)), await this._notifyAllSubscribers("MFA_CHALLENGE_VERIFIED", m), this._returnResult({ data: m, error: y }));
        });
      } catch (r) {
        if (mt(r))
          return this._returnResult({ data: null, error: r });
        throw r;
      }
    });
  }
  async _challenge(e) {
    return this._acquireLock(-1, async () => {
      try {
        return await this._useSession(async (r) => {
          var o;
          const { data: u, error: c } = r;
          if (c)
            return this._returnResult({ data: null, error: c });
          const f = await jt(this.fetch, "POST", `${this.url}/factors/${e.factorId}/challenge`, {
            body: e,
            headers: this.headers,
            jwt: (o = u == null ? void 0 : u.session) === null || o === void 0 ? void 0 : o.access_token
          });
          if (f.error)
            return f;
          const { data: m } = f;
          if (m.type !== "webauthn")
            return { data: m, error: null };
          switch (m.webauthn.type) {
            case "create":
              return {
                data: Object.assign(Object.assign({}, m), { webauthn: Object.assign(Object.assign({}, m.webauthn), { credential_options: Object.assign(Object.assign({}, m.webauthn.credential_options), { publicKey: Aq(m.webauthn.credential_options.publicKey) }) }) }),
                error: null
              };
            case "request":
              return {
                data: Object.assign(Object.assign({}, m), { webauthn: Object.assign(Object.assign({}, m.webauthn), { credential_options: Object.assign(Object.assign({}, m.webauthn.credential_options), { publicKey: Dq(m.webauthn.credential_options.publicKey) }) }) }),
                error: null
              };
          }
        });
      } catch (r) {
        if (mt(r))
          return this._returnResult({ data: null, error: r });
        throw r;
      }
    });
  }
  /**
   * {@see GoTrueMFAApi#challengeAndVerify}
   */
  async _challengeAndVerify(e) {
    const { data: r, error: o } = await this._challenge({
      factorId: e.factorId
    });
    return o ? this._returnResult({ data: null, error: o }) : await this._verify({
      factorId: e.factorId,
      challengeId: r.id,
      code: e.code
    });
  }
  /**
   * {@see GoTrueMFAApi#listFactors}
   */
  async _listFactors() {
    var e;
    const { data: { user: r }, error: o } = await this.getUser();
    if (o)
      return { data: null, error: o };
    const u = {
      all: [],
      phone: [],
      totp: [],
      webauthn: []
    };
    for (const c of (e = r == null ? void 0 : r.factors) !== null && e !== void 0 ? e : [])
      u.all.push(c), c.status === "verified" && u[c.factor_type].push(c);
    return {
      data: u,
      error: null
    };
  }
  /**
   * {@see GoTrueMFAApi#getAuthenticatorAssuranceLevel}
   */
  async _getAuthenticatorAssuranceLevel() {
    var e, r;
    const { data: { session: o }, error: u } = await this.getSession();
    if (u)
      return this._returnResult({ data: null, error: u });
    if (!o)
      return {
        data: { currentLevel: null, nextLevel: null, currentAuthenticationMethods: [] },
        error: null
      };
    const { payload: c } = DC(o.access_token);
    let f = null;
    c.aal && (f = c.aal);
    let m = f;
    ((r = (e = o.user.factors) === null || e === void 0 ? void 0 : e.filter((_) => _.status === "verified")) !== null && r !== void 0 ? r : []).length > 0 && (m = "aal2");
    const b = c.amr || [];
    return { data: { currentLevel: f, nextLevel: m, currentAuthenticationMethods: b }, error: null };
  }
  /**
   * Retrieves details about an OAuth authorization request.
   * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
   *
   * Returns authorization details including client info, scopes, and user information.
   * If the API returns a redirect_uri, it means consent was already given - the caller
   * should handle the redirect manually if needed.
   */
  async _getAuthorizationDetails(e) {
    try {
      return await this._useSession(async (r) => {
        const { data: { session: o }, error: u } = r;
        return u ? this._returnResult({ data: null, error: u }) : o ? await jt(this.fetch, "GET", `${this.url}/oauth/authorizations/${e}`, {
          headers: this.headers,
          jwt: o.access_token,
          xform: (c) => ({ data: c, error: null })
        }) : this._returnResult({ data: null, error: new Ts() });
      });
    } catch (r) {
      if (mt(r))
        return this._returnResult({ data: null, error: r });
      throw r;
    }
  }
  /**
   * Approves an OAuth authorization request.
   * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
   */
  async _approveAuthorization(e, r) {
    try {
      return await this._useSession(async (o) => {
        const { data: { session: u }, error: c } = o;
        if (c)
          return this._returnResult({ data: null, error: c });
        if (!u)
          return this._returnResult({ data: null, error: new Ts() });
        const f = await jt(this.fetch, "POST", `${this.url}/oauth/authorizations/${e}/consent`, {
          headers: this.headers,
          jwt: u.access_token,
          body: { action: "approve" },
          xform: (m) => ({ data: m, error: null })
        });
        return f.data && f.data.redirect_url && di() && !(r != null && r.skipBrowserRedirect) && window.location.assign(f.data.redirect_url), f;
      });
    } catch (o) {
      if (mt(o))
        return this._returnResult({ data: null, error: o });
      throw o;
    }
  }
  /**
   * Denies an OAuth authorization request.
   * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
   */
  async _denyAuthorization(e, r) {
    try {
      return await this._useSession(async (o) => {
        const { data: { session: u }, error: c } = o;
        if (c)
          return this._returnResult({ data: null, error: c });
        if (!u)
          return this._returnResult({ data: null, error: new Ts() });
        const f = await jt(this.fetch, "POST", `${this.url}/oauth/authorizations/${e}/consent`, {
          headers: this.headers,
          jwt: u.access_token,
          body: { action: "deny" },
          xform: (m) => ({ data: m, error: null })
        });
        return f.data && f.data.redirect_url && di() && !(r != null && r.skipBrowserRedirect) && window.location.assign(f.data.redirect_url), f;
      });
    } catch (o) {
      if (mt(o))
        return this._returnResult({ data: null, error: o });
      throw o;
    }
  }
  async fetchJwk(e, r = { keys: [] }) {
    let o = r.keys.find((m) => m.kid === e);
    if (o)
      return o;
    const u = Date.now();
    if (o = this.jwks.keys.find((m) => m.kid === e), o && this.jwks_cached_at + VW > u)
      return o;
    const { data: c, error: f } = await jt(this.fetch, "GET", `${this.url}/.well-known/jwks.json`, {
      headers: this.headers
    });
    if (f)
      throw f;
    return !c.keys || c.keys.length === 0 || (this.jwks = c, this.jwks_cached_at = u, o = c.keys.find((m) => m.kid === e), !o) ? null : o;
  }
  /**
   * Extracts the JWT claims present in the access token by first verifying the
   * JWT against the server's JSON Web Key Set endpoint
   * `/.well-known/jwks.json` which is often cached, resulting in significantly
   * faster responses. Prefer this method over {@link #getUser} which always
   * sends a request to the Auth server for each JWT.
   *
   * If the project is not using an asymmetric JWT signing key (like ECC or
   * RSA) it always sends a request to the Auth server (similar to {@link
   * #getUser}) to verify the JWT.
   *
   * @param jwt An optional specific JWT you wish to verify, not the one you
   *            can obtain from {@link #getSession}.
   * @param options Various additional options that allow you to customize the
   *                behavior of this method.
   */
  async getClaims(e, r = {}) {
    try {
      let o = e;
      if (!o) {
        const { data: C, error: M } = await this.getSession();
        if (M || !C.session)
          return this._returnResult({ data: null, error: M });
        o = C.session.access_token;
      }
      const { header: u, payload: c, signature: f, raw: { header: m, payload: y } } = DC(o);
      r != null && r.allowExpired || dq(c.exp);
      const b = !u.alg || u.alg.startsWith("HS") || !u.kid || !("crypto" in globalThis && "subtle" in globalThis.crypto) ? null : await this.fetchJwk(u.kid, r != null && r.keys ? { keys: r.keys } : r == null ? void 0 : r.jwks);
      if (!b) {
        const { error: C } = await this.getUser(o);
        if (C)
          throw C;
        return {
          data: {
            claims: c,
            header: u,
            signature: f
          },
          error: null
        };
      }
      const _ = fq(u.alg), T = await crypto.subtle.importKey("jwk", b, _, !0, [
        "verify"
      ]);
      if (!await crypto.subtle.verify(_, T, f, ZW(`${m}.${y}`)))
        throw new k1("Invalid JWT signature");
      return {
        data: {
          claims: c,
          header: u,
          signature: f
        },
        error: null
      };
    } catch (o) {
      if (mt(o))
        return this._returnResult({ data: null, error: o });
      throw o;
    }
  }
}
iy.nextInstanceID = {};
const Hq = iy;
class Wq extends Hq {
  constructor(e) {
    super(e);
  }
}
class qq {
  /**
   * Create a new client for use in the browser.
   * @param supabaseUrl The unique Supabase URL which is supplied when you create a new project in your project dashboard.
   * @param supabaseKey The unique Supabase Key which is supplied when you create a new project in your project dashboard.
   * @param options.db.schema You can switch in between schemas. The schema needs to be on the list of exposed schemas inside Supabase.
   * @param options.auth.autoRefreshToken Set to "true" if you want to automatically refresh the token before expiring.
   * @param options.auth.persistSession Set to "true" if you want to automatically save the user session into local storage.
   * @param options.auth.detectSessionInUrl Set to "true" if you want to automatically detects OAuth grants in the URL and signs in the user.
   * @param options.realtime Options passed along to realtime-js constructor.
   * @param options.storage Options passed along to the storage-js constructor.
   * @param options.global.fetch A custom fetch implementation.
   * @param options.global.headers Any additional headers to send with each network request.
   */
  constructor(e, r, o) {
    var u, c, f;
    this.supabaseUrl = e, this.supabaseKey = r;
    const m = UW(e);
    if (!r)
      throw new Error("supabaseKey is required.");
    this.realtimeUrl = new URL("realtime/v1", m), this.realtimeUrl.protocol = this.realtimeUrl.protocol.replace("http", "ws"), this.authUrl = new URL("auth/v1", m), this.storageUrl = new URL("storage/v1", m), this.functionsUrl = new URL("functions/v1", m);
    const y = `sb-${m.hostname.split(".")[0]}-auth-token`, b = {
      db: NW,
      realtime: AW,
      auth: Object.assign(Object.assign({}, jW), { storageKey: y }),
      global: OW
    }, _ = IW(o ?? {}, b);
    this.storageKey = (u = _.auth.storageKey) !== null && u !== void 0 ? u : "", this.headers = (c = _.global.headers) !== null && c !== void 0 ? c : {}, _.accessToken ? (this.accessToken = _.accessToken, this.auth = new Proxy({}, {
      get: (T, k) => {
        throw new Error(`@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.${String(k)} is not possible`);
      }
    })) : this.auth = this._initSupabaseAuthClient((f = _.auth) !== null && f !== void 0 ? f : {}, this.headers, _.global.fetch), this.fetch = MW(r, this._getAccessToken.bind(this), _.global.fetch), this.realtime = this._initRealtimeClient(Object.assign({ headers: this.headers, accessToken: this._getAccessToken.bind(this) }, _.realtime)), this.rest = new F8(new URL("rest/v1", m).href, {
      headers: this.headers,
      schema: _.db.schema,
      fetch: this.fetch
    }), this.storage = new TW(this.storageUrl.href, this.headers, this.fetch, o == null ? void 0 : o.storage), _.accessToken || this._listenForAuthEvents();
  }
  /**
   * Supabase Functions allows you to deploy and invoke edge functions.
   */
  get functions() {
    return new L8(this.functionsUrl.href, {
      headers: this.headers,
      customFetch: this.fetch
    });
  }
  /**
   * Perform a query on a table or a view.
   *
   * @param relation - The table or view name to query
   */
  from(e) {
    return this.rest.from(e);
  }
  // NOTE: signatures must be kept in sync with PostgrestClient.schema
  /**
   * Select a schema to query or perform an function (rpc) call.
   *
   * The schema needs to be on the list of exposed schemas inside Supabase.
   *
   * @param schema - The schema to query
   */
  schema(e) {
    return this.rest.schema(e);
  }
  // NOTE: signatures must be kept in sync with PostgrestClient.rpc
  /**
   * Perform a function call.
   *
   * @param fn - The function name to call
   * @param args - The arguments to pass to the function call
   * @param options - Named parameters
   * @param options.head - When set to `true`, `data` will not be returned.
   * Useful if you only need the count.
   * @param options.get - When set to `true`, the function will be called with
   * read-only access mode.
   * @param options.count - Count algorithm to use to count rows returned by the
   * function. Only applicable for [set-returning
   * functions](https://www.postgresql.org/docs/current/functions-srf.html).
   *
   * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
   * hood.
   *
   * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
   * statistics under the hood.
   *
   * `"estimated"`: Uses exact count for low numbers and planned count for high
   * numbers.
   */
  rpc(e, r = {}, o = {
    head: !1,
    get: !1,
    count: void 0
  }) {
    return this.rest.rpc(e, r, o);
  }
  /**
   * Creates a Realtime channel with Broadcast, Presence, and Postgres Changes.
   *
   * @param {string} name - The name of the Realtime channel.
   * @param {Object} opts - The options to pass to the Realtime channel.
   *
   */
  channel(e, r = { config: {} }) {
    return this.realtime.channel(e, r);
  }
  /**
   * Returns all Realtime channels.
   */
  getChannels() {
    return this.realtime.getChannels();
  }
  /**
   * Unsubscribes and removes Realtime channel from Realtime client.
   *
   * @param {RealtimeChannel} channel - The name of the Realtime channel.
   *
   */
  removeChannel(e) {
    return this.realtime.removeChannel(e);
  }
  /**
   * Unsubscribes and removes all Realtime channels from Realtime client.
   */
  removeAllChannels() {
    return this.realtime.removeAllChannels();
  }
  async _getAccessToken() {
    var e, r;
    if (this.accessToken)
      return await this.accessToken();
    const { data: o } = await this.auth.getSession();
    return (r = (e = o.session) === null || e === void 0 ? void 0 : e.access_token) !== null && r !== void 0 ? r : this.supabaseKey;
  }
  _initSupabaseAuthClient({ autoRefreshToken: e, persistSession: r, detectSessionInUrl: o, storage: u, userStorage: c, storageKey: f, flowType: m, lock: y, debug: b, throwOnError: _ }, T, k) {
    const C = {
      Authorization: `Bearer ${this.supabaseKey}`,
      apikey: `${this.supabaseKey}`
    };
    return new Wq({
      url: this.authUrl.href,
      headers: Object.assign(Object.assign({}, C), T),
      storageKey: f,
      autoRefreshToken: e,
      persistSession: r,
      detectSessionInUrl: o,
      storage: u,
      userStorage: c,
      flowType: m,
      lock: y,
      debug: b,
      throwOnError: _,
      fetch: k,
      // auth checks if there is a custom authorizaiton header using this flag
      // so it knows whether to return an error when getUser is called with no session
      hasCustomAuthorizationHeader: Object.keys(this.headers).some((M) => M.toLowerCase() === "authorization")
    });
  }
  _initRealtimeClient(e) {
    return new nW(this.realtimeUrl.href, Object.assign(Object.assign({}, e), { params: Object.assign({ apikey: this.supabaseKey }, e == null ? void 0 : e.params) }));
  }
  _listenForAuthEvents() {
    return this.auth.onAuthStateChange((r, o) => {
      this._handleTokenChanged(r, "CLIENT", o == null ? void 0 : o.access_token);
    });
  }
  _handleTokenChanged(e, r, o) {
    (e === "TOKEN_REFRESHED" || e === "SIGNED_IN") && this.changedAccessToken !== o ? (this.changedAccessToken = o, this.realtime.setAuth(o)) : e === "SIGNED_OUT" && (this.realtime.setAuth(), r == "STORAGE" && this.auth.signOut(), this.changedAccessToken = void 0);
  }
}
const Yq = (n, e, r) => new qq(n, e, r);
function Kq() {
  if (typeof window < "u" || typeof process > "u")
    return !1;
  const n = process.version;
  if (n == null)
    return !1;
  const e = n.match(/^v(\d+)\./);
  return e ? parseInt(e[1], 10) <= 18 : !1;
}
Kq() && console.warn("  Node.js 18 and below are deprecated and will no longer be supported in future versions of @supabase/supabase-js. Please upgrade to Node.js 20 or later. For more information, visit: https://github.com/orgs/supabase/discussions/37217");
const Gq = "https://mvsoifhykosbvajpcmdl.supabase.co", Qq = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im12c29pZmh5a29zYnZhanBjbWRsIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjI1MzgzMzEsImV4cCI6MjA3ODExNDMzMX0.i6Y-n_QAoL8REZK1xb-QU5q_nr-Ak9nw5QMblhEshMw", wo = Yq(Gq, Qq, {
  auth: {
    storage: localStorage,
    persistSession: !0,
    autoRefreshToken: !0
  }
});
function kT() {
  const [n, e] = D.useState(null), [r, o] = D.useState(null), [u, c] = D.useState(!0), [f, m] = D.useState(!1);
  D.useEffect(() => {
    const { data: { subscription: _ } } = wo.auth.onAuthStateChange(
      (T, k) => {
        o(k), e((k == null ? void 0 : k.user) ?? null), k != null && k.user ? setTimeout(() => {
          y(k.user.id);
        }, 0) : m(!1);
      }
    );
    return wo.auth.getSession().then(({ data: { session: T } }) => {
      o(T), e((T == null ? void 0 : T.user) ?? null), T != null && T.user && setTimeout(() => {
        y(T.user.id);
      }, 0), c(!1);
    }), () => _.unsubscribe();
  }, []);
  const y = async (_) => {
    try {
      const { data: T, error: k } = await wo.from("user_roles").select("role").eq("user_id", _).eq("role", "admin").maybeSingle();
      m(!!T && !k);
    } catch (T) {
      console.error("Error checking admin role:", T), m(!1);
    }
  };
  return {
    user: n,
    session: r,
    loading: u,
    isAdmin: f,
    signOut: async () => {
      await wo.auth.signOut();
    }
  };
}
const Zj = [
  { name: "Incio", href: "/" },
  { name: "Calados", href: "/categoria/calcados" },
  { name: "Roupas", href: "/categoria/roupas" },
  { name: "Perfumes", href: "/categoria/perfumes" },
  { name: "Cosmticos", href: "/categoria/cosmeticos" },
  { name: "Sobre", href: "/sobre" }
], tm = () => {
  const { user: n, isAdmin: e } = kT();
  return /* @__PURE__ */ x.jsx("header", {
    className: "sticky top-0 z-50 w-full border-b bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60", children: /* @__PURE__ */ x.jsxs("div", {
      className: "container mx-auto flex h-16 items-center justify-between px-4", children: [
    /* @__PURE__ */ x.jsx(ka, {
        to: "/", className: "flex items-center space-x-2", children: /* @__PURE__ */ x.jsxs("h1", {
          className: "text-2xl font-bold tracking-tight", children: [
      /* @__PURE__ */ x.jsx("span", { className: "text-foreground", children: "Bel" }),
      /* @__PURE__ */ x.jsx("span", { className: "text-accent", children: "ori" })
          ]
        })
      }),
    /* @__PURE__ */ x.jsx("nav", {
        className: "hidden md:flex items-center space-x-8", children: Zj.map((r) => /* @__PURE__ */ x.jsx(
          ka,
          {
            to: r.href,
            className: "text-sm font-medium text-muted-foreground transition-colors hover:text-foreground",
            children: r.name
          },
          r.name
        ))
      }),
    /* @__PURE__ */ x.jsxs("div", {
        className: "flex items-center gap-2", children: [
          e && /* @__PURE__ */ x.jsx(Jn, {
            variant: "ghost", size: "sm", asChild: !0, className: "hidden md:flex", children: /* @__PURE__ */ x.jsxs(ka, {
              to: "/admin", children: [
        /* @__PURE__ */ x.jsx(o3, { className: "h-4 w-4 mr-2" }),
                "Admin"
              ]
            })
          }),
          !n && /* @__PURE__ */ x.jsx(Jn, { variant: "ghost", size: "sm", asChild: !0, children: /* @__PURE__ */ x.jsx(ka, { to: "/auth", children: "Entrar" }) }),
      /* @__PURE__ */ x.jsx(P8, {}),
      /* @__PURE__ */ x.jsxs(CM, {
            children: [
        /* @__PURE__ */ x.jsx(TM, { asChild: !0, className: "md:hidden", children: /* @__PURE__ */ x.jsx(Jn, { variant: "ghost", size: "icon", children: /* @__PURE__ */ x.jsx(r3, { className: "h-5 w-5" }) }) }),
        /* @__PURE__ */ x.jsx(gT, {
              side: "right", children: /* @__PURE__ */ x.jsx("nav", {
                className: "flex flex-col space-y-4 mt-8", children: Zj.map((r) => /* @__PURE__ */ x.jsx(
                  ka,
                  {
                    to: r.href,
                    className: "text-lg font-medium text-muted-foreground transition-colors hover:text-foreground",
                    children: r.name
                  },
                  r.name
                ))
              })
            })
            ]
          })
        ]
      })
      ]
    })
  });
}, nm = () => /* @__PURE__ */ x.jsxs("footer", {
  className: "border-t bg-secondary/30 mt-20", children: [
  /* @__PURE__ */ x.jsxs("div", {
    className: "container mx-auto px-4 py-12", children: [
    /* @__PURE__ */ x.jsxs("div", {
      className: "grid grid-cols-1 md:grid-cols-4 gap-8", children: [
      /* @__PURE__ */ x.jsxs("div", {
        children: [
        /* @__PURE__ */ x.jsxs("h3", {
          className: "font-bold text-lg mb-4", children: [
          /* @__PURE__ */ x.jsx("span", { className: "text-foreground", children: "Bel" }),
          /* @__PURE__ */ x.jsx("span", { className: "text-accent", children: "ori" })
          ]
        }),
        /* @__PURE__ */ x.jsx("p", { className: "text-sm text-muted-foreground", children: "Estilo e elegncia para todas as ocasies. Encontre os melhores calados, roupas, perfumes e cosmticos." })
        ]
      }),
      /* @__PURE__ */ x.jsxs("div", {
        children: [
        /* @__PURE__ */ x.jsx("h4", { className: "font-semibold mb-4", children: "Categorias" }),
        /* @__PURE__ */ x.jsxs("ul", {
          className: "space-y-2 text-sm", children: [
          /* @__PURE__ */ x.jsx("li", { children: /* @__PURE__ */ x.jsx(ka, { to: "/categoria/calcados", className: "text-muted-foreground hover:text-foreground transition-colors", children: "Calados" }) }),
          /* @__PURE__ */ x.jsx("li", { children: /* @__PURE__ */ x.jsx(ka, { to: "/categoria/roupas", className: "text-muted-foreground hover:text-foreground transition-colors", children: "Roupas" }) }),
          /* @__PURE__ */ x.jsx("li", { children: /* @__PURE__ */ x.jsx(ka, { to: "/categoria/perfumes", className: "text-muted-foreground hover:text-foreground transition-colors", children: "Perfumes" }) }),
          /* @__PURE__ */ x.jsx("li", { children: /* @__PURE__ */ x.jsx(ka, { to: "/categoria/cosmeticos", className: "text-muted-foreground hover:text-foreground transition-colors", children: "Cosmticos" }) })
          ]
        })
        ]
      }),
      /* @__PURE__ */ x.jsxs("div", {
        children: [
        /* @__PURE__ */ x.jsx("h4", { className: "font-semibold mb-4", children: "Atendimento" }),
        /* @__PURE__ */ x.jsxs("ul", {
          className: "space-y-2 text-sm", children: [
          /* @__PURE__ */ x.jsx("li", { children: /* @__PURE__ */ x.jsx(ka, { to: "/sobre", className: "text-muted-foreground hover:text-foreground transition-colors", children: "Sobre Ns" }) }),
          /* @__PURE__ */ x.jsx("li", { children: /* @__PURE__ */ x.jsx("a", { href: "#", className: "text-muted-foreground hover:text-foreground transition-colors", children: "Poltica de Troca" }) }),
          /* @__PURE__ */ x.jsx("li", { children: /* @__PURE__ */ x.jsx("a", { href: "#", className: "text-muted-foreground hover:text-foreground transition-colors", children: "Envios" }) }),
          /* @__PURE__ */ x.jsx("li", { children: /* @__PURE__ */ x.jsx("a", { href: "#", className: "text-muted-foreground hover:text-foreground transition-colors", children: "FAQ" }) })
          ]
        })
        ]
      }),
      /* @__PURE__ */ x.jsxs("div", {
        children: [
        /* @__PURE__ */ x.jsx("h4", { className: "font-semibold mb-4", children: "Contato" }),
        /* @__PURE__ */ x.jsxs("ul", {
          className: "space-y-3 text-sm", children: [
          /* @__PURE__ */ x.jsxs("li", {
            className: "flex items-center gap-2 text-muted-foreground", children: [
            /* @__PURE__ */ x.jsx(AN, { className: "h-4 w-4" }),
            /* @__PURE__ */ x.jsx("span", { children: "(11) 99999-9999" })
            ]
          }),
          /* @__PURE__ */ x.jsxs("li", {
            className: "flex items-center gap-2 text-muted-foreground", children: [
            /* @__PURE__ */ x.jsx(n3, { className: "h-4 w-4" }),
            /* @__PURE__ */ x.jsx("span", { children: "contato@belori.com.br" })
            ]
          })
          ]
        }),
        /* @__PURE__ */ x.jsxs("div", {
          className: "flex gap-3 mt-4", children: [
          /* @__PURE__ */ x.jsx("a", { href: "#", className: "text-muted-foreground hover:text-accent transition-colors", children: /* @__PURE__ */ x.jsx(X4, { className: "h-5 w-5" }) }),
          /* @__PURE__ */ x.jsx("a", { href: "#", className: "text-muted-foreground hover:text-accent transition-colors", children: /* @__PURE__ */ x.jsx(G4, { className: "h-5 w-5" }) })
          ]
        })
        ]
      })
      ]
    }),
    /* @__PURE__ */ x.jsx("div", { className: "border-t mt-8 pt-8 text-center text-sm text-muted-foreground", children: /* @__PURE__ */ x.jsx("p", { children: " 2025 Belori. Todos os direitos reservados. Entrega para todo Brasil." }) })
    ]
  }),
  /* @__PURE__ */ x.jsx(
    "a",
    {
      href: "https://wa.me/5511999999999",
      target: "_blank",
      rel: "noopener noreferrer",
      className: "fixed bottom-6 right-6 z-50 bg-[#25D366] hover:bg-[#20BA5A] text-white rounded-full p-4 shadow-lg transition-all hover:scale-110",
      "aria-label": "Contato via WhatsApp",
      children: /* @__PURE__ */ x.jsx(AN, { className: "h-6 w-6" })
    }
  )
  ]
}), Jq = () => /* @__PURE__ */ x.jsxs("section", {
  className: "relative h-[500px] md:h-[600px] flex items-center justify-center bg-gradient-to-br from-secondary via-background to-beige overflow-hidden", children: [
  /* @__PURE__ */ x.jsx("div", { className: "absolute inset-0 bg-[url('/placeholder.svg')] bg-cover bg-center opacity-10" }),
  /* @__PURE__ */ x.jsxs("div", {
    className: "relative z-10 container mx-auto px-4 text-center", children: [
    /* @__PURE__ */ x.jsx("h1", { className: "text-4xl md:text-6xl font-bold mb-4 tracking-tight", children: "Estilo que define voc" }),
    /* @__PURE__ */ x.jsx("p", { className: "text-lg md:text-xl text-muted-foreground mb-8 max-w-2xl mx-auto", children: "Descubra a coleo perfeita de calados, roupas, perfumes e cosmticos para todas as ocasies" }),
    /* @__PURE__ */ x.jsxs("div", {
      className: "flex gap-4 justify-center flex-wrap", children: [
      /* @__PURE__ */ x.jsx(Jn, { size: "lg", asChild: !0, className: "bg-accent hover:bg-accent/90 text-accent-foreground", children: /* @__PURE__ */ x.jsx(ka, { to: "/categoria/calcados", children: "Ver Produtos" }) }),
      /* @__PURE__ */ x.jsx(Jn, { size: "lg", variant: "outline", asChild: !0, children: /* @__PURE__ */ x.jsx(ka, { to: "/sobre", children: "Conhea a Belori" }) })
      ]
    })
    ]
  })
  ]
}), Wo = D.forwardRef(({ className: n, ...e }, r) => /* @__PURE__ */ x.jsx("div", { ref: r, className: tn("rounded-lg border bg-card text-card-foreground shadow-sm", n), ...e }));
Wo.displayName = "Card";
const Hf = D.forwardRef(
  ({ className: n, ...e }, r) => /* @__PURE__ */ x.jsx("div", { ref: r, className: tn("flex flex-col space-y-1.5 p-6", n), ...e })
);
Hf.displayName = "CardHeader";
const sx = D.forwardRef(
  ({ className: n, ...e }, r) => /* @__PURE__ */ x.jsx("h3", { ref: r, className: tn("text-2xl font-semibold leading-none tracking-tight", n), ...e })
);
sx.displayName = "CardTitle";
const c2 = D.forwardRef(
  ({ className: n, ...e }, r) => /* @__PURE__ */ x.jsx("p", { ref: r, className: tn("text-sm text-muted-foreground", n), ...e })
);
c2.displayName = "CardDescription";
const qo = D.forwardRef(
  ({ className: n, ...e }, r) => /* @__PURE__ */ x.jsx("div", { ref: r, className: tn("p-6 pt-0", n), ...e })
);
qo.displayName = "CardContent";
const OT = D.forwardRef(
  ({ className: n, ...e }, r) => /* @__PURE__ */ x.jsx("div", { ref: r, className: tn("flex items-center p-6 pt-0", n), ...e })
);
OT.displayName = "CardFooter";
const Zq = [
  {
    name: "Calados",
    icon: Q4,
    href: "/categoria/calcados",
    description: "Tnis, sapatos e sapatilhas"
  },
  {
    name: "Roupas",
    icon: s3,
    href: "/categoria/roupas",
    description: "Moda para todos os estilos"
  },
  {
    name: "Perfumes",
    icon: l3,
    href: "/categoria/perfumes",
    description: "Fragrncias marcantes"
  },
  {
    name: "Cosmticos",
    icon: i3,
    href: "/categoria/cosmeticos",
    description: "Beleza e cuidados"
  }
], Xq = () => /* @__PURE__ */ x.jsxs("section", {
  className: "container mx-auto px-4 py-16", children: [
  /* @__PURE__ */ x.jsxs("div", {
    className: "text-center mb-12", children: [
    /* @__PURE__ */ x.jsx("h2", { className: "text-3xl md:text-4xl font-bold mb-4", children: "Nossas Categorias" }),
    /* @__PURE__ */ x.jsx("p", { className: "text-muted-foreground", children: "Explore nossa seleo cuidadosamente escolhida" })
    ]
  }),
  /* @__PURE__ */ x.jsx("div", {
    className: "grid grid-cols-2 lg:grid-cols-4 gap-4 md:gap-6", children: Zq.map((n) => /* @__PURE__ */ x.jsx(ka, {
      to: n.href, children: /* @__PURE__ */ x.jsx(Wo, {
        className: "group hover:shadow-lg transition-all hover:border-accent", children: /* @__PURE__ */ x.jsxs(qo, {
          className: "flex flex-col items-center justify-center p-6 md:p-8 text-center", children: [
    /* @__PURE__ */ x.jsx(n.icon, { className: "h-12 w-12 mb-4 text-accent group-hover:scale-110 transition-transform" }),
    /* @__PURE__ */ x.jsx("h3", { className: "font-semibold text-lg mb-2", children: n.name }),
    /* @__PURE__ */ x.jsx("p", { className: "text-sm text-muted-foreground", children: n.description })
          ]
        })
      })
    }, n.name))
  })
  ]
}), d2 = ({ product: n }) => {
  var m, y;
  const e = rx((b) => b.addItem), { node: r } = n, o = (b) => {
    var k;
    b.preventDefault(), b.stopPropagation();
    const _ = (k = r.variants.edges[0]) == null ? void 0 : k.node;
    if (!_) return;
    const T = {
      product: n,
      variantId: _.id,
      variantTitle: _.title,
      price: _.price,
      quantity: 1,
      selectedOptions: _.selectedOptions || []
    };
    e(T), ya.success("Produto adicionado ao carrinho!", {
      position: "top-center"
    });
  }, u = ((y = (m = r.images.edges[0]) == null ? void 0 : m.node) == null ? void 0 : y.url) || "/placeholder.svg", f = parseFloat(r.priceRange.minVariantPrice.amount).toLocaleString("pt-BR", { style: "currency", currency: "BRL" });
  return /* @__PURE__ */ x.jsx(ka, {
    to: `/produto/${r.handle}`, children: /* @__PURE__ */ x.jsxs(Wo, {
      className: "group overflow-hidden hover:shadow-lg transition-shadow", children: [
    /* @__PURE__ */ x.jsx(qo, {
        className: "p-0", children: /* @__PURE__ */ x.jsx("div", {
          className: "aspect-square overflow-hidden bg-secondary/20", children: /* @__PURE__ */ x.jsx(
            "img",
            {
              src: u,
              alt: r.title,
              className: "w-full h-full object-cover group-hover:scale-105 transition-transform duration-300"
            }
          )
        })
      }),
    /* @__PURE__ */ x.jsxs(OT, {
        className: "flex flex-col items-start p-4 gap-2", children: [
      /* @__PURE__ */ x.jsx("h3", { className: "font-semibold text-foreground line-clamp-2 w-full", children: r.title }),
      /* @__PURE__ */ x.jsxs("div", {
          className: "flex items-center justify-between w-full", children: [
        /* @__PURE__ */ x.jsx("p", { className: "text-xl font-bold text-accent", children: f }),
        /* @__PURE__ */ x.jsx(
            Jn,
            {
              size: "icon",
              variant: "outline",
              onClick: o,
              className: "hover:bg-accent hover:text-accent-foreground",
              children: /* @__PURE__ */ x.jsx(vm, { className: "h-4 w-4" })
            }
          )
          ]
        })
        ]
      })
      ]
    })
  });
}, e9 = () => {
  const { data: n, isLoading: e, error: r } = kl({
    queryKey: ["products"],
    queryFn: async () => {
      var c, f;
      const u = await Sy(bT, { first: 12 });
      return ((f = (c = u == null ? void 0 : u.data) == null ? void 0 : c.products) == null ? void 0 : f.edges) || [];
    }
  }), o = n;
  return /* @__PURE__ */ x.jsxs("div", {
    className: "min-h-screen flex flex-col", children: [
    /* @__PURE__ */ x.jsx(tm, {}),
    /* @__PURE__ */ x.jsxs("main", {
      className: "flex-1", children: [
      /* @__PURE__ */ x.jsx(Jq, {}),
      /* @__PURE__ */ x.jsx(Xq, {}),
      /* @__PURE__ */ x.jsxs("section", {
        className: "container mx-auto px-4 py-16", children: [
        /* @__PURE__ */ x.jsxs("div", {
          className: "text-center mb-12", children: [
          /* @__PURE__ */ x.jsx("h2", { className: "text-3xl md:text-4xl font-bold mb-4", children: "Produtos em Destaque" }),
          /* @__PURE__ */ x.jsx("p", { className: "text-muted-foreground", children: "Confira nossa seleo especial" })
          ]
        }),
          e && /* @__PURE__ */ x.jsx("div", { className: "flex justify-center items-center py-20", children: /* @__PURE__ */ x.jsx(Ff, { className: "h-8 w-8 animate-spin text-accent" }) }),
          r && /* @__PURE__ */ x.jsx("div", { className: "text-center py-20", children: /* @__PURE__ */ x.jsx("p", { className: "text-muted-foreground", children: "Erro ao carregar produtos" }) }),
          o && o.length === 0 && /* @__PURE__ */ x.jsxs("div", {
            className: "text-center py-20", children: [
          /* @__PURE__ */ x.jsx("p", { className: "text-muted-foreground mb-4", children: "Nenhum produto encontrado" }),
          /* @__PURE__ */ x.jsx("p", { className: "text-sm text-muted-foreground", children: "Por favor, crie produtos para comear a vender!" })
            ]
          }),
          o && o.length > 0 && /* @__PURE__ */ x.jsx("div", { className: "grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4 md:gap-6", children: o.map((u) => /* @__PURE__ */ x.jsx(d2, { product: u }, u.node.id)) })
        ]
      })
      ]
    }),
    /* @__PURE__ */ x.jsx(nm, {})
    ]
  });
}, t9 = {
  calcados: "Calados",
  roupas: "Roupas",
  perfumes: "Perfumes",
  cosmeticos: "Cosmticos"
}, n9 = () => {
  const { categoria: n } = wP(), e = t9[n || ""] || n, { data: r, isLoading: o, error: u } = kl({
    queryKey: ["products", n],
    queryFn: async () => {
      var m, y;
      const f = await Sy(bT, { first: 24 });
      return ((y = (m = f == null ? void 0 : f.data) == null ? void 0 : m.products) == null ? void 0 : y.edges) || [];
    }
  }), c = r;
  return /* @__PURE__ */ x.jsxs("div", {
    className: "min-h-screen flex flex-col", children: [
    /* @__PURE__ */ x.jsx(tm, {}),
    /* @__PURE__ */ x.jsxs("main", {
      className: "flex-1", children: [
      /* @__PURE__ */ x.jsx("section", {
        className: "bg-gradient-to-br from-secondary via-background to-beige py-12 md:py-16", children: /* @__PURE__ */ x.jsxs("div", {
          className: "container mx-auto px-4", children: [
        /* @__PURE__ */ x.jsx("h1", { className: "text-4xl md:text-5xl font-bold mb-4", children: e }),
        /* @__PURE__ */ x.jsx("p", { className: "text-muted-foreground", children: "Descubra os melhores produtos desta categoria" })
          ]
        })
      }),
      /* @__PURE__ */ x.jsxs("section", {
        className: "container mx-auto px-4 py-12", children: [
          o && /* @__PURE__ */ x.jsx("div", { className: "flex justify-center items-center py-20", children: /* @__PURE__ */ x.jsx(Ff, { className: "h-8 w-8 animate-spin text-accent" }) }),
          u && /* @__PURE__ */ x.jsx("div", { className: "text-center py-20", children: /* @__PURE__ */ x.jsx("p", { className: "text-muted-foreground", children: "Erro ao carregar produtos" }) }),
          c && c.length === 0 && /* @__PURE__ */ x.jsxs("div", {
            className: "text-center py-20", children: [
          /* @__PURE__ */ x.jsx("p", { className: "text-muted-foreground mb-4", children: "Nenhum produto encontrado nesta categoria" }),
          /* @__PURE__ */ x.jsx("p", { className: "text-sm text-muted-foreground", children: "Em breve teremos novidades!" })
            ]
          }),
          c && c.length > 0 && /* @__PURE__ */ x.jsx("div", { className: "grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4 md:gap-6", children: c.map((f) => /* @__PURE__ */ x.jsx(d2, { product: f }, f.node.id)) })
        ]
      })
      ]
    }),
    /* @__PURE__ */ x.jsx(nm, {})
    ]
  });
}, r9 = `
  query GetProduct($handle: String!) {
    productByHandle(handle: $handle) {
      id
      title
      description
      handle
      priceRange {
        minVariantPrice {
          amount
          currencyCode
        }
      }
      images(first: 5) {
        edges {
          node {
            url
            altText
          }
        }
      }
      variants(first: 10) {
        edges {
          node {
            id
            title
            price {
              amount
              currencyCode
            }
            availableForSale
            selectedOptions {
              name
              value
            }
          }
        }
      }
      options {
        name
        values
      }
    }
  }
`, a9 = () => {
    var _, T, k;
    const { handle: n } = wP(), e = rx((C) => C.addItem), [r, o] = D.useState(0), { data: u, isLoading: c, error: f } = kl({
      queryKey: ["product", n],
      queryFn: async () => {
        var M;
        const C = await Sy(r9, { handle: n });
        return (M = C == null ? void 0 : C.data) == null ? void 0 : M.productByHandle;
      }
    });
    if (c)
      return /* @__PURE__ */ x.jsxs("div", {
        className: "min-h-screen flex flex-col", children: [
      /* @__PURE__ */ x.jsx(tm, {}),
      /* @__PURE__ */ x.jsx("main", { className: "flex-1 flex items-center justify-center", children: /* @__PURE__ */ x.jsx(Ff, { className: "h-8 w-8 animate-spin text-accent" }) }),
      /* @__PURE__ */ x.jsx(nm, {})
        ]
      });
    if (f || !u)
      return /* @__PURE__ */ x.jsxs("div", {
        className: "min-h-screen flex flex-col", children: [
      /* @__PURE__ */ x.jsx(tm, {}),
      /* @__PURE__ */ x.jsx("main", { className: "flex-1 flex items-center justify-center", children: /* @__PURE__ */ x.jsx("p", { className: "text-muted-foreground", children: "Produto no encontrado" }) }),
      /* @__PURE__ */ x.jsx(nm, {})
        ]
      });
    const m = {
      node: u
    }, y = (_ = m.node.variants.edges[r]) == null ? void 0 : _.node, b = () => {
      if (!y) return;
      const C = {
        product: m,
        variantId: y.id,
        variantTitle: y.title,
        price: y.price,
        quantity: 1,
        selectedOptions: y.selectedOptions || []
      };
      e(C), ya.success("Produto adicionado ao carrinho!", {
        position: "top-center"
      });
    };
    return /* @__PURE__ */ x.jsxs("div", {
      className: "min-h-screen flex flex-col", children: [
    /* @__PURE__ */ x.jsx(tm, {}),
    /* @__PURE__ */ x.jsx("main", {
        className: "flex-1", children: /* @__PURE__ */ x.jsx("div", {
          className: "container mx-auto px-4 py-12", children: /* @__PURE__ */ x.jsxs("div", {
            className: "grid md:grid-cols-2 gap-8 lg:gap-12", children: [
      /* @__PURE__ */ x.jsxs("div", {
              className: "space-y-4", children: [
        /* @__PURE__ */ x.jsx("div", {
                className: "aspect-square bg-secondary/20 rounded-lg overflow-hidden", children: /* @__PURE__ */ x.jsx(
                  "img",
                  {
                    src: ((k = (T = m.node.images.edges[0]) == null ? void 0 : T.node) == null ? void 0 : k.url) || "/placeholder.svg",
                    alt: m.node.title,
                    className: "w-full h-full object-cover"
                  }
                )
              }),
        /* @__PURE__ */ x.jsx("div", {
                className: "grid grid-cols-4 gap-2", children: m.node.images.edges.slice(1, 5).map((C, M) => /* @__PURE__ */ x.jsx("div", {
                  className: "aspect-square bg-secondary/20 rounded-md overflow-hidden", children: /* @__PURE__ */ x.jsx(
                    "img",
                    {
                      src: C.node.url,
                      alt: `${m.node.title} ${M + 2}`,
                      className: "w-full h-full object-cover"
                    }
                  )
                }, M))
              })
              ]
            }),
      /* @__PURE__ */ x.jsxs("div", {
              className: "space-y-6", children: [
        /* @__PURE__ */ x.jsxs("div", {
                children: [
          /* @__PURE__ */ x.jsx("h1", { className: "text-3xl md:text-4xl font-bold mb-2", children: m.node.title }),
          /* @__PURE__ */ x.jsx("p", { className: "text-3xl font-bold text-accent", children: y ? Number(y.price.amount).toLocaleString("pt-BR", { style: "currency", currency: "BRL" }) : null })
                ]
              }),
        /* @__PURE__ */ x.jsx("div", { className: "prose prose-sm max-w-none", children: /* @__PURE__ */ x.jsx("p", { className: "text-muted-foreground", children: m.node.description }) }),
                m.node.options.map((C, M) => /* @__PURE__ */ x.jsxs("div", {
                  children: [
          /* @__PURE__ */ x.jsx("label", { className: "block text-sm font-medium mb-2", children: C.name }),
          /* @__PURE__ */ x.jsx("div", {
                    className: "flex flex-wrap gap-2", children: C.values.map((N, A) => {
                      const $ = m.node.variants.edges.findIndex(
                        (I) => I.node.selectedOptions.some((U) => U.value === N)
                      );
                      return /* @__PURE__ */ x.jsx(
                        Jn,
                        {
                          variant: r === $ ? "default" : "outline",
                          onClick: () => o($),
                          children: N
                        },
                        N
                      );
                    })
                  })
                  ]
                }, C.name)),
        /* @__PURE__ */ x.jsxs(
                  Jn,
                  {
                    size: "lg",
                    className: "w-full",
                    onClick: b,
                    disabled: !(y != null && y.availableForSale),
                    children: [
              /* @__PURE__ */ x.jsx(vm, { className: "mr-2 h-5 w-5" }),
                      y != null && y.availableForSale ? "Adicionar ao Carrinho" : "Indisponvel"
                    ]
                  }
                ),
        /* @__PURE__ */ x.jsxs("div", {
                  className: "border-t pt-6 space-y-2 text-sm", children: [
          /* @__PURE__ */ x.jsx("p", { className: "text-muted-foreground", children: " Entrega para todo o Brasil" }),
          /* @__PURE__ */ x.jsx("p", { className: "text-muted-foreground", children: " Frete calculado no checkout" }),
          /* @__PURE__ */ x.jsx("p", { className: "text-muted-foreground", children: " Pagamento seguro" })
                  ]
                })
              ]
            })
            ]
          })
        })
      }),
    /* @__PURE__ */ x.jsx(nm, {})
      ]
    });
  }, i9 = () => /* @__PURE__ */ x.jsxs("div", {
    className: "min-h-screen flex flex-col", children: [
  /* @__PURE__ */ x.jsx(tm, {}),
  /* @__PURE__ */ x.jsxs("main", {
      className: "flex-1", children: [
    /* @__PURE__ */ x.jsx("section", {
        className: "bg-gradient-to-br from-secondary via-background to-beige py-16 md:py-20", children: /* @__PURE__ */ x.jsxs("div", {
          className: "container mx-auto px-4 text-center", children: [
      /* @__PURE__ */ x.jsxs("h1", {
            className: "text-4xl md:text-5xl font-bold mb-4", children: [
              "Sobre a ",
        /* @__PURE__ */ x.jsx("span", { className: "text-accent", children: "Belori" })
            ]
          }),
      /* @__PURE__ */ x.jsx("p", { className: "text-lg text-muted-foreground max-w-2xl mx-auto", children: "Estilo, qualidade e elegncia em cada detalhe" })
          ]
        })
      }),
    /* @__PURE__ */ x.jsx("section", {
        className: "container mx-auto px-4 py-16", children: /* @__PURE__ */ x.jsxs("div", {
          className: "max-w-3xl mx-auto space-y-8", children: [
      /* @__PURE__ */ x.jsxs("div", {
            children: [
        /* @__PURE__ */ x.jsx("h2", { className: "text-2xl font-bold mb-4", children: "Nossa Histria" }),
        /* @__PURE__ */ x.jsx("p", { className: "text-muted-foreground leading-relaxed", children: "A Belori nasceu da paixo por moda e beleza, com o objetivo de oferecer produtos de alta qualidade que valorizam o estilo nico de cada pessoa. Acreditamos que todos merecem ter acesso a peas elegantes, confortveis e que expressem sua personalidade." })
            ]
          }),
      /* @__PURE__ */ x.jsxs("div", {
            children: [
        /* @__PURE__ */ x.jsx("h2", { className: "text-2xl font-bold mb-4", children: "Nossa Misso" }),
        /* @__PURE__ */ x.jsx("p", { className: "text-muted-foreground leading-relaxed", children: "Proporcionar uma experincia de compra excepcional, oferecendo calados, roupas, perfumes e cosmticos cuidadosamente selecionados. Buscamos sempre as melhores marcas e tendncias para atender aos mais diversos estilos e ocasies." })
            ]
          }),
      /* @__PURE__ */ x.jsxs("div", {
            className: "grid md:grid-cols-3 gap-6 pt-8", children: [
        /* @__PURE__ */ x.jsx(Wo, {
              children: /* @__PURE__ */ x.jsxs(qo, {
                className: "flex flex-col items-center text-center p-6", children: [
          /* @__PURE__ */ x.jsx(Z4, { className: "h-12 w-12 text-accent mb-4" }),
          /* @__PURE__ */ x.jsx("h3", { className: "font-semibold mb-2", children: "Qualidade" }),
          /* @__PURE__ */ x.jsx("p", { className: "text-sm text-muted-foreground", children: "Produtos selecionados com rigor e excelncia" })
                ]
              })
            }),
        /* @__PURE__ */ x.jsx(Wo, {
              children: /* @__PURE__ */ x.jsxs(qo, {
                className: "flex flex-col items-center text-center p-6", children: [
          /* @__PURE__ */ x.jsx(d3, { className: "h-12 w-12 text-accent mb-4" }),
          /* @__PURE__ */ x.jsx("h3", { className: "font-semibold mb-2", children: "Tendncias" }),
          /* @__PURE__ */ x.jsx("p", { className: "text-sm text-muted-foreground", children: "Sempre atualizados com as ltimas novidades" })
                ]
              })
            }),
        /* @__PURE__ */ x.jsx(Wo, {
              children: /* @__PURE__ */ x.jsxs(qo, {
                className: "flex flex-col items-center text-center p-6", children: [
          /* @__PURE__ */ x.jsx(J4, { className: "h-12 w-12 text-accent mb-4" }),
          /* @__PURE__ */ x.jsx("h3", { className: "font-semibold mb-2", children: "Todo Brasil" }),
          /* @__PURE__ */ x.jsx("p", { className: "text-sm text-muted-foreground", children: "Entregamos para todos os estados" })
                ]
              })
            })
            ]
          })
          ]
        })
      })
      ]
    }),
  /* @__PURE__ */ x.jsx(nm, {})
    ]
  }), hi = D.forwardRef(
    ({ className: n, type: e, ...r }, o) => /* @__PURE__ */ x.jsx(
      "input",
      {
        type: e,
        className: tn(
          "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
          n
        ),
        ref: o,
        ...r
      }
    )
  );
hi.displayName = "Input";
var o9 = "Label", f2 = D.forwardRef((n, e) => /* @__PURE__ */ x.jsx(
  Zn.label,
  {
    ...n,
    ref: e,
    onMouseDown: (r) => {
      var u;
      r.target.closest("button, input, select, textarea") || ((u = n.onMouseDown) == null || u.call(n, r), !r.defaultPrevented && r.detail > 1 && r.preventDefault());
    }
  }
));
f2.displayName = o9;
var h2 = f2;
const s9 = gy("text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"), vo = D.forwardRef(({ className: n, ...e }, r) => /* @__PURE__ */ x.jsx(h2, { ref: r, className: tn(s9(), n), ...e }));
vo.displayName = h2.displayName;
var l9 = D.createContext(void 0);
function p2(n) {
  const e = D.useContext(l9);
  return n || e || "ltr";
}
var LC = "rovingFocusGroup.onEntryFocus", u9 = { bubbles: !1, cancelable: !0 }, Ey = "RovingFocusGroup", [O1, m2, c9] = $A(Ey), [d9, v2] = Yf(
  Ey,
  [c9]
), [f9, h9] = d9(Ey), g2 = D.forwardRef(
  (n, e) => /* @__PURE__ */ x.jsx(O1.Provider, { scope: n.__scopeRovingFocusGroup, children: /* @__PURE__ */ x.jsx(O1.Slot, { scope: n.__scopeRovingFocusGroup, children: /* @__PURE__ */ x.jsx(p9, { ...n, ref: e }) }) })
);
g2.displayName = Ey;
var p9 = D.forwardRef((n, e) => {
  const {
    __scopeRovingFocusGroup: r,
    orientation: o,
    loop: u = !1,
    dir: c,
    currentTabStopId: f,
    defaultCurrentTabStopId: m,
    onCurrentTabStopIdChange: y,
    onEntryFocus: b,
    preventScrollOnEntryFocus: _ = !1,
    ...T
  } = n, k = D.useRef(null), C = pi(e, k), M = p2(c), [N, A] = mx({
    prop: f,
    defaultProp: m ?? null,
    onChange: y,
    caller: Ey
  }), [$, I] = D.useState(!1), U = As(b), B = m2(r), K = D.useRef(!1), [te, re] = D.useState(0);
  return D.useEffect(() => {
    const ve = k.current;
    if (ve)
      return ve.addEventListener(LC, U), () => ve.removeEventListener(LC, U);
  }, [U]), /* @__PURE__ */ x.jsx(
    f9,
    {
      scope: r,
      orientation: o,
      dir: M,
      loop: u,
      currentTabStopId: N,
      onItemFocus: D.useCallback(
        (ve) => A(ve),
        [A]
      ),
      onItemShiftTab: D.useCallback(() => I(!0), []),
      onFocusableItemAdd: D.useCallback(
        () => re((ve) => ve + 1),
        []
      ),
      onFocusableItemRemove: D.useCallback(
        () => re((ve) => ve - 1),
        []
      ),
      children: /* @__PURE__ */ x.jsx(
        Zn.div,
        {
          tabIndex: $ || te === 0 ? -1 : 0,
          "data-orientation": o,
          ...T,
          ref: C,
          style: { outline: "none", ...n.style },
          onMouseDown: wn(n.onMouseDown, () => {
            K.current = !0;
          }),
          onFocus: wn(n.onFocus, (ve) => {
            const Ce = !K.current;
            if (ve.target === ve.currentTarget && Ce && !$) {
              const ke = new CustomEvent(LC, u9);
              if (ve.currentTarget.dispatchEvent(ke), !ke.defaultPrevented) {
                const Ie = B().filter((Me) => Me.focusable), Ne = Ie.find((Me) => Me.active), Re = Ie.find((Me) => Me.id === N), Ge = [Ne, Re, ...Ie].filter(
                  Boolean
                ).map((Me) => Me.ref.current);
                w2(Ge, _);
              }
            }
            K.current = !1;
          }),
          onBlur: wn(n.onBlur, () => I(!1))
        }
      )
    }
  );
}), y2 = "RovingFocusGroupItem", b2 = D.forwardRef(
  (n, e) => {
    const {
      __scopeRovingFocusGroup: r,
      focusable: o = !0,
      active: u = !1,
      tabStopId: c,
      children: f,
      ...m
    } = n, y = Wg(), b = c || y, _ = h9(y2, r), T = _.currentTabStopId === b, k = m2(r), { onFocusableItemAdd: C, onFocusableItemRemove: M, currentTabStopId: N } = _;
    return D.useEffect(() => {
      if (o)
        return C(), () => M();
    }, [o, C, M]), /* @__PURE__ */ x.jsx(
      O1.ItemSlot,
      {
        scope: r,
        id: b,
        focusable: o,
        active: u,
        children: /* @__PURE__ */ x.jsx(
          Zn.span,
          {
            tabIndex: T ? 0 : -1,
            "data-orientation": _.orientation,
            ...m,
            ref: e,
            onMouseDown: wn(n.onMouseDown, (A) => {
              o ? _.onItemFocus(b) : A.preventDefault();
            }),
            onFocus: wn(n.onFocus, () => _.onItemFocus(b)),
            onKeyDown: wn(n.onKeyDown, (A) => {
              if (A.key === "Tab" && A.shiftKey) {
                _.onItemShiftTab();
                return;
              }
              if (A.target !== A.currentTarget) return;
              const $ = g9(A, _.orientation, _.dir);
              if ($ !== void 0) {
                if (A.metaKey || A.ctrlKey || A.altKey || A.shiftKey) return;
                A.preventDefault();
                let U = k().filter((B) => B.focusable).map((B) => B.ref.current);
                if ($ === "last") U.reverse();
                else if ($ === "prev" || $ === "next") {
                  $ === "prev" && U.reverse();
                  const B = U.indexOf(A.currentTarget);
                  U = _.loop ? y9(U, B + 1) : U.slice(B + 1);
                }
                setTimeout(() => w2(U));
              }
            }),
            children: typeof f == "function" ? f({ isCurrentTabStop: T, hasTabStop: N != null }) : f
          }
        )
      }
    );
  }
);
b2.displayName = y2;
var m9 = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function v9(n, e) {
  return e !== "rtl" ? n : n === "ArrowLeft" ? "ArrowRight" : n === "ArrowRight" ? "ArrowLeft" : n;
}
function g9(n, e, r) {
  const o = v9(n.key, r);
  if (!(e === "vertical" && ["ArrowLeft", "ArrowRight"].includes(o)) && !(e === "horizontal" && ["ArrowUp", "ArrowDown"].includes(o)))
    return m9[o];
}
function w2(n, e = !1) {
  const r = document.activeElement;
  for (const o of n)
    if (o === r || (o.focus({ preventScroll: e }), document.activeElement !== r)) return;
}
function y9(n, e) {
  return n.map((r, o) => n[(e + o) % n.length]);
}
var b9 = g2, w9 = b2, Dx = "Tabs", [x9, fK] = Yf(Dx, [
  v2
]), x2 = v2(), [S9, NT] = x9(Dx), S2 = D.forwardRef(
  (n, e) => {
    const {
      __scopeTabs: r,
      value: o,
      onValueChange: u,
      defaultValue: c,
      orientation: f = "horizontal",
      dir: m,
      activationMode: y = "automatic",
      ...b
    } = n, _ = p2(m), [T, k] = mx({
      prop: o,
      onChange: u,
      defaultProp: c ?? "",
      caller: Dx
    });
    return /* @__PURE__ */ x.jsx(
      S9,
      {
        scope: r,
        baseId: Wg(),
        value: T,
        onValueChange: k,
        orientation: f,
        dir: _,
        activationMode: y,
        children: /* @__PURE__ */ x.jsx(
          Zn.div,
          {
            dir: _,
            "data-orientation": f,
            ...b,
            ref: e
          }
        )
      }
    );
  }
);
S2.displayName = Dx;
var _2 = "TabsList", E2 = D.forwardRef(
  (n, e) => {
    const { __scopeTabs: r, loop: o = !0, ...u } = n, c = NT(_2, r), f = x2(r);
    return /* @__PURE__ */ x.jsx(
      b9,
      {
        asChild: !0,
        ...f,
        orientation: c.orientation,
        dir: c.dir,
        loop: o,
        children: /* @__PURE__ */ x.jsx(
          Zn.div,
          {
            role: "tablist",
            "aria-orientation": c.orientation,
            ...u,
            ref: e
          }
        )
      }
    );
  }
);
E2.displayName = _2;
var C2 = "TabsTrigger", T2 = D.forwardRef(
  (n, e) => {
    const { __scopeTabs: r, value: o, disabled: u = !1, ...c } = n, f = NT(C2, r), m = x2(r), y = O2(f.baseId, o), b = N2(f.baseId, o), _ = o === f.value;
    return /* @__PURE__ */ x.jsx(
      w9,
      {
        asChild: !0,
        ...m,
        focusable: !u,
        active: _,
        children: /* @__PURE__ */ x.jsx(
          Zn.button,
          {
            type: "button",
            role: "tab",
            "aria-selected": _,
            "aria-controls": b,
            "data-state": _ ? "active" : "inactive",
            "data-disabled": u ? "" : void 0,
            disabled: u,
            id: y,
            ...c,
            ref: e,
            onMouseDown: wn(n.onMouseDown, (T) => {
              !u && T.button === 0 && T.ctrlKey === !1 ? f.onValueChange(o) : T.preventDefault();
            }),
            onKeyDown: wn(n.onKeyDown, (T) => {
              [" ", "Enter"].includes(T.key) && f.onValueChange(o);
            }),
            onFocus: wn(n.onFocus, () => {
              const T = f.activationMode !== "manual";
              !_ && !u && T && f.onValueChange(o);
            })
          }
        )
      }
    );
  }
);
T2.displayName = C2;
var R2 = "TabsContent", k2 = D.forwardRef(
  (n, e) => {
    const { __scopeTabs: r, value: o, forceMount: u, children: c, ...f } = n, m = NT(R2, r), y = O2(m.baseId, o), b = N2(m.baseId, o), _ = o === m.value, T = D.useRef(_);
    return D.useEffect(() => {
      const k = requestAnimationFrame(() => T.current = !1);
      return () => cancelAnimationFrame(k);
    }, []), /* @__PURE__ */ x.jsx(Kf, {
      present: u || _, children: ({ present: k }) => /* @__PURE__ */ x.jsx(
        Zn.div,
        {
          "data-state": _ ? "active" : "inactive",
          "data-orientation": m.orientation,
          role: "tabpanel",
          "aria-labelledby": y,
          hidden: !k,
          id: b,
          tabIndex: 0,
          ...f,
          ref: e,
          style: {
            ...n.style,
            animationDuration: T.current ? "0s" : void 0
          },
          children: k && c
        }
      )
    });
  }
);
k2.displayName = R2;
function O2(n, e) {
  return `${n}-trigger-${e}`;
}
function N2(n, e) {
  return `${n}-content-${e}`;
}
var _9 = S2, j2 = E2, A2 = T2, D2 = k2;
const E9 = _9, P2 = D.forwardRef(({ className: n, ...e }, r) => /* @__PURE__ */ x.jsx(
  j2,
  {
    ref: r,
    className: tn(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      n
    ),
    ...e
  }
));
P2.displayName = j2.displayName;
const N1 = D.forwardRef(({ className: n, ...e }, r) => /* @__PURE__ */ x.jsx(
  A2,
  {
    ref: r,
    className: tn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
      n
    ),
    ...e
  }
));
N1.displayName = A2.displayName;
const j1 = D.forwardRef(({ className: n, ...e }, r) => /* @__PURE__ */ x.jsx(
  D2,
  {
    ref: r,
    className: tn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      n
    ),
    ...e
  }
));
j1.displayName = D2.displayName;
var Tn;
(function (n) {
  n.assertEqual = (u) => {
  };
  function e(u) {
  }
  n.assertIs = e;
  function r(u) {
    throw new Error();
  }
  n.assertNever = r, n.arrayToEnum = (u) => {
    const c = {};
    for (const f of u)
      c[f] = f;
    return c;
  }, n.getValidEnumValues = (u) => {
    const c = n.objectKeys(u).filter((m) => typeof u[u[m]] != "number"), f = {};
    for (const m of c)
      f[m] = u[m];
    return n.objectValues(f);
  }, n.objectValues = (u) => n.objectKeys(u).map(function (c) {
    return u[c];
  }), n.objectKeys = typeof Object.keys == "function" ? (u) => Object.keys(u) : (u) => {
    const c = [];
    for (const f in u)
      Object.prototype.hasOwnProperty.call(u, f) && c.push(f);
    return c;
  }, n.find = (u, c) => {
    for (const f of u)
      if (c(f))
        return f;
  }, n.isInteger = typeof Number.isInteger == "function" ? (u) => Number.isInteger(u) : (u) => typeof u == "number" && Number.isFinite(u) && Math.floor(u) === u;
  function o(u, c = " | ") {
    return u.map((f) => typeof f == "string" ? `'${f}'` : f).join(c);
  }
  n.joinValues = o, n.jsonStringifyReplacer = (u, c) => typeof c == "bigint" ? c.toString() : c;
})(Tn || (Tn = {}));
var Xj;
(function (n) {
  n.mergeShapes = (e, r) => ({
    ...e,
    ...r
    // second overwrites first
  });
})(Xj || (Xj = {}));
const it = Tn.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), qc = (n) => {
  switch (typeof n) {
    case "undefined":
      return it.undefined;
    case "string":
      return it.string;
    case "number":
      return Number.isNaN(n) ? it.nan : it.number;
    case "boolean":
      return it.boolean;
    case "function":
      return it.function;
    case "bigint":
      return it.bigint;
    case "symbol":
      return it.symbol;
    case "object":
      return Array.isArray(n) ? it.array : n === null ? it.null : n.then && typeof n.then == "function" && n.catch && typeof n.catch == "function" ? it.promise : typeof Map < "u" && n instanceof Map ? it.map : typeof Set < "u" && n instanceof Set ? it.set : typeof Date < "u" && n instanceof Date ? it.date : it.object;
    default:
      return it.unknown;
  }
}, De = Tn.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
class Ls extends Error {
  get errors() {
    return this.issues;
  }
  constructor(e) {
    super(), this.issues = [], this.addIssue = (o) => {
      this.issues = [...this.issues, o];
    }, this.addIssues = (o = []) => {
      this.issues = [...this.issues, ...o];
    };
    const r = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, r) : this.__proto__ = r, this.name = "ZodError", this.issues = e;
  }
  format(e) {
    const r = e || function (c) {
      return c.message;
    }, o = { _errors: [] }, u = (c) => {
      for (const f of c.issues)
        if (f.code === "invalid_union")
          f.unionErrors.map(u);
        else if (f.code === "invalid_return_type")
          u(f.returnTypeError);
        else if (f.code === "invalid_arguments")
          u(f.argumentsError);
        else if (f.path.length === 0)
          o._errors.push(r(f));
        else {
          let m = o, y = 0;
          for (; y < f.path.length;) {
            const b = f.path[y];
            y === f.path.length - 1 ? (m[b] = m[b] || { _errors: [] }, m[b]._errors.push(r(f))) : m[b] = m[b] || { _errors: [] }, m = m[b], y++;
          }
        }
    };
    return u(this), o;
  }
  static assert(e) {
    if (!(e instanceof Ls))
      throw new Error(`Not a ZodError: ${e}`);
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, Tn.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(e = (r) => r.message) {
    const r = {}, o = [];
    for (const u of this.issues)
      if (u.path.length > 0) {
        const c = u.path[0];
        r[c] = r[c] || [], r[c].push(e(u));
      } else
        o.push(e(u));
    return { formErrors: o, fieldErrors: r };
  }
  get formErrors() {
    return this.flatten();
  }
}
Ls.create = (n) => new Ls(n);
const A1 = (n, e) => {
  let r;
  switch (n.code) {
    case De.invalid_type:
      n.received === it.undefined ? r = "Required" : r = `Expected ${n.expected}, received ${n.received}`;
      break;
    case De.invalid_literal:
      r = `Invalid literal value, expected ${JSON.stringify(n.expected, Tn.jsonStringifyReplacer)}`;
      break;
    case De.unrecognized_keys:
      r = `Unrecognized key(s) in object: ${Tn.joinValues(n.keys, ", ")}`;
      break;
    case De.invalid_union:
      r = "Invalid input";
      break;
    case De.invalid_union_discriminator:
      r = `Invalid discriminator value. Expected ${Tn.joinValues(n.options)}`;
      break;
    case De.invalid_enum_value:
      r = `Invalid enum value. Expected ${Tn.joinValues(n.options)}, received '${n.received}'`;
      break;
    case De.invalid_arguments:
      r = "Invalid function arguments";
      break;
    case De.invalid_return_type:
      r = "Invalid function return type";
      break;
    case De.invalid_date:
      r = "Invalid date";
      break;
    case De.invalid_string:
      typeof n.validation == "object" ? "includes" in n.validation ? (r = `Invalid input: must include "${n.validation.includes}"`, typeof n.validation.position == "number" && (r = `${r} at one or more positions greater than or equal to ${n.validation.position}`)) : "startsWith" in n.validation ? r = `Invalid input: must start with "${n.validation.startsWith}"` : "endsWith" in n.validation ? r = `Invalid input: must end with "${n.validation.endsWith}"` : Tn.assertNever(n.validation) : n.validation !== "regex" ? r = `Invalid ${n.validation}` : r = "Invalid";
      break;
    case De.too_small:
      n.type === "array" ? r = `Array must contain ${n.exact ? "exactly" : n.inclusive ? "at least" : "more than"} ${n.minimum} element(s)` : n.type === "string" ? r = `String must contain ${n.exact ? "exactly" : n.inclusive ? "at least" : "over"} ${n.minimum} character(s)` : n.type === "number" ? r = `Number must be ${n.exact ? "exactly equal to " : n.inclusive ? "greater than or equal to " : "greater than "}${n.minimum}` : n.type === "bigint" ? r = `Number must be ${n.exact ? "exactly equal to " : n.inclusive ? "greater than or equal to " : "greater than "}${n.minimum}` : n.type === "date" ? r = `Date must be ${n.exact ? "exactly equal to " : n.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(n.minimum))}` : r = "Invalid input";
      break;
    case De.too_big:
      n.type === "array" ? r = `Array must contain ${n.exact ? "exactly" : n.inclusive ? "at most" : "less than"} ${n.maximum} element(s)` : n.type === "string" ? r = `String must contain ${n.exact ? "exactly" : n.inclusive ? "at most" : "under"} ${n.maximum} character(s)` : n.type === "number" ? r = `Number must be ${n.exact ? "exactly" : n.inclusive ? "less than or equal to" : "less than"} ${n.maximum}` : n.type === "bigint" ? r = `BigInt must be ${n.exact ? "exactly" : n.inclusive ? "less than or equal to" : "less than"} ${n.maximum}` : n.type === "date" ? r = `Date must be ${n.exact ? "exactly" : n.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(n.maximum))}` : r = "Invalid input";
      break;
    case De.custom:
      r = "Invalid input";
      break;
    case De.invalid_intersection_types:
      r = "Intersection results could not be merged";
      break;
    case De.not_multiple_of:
      r = `Number must be a multiple of ${n.multipleOf}`;
      break;
    case De.not_finite:
      r = "Number must be finite";
      break;
    default:
      r = e.defaultError, Tn.assertNever(n);
  }
  return { message: r };
};
let C9 = A1;
function T9() {
  return C9;
}
const R9 = (n) => {
  const { data: e, path: r, errorMaps: o, issueData: u } = n, c = [...r, ...u.path || []], f = {
    ...u,
    path: c
  };
  if (u.message !== void 0)
    return {
      ...u,
      path: c,
      message: u.message
    };
  let m = "";
  const y = o.filter((b) => !!b).slice().reverse();
  for (const b of y)
    m = b(f, { data: e, defaultError: m }).message;
  return {
    ...u,
    path: c,
    message: m
  };
};
function Ke(n, e) {
  const r = T9(), o = R9({
    issueData: e,
    data: n.data,
    path: n.path,
    errorMaps: [
      n.common.contextualErrorMap,
      // contextual error map is first priority
      n.schemaErrorMap,
      // then schema-bound map if available
      r,
      // then global override map
      r === A1 ? void 0 : A1
      // then global default map
    ].filter((u) => !!u)
  });
  n.common.issues.push(o);
}
class So {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(e, r) {
    const o = [];
    for (const u of r) {
      if (u.status === "aborted")
        return Lt;
      u.status === "dirty" && e.dirty(), o.push(u.value);
    }
    return { status: e.value, value: o };
  }
  static async mergeObjectAsync(e, r) {
    const o = [];
    for (const u of r) {
      const c = await u.key, f = await u.value;
      o.push({
        key: c,
        value: f
      });
    }
    return So.mergeObjectSync(e, o);
  }
  static mergeObjectSync(e, r) {
    const o = {};
    for (const u of r) {
      const { key: c, value: f } = u;
      if (c.status === "aborted" || f.status === "aborted")
        return Lt;
      c.status === "dirty" && e.dirty(), f.status === "dirty" && e.dirty(), c.value !== "__proto__" && (typeof f.value < "u" || u.alwaysSet) && (o[c.value] = f.value);
    }
    return { status: e.value, value: o };
  }
}
const Lt = Object.freeze({
  status: "aborted"
}), Vg = (n) => ({ status: "dirty", value: n }), Ko = (n) => ({ status: "valid", value: n }), eA = (n) => n.status === "aborted", tA = (n) => n.status === "dirty", xm = (n) => n.status === "valid", lx = (n) => typeof Promise < "u" && n instanceof Promise;
var ct;
(function (n) {
  n.errToObj = (e) => typeof e == "string" ? { message: e } : e || {}, n.toString = (e) => typeof e == "string" ? e : e == null ? void 0 : e.message;
})(ct || (ct = {}));
class dd {
  constructor(e, r, o, u) {
    this._cachedPath = [], this.parent = e, this.data = r, this._path = o, this._key = u;
  }
  get path() {
    return this._cachedPath.length || (Array.isArray(this._key) ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
}
const nA = (n, e) => {
  if (xm(e))
    return { success: !0, data: e.value };
  if (!n.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const r = new Ls(n.common.issues);
      return this._error = r, this._error;
    }
  };
};
function en(n) {
  if (!n)
    return {};
  const { errorMap: e, invalid_type_error: r, required_error: o, description: u } = n;
  if (e && (r || o))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return e ? { errorMap: e, description: u } : {
    errorMap: (f, m) => {
      const { message: y } = n;
      return f.code === "invalid_enum_value" ? { message: y ?? m.defaultError } : typeof m.data > "u" ? { message: y ?? o ?? m.defaultError } : f.code !== "invalid_type" ? { message: m.defaultError } : { message: y ?? r ?? m.defaultError };
    }, description: u
  };
}
class xn {
  get description() {
    return this._def.description;
  }
  _getType(e) {
    return qc(e.data);
  }
  _getOrReturnCtx(e, r) {
    return r || {
      common: e.parent.common,
      data: e.data,
      parsedType: qc(e.data),
      schemaErrorMap: this._def.errorMap,
      path: e.path,
      parent: e.parent
    };
  }
  _processInputParams(e) {
    return {
      status: new So(),
      ctx: {
        common: e.parent.common,
        data: e.data,
        parsedType: qc(e.data),
        schemaErrorMap: this._def.errorMap,
        path: e.path,
        parent: e.parent
      }
    };
  }
  _parseSync(e) {
    const r = this._parse(e);
    if (lx(r))
      throw new Error("Synchronous parse encountered promise.");
    return r;
  }
  _parseAsync(e) {
    const r = this._parse(e);
    return Promise.resolve(r);
  }
  parse(e, r) {
    const o = this.safeParse(e, r);
    if (o.success)
      return o.data;
    throw o.error;
  }
  safeParse(e, r) {
    const o = {
      common: {
        issues: [],
        async: (r == null ? void 0 : r.async) ?? !1,
        contextualErrorMap: r == null ? void 0 : r.errorMap
      },
      path: (r == null ? void 0 : r.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: qc(e)
    }, u = this._parseSync({ data: e, path: o.path, parent: o });
    return nA(o, u);
  }
  "~validate"(e) {
    var o, u;
    const r = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: qc(e)
    };
    if (!this["~standard"].async)
      try {
        const c = this._parseSync({ data: e, path: [], parent: r });
        return xm(c) ? {
          value: c.value
        } : {
          issues: r.common.issues
        };
      } catch (c) {
        (u = (o = c == null ? void 0 : c.message) == null ? void 0 : o.toLowerCase()) != null && u.includes("encountered") && (this["~standard"].async = !0), r.common = {
          issues: [],
          async: !0
        };
      }
    return this._parseAsync({ data: e, path: [], parent: r }).then((c) => xm(c) ? {
      value: c.value
    } : {
      issues: r.common.issues
    });
  }
  async parseAsync(e, r) {
    const o = await this.safeParseAsync(e, r);
    if (o.success)
      return o.data;
    throw o.error;
  }
  async safeParseAsync(e, r) {
    const o = {
      common: {
        issues: [],
        contextualErrorMap: r == null ? void 0 : r.errorMap,
        async: !0
      },
      path: (r == null ? void 0 : r.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: qc(e)
    }, u = this._parse({ data: e, path: o.path, parent: o }), c = await (lx(u) ? u : Promise.resolve(u));
    return nA(o, c);
  }
  refine(e, r) {
    const o = (u) => typeof r == "string" || typeof r > "u" ? { message: r } : typeof r == "function" ? r(u) : r;
    return this._refinement((u, c) => {
      const f = e(u), m = () => c.addIssue({
        code: De.custom,
        ...o(u)
      });
      return typeof Promise < "u" && f instanceof Promise ? f.then((y) => y ? !0 : (m(), !1)) : f ? !0 : (m(), !1);
    });
  }
  refinement(e, r) {
    return this._refinement((o, u) => e(o) ? !0 : (u.addIssue(typeof r == "function" ? r(o, u) : r), !1));
  }
  _refinement(e) {
    return new _m({
      schema: this,
      typeName: It.ZodEffects,
      effect: { type: "refinement", refinement: e }
    });
  }
  superRefine(e) {
    return this._refinement(e);
  }
  constructor(e) {
    this.spa = this.safeParseAsync, this._def = e, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this), this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (r) => this["~validate"](r)
    };
  }
  optional() {
    return sd.create(this, this._def);
  }
  nullable() {
    return Em.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return Nl.create(this);
  }
  promise() {
    return fx.create(this, this._def);
  }
  or(e) {
    return cx.create([this, e], this._def);
  }
  and(e) {
    return dx.create(this, e, this._def);
  }
  transform(e) {
    return new _m({
      ...en(this._def),
      schema: this,
      typeName: It.ZodEffects,
      effect: { type: "transform", transform: e }
    });
  }
  default(e) {
    const r = typeof e == "function" ? e : () => e;
    return new P1({
      ...en(this._def),
      innerType: this,
      defaultValue: r,
      typeName: It.ZodDefault
    });
  }
  brand() {
    return new Q9({
      typeName: It.ZodBranded,
      type: this,
      ...en(this._def)
    });
  }
  catch(e) {
    const r = typeof e == "function" ? e : () => e;
    return new M1({
      ...en(this._def),
      innerType: this,
      catchValue: r,
      typeName: It.ZodCatch
    });
  }
  describe(e) {
    const r = this.constructor;
    return new r({
      ...this._def,
      description: e
    });
  }
  pipe(e) {
    return jT.create(this, e);
  }
  readonly() {
    return L1.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const k9 = /^c[^\s-]{8,}$/i, O9 = /^[0-9a-z]+$/, N9 = /^[0-9A-HJKMNP-TV-Z]{26}$/i, j9 = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, A9 = /^[a-z0-9_-]{21}$/i, D9 = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/, P9 = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, M9 = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, L9 = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let IC;
const I9 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, U9 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/, F9 = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/, $9 = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, z9 = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, B9 = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/, M2 = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))", V9 = new RegExp(`^${M2}$`);
function L2(n) {
  let e = "[0-5]\\d";
  n.precision ? e = `${e}\\.\\d{${n.precision}}` : n.precision == null && (e = `${e}(\\.\\d+)?`);
  const r = n.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${e})${r}`;
}
function H9(n) {
  return new RegExp(`^${L2(n)}$`);
}
function W9(n) {
  let e = `${M2}T${L2(n)}`;
  const r = [];
  return r.push(n.local ? "Z?" : "Z"), n.offset && r.push("([+-]\\d{2}:?\\d{2})"), e = `${e}(${r.join("|")})`, new RegExp(`^${e}$`);
}
function q9(n, e) {
  return !!((e === "v4" || !e) && I9.test(n) || (e === "v6" || !e) && F9.test(n));
}
function Y9(n, e) {
  if (!D9.test(n))
    return !1;
  try {
    const [r] = n.split(".");
    if (!r)
      return !1;
    const o = r.replace(/-/g, "+").replace(/_/g, "/").padEnd(r.length + (4 - r.length % 4) % 4, "="), u = JSON.parse(atob(o));
    return !(typeof u != "object" || u === null || "typ" in u && (u == null ? void 0 : u.typ) !== "JWT" || !u.alg || e && u.alg !== e);
  } catch {
    return !1;
  }
}
function K9(n, e) {
  return !!((e === "v4" || !e) && U9.test(n) || (e === "v6" || !e) && $9.test(n));
}
class id extends xn {
  _parse(e) {
    if (this._def.coerce && (e.data = String(e.data)), this._getType(e) !== it.string) {
      const c = this._getOrReturnCtx(e);
      return Ke(c, {
        code: De.invalid_type,
        expected: it.string,
        received: c.parsedType
      }), Lt;
    }
    const o = new So();
    let u;
    for (const c of this._def.checks)
      if (c.kind === "min")
        e.data.length < c.value && (u = this._getOrReturnCtx(e, u), Ke(u, {
          code: De.too_small,
          minimum: c.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: c.message
        }), o.dirty());
      else if (c.kind === "max")
        e.data.length > c.value && (u = this._getOrReturnCtx(e, u), Ke(u, {
          code: De.too_big,
          maximum: c.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: c.message
        }), o.dirty());
      else if (c.kind === "length") {
        const f = e.data.length > c.value, m = e.data.length < c.value;
        (f || m) && (u = this._getOrReturnCtx(e, u), f ? Ke(u, {
          code: De.too_big,
          maximum: c.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: c.message
        }) : m && Ke(u, {
          code: De.too_small,
          minimum: c.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: c.message
        }), o.dirty());
      } else if (c.kind === "email")
        M9.test(e.data) || (u = this._getOrReturnCtx(e, u), Ke(u, {
          validation: "email",
          code: De.invalid_string,
          message: c.message
        }), o.dirty());
      else if (c.kind === "emoji")
        IC || (IC = new RegExp(L9, "u")), IC.test(e.data) || (u = this._getOrReturnCtx(e, u), Ke(u, {
          validation: "emoji",
          code: De.invalid_string,
          message: c.message
        }), o.dirty());
      else if (c.kind === "uuid")
        j9.test(e.data) || (u = this._getOrReturnCtx(e, u), Ke(u, {
          validation: "uuid",
          code: De.invalid_string,
          message: c.message
        }), o.dirty());
      else if (c.kind === "nanoid")
        A9.test(e.data) || (u = this._getOrReturnCtx(e, u), Ke(u, {
          validation: "nanoid",
          code: De.invalid_string,
          message: c.message
        }), o.dirty());
      else if (c.kind === "cuid")
        k9.test(e.data) || (u = this._getOrReturnCtx(e, u), Ke(u, {
          validation: "cuid",
          code: De.invalid_string,
          message: c.message
        }), o.dirty());
      else if (c.kind === "cuid2")
        O9.test(e.data) || (u = this._getOrReturnCtx(e, u), Ke(u, {
          validation: "cuid2",
          code: De.invalid_string,
          message: c.message
        }), o.dirty());
      else if (c.kind === "ulid")
        N9.test(e.data) || (u = this._getOrReturnCtx(e, u), Ke(u, {
          validation: "ulid",
          code: De.invalid_string,
          message: c.message
        }), o.dirty());
      else if (c.kind === "url")
        try {
          new URL(e.data);
        } catch {
          u = this._getOrReturnCtx(e, u), Ke(u, {
            validation: "url",
            code: De.invalid_string,
            message: c.message
          }), o.dirty();
        }
      else c.kind === "regex" ? (c.regex.lastIndex = 0, c.regex.test(e.data) || (u = this._getOrReturnCtx(e, u), Ke(u, {
        validation: "regex",
        code: De.invalid_string,
        message: c.message
      }), o.dirty())) : c.kind === "trim" ? e.data = e.data.trim() : c.kind === "includes" ? e.data.includes(c.value, c.position) || (u = this._getOrReturnCtx(e, u), Ke(u, {
        code: De.invalid_string,
        validation: { includes: c.value, position: c.position },
        message: c.message
      }), o.dirty()) : c.kind === "toLowerCase" ? e.data = e.data.toLowerCase() : c.kind === "toUpperCase" ? e.data = e.data.toUpperCase() : c.kind === "startsWith" ? e.data.startsWith(c.value) || (u = this._getOrReturnCtx(e, u), Ke(u, {
        code: De.invalid_string,
        validation: { startsWith: c.value },
        message: c.message
      }), o.dirty()) : c.kind === "endsWith" ? e.data.endsWith(c.value) || (u = this._getOrReturnCtx(e, u), Ke(u, {
        code: De.invalid_string,
        validation: { endsWith: c.value },
        message: c.message
      }), o.dirty()) : c.kind === "datetime" ? W9(c).test(e.data) || (u = this._getOrReturnCtx(e, u), Ke(u, {
        code: De.invalid_string,
        validation: "datetime",
        message: c.message
      }), o.dirty()) : c.kind === "date" ? V9.test(e.data) || (u = this._getOrReturnCtx(e, u), Ke(u, {
        code: De.invalid_string,
        validation: "date",
        message: c.message
      }), o.dirty()) : c.kind === "time" ? H9(c).test(e.data) || (u = this._getOrReturnCtx(e, u), Ke(u, {
        code: De.invalid_string,
        validation: "time",
        message: c.message
      }), o.dirty()) : c.kind === "duration" ? P9.test(e.data) || (u = this._getOrReturnCtx(e, u), Ke(u, {
        validation: "duration",
        code: De.invalid_string,
        message: c.message
      }), o.dirty()) : c.kind === "ip" ? q9(e.data, c.version) || (u = this._getOrReturnCtx(e, u), Ke(u, {
        validation: "ip",
        code: De.invalid_string,
        message: c.message
      }), o.dirty()) : c.kind === "jwt" ? Y9(e.data, c.alg) || (u = this._getOrReturnCtx(e, u), Ke(u, {
        validation: "jwt",
        code: De.invalid_string,
        message: c.message
      }), o.dirty()) : c.kind === "cidr" ? K9(e.data, c.version) || (u = this._getOrReturnCtx(e, u), Ke(u, {
        validation: "cidr",
        code: De.invalid_string,
        message: c.message
      }), o.dirty()) : c.kind === "base64" ? z9.test(e.data) || (u = this._getOrReturnCtx(e, u), Ke(u, {
        validation: "base64",
        code: De.invalid_string,
        message: c.message
      }), o.dirty()) : c.kind === "base64url" ? B9.test(e.data) || (u = this._getOrReturnCtx(e, u), Ke(u, {
        validation: "base64url",
        code: De.invalid_string,
        message: c.message
      }), o.dirty()) : Tn.assertNever(c);
    return { status: o.value, value: e.data };
  }
  _regex(e, r, o) {
    return this.refinement((u) => e.test(u), {
      validation: r,
      code: De.invalid_string,
      ...ct.errToObj(o)
    });
  }
  _addCheck(e) {
    return new id({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  email(e) {
    return this._addCheck({ kind: "email", ...ct.errToObj(e) });
  }
  url(e) {
    return this._addCheck({ kind: "url", ...ct.errToObj(e) });
  }
  emoji(e) {
    return this._addCheck({ kind: "emoji", ...ct.errToObj(e) });
  }
  uuid(e) {
    return this._addCheck({ kind: "uuid", ...ct.errToObj(e) });
  }
  nanoid(e) {
    return this._addCheck({ kind: "nanoid", ...ct.errToObj(e) });
  }
  cuid(e) {
    return this._addCheck({ kind: "cuid", ...ct.errToObj(e) });
  }
  cuid2(e) {
    return this._addCheck({ kind: "cuid2", ...ct.errToObj(e) });
  }
  ulid(e) {
    return this._addCheck({ kind: "ulid", ...ct.errToObj(e) });
  }
  base64(e) {
    return this._addCheck({ kind: "base64", ...ct.errToObj(e) });
  }
  base64url(e) {
    return this._addCheck({
      kind: "base64url",
      ...ct.errToObj(e)
    });
  }
  jwt(e) {
    return this._addCheck({ kind: "jwt", ...ct.errToObj(e) });
  }
  ip(e) {
    return this._addCheck({ kind: "ip", ...ct.errToObj(e) });
  }
  cidr(e) {
    return this._addCheck({ kind: "cidr", ...ct.errToObj(e) });
  }
  datetime(e) {
    return typeof e == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      local: !1,
      message: e
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof (e == null ? void 0 : e.precision) > "u" ? null : e == null ? void 0 : e.precision,
      offset: (e == null ? void 0 : e.offset) ?? !1,
      local: (e == null ? void 0 : e.local) ?? !1,
      ...ct.errToObj(e == null ? void 0 : e.message)
    });
  }
  date(e) {
    return this._addCheck({ kind: "date", message: e });
  }
  time(e) {
    return typeof e == "string" ? this._addCheck({
      kind: "time",
      precision: null,
      message: e
    }) : this._addCheck({
      kind: "time",
      precision: typeof (e == null ? void 0 : e.precision) > "u" ? null : e == null ? void 0 : e.precision,
      ...ct.errToObj(e == null ? void 0 : e.message)
    });
  }
  duration(e) {
    return this._addCheck({ kind: "duration", ...ct.errToObj(e) });
  }
  regex(e, r) {
    return this._addCheck({
      kind: "regex",
      regex: e,
      ...ct.errToObj(r)
    });
  }
  includes(e, r) {
    return this._addCheck({
      kind: "includes",
      value: e,
      position: r == null ? void 0 : r.position,
      ...ct.errToObj(r == null ? void 0 : r.message)
    });
  }
  startsWith(e, r) {
    return this._addCheck({
      kind: "startsWith",
      value: e,
      ...ct.errToObj(r)
    });
  }
  endsWith(e, r) {
    return this._addCheck({
      kind: "endsWith",
      value: e,
      ...ct.errToObj(r)
    });
  }
  min(e, r) {
    return this._addCheck({
      kind: "min",
      value: e,
      ...ct.errToObj(r)
    });
  }
  max(e, r) {
    return this._addCheck({
      kind: "max",
      value: e,
      ...ct.errToObj(r)
    });
  }
  length(e, r) {
    return this._addCheck({
      kind: "length",
      value: e,
      ...ct.errToObj(r)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(e) {
    return this.min(1, ct.errToObj(e));
  }
  trim() {
    return new id({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new id({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new id({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((e) => e.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((e) => e.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((e) => e.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((e) => e.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((e) => e.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((e) => e.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((e) => e.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((e) => e.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((e) => e.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((e) => e.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((e) => e.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((e) => e.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((e) => e.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((e) => e.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((e) => e.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((e) => e.kind === "base64url");
  }
  get minLength() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "min" && (e === null || r.value > e) && (e = r.value);
    return e;
  }
  get maxLength() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    return e;
  }
}
id.create = (n) => new id({
  checks: [],
  typeName: It.ZodString,
  coerce: (n == null ? void 0 : n.coerce) ?? !1,
  ...en(n)
});
function G9(n, e) {
  const r = (n.toString().split(".")[1] || "").length, o = (e.toString().split(".")[1] || "").length, u = r > o ? r : o, c = Number.parseInt(n.toFixed(u).replace(".", "")), f = Number.parseInt(e.toFixed(u).replace(".", ""));
  return c % f / 10 ** u;
}
class oy extends xn {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(e) {
    if (this._def.coerce && (e.data = Number(e.data)), this._getType(e) !== it.number) {
      const c = this._getOrReturnCtx(e);
      return Ke(c, {
        code: De.invalid_type,
        expected: it.number,
        received: c.parsedType
      }), Lt;
    }
    let o;
    const u = new So();
    for (const c of this._def.checks)
      c.kind === "int" ? Tn.isInteger(e.data) || (o = this._getOrReturnCtx(e, o), Ke(o, {
        code: De.invalid_type,
        expected: "integer",
        received: "float",
        message: c.message
      }), u.dirty()) : c.kind === "min" ? (c.inclusive ? e.data < c.value : e.data <= c.value) && (o = this._getOrReturnCtx(e, o), Ke(o, {
        code: De.too_small,
        minimum: c.value,
        type: "number",
        inclusive: c.inclusive,
        exact: !1,
        message: c.message
      }), u.dirty()) : c.kind === "max" ? (c.inclusive ? e.data > c.value : e.data >= c.value) && (o = this._getOrReturnCtx(e, o), Ke(o, {
        code: De.too_big,
        maximum: c.value,
        type: "number",
        inclusive: c.inclusive,
        exact: !1,
        message: c.message
      }), u.dirty()) : c.kind === "multipleOf" ? G9(e.data, c.value) !== 0 && (o = this._getOrReturnCtx(e, o), Ke(o, {
        code: De.not_multiple_of,
        multipleOf: c.value,
        message: c.message
      }), u.dirty()) : c.kind === "finite" ? Number.isFinite(e.data) || (o = this._getOrReturnCtx(e, o), Ke(o, {
        code: De.not_finite,
        message: c.message
      }), u.dirty()) : Tn.assertNever(c);
    return { status: u.value, value: e.data };
  }
  gte(e, r) {
    return this.setLimit("min", e, !0, ct.toString(r));
  }
  gt(e, r) {
    return this.setLimit("min", e, !1, ct.toString(r));
  }
  lte(e, r) {
    return this.setLimit("max", e, !0, ct.toString(r));
  }
  lt(e, r) {
    return this.setLimit("max", e, !1, ct.toString(r));
  }
  setLimit(e, r, o, u) {
    return new oy({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e,
          value: r,
          inclusive: o,
          message: ct.toString(u)
        }
      ]
    });
  }
  _addCheck(e) {
    return new oy({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  int(e) {
    return this._addCheck({
      kind: "int",
      message: ct.toString(e)
    });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: ct.toString(e)
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: ct.toString(e)
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: ct.toString(e)
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: ct.toString(e)
    });
  }
  multipleOf(e, r) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: ct.toString(r)
    });
  }
  finite(e) {
    return this._addCheck({
      kind: "finite",
      message: ct.toString(e)
    });
  }
  safe(e) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: ct.toString(e)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: ct.toString(e)
    });
  }
  get minValue() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "min" && (e === null || r.value > e) && (e = r.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    return e;
  }
  get isInt() {
    return !!this._def.checks.find((e) => e.kind === "int" || e.kind === "multipleOf" && Tn.isInteger(e.value));
  }
  get isFinite() {
    let e = null, r = null;
    for (const o of this._def.checks) {
      if (o.kind === "finite" || o.kind === "int" || o.kind === "multipleOf")
        return !0;
      o.kind === "min" ? (r === null || o.value > r) && (r = o.value) : o.kind === "max" && (e === null || o.value < e) && (e = o.value);
    }
    return Number.isFinite(r) && Number.isFinite(e);
  }
}
oy.create = (n) => new oy({
  checks: [],
  typeName: It.ZodNumber,
  coerce: (n == null ? void 0 : n.coerce) || !1,
  ...en(n)
});
class sy extends xn {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(e) {
    if (this._def.coerce)
      try {
        e.data = BigInt(e.data);
      } catch {
        return this._getInvalidInput(e);
      }
    if (this._getType(e) !== it.bigint)
      return this._getInvalidInput(e);
    let o;
    const u = new So();
    for (const c of this._def.checks)
      c.kind === "min" ? (c.inclusive ? e.data < c.value : e.data <= c.value) && (o = this._getOrReturnCtx(e, o), Ke(o, {
        code: De.too_small,
        type: "bigint",
        minimum: c.value,
        inclusive: c.inclusive,
        message: c.message
      }), u.dirty()) : c.kind === "max" ? (c.inclusive ? e.data > c.value : e.data >= c.value) && (o = this._getOrReturnCtx(e, o), Ke(o, {
        code: De.too_big,
        type: "bigint",
        maximum: c.value,
        inclusive: c.inclusive,
        message: c.message
      }), u.dirty()) : c.kind === "multipleOf" ? e.data % c.value !== BigInt(0) && (o = this._getOrReturnCtx(e, o), Ke(o, {
        code: De.not_multiple_of,
        multipleOf: c.value,
        message: c.message
      }), u.dirty()) : Tn.assertNever(c);
    return { status: u.value, value: e.data };
  }
  _getInvalidInput(e) {
    const r = this._getOrReturnCtx(e);
    return Ke(r, {
      code: De.invalid_type,
      expected: it.bigint,
      received: r.parsedType
    }), Lt;
  }
  gte(e, r) {
    return this.setLimit("min", e, !0, ct.toString(r));
  }
  gt(e, r) {
    return this.setLimit("min", e, !1, ct.toString(r));
  }
  lte(e, r) {
    return this.setLimit("max", e, !0, ct.toString(r));
  }
  lt(e, r) {
    return this.setLimit("max", e, !1, ct.toString(r));
  }
  setLimit(e, r, o, u) {
    return new sy({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e,
          value: r,
          inclusive: o,
          message: ct.toString(u)
        }
      ]
    });
  }
  _addCheck(e) {
    return new sy({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: ct.toString(e)
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: ct.toString(e)
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: ct.toString(e)
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: ct.toString(e)
    });
  }
  multipleOf(e, r) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: ct.toString(r)
    });
  }
  get minValue() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "min" && (e === null || r.value > e) && (e = r.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    return e;
  }
}
sy.create = (n) => new sy({
  checks: [],
  typeName: It.ZodBigInt,
  coerce: (n == null ? void 0 : n.coerce) ?? !1,
  ...en(n)
});
class rA extends xn {
  _parse(e) {
    if (this._def.coerce && (e.data = !!e.data), this._getType(e) !== it.boolean) {
      const o = this._getOrReturnCtx(e);
      return Ke(o, {
        code: De.invalid_type,
        expected: it.boolean,
        received: o.parsedType
      }), Lt;
    }
    return Ko(e.data);
  }
}
rA.create = (n) => new rA({
  typeName: It.ZodBoolean,
  coerce: (n == null ? void 0 : n.coerce) || !1,
  ...en(n)
});
class ux extends xn {
  _parse(e) {
    if (this._def.coerce && (e.data = new Date(e.data)), this._getType(e) !== it.date) {
      const c = this._getOrReturnCtx(e);
      return Ke(c, {
        code: De.invalid_type,
        expected: it.date,
        received: c.parsedType
      }), Lt;
    }
    if (Number.isNaN(e.data.getTime())) {
      const c = this._getOrReturnCtx(e);
      return Ke(c, {
        code: De.invalid_date
      }), Lt;
    }
    const o = new So();
    let u;
    for (const c of this._def.checks)
      c.kind === "min" ? e.data.getTime() < c.value && (u = this._getOrReturnCtx(e, u), Ke(u, {
        code: De.too_small,
        message: c.message,
        inclusive: !0,
        exact: !1,
        minimum: c.value,
        type: "date"
      }), o.dirty()) : c.kind === "max" ? e.data.getTime() > c.value && (u = this._getOrReturnCtx(e, u), Ke(u, {
        code: De.too_big,
        message: c.message,
        inclusive: !0,
        exact: !1,
        maximum: c.value,
        type: "date"
      }), o.dirty()) : Tn.assertNever(c);
    return {
      status: o.value,
      value: new Date(e.data.getTime())
    };
  }
  _addCheck(e) {
    return new ux({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  min(e, r) {
    return this._addCheck({
      kind: "min",
      value: e.getTime(),
      message: ct.toString(r)
    });
  }
  max(e, r) {
    return this._addCheck({
      kind: "max",
      value: e.getTime(),
      message: ct.toString(r)
    });
  }
  get minDate() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "min" && (e === null || r.value > e) && (e = r.value);
    return e != null ? new Date(e) : null;
  }
  get maxDate() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    return e != null ? new Date(e) : null;
  }
}
ux.create = (n) => new ux({
  checks: [],
  coerce: (n == null ? void 0 : n.coerce) || !1,
  typeName: It.ZodDate,
  ...en(n)
});
class aA extends xn {
  _parse(e) {
    if (this._getType(e) !== it.symbol) {
      const o = this._getOrReturnCtx(e);
      return Ke(o, {
        code: De.invalid_type,
        expected: it.symbol,
        received: o.parsedType
      }), Lt;
    }
    return Ko(e.data);
  }
}
aA.create = (n) => new aA({
  typeName: It.ZodSymbol,
  ...en(n)
});
class iA extends xn {
  _parse(e) {
    if (this._getType(e) !== it.undefined) {
      const o = this._getOrReturnCtx(e);
      return Ke(o, {
        code: De.invalid_type,
        expected: it.undefined,
        received: o.parsedType
      }), Lt;
    }
    return Ko(e.data);
  }
}
iA.create = (n) => new iA({
  typeName: It.ZodUndefined,
  ...en(n)
});
class oA extends xn {
  _parse(e) {
    if (this._getType(e) !== it.null) {
      const o = this._getOrReturnCtx(e);
      return Ke(o, {
        code: De.invalid_type,
        expected: it.null,
        received: o.parsedType
      }), Lt;
    }
    return Ko(e.data);
  }
}
oA.create = (n) => new oA({
  typeName: It.ZodNull,
  ...en(n)
});
class sA extends xn {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(e) {
    return Ko(e.data);
  }
}
sA.create = (n) => new sA({
  typeName: It.ZodAny,
  ...en(n)
});
class lA extends xn {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(e) {
    return Ko(e.data);
  }
}
lA.create = (n) => new lA({
  typeName: It.ZodUnknown,
  ...en(n)
});
class fd extends xn {
  _parse(e) {
    const r = this._getOrReturnCtx(e);
    return Ke(r, {
      code: De.invalid_type,
      expected: it.never,
      received: r.parsedType
    }), Lt;
  }
}
fd.create = (n) => new fd({
  typeName: It.ZodNever,
  ...en(n)
});
class uA extends xn {
  _parse(e) {
    if (this._getType(e) !== it.undefined) {
      const o = this._getOrReturnCtx(e);
      return Ke(o, {
        code: De.invalid_type,
        expected: it.void,
        received: o.parsedType
      }), Lt;
    }
    return Ko(e.data);
  }
}
uA.create = (n) => new uA({
  typeName: It.ZodVoid,
  ...en(n)
});
class Nl extends xn {
  _parse(e) {
    const { ctx: r, status: o } = this._processInputParams(e), u = this._def;
    if (r.parsedType !== it.array)
      return Ke(r, {
        code: De.invalid_type,
        expected: it.array,
        received: r.parsedType
      }), Lt;
    if (u.exactLength !== null) {
      const f = r.data.length > u.exactLength.value, m = r.data.length < u.exactLength.value;
      (f || m) && (Ke(r, {
        code: f ? De.too_big : De.too_small,
        minimum: m ? u.exactLength.value : void 0,
        maximum: f ? u.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: u.exactLength.message
      }), o.dirty());
    }
    if (u.minLength !== null && r.data.length < u.minLength.value && (Ke(r, {
      code: De.too_small,
      minimum: u.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: u.minLength.message
    }), o.dirty()), u.maxLength !== null && r.data.length > u.maxLength.value && (Ke(r, {
      code: De.too_big,
      maximum: u.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: u.maxLength.message
    }), o.dirty()), r.common.async)
      return Promise.all([...r.data].map((f, m) => u.type._parseAsync(new dd(r, f, r.path, m)))).then((f) => So.mergeArray(o, f));
    const c = [...r.data].map((f, m) => u.type._parseSync(new dd(r, f, r.path, m)));
    return So.mergeArray(o, c);
  }
  get element() {
    return this._def.type;
  }
  min(e, r) {
    return new Nl({
      ...this._def,
      minLength: { value: e, message: ct.toString(r) }
    });
  }
  max(e, r) {
    return new Nl({
      ...this._def,
      maxLength: { value: e, message: ct.toString(r) }
    });
  }
  length(e, r) {
    return new Nl({
      ...this._def,
      exactLength: { value: e, message: ct.toString(r) }
    });
  }
  nonempty(e) {
    return this.min(1, e);
  }
}
Nl.create = (n, e) => new Nl({
  type: n,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: It.ZodArray,
  ...en(e)
});
function Qp(n) {
  if (n instanceof Ir) {
    const e = {};
    for (const r in n.shape) {
      const o = n.shape[r];
      e[r] = sd.create(Qp(o));
    }
    return new Ir({
      ...n._def,
      shape: () => e
    });
  } else return n instanceof Nl ? new Nl({
    ...n._def,
    type: Qp(n.element)
  }) : n instanceof sd ? sd.create(Qp(n.unwrap())) : n instanceof Em ? Em.create(Qp(n.unwrap())) : n instanceof Wf ? Wf.create(n.items.map((e) => Qp(e))) : n;
}
class Ir extends xn {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const e = this._def.shape(), r = Tn.objectKeys(e);
    return this._cached = { shape: e, keys: r }, this._cached;
  }
  _parse(e) {
    if (this._getType(e) !== it.object) {
      const b = this._getOrReturnCtx(e);
      return Ke(b, {
        code: De.invalid_type,
        expected: it.object,
        received: b.parsedType
      }), Lt;
    }
    const { status: o, ctx: u } = this._processInputParams(e), { shape: c, keys: f } = this._getCached(), m = [];
    if (!(this._def.catchall instanceof fd && this._def.unknownKeys === "strip"))
      for (const b in u.data)
        f.includes(b) || m.push(b);
    const y = [];
    for (const b of f) {
      const _ = c[b], T = u.data[b];
      y.push({
        key: { status: "valid", value: b },
        value: _._parse(new dd(u, T, u.path, b)),
        alwaysSet: b in u.data
      });
    }
    if (this._def.catchall instanceof fd) {
      const b = this._def.unknownKeys;
      if (b === "passthrough")
        for (const _ of m)
          y.push({
            key: { status: "valid", value: _ },
            value: { status: "valid", value: u.data[_] }
          });
      else if (b === "strict")
        m.length > 0 && (Ke(u, {
          code: De.unrecognized_keys,
          keys: m
        }), o.dirty());
      else if (b !== "strip") throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const b = this._def.catchall;
      for (const _ of m) {
        const T = u.data[_];
        y.push({
          key: { status: "valid", value: _ },
          value: b._parse(
            new dd(u, T, u.path, _)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: _ in u.data
        });
      }
    }
    return u.common.async ? Promise.resolve().then(async () => {
      const b = [];
      for (const _ of y) {
        const T = await _.key, k = await _.value;
        b.push({
          key: T,
          value: k,
          alwaysSet: _.alwaysSet
        });
      }
      return b;
    }).then((b) => So.mergeObjectSync(o, b)) : So.mergeObjectSync(o, y);
  }
  get shape() {
    return this._def.shape();
  }
  strict(e) {
    return ct.errToObj, new Ir({
      ...this._def,
      unknownKeys: "strict",
      ...e !== void 0 ? {
        errorMap: (r, o) => {
          var c, f;
          const u = ((f = (c = this._def).errorMap) == null ? void 0 : f.call(c, r, o).message) ?? o.defaultError;
          return r.code === "unrecognized_keys" ? {
            message: ct.errToObj(e).message ?? u
          } : {
            message: u
          };
        }
      } : {}
    });
  }
  strip() {
    return new Ir({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new Ir({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(e) {
    return new Ir({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...e
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(e) {
    return new Ir({
      unknownKeys: e._def.unknownKeys,
      catchall: e._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...e._def.shape()
      }),
      typeName: It.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(e, r) {
    return this.augment({ [e]: r });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(e) {
    return new Ir({
      ...this._def,
      catchall: e
    });
  }
  pick(e) {
    const r = {};
    for (const o of Tn.objectKeys(e))
      e[o] && this.shape[o] && (r[o] = this.shape[o]);
    return new Ir({
      ...this._def,
      shape: () => r
    });
  }
  omit(e) {
    const r = {};
    for (const o of Tn.objectKeys(this.shape))
      e[o] || (r[o] = this.shape[o]);
    return new Ir({
      ...this._def,
      shape: () => r
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return Qp(this);
  }
  partial(e) {
    const r = {};
    for (const o of Tn.objectKeys(this.shape)) {
      const u = this.shape[o];
      e && !e[o] ? r[o] = u : r[o] = u.optional();
    }
    return new Ir({
      ...this._def,
      shape: () => r
    });
  }
  required(e) {
    const r = {};
    for (const o of Tn.objectKeys(this.shape))
      if (e && !e[o])
        r[o] = this.shape[o];
      else {
        let c = this.shape[o];
        for (; c instanceof sd;)
          c = c._def.innerType;
        r[o] = c;
      }
    return new Ir({
      ...this._def,
      shape: () => r
    });
  }
  keyof() {
    return I2(Tn.objectKeys(this.shape));
  }
}
Ir.create = (n, e) => new Ir({
  shape: () => n,
  unknownKeys: "strip",
  catchall: fd.create(),
  typeName: It.ZodObject,
  ...en(e)
});
Ir.strictCreate = (n, e) => new Ir({
  shape: () => n,
  unknownKeys: "strict",
  catchall: fd.create(),
  typeName: It.ZodObject,
  ...en(e)
});
Ir.lazycreate = (n, e) => new Ir({
  shape: n,
  unknownKeys: "strip",
  catchall: fd.create(),
  typeName: It.ZodObject,
  ...en(e)
});
class cx extends xn {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e), o = this._def.options;
    function u(c) {
      for (const m of c)
        if (m.result.status === "valid")
          return m.result;
      for (const m of c)
        if (m.result.status === "dirty")
          return r.common.issues.push(...m.ctx.common.issues), m.result;
      const f = c.map((m) => new Ls(m.ctx.common.issues));
      return Ke(r, {
        code: De.invalid_union,
        unionErrors: f
      }), Lt;
    }
    if (r.common.async)
      return Promise.all(o.map(async (c) => {
        const f = {
          ...r,
          common: {
            ...r.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await c._parseAsync({
            data: r.data,
            path: r.path,
            parent: f
          }),
          ctx: f
        };
      })).then(u);
    {
      let c;
      const f = [];
      for (const y of o) {
        const b = {
          ...r,
          common: {
            ...r.common,
            issues: []
          },
          parent: null
        }, _ = y._parseSync({
          data: r.data,
          path: r.path,
          parent: b
        });
        if (_.status === "valid")
          return _;
        _.status === "dirty" && !c && (c = { result: _, ctx: b }), b.common.issues.length && f.push(b.common.issues);
      }
      if (c)
        return r.common.issues.push(...c.ctx.common.issues), c.result;
      const m = f.map((y) => new Ls(y));
      return Ke(r, {
        code: De.invalid_union,
        unionErrors: m
      }), Lt;
    }
  }
  get options() {
    return this._def.options;
  }
}
cx.create = (n, e) => new cx({
  options: n,
  typeName: It.ZodUnion,
  ...en(e)
});
function D1(n, e) {
  const r = qc(n), o = qc(e);
  if (n === e)
    return { valid: !0, data: n };
  if (r === it.object && o === it.object) {
    const u = Tn.objectKeys(e), c = Tn.objectKeys(n).filter((m) => u.indexOf(m) !== -1), f = { ...n, ...e };
    for (const m of c) {
      const y = D1(n[m], e[m]);
      if (!y.valid)
        return { valid: !1 };
      f[m] = y.data;
    }
    return { valid: !0, data: f };
  } else if (r === it.array && o === it.array) {
    if (n.length !== e.length)
      return { valid: !1 };
    const u = [];
    for (let c = 0; c < n.length; c++) {
      const f = n[c], m = e[c], y = D1(f, m);
      if (!y.valid)
        return { valid: !1 };
      u.push(y.data);
    }
    return { valid: !0, data: u };
  } else return r === it.date && o === it.date && +n == +e ? { valid: !0, data: n } : { valid: !1 };
}
class dx extends xn {
  _parse(e) {
    const { status: r, ctx: o } = this._processInputParams(e), u = (c, f) => {
      if (eA(c) || eA(f))
        return Lt;
      const m = D1(c.value, f.value);
      return m.valid ? ((tA(c) || tA(f)) && r.dirty(), { status: r.value, value: m.data }) : (Ke(o, {
        code: De.invalid_intersection_types
      }), Lt);
    };
    return o.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: o.data,
        path: o.path,
        parent: o
      }),
      this._def.right._parseAsync({
        data: o.data,
        path: o.path,
        parent: o
      })
    ]).then(([c, f]) => u(c, f)) : u(this._def.left._parseSync({
      data: o.data,
      path: o.path,
      parent: o
    }), this._def.right._parseSync({
      data: o.data,
      path: o.path,
      parent: o
    }));
  }
}
dx.create = (n, e, r) => new dx({
  left: n,
  right: e,
  typeName: It.ZodIntersection,
  ...en(r)
});
class Wf extends xn {
  _parse(e) {
    const { status: r, ctx: o } = this._processInputParams(e);
    if (o.parsedType !== it.array)
      return Ke(o, {
        code: De.invalid_type,
        expected: it.array,
        received: o.parsedType
      }), Lt;
    if (o.data.length < this._def.items.length)
      return Ke(o, {
        code: De.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), Lt;
    !this._def.rest && o.data.length > this._def.items.length && (Ke(o, {
      code: De.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), r.dirty());
    const c = [...o.data].map((f, m) => {
      const y = this._def.items[m] || this._def.rest;
      return y ? y._parse(new dd(o, f, o.path, m)) : null;
    }).filter((f) => !!f);
    return o.common.async ? Promise.all(c).then((f) => So.mergeArray(r, f)) : So.mergeArray(r, c);
  }
  get items() {
    return this._def.items;
  }
  rest(e) {
    return new Wf({
      ...this._def,
      rest: e
    });
  }
}
Wf.create = (n, e) => {
  if (!Array.isArray(n))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new Wf({
    items: n,
    typeName: It.ZodTuple,
    rest: null,
    ...en(e)
  });
};
class cA extends xn {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e) {
    const { status: r, ctx: o } = this._processInputParams(e);
    if (o.parsedType !== it.map)
      return Ke(o, {
        code: De.invalid_type,
        expected: it.map,
        received: o.parsedType
      }), Lt;
    const u = this._def.keyType, c = this._def.valueType, f = [...o.data.entries()].map(([m, y], b) => ({
      key: u._parse(new dd(o, m, o.path, [b, "key"])),
      value: c._parse(new dd(o, y, o.path, [b, "value"]))
    }));
    if (o.common.async) {
      const m = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const y of f) {
          const b = await y.key, _ = await y.value;
          if (b.status === "aborted" || _.status === "aborted")
            return Lt;
          (b.status === "dirty" || _.status === "dirty") && r.dirty(), m.set(b.value, _.value);
        }
        return { status: r.value, value: m };
      });
    } else {
      const m = /* @__PURE__ */ new Map();
      for (const y of f) {
        const b = y.key, _ = y.value;
        if (b.status === "aborted" || _.status === "aborted")
          return Lt;
        (b.status === "dirty" || _.status === "dirty") && r.dirty(), m.set(b.value, _.value);
      }
      return { status: r.value, value: m };
    }
  }
}
cA.create = (n, e, r) => new cA({
  valueType: e,
  keyType: n,
  typeName: It.ZodMap,
  ...en(r)
});
class ly extends xn {
  _parse(e) {
    const { status: r, ctx: o } = this._processInputParams(e);
    if (o.parsedType !== it.set)
      return Ke(o, {
        code: De.invalid_type,
        expected: it.set,
        received: o.parsedType
      }), Lt;
    const u = this._def;
    u.minSize !== null && o.data.size < u.minSize.value && (Ke(o, {
      code: De.too_small,
      minimum: u.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: u.minSize.message
    }), r.dirty()), u.maxSize !== null && o.data.size > u.maxSize.value && (Ke(o, {
      code: De.too_big,
      maximum: u.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: u.maxSize.message
    }), r.dirty());
    const c = this._def.valueType;
    function f(y) {
      const b = /* @__PURE__ */ new Set();
      for (const _ of y) {
        if (_.status === "aborted")
          return Lt;
        _.status === "dirty" && r.dirty(), b.add(_.value);
      }
      return { status: r.value, value: b };
    }
    const m = [...o.data.values()].map((y, b) => c._parse(new dd(o, y, o.path, b)));
    return o.common.async ? Promise.all(m).then((y) => f(y)) : f(m);
  }
  min(e, r) {
    return new ly({
      ...this._def,
      minSize: { value: e, message: ct.toString(r) }
    });
  }
  max(e, r) {
    return new ly({
      ...this._def,
      maxSize: { value: e, message: ct.toString(r) }
    });
  }
  size(e, r) {
    return this.min(e, r).max(e, r);
  }
  nonempty(e) {
    return this.min(1, e);
  }
}
ly.create = (n, e) => new ly({
  valueType: n,
  minSize: null,
  maxSize: null,
  typeName: It.ZodSet,
  ...en(e)
});
class dA extends xn {
  get schema() {
    return this._def.getter();
  }
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    return this._def.getter()._parse({ data: r.data, path: r.path, parent: r });
  }
}
dA.create = (n, e) => new dA({
  getter: n,
  typeName: It.ZodLazy,
  ...en(e)
});
class fA extends xn {
  _parse(e) {
    if (e.data !== this._def.value) {
      const r = this._getOrReturnCtx(e);
      return Ke(r, {
        received: r.data,
        code: De.invalid_literal,
        expected: this._def.value
      }), Lt;
    }
    return { status: "valid", value: e.data };
  }
  get value() {
    return this._def.value;
  }
}
fA.create = (n, e) => new fA({
  value: n,
  typeName: It.ZodLiteral,
  ...en(e)
});
function I2(n, e) {
  return new Sm({
    values: n,
    typeName: It.ZodEnum,
    ...en(e)
  });
}
class Sm extends xn {
  _parse(e) {
    if (typeof e.data != "string") {
      const r = this._getOrReturnCtx(e), o = this._def.values;
      return Ke(r, {
        expected: Tn.joinValues(o),
        received: r.parsedType,
        code: De.invalid_type
      }), Lt;
    }
    if (this._cache || (this._cache = new Set(this._def.values)), !this._cache.has(e.data)) {
      const r = this._getOrReturnCtx(e), o = this._def.values;
      return Ke(r, {
        received: r.data,
        code: De.invalid_enum_value,
        options: o
      }), Lt;
    }
    return Ko(e.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const e = {};
    for (const r of this._def.values)
      e[r] = r;
    return e;
  }
  get Values() {
    const e = {};
    for (const r of this._def.values)
      e[r] = r;
    return e;
  }
  get Enum() {
    const e = {};
    for (const r of this._def.values)
      e[r] = r;
    return e;
  }
  extract(e, r = this._def) {
    return Sm.create(e, {
      ...this._def,
      ...r
    });
  }
  exclude(e, r = this._def) {
    return Sm.create(this.options.filter((o) => !e.includes(o)), {
      ...this._def,
      ...r
    });
  }
}
Sm.create = I2;
class hA extends xn {
  _parse(e) {
    const r = Tn.getValidEnumValues(this._def.values), o = this._getOrReturnCtx(e);
    if (o.parsedType !== it.string && o.parsedType !== it.number) {
      const u = Tn.objectValues(r);
      return Ke(o, {
        expected: Tn.joinValues(u),
        received: o.parsedType,
        code: De.invalid_type
      }), Lt;
    }
    if (this._cache || (this._cache = new Set(Tn.getValidEnumValues(this._def.values))), !this._cache.has(e.data)) {
      const u = Tn.objectValues(r);
      return Ke(o, {
        received: o.data,
        code: De.invalid_enum_value,
        options: u
      }), Lt;
    }
    return Ko(e.data);
  }
  get enum() {
    return this._def.values;
  }
}
hA.create = (n, e) => new hA({
  values: n,
  typeName: It.ZodNativeEnum,
  ...en(e)
});
class fx extends xn {
  unwrap() {
    return this._def.type;
  }
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    if (r.parsedType !== it.promise && r.common.async === !1)
      return Ke(r, {
        code: De.invalid_type,
        expected: it.promise,
        received: r.parsedType
      }), Lt;
    const o = r.parsedType === it.promise ? r.data : Promise.resolve(r.data);
    return Ko(o.then((u) => this._def.type.parseAsync(u, {
      path: r.path,
      errorMap: r.common.contextualErrorMap
    })));
  }
}
fx.create = (n, e) => new fx({
  type: n,
  typeName: It.ZodPromise,
  ...en(e)
});
class _m extends xn {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === It.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(e) {
    const { status: r, ctx: o } = this._processInputParams(e), u = this._def.effect || null, c = {
      addIssue: (f) => {
        Ke(o, f), f.fatal ? r.abort() : r.dirty();
      },
      get path() {
        return o.path;
      }
    };
    if (c.addIssue = c.addIssue.bind(c), u.type === "preprocess") {
      const f = u.transform(o.data, c);
      if (o.common.async)
        return Promise.resolve(f).then(async (m) => {
          if (r.value === "aborted")
            return Lt;
          const y = await this._def.schema._parseAsync({
            data: m,
            path: o.path,
            parent: o
          });
          return y.status === "aborted" ? Lt : y.status === "dirty" || r.value === "dirty" ? Vg(y.value) : y;
        });
      {
        if (r.value === "aborted")
          return Lt;
        const m = this._def.schema._parseSync({
          data: f,
          path: o.path,
          parent: o
        });
        return m.status === "aborted" ? Lt : m.status === "dirty" || r.value === "dirty" ? Vg(m.value) : m;
      }
    }
    if (u.type === "refinement") {
      const f = (m) => {
        const y = u.refinement(m, c);
        if (o.common.async)
          return Promise.resolve(y);
        if (y instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return m;
      };
      if (o.common.async === !1) {
        const m = this._def.schema._parseSync({
          data: o.data,
          path: o.path,
          parent: o
        });
        return m.status === "aborted" ? Lt : (m.status === "dirty" && r.dirty(), f(m.value), { status: r.value, value: m.value });
      } else
        return this._def.schema._parseAsync({ data: o.data, path: o.path, parent: o }).then((m) => m.status === "aborted" ? Lt : (m.status === "dirty" && r.dirty(), f(m.value).then(() => ({ status: r.value, value: m.value }))));
    }
    if (u.type === "transform")
      if (o.common.async === !1) {
        const f = this._def.schema._parseSync({
          data: o.data,
          path: o.path,
          parent: o
        });
        if (!xm(f))
          return Lt;
        const m = u.transform(f.value, c);
        if (m instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: r.value, value: m };
      } else
        return this._def.schema._parseAsync({ data: o.data, path: o.path, parent: o }).then((f) => xm(f) ? Promise.resolve(u.transform(f.value, c)).then((m) => ({
          status: r.value,
          value: m
        })) : Lt);
    Tn.assertNever(u);
  }
}
_m.create = (n, e, r) => new _m({
  schema: n,
  typeName: It.ZodEffects,
  effect: e,
  ...en(r)
});
_m.createWithPreprocess = (n, e, r) => new _m({
  schema: e,
  effect: { type: "preprocess", transform: n },
  typeName: It.ZodEffects,
  ...en(r)
});
class sd extends xn {
  _parse(e) {
    return this._getType(e) === it.undefined ? Ko(void 0) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
}
sd.create = (n, e) => new sd({
  innerType: n,
  typeName: It.ZodOptional,
  ...en(e)
});
class Em extends xn {
  _parse(e) {
    return this._getType(e) === it.null ? Ko(null) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
}
Em.create = (n, e) => new Em({
  innerType: n,
  typeName: It.ZodNullable,
  ...en(e)
});
class P1 extends xn {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    let o = r.data;
    return r.parsedType === it.undefined && (o = this._def.defaultValue()), this._def.innerType._parse({
      data: o,
      path: r.path,
      parent: r
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
P1.create = (n, e) => new P1({
  innerType: n,
  typeName: It.ZodDefault,
  defaultValue: typeof e.default == "function" ? e.default : () => e.default,
  ...en(e)
});
class M1 extends xn {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e), o = {
      ...r,
      common: {
        ...r.common,
        issues: []
      }
    }, u = this._def.innerType._parse({
      data: o.data,
      path: o.path,
      parent: {
        ...o
      }
    });
    return lx(u) ? u.then((c) => ({
      status: "valid",
      value: c.status === "valid" ? c.value : this._def.catchValue({
        get error() {
          return new Ls(o.common.issues);
        },
        input: o.data
      })
    })) : {
      status: "valid",
      value: u.status === "valid" ? u.value : this._def.catchValue({
        get error() {
          return new Ls(o.common.issues);
        },
        input: o.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
}
M1.create = (n, e) => new M1({
  innerType: n,
  typeName: It.ZodCatch,
  catchValue: typeof e.catch == "function" ? e.catch : () => e.catch,
  ...en(e)
});
class pA extends xn {
  _parse(e) {
    if (this._getType(e) !== it.nan) {
      const o = this._getOrReturnCtx(e);
      return Ke(o, {
        code: De.invalid_type,
        expected: it.nan,
        received: o.parsedType
      }), Lt;
    }
    return { status: "valid", value: e.data };
  }
}
pA.create = (n) => new pA({
  typeName: It.ZodNaN,
  ...en(n)
});
class Q9 extends xn {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e), o = r.data;
    return this._def.type._parse({
      data: o,
      path: r.path,
      parent: r
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class jT extends xn {
  _parse(e) {
    const { status: r, ctx: o } = this._processInputParams(e);
    if (o.common.async)
      return (async () => {
        const c = await this._def.in._parseAsync({
          data: o.data,
          path: o.path,
          parent: o
        });
        return c.status === "aborted" ? Lt : c.status === "dirty" ? (r.dirty(), Vg(c.value)) : this._def.out._parseAsync({
          data: c.value,
          path: o.path,
          parent: o
        });
      })();
    {
      const u = this._def.in._parseSync({
        data: o.data,
        path: o.path,
        parent: o
      });
      return u.status === "aborted" ? Lt : u.status === "dirty" ? (r.dirty(), {
        status: "dirty",
        value: u.value
      }) : this._def.out._parseSync({
        data: u.value,
        path: o.path,
        parent: o
      });
    }
  }
  static create(e, r) {
    return new jT({
      in: e,
      out: r,
      typeName: It.ZodPipeline
    });
  }
}
class L1 extends xn {
  _parse(e) {
    const r = this._def.innerType._parse(e), o = (u) => (xm(u) && (u.value = Object.freeze(u.value)), u);
    return lx(r) ? r.then((u) => o(u)) : o(r);
  }
  unwrap() {
    return this._def.innerType;
  }
}
L1.create = (n, e) => new L1({
  innerType: n,
  typeName: It.ZodReadonly,
  ...en(e)
});
Ir.lazycreate;
var It;
(function (n) {
  n.ZodString = "ZodString", n.ZodNumber = "ZodNumber", n.ZodNaN = "ZodNaN", n.ZodBigInt = "ZodBigInt", n.ZodBoolean = "ZodBoolean", n.ZodDate = "ZodDate", n.ZodSymbol = "ZodSymbol", n.ZodUndefined = "ZodUndefined", n.ZodNull = "ZodNull", n.ZodAny = "ZodAny", n.ZodUnknown = "ZodUnknown", n.ZodNever = "ZodNever", n.ZodVoid = "ZodVoid", n.ZodArray = "ZodArray", n.ZodObject = "ZodObject", n.ZodUnion = "ZodUnion", n.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", n.ZodIntersection = "ZodIntersection", n.ZodTuple = "ZodTuple", n.ZodRecord = "ZodRecord", n.ZodMap = "ZodMap", n.ZodSet = "ZodSet", n.ZodFunction = "ZodFunction", n.ZodLazy = "ZodLazy", n.ZodLiteral = "ZodLiteral", n.ZodEnum = "ZodEnum", n.ZodEffects = "ZodEffects", n.ZodNativeEnum = "ZodNativeEnum", n.ZodOptional = "ZodOptional", n.ZodNullable = "ZodNullable", n.ZodDefault = "ZodDefault", n.ZodCatch = "ZodCatch", n.ZodPromise = "ZodPromise", n.ZodBranded = "ZodBranded", n.ZodPipeline = "ZodPipeline", n.ZodReadonly = "ZodReadonly";
})(It || (It = {}));
const UC = id.create;
fd.create;
Nl.create;
const J9 = Ir.create;
Ir.strictCreate;
cx.create;
dx.create;
Wf.create;
Sm.create;
fx.create;
sd.create;
Em.create;
const mA = J9({
  email: UC().email("Email invlido").max(255, "Email muito longo"),
  password: UC().min(6, "Senha deve ter no mnimo 6 caracteres").max(100, "Senha muito longa"),
  fullName: UC().trim().max(100, "Nome muito longo").optional()
});
function Z9() {
  const n = _x(), [e, r] = D.useState(!1), [o, u] = D.useState({
    email: "",
    password: "",
    fullName: ""
  }), c = async (m) => {
    m.preventDefault(), r(!0);
    try {
      const y = mA.parse(o), b = `${window.location.origin}/`, { error: _ } = await wo.auth.signUp({
        email: y.email,
        password: y.password,
        options: {
          emailRedirectTo: b,
          data: {
            full_name: y.fullName || ""
          }
        }
      });
      if (_) {
        _.message.includes("already registered") ? ya.error("Este email j est cadastrado. Faa login.") : ya.error(_.message);
        return;
      }
      ya.success("Cadastro realizado com sucesso!"), n("/");
    } catch (y) {
      y instanceof Ls ? ya.error(y.errors[0].message) : ya.error("Erro ao criar conta");
    } finally {
      r(!1);
    }
  }, f = async (m) => {
    m.preventDefault(), r(!0);
    try {
      const y = mA.omit({ fullName: !0 }).parse({
        email: o.email,
        password: o.password
      }), { error: b } = await wo.auth.signInWithPassword({
        email: y.email,
        password: y.password
      });
      if (b) {
        b.message.includes("Invalid login credentials") ? ya.error("Email ou senha incorretos") : ya.error(b.message);
        return;
      }
      ya.success("Login realizado com sucesso!"), n("/");
    } catch (y) {
      y instanceof Ls ? ya.error(y.errors[0].message) : ya.error("Erro ao fazer login");
    } finally {
      r(!1);
    }
  };
  return /* @__PURE__ */ x.jsx("div", {
    className: "min-h-screen flex items-center justify-center bg-gradient-to-br from-secondary via-background to-beige p-4", children: /* @__PURE__ */ x.jsxs(Wo, {
      className: "w-full max-w-md", children: [
    /* @__PURE__ */ x.jsxs(Hf, {
        className: "text-center", children: [
      /* @__PURE__ */ x.jsxs(sx, {
          className: "text-3xl", children: [
        /* @__PURE__ */ x.jsx("span", { className: "text-foreground", children: "Bel" }),
        /* @__PURE__ */ x.jsx("span", { className: "text-accent", children: "ori" })
          ]
        }),
      /* @__PURE__ */ x.jsx(c2, { children: "Acesse sua conta ou crie uma nova" })
        ]
      }),
    /* @__PURE__ */ x.jsx(qo, {
        children: /* @__PURE__ */ x.jsxs(E9, {
          defaultValue: "signin", className: "w-full", children: [
      /* @__PURE__ */ x.jsxs(P2, {
            className: "grid w-full grid-cols-2", children: [
        /* @__PURE__ */ x.jsx(N1, { value: "signin", children: "Entrar" }),
        /* @__PURE__ */ x.jsx(N1, { value: "signup", children: "Cadastrar" })
            ]
          }),
      /* @__PURE__ */ x.jsx(j1, {
            value: "signin", children: /* @__PURE__ */ x.jsxs("form", {
              onSubmit: f, className: "space-y-4", children: [
        /* @__PURE__ */ x.jsxs("div", {
                className: "space-y-2", children: [
          /* @__PURE__ */ x.jsx(vo, { htmlFor: "signin-email", children: "Email" }),
          /* @__PURE__ */ x.jsx(
                  hi,
                  {
                    id: "signin-email",
                    type: "email",
                    placeholder: "seu@email.com",
                    value: o.email,
                    onChange: (m) => u({ ...o, email: m.target.value }),
                    required: !0,
                    disabled: e
                  }
                )
                ]
              }),
        /* @__PURE__ */ x.jsxs("div", {
                className: "space-y-2", children: [
          /* @__PURE__ */ x.jsx(vo, { htmlFor: "signin-password", children: "Senha" }),
          /* @__PURE__ */ x.jsx(
                  hi,
                  {
                    id: "signin-password",
                    type: "password",
                    placeholder: "",
                    value: o.password,
                    onChange: (m) => u({ ...o, password: m.target.value }),
                    required: !0,
                    disabled: e
                  }
                )
                ]
              }),
        /* @__PURE__ */ x.jsxs(Jn, {
                type: "submit", className: "w-full", disabled: e, children: [
                  e && /* @__PURE__ */ x.jsx(Ff, { className: "mr-2 h-4 w-4 animate-spin" }),
                  "Entrar"
                ]
              })
              ]
            })
          }),
      /* @__PURE__ */ x.jsx(j1, {
            value: "signup", children: /* @__PURE__ */ x.jsxs("form", {
              onSubmit: c, className: "space-y-4", children: [
        /* @__PURE__ */ x.jsxs("div", {
                className: "space-y-2", children: [
          /* @__PURE__ */ x.jsx(vo, { htmlFor: "signup-name", children: "Nome Completo" }),
          /* @__PURE__ */ x.jsx(
                  hi,
                  {
                    id: "signup-name",
                    type: "text",
                    placeholder: "Seu nome",
                    value: o.fullName,
                    onChange: (m) => u({ ...o, fullName: m.target.value }),
                    disabled: e
                  }
                )
                ]
              }),
        /* @__PURE__ */ x.jsxs("div", {
                className: "space-y-2", children: [
          /* @__PURE__ */ x.jsx(vo, { htmlFor: "signup-email", children: "Email" }),
          /* @__PURE__ */ x.jsx(
                  hi,
                  {
                    id: "signup-email",
                    type: "email",
                    placeholder: "seu@email.com",
                    value: o.email,
                    onChange: (m) => u({ ...o, email: m.target.value }),
                    required: !0,
                    disabled: e
                  }
                )
                ]
              }),
        /* @__PURE__ */ x.jsxs("div", {
                className: "space-y-2", children: [
          /* @__PURE__ */ x.jsx(vo, { htmlFor: "signup-password", children: "Senha" }),
          /* @__PURE__ */ x.jsx(
                  hi,
                  {
                    id: "signup-password",
                    type: "password",
                    placeholder: "",
                    value: o.password,
                    onChange: (m) => u({ ...o, password: m.target.value }),
                    required: !0,
                    disabled: e
                  }
                )
                ]
              }),
        /* @__PURE__ */ x.jsxs(Jn, {
                type: "submit", className: "w-full", disabled: e, children: [
                  e && /* @__PURE__ */ x.jsx(Ff, { className: "mr-2 h-4 w-4 animate-spin" }),
                  "Criar Conta"
                ]
              })
              ]
            })
          })
          ]
        })
      }),
    /* @__PURE__ */ x.jsx(OT, { className: "flex justify-center", children: /* @__PURE__ */ x.jsx(Jn, { variant: "link", onClick: () => n("/"), children: "Voltar para a loja" }) })
      ]
    })
  });
}
const X9 = [
  { name: "Dashboard", href: "/admin", icon: e3 },
  { name: "Produtos", href: "/admin/produtos", icon: pD },
  { name: "Pedidos", href: "/admin/pedidos", icon: vm },
  { name: "Clientes", href: "/admin/clientes", icon: vD }
], Px = ({ children: n }) => {
  var f;
  const e = ku(), r = _x(), { signOut: o, user: u } = kT(), c = async () => {
    await o(), ya.success("Logout realizado com sucesso"), r("/");
  };
  return /* @__PURE__ */ x.jsxs("div", {
    className: "min-h-screen bg-secondary/20", children: [
    /* @__PURE__ */ x.jsx("aside", {
      className: "fixed inset-y-0 left-0 z-50 w-64 bg-background border-r", children: /* @__PURE__ */ x.jsxs("div", {
        className: "flex flex-col h-full", children: [
      /* @__PURE__ */ x.jsx("div", {
          className: "flex items-center justify-between h-16 px-6 border-b", children: /* @__PURE__ */ x.jsx(ka, {
            to: "/", className: "flex items-center space-x-2", children: /* @__PURE__ */ x.jsxs("h1", {
              className: "text-xl font-bold", children: [
        /* @__PURE__ */ x.jsx("span", { className: "text-foreground", children: "Bel" }),
        /* @__PURE__ */ x.jsx("span", { className: "text-accent", children: "ori" })
              ]
            })
          })
        }),
      /* @__PURE__ */ x.jsx("nav", {
          className: "flex-1 p-4 space-y-1", children: X9.map((m) => {
            const y = e.pathname === m.href;
            return /* @__PURE__ */ x.jsxs(
              ka,
              {
                to: m.href,
                className: `flex items-center gap-3 px-3 py-2 rounded-lg transition-colors ${y ? "bg-accent text-accent-foreground" : "text-muted-foreground hover:bg-secondary hover:text-foreground"}`,
                children: [
              /* @__PURE__ */ x.jsx(m.icon, { className: "h-5 w-5" }),
              /* @__PURE__ */ x.jsx("span", { className: "font-medium", children: m.name })
                ]
              },
              m.name
            );
          })
        }),
      /* @__PURE__ */ x.jsxs("div", {
          className: "p-4 border-t", children: [
        /* @__PURE__ */ x.jsxs("div", {
            className: "flex items-center gap-3 mb-3 px-3", children: [
          /* @__PURE__ */ x.jsx("div", { className: "w-8 h-8 rounded-full bg-accent flex items-center justify-center", children: /* @__PURE__ */ x.jsx("span", { className: "text-sm font-medium text-accent-foreground", children: (f = u == null ? void 0 : u.email) == null ? void 0 : f.charAt(0).toUpperCase() }) }),
          /* @__PURE__ */ x.jsxs("div", {
              className: "flex-1 min-w-0", children: [
            /* @__PURE__ */ x.jsx("p", { className: "text-sm font-medium truncate", children: u == null ? void 0 : u.email }),
            /* @__PURE__ */ x.jsx("p", { className: "text-xs text-muted-foreground", children: "Admin" })
              ]
            })
            ]
          }),
        /* @__PURE__ */ x.jsxs(
            Jn,
            {
              variant: "ghost",
              className: "w-full justify-start",
              onClick: () => r("/"),
              children: [
              /* @__PURE__ */ x.jsx(c3, { className: "mr-2 h-4 w-4" }),
                "Ver Loja"
              ]
            }
          ),
        /* @__PURE__ */ x.jsxs(
            Jn,
            {
              variant: "ghost",
              className: "w-full justify-start text-destructive hover:text-destructive",
              onClick: c,
              children: [
              /* @__PURE__ */ x.jsx(t3, { className: "mr-2 h-4 w-4" }),
                "Sair"
              ]
            }
          )
          ]
        })
        ]
      })
    }),
    /* @__PURE__ */ x.jsx("main", { className: "pl-64", children: /* @__PURE__ */ x.jsx("div", { className: "p-8", children: n }) })
    ]
  });
};
function e7() {
  const { data: n } = kl({
    queryKey: ["admin-orders-count"],
    queryFn: async () => {
      const { count: c } = await wo.from("orders").select("*", { count: "exact", head: !0 });
      return c || 0;
    }
  }), { data: e } = kl({
    queryKey: ["admin-customers-count"],
    queryFn: async () => {
      const { count: c } = await wo.from("customers").select("*", { count: "exact", head: !0 });
      return c || 0;
    }
  }), { data: r } = kl({
    queryKey: ["admin-products-count"],
    queryFn: async () => 10
  }), { data: o } = kl({
    queryKey: ["admin-revenue"],
    queryFn: async () => {
      const { data: c } = await wo.from("orders").select("total_amount");
      return ((c == null ? void 0 : c.reduce((m, y) => m + Number(y.total_amount), 0)) || 0).toFixed(2);
    }
  }), u = [
    {
      title: "Produtos",
      value: r || 0,
      icon: pD,
      color: "text-blue-600"
    },
    {
      title: "Pedidos",
      value: n || 0,
      icon: vm,
      color: "text-green-600"
    },
    {
      title: "Clientes",
      value: e || 0,
      icon: vD,
      color: "text-purple-600"
    },
    {
      title: "Receita Total",
      value: `R$ ${o || "0.00"}`,
      icon: Y4,
      color: "text-amber-600"
    }
  ];
  return /* @__PURE__ */ x.jsx(Px, {
    children: /* @__PURE__ */ x.jsxs("div", {
      className: "space-y-8", children: [
    /* @__PURE__ */ x.jsxs("div", {
        children: [
      /* @__PURE__ */ x.jsx("h1", { className: "text-3xl font-bold mb-2", children: "Dashboard" }),
      /* @__PURE__ */ x.jsx("p", { className: "text-muted-foreground", children: "Viso geral da sua loja" })
        ]
      }),
    /* @__PURE__ */ x.jsx("div", {
        className: "grid gap-4 md:grid-cols-2 lg:grid-cols-4", children: u.map((c) => /* @__PURE__ */ x.jsxs(Wo, {
          children: [
      /* @__PURE__ */ x.jsxs(Hf, {
            className: "flex flex-row items-center justify-between pb-2", children: [
        /* @__PURE__ */ x.jsx(sx, { className: "text-sm font-medium text-muted-foreground", children: c.title }),
        /* @__PURE__ */ x.jsx(c.icon, { className: `h-5 w-5 ${c.color}` })
            ]
          }),
      /* @__PURE__ */ x.jsx(qo, { children: /* @__PURE__ */ x.jsx("div", { className: "text-2xl font-bold", children: c.value }) })
          ]
        }, c.title))
      }),
    /* @__PURE__ */ x.jsxs(Wo, {
        children: [
      /* @__PURE__ */ x.jsx(Hf, { children: /* @__PURE__ */ x.jsx(sx, { children: "Bem-vindo ao Painel Administrativo" }) }),
      /* @__PURE__ */ x.jsx(qo, { children: /* @__PURE__ */ x.jsx("p", { className: "text-muted-foreground", children: "Gerencie seus produtos, pedidos e clientes de forma fcil e eficiente. Use o menu lateral para navegar entre as diferentes sees." }) })
        ]
      })
      ]
    })
  });
}
const Mx = D.forwardRef(
  ({ className: n, ...e }, r) => /* @__PURE__ */ x.jsx("div", { className: "relative w-full overflow-auto", children: /* @__PURE__ */ x.jsx("table", { ref: r, className: tn("w-full caption-bottom text-sm", n), ...e }) })
);
Mx.displayName = "Table";
const Lx = D.forwardRef(
  ({ className: n, ...e }, r) => /* @__PURE__ */ x.jsx("thead", { ref: r, className: tn("[&_tr]:border-b", n), ...e })
);
Lx.displayName = "TableHeader";
const Ix = D.forwardRef(
  ({ className: n, ...e }, r) => /* @__PURE__ */ x.jsx("tbody", { ref: r, className: tn("[&_tr:last-child]:border-0", n), ...e })
);
Ix.displayName = "TableBody";
const t7 = D.forwardRef(
  ({ className: n, ...e }, r) => /* @__PURE__ */ x.jsx("tfoot", { ref: r, className: tn("border-t bg-muted/50 font-medium [&>tr]:last:border-b-0", n), ...e })
);
t7.displayName = "TableFooter";
const qf = D.forwardRef(
  ({ className: n, ...e }, r) => /* @__PURE__ */ x.jsx(
    "tr",
    {
      ref: r,
      className: tn("border-b transition-colors data-[state=selected]:bg-muted hover:bg-muted/50", n),
      ...e
    }
  )
);
qf.displayName = "TableRow";
const Ta = D.forwardRef(
  ({ className: n, ...e }, r) => /* @__PURE__ */ x.jsx(
    "th",
    {
      ref: r,
      className: tn(
        "h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0",
        n
      ),
      ...e
    }
  )
);
Ta.displayName = "TableHead";
const Ra = D.forwardRef(
  ({ className: n, ...e }, r) => /* @__PURE__ */ x.jsx("td", { ref: r, className: tn("p-4 align-middle [&:has([role=checkbox])]:pr-0", n), ...e })
);
Ra.displayName = "TableCell";
const n7 = D.forwardRef(
  ({ className: n, ...e }, r) => /* @__PURE__ */ x.jsx("caption", { ref: r, className: tn("mt-4 text-sm text-muted-foreground", n), ...e })
);
n7.displayName = "TableCaption";
function r7() {
  const [n, e] = D.useState(""), { data: r, isLoading: o } = kl({
    queryKey: ["admin-products"],
    queryFn: async () => {
      var m, y;
      const f = await Sy(bT, { first: 50 });
      return ((y = (m = f == null ? void 0 : f.data) == null ? void 0 : m.products) == null ? void 0 : y.edges) || [];
    }
  }), u = r == null ? void 0 : r.filter(
    (f) => f.node.title.toLowerCase().includes(n.toLowerCase())
  ), c = () => {
    ya.info("Para adicionar produtos, use o chat! Ex: 'criar produto X por R$Y'");
  };
  return /* @__PURE__ */ x.jsx(Px, {
    children: /* @__PURE__ */ x.jsxs("div", {
      className: "space-y-6", children: [
    /* @__PURE__ */ x.jsxs("div", {
        className: "flex justify-between items-center", children: [
      /* @__PURE__ */ x.jsxs("div", {
          children: [
        /* @__PURE__ */ x.jsx("h1", { className: "text-3xl font-bold mb-2", children: "Produtos" }),
        /* @__PURE__ */ x.jsx("p", { className: "text-muted-foreground", children: "Gerencie o catlogo de produtos da loja" })
          ]
        }),
      /* @__PURE__ */ x.jsxs(Jn, {
          onClick: c, children: [
        /* @__PURE__ */ x.jsx(B1, { className: "mr-2 h-4 w-4" }),
            "Adicionar Produto"
          ]
        })
        ]
      }),
    /* @__PURE__ */ x.jsxs(Wo, {
        children: [
      /* @__PURE__ */ x.jsx(Hf, {
          children: /* @__PURE__ */ x.jsx("div", {
            className: "flex items-center gap-4", children: /* @__PURE__ */ x.jsxs("div", {
              className: "relative flex-1", children: [
        /* @__PURE__ */ x.jsx(V1, { className: "absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-muted-foreground" }),
        /* @__PURE__ */ x.jsx(
                hi,
                {
                  placeholder: "Buscar produtos...",
                  value: n,
                  onChange: (f) => e(f.target.value),
                  className: "pl-10"
                }
              )
              ]
            })
          })
        }),
      /* @__PURE__ */ x.jsx(qo, {
          children: o ? /* @__PURE__ */ x.jsx("p", { className: "text-center py-8 text-muted-foreground", children: "Carregando produtos..." }) : u && u.length > 0 ? /* @__PURE__ */ x.jsxs(Mx, {
            children: [
        /* @__PURE__ */ x.jsx(Lx, {
              children: /* @__PURE__ */ x.jsxs(qf, {
                children: [
          /* @__PURE__ */ x.jsx(Ta, { children: "Produto" }),
          /* @__PURE__ */ x.jsx(Ta, { children: "Preo" }),
          /* @__PURE__ */ x.jsx(Ta, { children: "Variantes" }),
          /* @__PURE__ */ x.jsx(Ta, { children: "Status" }),
          /* @__PURE__ */ x.jsx(Ta, { className: "text-right", children: "Aes" })
                ]
              })
            }),
        /* @__PURE__ */ x.jsx(Ix, {
              children: u.map((f) => {
                var m, y;
                return /* @__PURE__ */ x.jsxs(qf, {
                  children: [
            /* @__PURE__ */ x.jsx(Ra, {
                    children: /* @__PURE__ */ x.jsxs("div", {
                      className: "flex items-center gap-3", children: [
              /* @__PURE__ */ x.jsx("div", {
                        className: "w-12 h-12 bg-secondary rounded-md overflow-hidden", children: ((y = (m = f.node.images.edges[0]) == null ? void 0 : m.node) == null ? void 0 : y.url) && /* @__PURE__ */ x.jsx(
                          "img",
                          {
                            src: f.node.images.edges[0].node.url,
                            alt: f.node.title,
                            className: "w-full h-full object-cover"
                          }
                        )
                      }),
              /* @__PURE__ */ x.jsxs("div", {
                        children: [
                /* @__PURE__ */ x.jsx("p", { className: "font-medium", children: f.node.title }),
                /* @__PURE__ */ x.jsx("p", { className: "text-sm text-muted-foreground line-clamp-1", children: f.node.description })
                        ]
                      })
                      ]
                    })
                  }),
            /* @__PURE__ */ x.jsx(Ra, { children: Number(f.node.priceRange.minVariantPrice.amount).toLocaleString("pt-BR", { style: "currency", currency: "BRL" }) }),
            /* @__PURE__ */ x.jsx(Ra, { children: f.node.variants.edges.length }),
            /* @__PURE__ */ x.jsx(Ra, { children: /* @__PURE__ */ x.jsx(yT, { variant: "secondary", children: "Ativo" }) }),
            /* @__PURE__ */ x.jsx(Ra, {
                    className: "text-right", children: /* @__PURE__ */ x.jsx(
                      Jn,
                      {
                        variant: "ghost",
                        size: "sm",
                        onClick: () => window.open(`/produto/${f.node.handle}`, "_blank"),
                        children: /* @__PURE__ */ x.jsx(hD, { className: "h-4 w-4" })
                      }
                    )
                  })
                  ]
                }, f.node.id);
              })
            })
            ]
          }) : /* @__PURE__ */ x.jsx("p", { className: "text-center py-8 text-muted-foreground", children: "Nenhum produto encontrado" })
        })
        ]
      })
      ]
    })
  });
}
const U2 = 6048e5, a7 = 864e5, vA = Symbol.for("constructDateFrom");
function hd(n, e) {
  return typeof n == "function" ? n(e) : n && typeof n == "object" && vA in n ? n[vA](e) : n instanceof Date ? new n.constructor(e) : new Date(e);
}
function Fs(n, e) {
  return hd(e || n, n);
}
let i7 = {};
function Ux() {
  return i7;
}
function uy(n, e) {
  var m, y, b, _;
  const r = Ux(), o = (e == null ? void 0 : e.weekStartsOn) ?? ((y = (m = e == null ? void 0 : e.locale) == null ? void 0 : m.options) == null ? void 0 : y.weekStartsOn) ?? r.weekStartsOn ?? ((_ = (b = r.locale) == null ? void 0 : b.options) == null ? void 0 : _.weekStartsOn) ?? 0, u = Fs(n, e == null ? void 0 : e.in), c = u.getDay(), f = (c < o ? 7 : 0) + c - o;
  return u.setDate(u.getDate() - f), u.setHours(0, 0, 0, 0), u;
}
function hx(n, e) {
  return uy(n, { ...e, weekStartsOn: 1 });
}
function F2(n, e) {
  const r = Fs(n, e == null ? void 0 : e.in), o = r.getFullYear(), u = hd(r, 0);
  u.setFullYear(o + 1, 0, 4), u.setHours(0, 0, 0, 0);
  const c = hx(u), f = hd(r, 0);
  f.setFullYear(o, 0, 4), f.setHours(0, 0, 0, 0);
  const m = hx(f);
  return r.getTime() >= c.getTime() ? o + 1 : r.getTime() >= m.getTime() ? o : o - 1;
}
function gA(n) {
  const e = Fs(n), r = new Date(
    Date.UTC(
      e.getFullYear(),
      e.getMonth(),
      e.getDate(),
      e.getHours(),
      e.getMinutes(),
      e.getSeconds(),
      e.getMilliseconds()
    )
  );
  return r.setUTCFullYear(e.getFullYear()), +n - +r;
}
function o7(n, ...e) {
  const r = hd.bind(
    null,
    e.find((o) => typeof o == "object")
  );
  return e.map(r);
}
function yA(n, e) {
  const r = Fs(n, e == null ? void 0 : e.in);
  return r.setHours(0, 0, 0, 0), r;
}
function s7(n, e, r) {
  const [o, u] = o7(
    r == null ? void 0 : r.in,
    n,
    e
  ), c = yA(o), f = yA(u), m = +c - gA(c), y = +f - gA(f);
  return Math.round((m - y) / a7);
}
function l7(n, e) {
  const r = F2(n, e), o = hd(n, 0);
  return o.setFullYear(r, 0, 4), o.setHours(0, 0, 0, 0), hx(o);
}
function u7(n) {
  return n instanceof Date || typeof n == "object" && Object.prototype.toString.call(n) === "[object Date]";
}
function c7(n) {
  return !(!u7(n) && typeof n != "number" || isNaN(+Fs(n)));
}
function d7(n, e) {
  const r = Fs(n, e == null ? void 0 : e.in);
  return r.setFullYear(r.getFullYear(), 0, 1), r.setHours(0, 0, 0, 0), r;
}
const f7 = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
}, h7 = (n, e, r) => {
  let o;
  const u = f7[n];
  return typeof u == "string" ? o = u : e === 1 ? o = u.one : o = u.other.replace("{{count}}", e.toString()), r != null && r.addSuffix ? r.comparison && r.comparison > 0 ? "in " + o : o + " ago" : o;
};
function rm(n) {
  return (e = {}) => {
    const r = e.width ? String(e.width) : n.defaultWidth;
    return n.formats[r] || n.formats[n.defaultWidth];
  };
}
const p7 = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
}, m7 = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
}, v7 = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
}, g7 = {
  date: rm({
    formats: p7,
    defaultWidth: "full"
  }),
  time: rm({
    formats: m7,
    defaultWidth: "full"
  }),
  dateTime: rm({
    formats: v7,
    defaultWidth: "full"
  })
}, y7 = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
}, b7 = (n, e, r, o) => y7[n];
function Cl(n) {
  return (e, r) => {
    const o = r != null && r.context ? String(r.context) : "standalone";
    let u;
    if (o === "formatting" && n.formattingValues) {
      const f = n.defaultFormattingWidth || n.defaultWidth, m = r != null && r.width ? String(r.width) : f;
      u = n.formattingValues[m] || n.formattingValues[f];
    } else {
      const f = n.defaultWidth, m = r != null && r.width ? String(r.width) : n.defaultWidth;
      u = n.values[m] || n.values[f];
    }
    const c = n.argumentCallback ? n.argumentCallback(e) : e;
    return u[c];
  };
}
const w7 = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
}, x7 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
}, S7 = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ],
  wide: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ]
}, _7 = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ]
}, E7 = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
}, C7 = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
}, T7 = (n, e) => {
  const r = Number(n), o = r % 100;
  if (o > 20 || o < 10)
    switch (o % 10) {
      case 1:
        return r + "st";
      case 2:
        return r + "nd";
      case 3:
        return r + "rd";
    }
  return r + "th";
}, R7 = {
  ordinalNumber: T7,
  era: Cl({
    values: w7,
    defaultWidth: "wide"
  }),
  quarter: Cl({
    values: x7,
    defaultWidth: "wide",
    argumentCallback: (n) => n - 1
  }),
  month: Cl({
    values: S7,
    defaultWidth: "wide"
  }),
  day: Cl({
    values: _7,
    defaultWidth: "wide"
  }),
  dayPeriod: Cl({
    values: E7,
    defaultWidth: "wide",
    formattingValues: C7,
    defaultFormattingWidth: "wide"
  })
};
function Tl(n) {
  return (e, r = {}) => {
    const o = r.width, u = o && n.matchPatterns[o] || n.matchPatterns[n.defaultMatchWidth], c = e.match(u);
    if (!c)
      return null;
    const f = c[0], m = o && n.parsePatterns[o] || n.parsePatterns[n.defaultParseWidth], y = Array.isArray(m) ? O7(m, (T) => T.test(f)) : (
      // [TODO] -- I challenge you to fix the type
      k7(m, (T) => T.test(f))
    );
    let b;
    b = n.valueCallback ? n.valueCallback(y) : y, b = r.valueCallback ? (
      // [TODO] -- I challenge you to fix the type
      r.valueCallback(b)
    ) : b;
    const _ = e.slice(f.length);
    return { value: b, rest: _ };
  };
}
function k7(n, e) {
  for (const r in n)
    if (Object.prototype.hasOwnProperty.call(n, r) && e(n[r]))
      return r;
}
function O7(n, e) {
  for (let r = 0; r < n.length; r++)
    if (e(n[r]))
      return r;
}
function $2(n) {
  return (e, r = {}) => {
    const o = e.match(n.matchPattern);
    if (!o) return null;
    const u = o[0], c = e.match(n.parsePattern);
    if (!c) return null;
    let f = n.valueCallback ? n.valueCallback(c[0]) : c[0];
    f = r.valueCallback ? r.valueCallback(f) : f;
    const m = e.slice(u.length);
    return { value: f, rest: m };
  };
}
const N7 = /^(\d+)(th|st|nd|rd)?/i, j7 = /\d+/i, A7 = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
}, D7 = {
  any: [/^b/i, /^(a|c)/i]
}, P7 = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
}, M7 = {
  any: [/1/i, /2/i, /3/i, /4/i]
}, L7 = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
}, I7 = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^may/i,
    /^jun/i,
    /^jul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
}, U7 = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
}, F7 = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
}, $7 = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
}, z7 = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
}, B7 = {
  ordinalNumber: $2({
    matchPattern: N7,
    parsePattern: j7,
    valueCallback: (n) => parseInt(n, 10)
  }),
  era: Tl({
    matchPatterns: A7,
    defaultMatchWidth: "wide",
    parsePatterns: D7,
    defaultParseWidth: "any"
  }),
  quarter: Tl({
    matchPatterns: P7,
    defaultMatchWidth: "wide",
    parsePatterns: M7,
    defaultParseWidth: "any",
    valueCallback: (n) => n + 1
  }),
  month: Tl({
    matchPatterns: L7,
    defaultMatchWidth: "wide",
    parsePatterns: I7,
    defaultParseWidth: "any"
  }),
  day: Tl({
    matchPatterns: U7,
    defaultMatchWidth: "wide",
    parsePatterns: F7,
    defaultParseWidth: "any"
  }),
  dayPeriod: Tl({
    matchPatterns: $7,
    defaultMatchWidth: "any",
    parsePatterns: z7,
    defaultParseWidth: "any"
  })
}, V7 = {
  code: "en-US",
  formatDistance: h7,
  formatLong: g7,
  formatRelative: b7,
  localize: R7,
  match: B7,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
function H7(n, e) {
  const r = Fs(n, e == null ? void 0 : e.in);
  return s7(r, d7(r)) + 1;
}
function W7(n, e) {
  const r = Fs(n, e == null ? void 0 : e.in), o = +hx(r) - +l7(r);
  return Math.round(o / U2) + 1;
}
function z2(n, e) {
  var _, T, k, C;
  const r = Fs(n, e == null ? void 0 : e.in), o = r.getFullYear(), u = Ux(), c = (e == null ? void 0 : e.firstWeekContainsDate) ?? ((T = (_ = e == null ? void 0 : e.locale) == null ? void 0 : _.options) == null ? void 0 : T.firstWeekContainsDate) ?? u.firstWeekContainsDate ?? ((C = (k = u.locale) == null ? void 0 : k.options) == null ? void 0 : C.firstWeekContainsDate) ?? 1, f = hd((e == null ? void 0 : e.in) || n, 0);
  f.setFullYear(o + 1, 0, c), f.setHours(0, 0, 0, 0);
  const m = uy(f, e), y = hd((e == null ? void 0 : e.in) || n, 0);
  y.setFullYear(o, 0, c), y.setHours(0, 0, 0, 0);
  const b = uy(y, e);
  return +r >= +m ? o + 1 : +r >= +b ? o : o - 1;
}
function q7(n, e) {
  var m, y, b, _;
  const r = Ux(), o = (e == null ? void 0 : e.firstWeekContainsDate) ?? ((y = (m = e == null ? void 0 : e.locale) == null ? void 0 : m.options) == null ? void 0 : y.firstWeekContainsDate) ?? r.firstWeekContainsDate ?? ((_ = (b = r.locale) == null ? void 0 : b.options) == null ? void 0 : _.firstWeekContainsDate) ?? 1, u = z2(n, e), c = hd((e == null ? void 0 : e.in) || n, 0);
  return c.setFullYear(u, 0, o), c.setHours(0, 0, 0, 0), uy(c, e);
}
function Y7(n, e) {
  const r = Fs(n, e == null ? void 0 : e.in), o = +uy(r, e) - +q7(r, e);
  return Math.round(o / U2) + 1;
}
function In(n, e) {
  const r = n < 0 ? "-" : "", o = Math.abs(n).toString().padStart(e, "0");
  return r + o;
}
const Vc = {
  // Year
  y(n, e) {
    const r = n.getFullYear(), o = r > 0 ? r : 1 - r;
    return In(e === "yy" ? o % 100 : o, e.length);
  },
  // Month
  M(n, e) {
    const r = n.getMonth();
    return e === "M" ? String(r + 1) : In(r + 1, 2);
  },
  // Day of the month
  d(n, e) {
    return In(n.getDate(), e.length);
  },
  // AM or PM
  a(n, e) {
    const r = n.getHours() / 12 >= 1 ? "pm" : "am";
    switch (e) {
      case "a":
      case "aa":
        return r.toUpperCase();
      case "aaa":
        return r;
      case "aaaaa":
        return r[0];
      case "aaaa":
      default:
        return r === "am" ? "a.m." : "p.m.";
    }
  },
  // Hour [1-12]
  h(n, e) {
    return In(n.getHours() % 12 || 12, e.length);
  },
  // Hour [0-23]
  H(n, e) {
    return In(n.getHours(), e.length);
  },
  // Minute
  m(n, e) {
    return In(n.getMinutes(), e.length);
  },
  // Second
  s(n, e) {
    return In(n.getSeconds(), e.length);
  },
  // Fraction of second
  S(n, e) {
    const r = e.length, o = n.getMilliseconds(), u = Math.trunc(
      o * Math.pow(10, r - 3)
    );
    return In(u, e.length);
  }
}, Yp = {
  am: "am",
  pm: "pm",
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night"
}, bA = {
  // Era
  G: function (n, e, r) {
    const o = n.getFullYear() > 0 ? 1 : 0;
    switch (e) {
      case "G":
      case "GG":
      case "GGG":
        return r.era(o, { width: "abbreviated" });
      case "GGGGG":
        return r.era(o, { width: "narrow" });
      case "GGGG":
      default:
        return r.era(o, { width: "wide" });
    }
  },
  // Year
  y: function (n, e, r) {
    if (e === "yo") {
      const o = n.getFullYear(), u = o > 0 ? o : 1 - o;
      return r.ordinalNumber(u, { unit: "year" });
    }
    return Vc.y(n, e);
  },
  // Local week-numbering year
  Y: function (n, e, r, o) {
    const u = z2(n, o), c = u > 0 ? u : 1 - u;
    if (e === "YY") {
      const f = c % 100;
      return In(f, 2);
    }
    return e === "Yo" ? r.ordinalNumber(c, { unit: "year" }) : In(c, e.length);
  },
  // ISO week-numbering year
  R: function (n, e) {
    const r = F2(n);
    return In(r, e.length);
  },
  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function (n, e) {
    const r = n.getFullYear();
    return In(r, e.length);
  },
  // Quarter
  Q: function (n, e, r) {
    const o = Math.ceil((n.getMonth() + 1) / 3);
    switch (e) {
      case "Q":
        return String(o);
      case "QQ":
        return In(o, 2);
      case "Qo":
        return r.ordinalNumber(o, { unit: "quarter" });
      case "QQQ":
        return r.quarter(o, {
          width: "abbreviated",
          context: "formatting"
        });
      case "QQQQQ":
        return r.quarter(o, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQ":
      default:
        return r.quarter(o, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone quarter
  q: function (n, e, r) {
    const o = Math.ceil((n.getMonth() + 1) / 3);
    switch (e) {
      case "q":
        return String(o);
      case "qq":
        return In(o, 2);
      case "qo":
        return r.ordinalNumber(o, { unit: "quarter" });
      case "qqq":
        return r.quarter(o, {
          width: "abbreviated",
          context: "standalone"
        });
      case "qqqqq":
        return r.quarter(o, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqq":
      default:
        return r.quarter(o, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // Month
  M: function (n, e, r) {
    const o = n.getMonth();
    switch (e) {
      case "M":
      case "MM":
        return Vc.M(n, e);
      case "Mo":
        return r.ordinalNumber(o + 1, { unit: "month" });
      case "MMM":
        return r.month(o, {
          width: "abbreviated",
          context: "formatting"
        });
      case "MMMMM":
        return r.month(o, {
          width: "narrow",
          context: "formatting"
        });
      case "MMMM":
      default:
        return r.month(o, { width: "wide", context: "formatting" });
    }
  },
  // Stand-alone month
  L: function (n, e, r) {
    const o = n.getMonth();
    switch (e) {
      case "L":
        return String(o + 1);
      case "LL":
        return In(o + 1, 2);
      case "Lo":
        return r.ordinalNumber(o + 1, { unit: "month" });
      case "LLL":
        return r.month(o, {
          width: "abbreviated",
          context: "standalone"
        });
      case "LLLLL":
        return r.month(o, {
          width: "narrow",
          context: "standalone"
        });
      case "LLLL":
      default:
        return r.month(o, { width: "wide", context: "standalone" });
    }
  },
  // Local week of year
  w: function (n, e, r, o) {
    const u = Y7(n, o);
    return e === "wo" ? r.ordinalNumber(u, { unit: "week" }) : In(u, e.length);
  },
  // ISO week of year
  I: function (n, e, r) {
    const o = W7(n);
    return e === "Io" ? r.ordinalNumber(o, { unit: "week" }) : In(o, e.length);
  },
  // Day of the month
  d: function (n, e, r) {
    return e === "do" ? r.ordinalNumber(n.getDate(), { unit: "date" }) : Vc.d(n, e);
  },
  // Day of year
  D: function (n, e, r) {
    const o = H7(n);
    return e === "Do" ? r.ordinalNumber(o, { unit: "dayOfYear" }) : In(o, e.length);
  },
  // Day of week
  E: function (n, e, r) {
    const o = n.getDay();
    switch (e) {
      case "E":
      case "EE":
      case "EEE":
        return r.day(o, {
          width: "abbreviated",
          context: "formatting"
        });
      case "EEEEE":
        return r.day(o, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEEEE":
        return r.day(o, {
          width: "short",
          context: "formatting"
        });
      case "EEEE":
      default:
        return r.day(o, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Local day of week
  e: function (n, e, r, o) {
    const u = n.getDay(), c = (u - o.weekStartsOn + 8) % 7 || 7;
    switch (e) {
      case "e":
        return String(c);
      case "ee":
        return In(c, 2);
      case "eo":
        return r.ordinalNumber(c, { unit: "day" });
      case "eee":
        return r.day(u, {
          width: "abbreviated",
          context: "formatting"
        });
      case "eeeee":
        return r.day(u, {
          width: "narrow",
          context: "formatting"
        });
      case "eeeeee":
        return r.day(u, {
          width: "short",
          context: "formatting"
        });
      case "eeee":
      default:
        return r.day(u, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone local day of week
  c: function (n, e, r, o) {
    const u = n.getDay(), c = (u - o.weekStartsOn + 8) % 7 || 7;
    switch (e) {
      case "c":
        return String(c);
      case "cc":
        return In(c, e.length);
      case "co":
        return r.ordinalNumber(c, { unit: "day" });
      case "ccc":
        return r.day(u, {
          width: "abbreviated",
          context: "standalone"
        });
      case "ccccc":
        return r.day(u, {
          width: "narrow",
          context: "standalone"
        });
      case "cccccc":
        return r.day(u, {
          width: "short",
          context: "standalone"
        });
      case "cccc":
      default:
        return r.day(u, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // ISO day of week
  i: function (n, e, r) {
    const o = n.getDay(), u = o === 0 ? 7 : o;
    switch (e) {
      case "i":
        return String(u);
      case "ii":
        return In(u, e.length);
      case "io":
        return r.ordinalNumber(u, { unit: "day" });
      case "iii":
        return r.day(o, {
          width: "abbreviated",
          context: "formatting"
        });
      case "iiiii":
        return r.day(o, {
          width: "narrow",
          context: "formatting"
        });
      case "iiiiii":
        return r.day(o, {
          width: "short",
          context: "formatting"
        });
      case "iiii":
      default:
        return r.day(o, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM or PM
  a: function (n, e, r) {
    const u = n.getHours() / 12 >= 1 ? "pm" : "am";
    switch (e) {
      case "a":
      case "aa":
        return r.dayPeriod(u, {
          width: "abbreviated",
          context: "formatting"
        });
      case "aaa":
        return r.dayPeriod(u, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "aaaaa":
        return r.dayPeriod(u, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return r.dayPeriod(u, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM, PM, midnight, noon
  b: function (n, e, r) {
    const o = n.getHours();
    let u;
    switch (o === 12 ? u = Yp.noon : o === 0 ? u = Yp.midnight : u = o / 12 >= 1 ? "pm" : "am", e) {
      case "b":
      case "bb":
        return r.dayPeriod(u, {
          width: "abbreviated",
          context: "formatting"
        });
      case "bbb":
        return r.dayPeriod(u, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "bbbbb":
        return r.dayPeriod(u, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return r.dayPeriod(u, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // in the morning, in the afternoon, in the evening, at night
  B: function (n, e, r) {
    const o = n.getHours();
    let u;
    switch (o >= 17 ? u = Yp.evening : o >= 12 ? u = Yp.afternoon : o >= 4 ? u = Yp.morning : u = Yp.night, e) {
      case "B":
      case "BB":
      case "BBB":
        return r.dayPeriod(u, {
          width: "abbreviated",
          context: "formatting"
        });
      case "BBBBB":
        return r.dayPeriod(u, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return r.dayPeriod(u, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Hour [1-12]
  h: function (n, e, r) {
    if (e === "ho") {
      let o = n.getHours() % 12;
      return o === 0 && (o = 12), r.ordinalNumber(o, { unit: "hour" });
    }
    return Vc.h(n, e);
  },
  // Hour [0-23]
  H: function (n, e, r) {
    return e === "Ho" ? r.ordinalNumber(n.getHours(), { unit: "hour" }) : Vc.H(n, e);
  },
  // Hour [0-11]
  K: function (n, e, r) {
    const o = n.getHours() % 12;
    return e === "Ko" ? r.ordinalNumber(o, { unit: "hour" }) : In(o, e.length);
  },
  // Hour [1-24]
  k: function (n, e, r) {
    let o = n.getHours();
    return o === 0 && (o = 24), e === "ko" ? r.ordinalNumber(o, { unit: "hour" }) : In(o, e.length);
  },
  // Minute
  m: function (n, e, r) {
    return e === "mo" ? r.ordinalNumber(n.getMinutes(), { unit: "minute" }) : Vc.m(n, e);
  },
  // Second
  s: function (n, e, r) {
    return e === "so" ? r.ordinalNumber(n.getSeconds(), { unit: "second" }) : Vc.s(n, e);
  },
  // Fraction of second
  S: function (n, e) {
    return Vc.S(n, e);
  },
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function (n, e, r) {
    const o = n.getTimezoneOffset();
    if (o === 0)
      return "Z";
    switch (e) {
      case "X":
        return xA(o);
      case "XXXX":
      case "XX":
        return Tf(o);
      case "XXXXX":
      case "XXX":
      default:
        return Tf(o, ":");
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function (n, e, r) {
    const o = n.getTimezoneOffset();
    switch (e) {
      case "x":
        return xA(o);
      case "xxxx":
      case "xx":
        return Tf(o);
      case "xxxxx":
      case "xxx":
      default:
        return Tf(o, ":");
    }
  },
  // Timezone (GMT)
  O: function (n, e, r) {
    const o = n.getTimezoneOffset();
    switch (e) {
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + wA(o, ":");
      case "OOOO":
      default:
        return "GMT" + Tf(o, ":");
    }
  },
  // Timezone (specific non-location)
  z: function (n, e, r) {
    const o = n.getTimezoneOffset();
    switch (e) {
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + wA(o, ":");
      case "zzzz":
      default:
        return "GMT" + Tf(o, ":");
    }
  },
  // Seconds timestamp
  t: function (n, e, r) {
    const o = Math.trunc(+n / 1e3);
    return In(o, e.length);
  },
  // Milliseconds timestamp
  T: function (n, e, r) {
    return In(+n, e.length);
  }
};
function wA(n, e = "") {
  const r = n > 0 ? "-" : "+", o = Math.abs(n), u = Math.trunc(o / 60), c = o % 60;
  return c === 0 ? r + String(u) : r + String(u) + e + In(c, 2);
}
function xA(n, e) {
  return n % 60 === 0 ? (n > 0 ? "-" : "+") + In(Math.abs(n) / 60, 2) : Tf(n, e);
}
function Tf(n, e = "") {
  const r = n > 0 ? "-" : "+", o = Math.abs(n), u = In(Math.trunc(o / 60), 2), c = In(o % 60, 2);
  return r + u + e + c;
}
const SA = (n, e) => {
  switch (n) {
    case "P":
      return e.date({ width: "short" });
    case "PP":
      return e.date({ width: "medium" });
    case "PPP":
      return e.date({ width: "long" });
    case "PPPP":
    default:
      return e.date({ width: "full" });
  }
}, B2 = (n, e) => {
  switch (n) {
    case "p":
      return e.time({ width: "short" });
    case "pp":
      return e.time({ width: "medium" });
    case "ppp":
      return e.time({ width: "long" });
    case "pppp":
    default:
      return e.time({ width: "full" });
  }
}, K7 = (n, e) => {
  const r = n.match(/(P+)(p+)?/) || [], o = r[1], u = r[2];
  if (!u)
    return SA(n, e);
  let c;
  switch (o) {
    case "P":
      c = e.dateTime({ width: "short" });
      break;
    case "PP":
      c = e.dateTime({ width: "medium" });
      break;
    case "PPP":
      c = e.dateTime({ width: "long" });
      break;
    case "PPPP":
    default:
      c = e.dateTime({ width: "full" });
      break;
  }
  return c.replace("{{date}}", SA(o, e)).replace("{{time}}", B2(u, e));
}, G7 = {
  p: B2,
  P: K7
}, Q7 = /^D+$/, J7 = /^Y+$/, Z7 = ["D", "DD", "YY", "YYYY"];
function X7(n) {
  return Q7.test(n);
}
function eY(n) {
  return J7.test(n);
}
function tY(n, e, r) {
  const o = nY(n, e, r);
  if (console.warn(o), Z7.includes(n)) throw new RangeError(o);
}
function nY(n, e, r) {
  const o = n[0] === "Y" ? "years" : "days of the month";
  return `Use \`${n.toLowerCase()}\` instead of \`${n}\` (in \`${e}\`) for formatting ${o} to the input \`${r}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`;
}
const rY = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g, aY = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g, iY = /^'([^]*?)'?$/, oY = /''/g, sY = /[a-zA-Z]/;
function V2(n, e, r) {
  var _, T, k, C, M, N, A, $;
  const o = Ux(), u = (r == null ? void 0 : r.locale) ?? o.locale ?? V7, c = (r == null ? void 0 : r.firstWeekContainsDate) ?? ((T = (_ = r == null ? void 0 : r.locale) == null ? void 0 : _.options) == null ? void 0 : T.firstWeekContainsDate) ?? o.firstWeekContainsDate ?? ((C = (k = o.locale) == null ? void 0 : k.options) == null ? void 0 : C.firstWeekContainsDate) ?? 1, f = (r == null ? void 0 : r.weekStartsOn) ?? ((N = (M = r == null ? void 0 : r.locale) == null ? void 0 : M.options) == null ? void 0 : N.weekStartsOn) ?? o.weekStartsOn ?? (($ = (A = o.locale) == null ? void 0 : A.options) == null ? void 0 : $.weekStartsOn) ?? 0, m = Fs(n, r == null ? void 0 : r.in);
  if (!c7(m))
    throw new RangeError("Invalid time value");
  let y = e.match(aY).map((I) => {
    const U = I[0];
    if (U === "p" || U === "P") {
      const B = G7[U];
      return B(I, u.formatLong);
    }
    return I;
  }).join("").match(rY).map((I) => {
    if (I === "''")
      return { isToken: !1, value: "'" };
    const U = I[0];
    if (U === "'")
      return { isToken: !1, value: lY(I) };
    if (bA[U])
      return { isToken: !0, value: I };
    if (U.match(sY))
      throw new RangeError(
        "Format string contains an unescaped latin alphabet character `" + U + "`"
      );
    return { isToken: !1, value: I };
  });
  u.localize.preprocessor && (y = u.localize.preprocessor(m, y));
  const b = {
    firstWeekContainsDate: c,
    weekStartsOn: f,
    locale: u
  };
  return y.map((I) => {
    if (!I.isToken) return I.value;
    const U = I.value;
    (!(r != null && r.useAdditionalWeekYearTokens) && eY(U) || !(r != null && r.useAdditionalDayOfYearTokens) && X7(U)) && tY(U, e, String(n));
    const B = bA[U[0]];
    return B(m, U, u.localize, b);
  }).join("");
}
function lY(n) {
  const e = n.match(iY);
  return e ? e[1].replace(oY, "'") : n;
}
const uY = {
  lessThanXSeconds: {
    one: "menos de um segundo",
    other: "menos de {{count}} segundos"
  },
  xSeconds: {
    one: "1 segundo",
    other: "{{count}} segundos"
  },
  halfAMinute: "meio minuto",
  lessThanXMinutes: {
    one: "menos de um minuto",
    other: "menos de {{count}} minutos"
  },
  xMinutes: {
    one: "1 minuto",
    other: "{{count}} minutos"
  },
  aboutXHours: {
    one: "cerca de 1 hora",
    other: "cerca de {{count}} horas"
  },
  xHours: {
    one: "1 hora",
    other: "{{count}} horas"
  },
  xDays: {
    one: "1 dia",
    other: "{{count}} dias"
  },
  aboutXWeeks: {
    one: "cerca de 1 semana",
    other: "cerca de {{count}} semanas"
  },
  xWeeks: {
    one: "1 semana",
    other: "{{count}} semanas"
  },
  aboutXMonths: {
    one: "cerca de 1 ms",
    other: "cerca de {{count}} meses"
  },
  xMonths: {
    one: "1 ms",
    other: "{{count}} meses"
  },
  aboutXYears: {
    one: "cerca de 1 ano",
    other: "cerca de {{count}} anos"
  },
  xYears: {
    one: "1 ano",
    other: "{{count}} anos"
  },
  overXYears: {
    one: "mais de 1 ano",
    other: "mais de {{count}} anos"
  },
  almostXYears: {
    one: "quase 1 ano",
    other: "quase {{count}} anos"
  }
}, cY = (n, e, r) => {
  let o;
  const u = uY[n];
  return typeof u == "string" ? o = u : e === 1 ? o = u.one : o = u.other.replace("{{count}}", String(e)), r != null && r.addSuffix ? r.comparison && r.comparison > 0 ? "em " + o : "h " + o : o;
}, dY = {
  full: "EEEE, d 'de' MMMM 'de' y",
  long: "d 'de' MMMM 'de' y",
  medium: "d MMM y",
  short: "dd/MM/yyyy"
}, fY = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
}, hY = {
  full: "{{date}} 's' {{time}}",
  long: "{{date}} 's' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
}, pY = {
  date: rm({
    formats: dY,
    defaultWidth: "full"
  }),
  time: rm({
    formats: fY,
    defaultWidth: "full"
  }),
  dateTime: rm({
    formats: hY,
    defaultWidth: "full"
  })
}, mY = {
  lastWeek: (n) => {
    const e = n.getDay();
    return "'" + (e === 0 || e === 6 ? "ltimo" : "ltima") + "' eeee 's' p";
  },
  yesterday: "'ontem s' p",
  today: "'hoje s' p",
  tomorrow: "'amanh s' p",
  nextWeek: "eeee 's' p",
  other: "P"
}, vY = (n, e, r, o) => {
  const u = mY[n];
  return typeof u == "function" ? u(e) : u;
}, gY = {
  narrow: ["AC", "DC"],
  abbreviated: ["AC", "DC"],
  wide: ["antes de cristo", "depois de cristo"]
}, yY = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["T1", "T2", "T3", "T4"],
  wide: ["1 trimestre", "2 trimestre", "3 trimestre", "4 trimestre"]
}, bY = {
  narrow: ["j", "f", "m", "a", "m", "j", "j", "a", "s", "o", "n", "d"],
  abbreviated: [
    "jan",
    "fev",
    "mar",
    "abr",
    "mai",
    "jun",
    "jul",
    "ago",
    "set",
    "out",
    "nov",
    "dez"
  ],
  wide: [
    "janeiro",
    "fevereiro",
    "maro",
    "abril",
    "maio",
    "junho",
    "julho",
    "agosto",
    "setembro",
    "outubro",
    "novembro",
    "dezembro"
  ]
}, wY = {
  narrow: ["D", "S", "T", "Q", "Q", "S", "S"],
  short: ["dom", "seg", "ter", "qua", "qui", "sex", "sab"],
  abbreviated: [
    "domingo",
    "segunda",
    "tera",
    "quarta",
    "quinta",
    "sexta",
    "sbado"
  ],
  wide: [
    "domingo",
    "segunda-feira",
    "tera-feira",
    "quarta-feira",
    "quinta-feira",
    "sexta-feira",
    "sbado"
  ]
}, xY = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mn",
    noon: "md",
    morning: "manh",
    afternoon: "tarde",
    evening: "tarde",
    night: "noite"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "meia-noite",
    noon: "meio-dia",
    morning: "manh",
    afternoon: "tarde",
    evening: "tarde",
    night: "noite"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "meia-noite",
    noon: "meio-dia",
    morning: "manh",
    afternoon: "tarde",
    evening: "tarde",
    night: "noite"
  }
}, SY = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mn",
    noon: "md",
    morning: "da manh",
    afternoon: "da tarde",
    evening: "da tarde",
    night: "da noite"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "meia-noite",
    noon: "meio-dia",
    morning: "da manh",
    afternoon: "da tarde",
    evening: "da tarde",
    night: "da noite"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "meia-noite",
    noon: "meio-dia",
    morning: "da manh",
    afternoon: "da tarde",
    evening: "da tarde",
    night: "da noite"
  }
}, _Y = (n, e) => {
  const r = Number(n);
  return (e == null ? void 0 : e.unit) === "week" ? r + "" : r + "";
}, EY = {
  ordinalNumber: _Y,
  era: Cl({
    values: gY,
    defaultWidth: "wide"
  }),
  quarter: Cl({
    values: yY,
    defaultWidth: "wide",
    argumentCallback: (n) => n - 1
  }),
  month: Cl({
    values: bY,
    defaultWidth: "wide"
  }),
  day: Cl({
    values: wY,
    defaultWidth: "wide"
  }),
  dayPeriod: Cl({
    values: xY,
    defaultWidth: "wide",
    formattingValues: SY,
    defaultFormattingWidth: "wide"
  })
}, CY = /^(\d+)[o]?/i, TY = /\d+/i, RY = {
  narrow: /^(ac|dc|a|d)/i,
  abbreviated: /^(a\.?\s?c\.?|d\.?\s?c\.?)/i,
  wide: /^(antes de cristo|depois de cristo)/i
}, kY = {
  any: [/^ac/i, /^dc/i],
  wide: [/^antes de cristo/i, /^depois de cristo/i]
}, OY = {
  narrow: /^[1234]/i,
  abbreviated: /^T[1234]/i,
  wide: /^[1234]()? trimestre/i
}, NY = {
  any: [/1/i, /2/i, /3/i, /4/i]
}, jY = {
  narrow: /^[jfmajsond]/i,
  abbreviated: /^(jan|fev|mar|abr|mai|jun|jul|ago|set|out|nov|dez)/i,
  wide: /^(janeiro|fevereiro|maro|abril|maio|junho|julho|agosto|setembro|outubro|novembro|dezembro)/i
}, AY = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^fev/i,
    /^mar/i,
    /^abr/i,
    /^mai/i,
    /^jun/i,
    /^jul/i,
    /^ago/i,
    /^set/i,
    /^out/i,
    /^nov/i,
    /^dez/i
  ]
}, DY = {
  narrow: /^(dom|[23456]?|s[a]b)/i,
  short: /^(dom|[23456]?|s[a]b)/i,
  abbreviated: /^(dom|seg|ter|qua|qui|sex|s[a]b)/i,
  wide: /^(domingo|(segunda|ter[c]a|quarta|quinta|sexta)([- ]feira)?|s[a]bado)/i
}, PY = {
  short: [/^d/i, /^2/i, /^3/i, /^4/i, /^5/i, /^6/i, /^s[a]/i],
  narrow: [/^d/i, /^2/i, /^3/i, /^4/i, /^5/i, /^6/i, /^s[a]/i],
  any: [/^d/i, /^seg/i, /^t/i, /^qua/i, /^qui/i, /^sex/i, /^s[a]b/i]
}, MY = {
  narrow: /^(a|p|mn|md|(da) (manh|tarde|noite))/i,
  any: /^([ap]\.?\s?m\.?|meia[-\s]noite|meio[-\s]dia|(da) (manh|tarde|noite))/i
}, LY = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mn|^meia[-\s]noite/i,
    noon: /^md|^meio[-\s]dia/i,
    morning: /manh/i,
    afternoon: /tarde/i,
    evening: /tarde/i,
    night: /noite/i
  }
}, IY = {
  ordinalNumber: $2({
    matchPattern: CY,
    parsePattern: TY,
    valueCallback: (n) => parseInt(n, 10)
  }),
  era: Tl({
    matchPatterns: RY,
    defaultMatchWidth: "wide",
    parsePatterns: kY,
    defaultParseWidth: "any"
  }),
  quarter: Tl({
    matchPatterns: OY,
    defaultMatchWidth: "wide",
    parsePatterns: NY,
    defaultParseWidth: "any",
    valueCallback: (n) => n + 1
  }),
  month: Tl({
    matchPatterns: jY,
    defaultMatchWidth: "wide",
    parsePatterns: AY,
    defaultParseWidth: "any"
  }),
  day: Tl({
    matchPatterns: DY,
    defaultMatchWidth: "wide",
    parsePatterns: PY,
    defaultParseWidth: "any"
  }),
  dayPeriod: Tl({
    matchPatterns: MY,
    defaultMatchWidth: "any",
    parsePatterns: LY,
    defaultParseWidth: "any"
  })
}, H2 = {
  code: "pt-BR",
  formatDistance: cY,
  formatLong: pY,
  formatRelative: vY,
  localize: EY,
  match: IY,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
}, UY = {
  pending: "bg-yellow-100 text-yellow-800",
  processing: "bg-blue-100 text-blue-800",
  completed: "bg-green-100 text-green-800",
  cancelled: "bg-red-100 text-red-800"
}, FY = {
  pending: "Pendente",
  processing: "Em Processamento",
  completed: "Concludo",
  cancelled: "Cancelado"
};
function $Y() {
  const [n, e] = D.useState(""), { data: r, isLoading: o } = kl({
    queryKey: ["admin-orders"],
    queryFn: async () => {
      const { data: c } = await wo.from("orders").select("*").order("created_at", { ascending: !1 });
      return c || [];
    }
  }), u = r == null ? void 0 : r.filter(
    (c) => c.order_number.toLowerCase().includes(n.toLowerCase()) || c.customer_email.toLowerCase().includes(n.toLowerCase())
  );
  return /* @__PURE__ */ x.jsx(Px, {
    children: /* @__PURE__ */ x.jsxs("div", {
      className: "space-y-6", children: [
    /* @__PURE__ */ x.jsxs("div", {
        children: [
      /* @__PURE__ */ x.jsx("h1", { className: "text-3xl font-bold mb-2", children: "Pedidos" }),
      /* @__PURE__ */ x.jsx("p", { className: "text-muted-foreground", children: "Gerencie todos os pedidos da loja" })
        ]
      }),
    /* @__PURE__ */ x.jsxs(Wo, {
        children: [
      /* @__PURE__ */ x.jsx(Hf, {
          children: /* @__PURE__ */ x.jsx("div", {
            className: "flex items-center gap-4", children: /* @__PURE__ */ x.jsxs("div", {
              className: "relative flex-1", children: [
        /* @__PURE__ */ x.jsx(V1, { className: "absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-muted-foreground" }),
        /* @__PURE__ */ x.jsx(
                hi,
                {
                  placeholder: "Buscar por nmero ou email...",
                  value: n,
                  onChange: (c) => e(c.target.value),
                  className: "pl-10"
                }
              )
              ]
            })
          })
        }),
      /* @__PURE__ */ x.jsx(qo, {
          children: o ? /* @__PURE__ */ x.jsx("p", { className: "text-center py-8 text-muted-foreground", children: "Carregando pedidos..." }) : u && u.length > 0 ? /* @__PURE__ */ x.jsxs(Mx, {
            children: [
        /* @__PURE__ */ x.jsx(Lx, {
              children: /* @__PURE__ */ x.jsxs(qf, {
                children: [
          /* @__PURE__ */ x.jsx(Ta, { children: "Nmero" }),
          /* @__PURE__ */ x.jsx(Ta, { children: "Cliente" }),
          /* @__PURE__ */ x.jsx(Ta, { children: "Data" }),
          /* @__PURE__ */ x.jsx(Ta, { children: "Total" }),
          /* @__PURE__ */ x.jsx(Ta, { children: "Status" }),
          /* @__PURE__ */ x.jsx(Ta, { className: "text-right", children: "Aes" })
                ]
              })
            }),
        /* @__PURE__ */ x.jsx(Ix, {
              children: u.map((c) => /* @__PURE__ */ x.jsxs(qf, {
                children: [
          /* @__PURE__ */ x.jsx(Ra, { className: "font-medium", children: c.order_number }),
          /* @__PURE__ */ x.jsx(Ra, {
                  children: /* @__PURE__ */ x.jsxs("div", {
                    children: [
            /* @__PURE__ */ x.jsx("p", { children: c.customer_name }),
            /* @__PURE__ */ x.jsx("p", { className: "text-sm text-muted-foreground", children: c.customer_email })
                    ]
                  })
                }),
          /* @__PURE__ */ x.jsx(Ra, { children: V2(new Date(c.created_at), "dd/MM/yyyy", { locale: H2 }) }),
          /* @__PURE__ */ x.jsxs(Ra, {
                  children: [
                    "R$ ",
                    Number(c.total_amount).toFixed(2)
                  ]
                }),
          /* @__PURE__ */ x.jsx(Ra, { children: /* @__PURE__ */ x.jsx(yT, { className: UY[c.status] || "", children: FY[c.status] || c.status }) }),
          /* @__PURE__ */ x.jsx(Ra, { className: "text-right", children: /* @__PURE__ */ x.jsx(Jn, { variant: "ghost", size: "sm", children: /* @__PURE__ */ x.jsx(K4, { className: "h-4 w-4" }) }) })
                ]
              }, c.id))
            })
            ]
          }) : /* @__PURE__ */ x.jsx("p", { className: "text-center py-8 text-muted-foreground", children: "Nenhum pedido encontrado" })
        })
        ]
      })
      ]
    })
  });
}
const zY = xM, BY = SM, VY = _M, W2 = D.forwardRef(({ className: n, ...e }, r) => /* @__PURE__ */ x.jsx(
  kx,
  {
    ref: r,
    className: tn(
      "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      n
    ),
    ...e
  }
));
W2.displayName = kx.displayName;
const q2 = D.forwardRef(({ className: n, children: e, ...r }, o) => /* @__PURE__ */ x.jsxs(VY, {
  children: [
  /* @__PURE__ */ x.jsx(W2, {}),
  /* @__PURE__ */ x.jsxs(
    Ox,
    {
      ref: o,
      className: tn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        n
      ),
      ...r,
      children: [
        e,
        /* @__PURE__ */ x.jsxs(EM, {
          className: "absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity data-[state=open]:bg-accent data-[state=open]:text-muted-foreground hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none", children: [
          /* @__PURE__ */ x.jsx(H1, { className: "h-4 w-4" }),
          /* @__PURE__ */ x.jsx("span", { className: "sr-only", children: "Close" })
          ]
        })
      ]
    }
  )
  ]
}));
q2.displayName = Ox.displayName;
const Y2 = ({ className: n, ...e }) => /* @__PURE__ */ x.jsx("div", { className: tn("flex flex-col space-y-1.5 text-center sm:text-left", n), ...e });
Y2.displayName = "DialogHeader";
const K2 = D.forwardRef(({ className: n, ...e }, r) => /* @__PURE__ */ x.jsx(
  Nx,
  {
    ref: r,
    className: tn("text-lg font-semibold leading-none tracking-tight", n),
    ...e
  }
));
K2.displayName = Nx.displayName;
const HY = D.forwardRef(({ className: n, ...e }, r) => /* @__PURE__ */ x.jsx(jx, { ref: r, className: tn("text-sm text-muted-foreground", n), ...e }));
HY.displayName = jx.displayName;
function WY() {
  const [n, e] = D.useState(""), [r, o] = D.useState(!1), [u, c] = D.useState({
    full_name: "",
    email: "",
    phone: "",
    address: "",
    city: "",
    state: "",
    postal_code: ""
  }), f = aT(), { data: m, isLoading: y } = kl({
    queryKey: ["admin-customers"],
    queryFn: async () => {
      const { data: C } = await wo.from("customers").select("*").order("created_at", { ascending: !1 });
      return C || [];
    }
  }), b = aj({
    mutationFn: async (C) => {
      const { error: M } = await wo.from("customers").insert([C]);
      if (M) throw M;
    },
    onSuccess: () => {
      f.invalidateQueries({ queryKey: ["admin-customers"] }), ya.success("Cliente cadastrado com sucesso!"), o(!1), c({
        full_name: "",
        email: "",
        phone: "",
        address: "",
        city: "",
        state: "",
        postal_code: ""
      });
    },
    onError: () => {
      ya.error("Erro ao cadastrar cliente");
    }
  }), _ = aj({
    mutationFn: async (C) => {
      const { error: M } = await wo.from("customers").delete().eq("id", C);
      if (M) throw M;
    },
    onSuccess: () => {
      f.invalidateQueries({ queryKey: ["admin-customers"] }), ya.success("Cliente removido com sucesso!");
    },
    onError: () => {
      ya.error("Erro ao remover cliente");
    }
  }), T = m == null ? void 0 : m.filter(
    (C) => C.full_name.toLowerCase().includes(n.toLowerCase()) || C.email.toLowerCase().includes(n.toLowerCase())
  ), k = (C) => {
    C.preventDefault(), b.mutate(u);
  };
  return /* @__PURE__ */ x.jsx(Px, {
    children: /* @__PURE__ */ x.jsxs("div", {
      className: "space-y-6", children: [
    /* @__PURE__ */ x.jsxs("div", {
        className: "flex justify-between items-center", children: [
      /* @__PURE__ */ x.jsxs("div", {
          children: [
        /* @__PURE__ */ x.jsx("h1", { className: "text-3xl font-bold mb-2", children: "Clientes" }),
        /* @__PURE__ */ x.jsx("p", { className: "text-muted-foreground", children: "Gerencie os clientes da loja" })
          ]
        }),
      /* @__PURE__ */ x.jsxs(zY, {
          open: r, onOpenChange: o, children: [
        /* @__PURE__ */ x.jsx(BY, {
            asChild: !0, children: /* @__PURE__ */ x.jsxs(Jn, {
              children: [
          /* @__PURE__ */ x.jsx(B1, { className: "mr-2 h-4 w-4" }),
                "Novo Cliente"
              ]
            })
          }),
        /* @__PURE__ */ x.jsxs(q2, {
            className: "max-w-2xl", children: [
          /* @__PURE__ */ x.jsx(Y2, { children: /* @__PURE__ */ x.jsx(K2, { children: "Cadastrar Novo Cliente" }) }),
          /* @__PURE__ */ x.jsxs("form", {
              onSubmit: k, className: "space-y-4", children: [
            /* @__PURE__ */ x.jsxs("div", {
                className: "grid grid-cols-2 gap-4", children: [
              /* @__PURE__ */ x.jsxs("div", {
                  className: "space-y-2", children: [
                /* @__PURE__ */ x.jsx(vo, { htmlFor: "full_name", children: "Nome Completo *" }),
                /* @__PURE__ */ x.jsx(
                    hi,
                    {
                      id: "full_name",
                      value: u.full_name,
                      onChange: (C) => c({ ...u, full_name: C.target.value }),
                      required: !0
                    }
                  )
                  ]
                }),
              /* @__PURE__ */ x.jsxs("div", {
                  className: "space-y-2", children: [
                /* @__PURE__ */ x.jsx(vo, { htmlFor: "email", children: "Email *" }),
                /* @__PURE__ */ x.jsx(
                    hi,
                    {
                      id: "email",
                      type: "email",
                      value: u.email,
                      onChange: (C) => c({ ...u, email: C.target.value }),
                      required: !0
                    }
                  )
                  ]
                }),
              /* @__PURE__ */ x.jsxs("div", {
                  className: "space-y-2", children: [
                /* @__PURE__ */ x.jsx(vo, { htmlFor: "phone", children: "Telefone" }),
                /* @__PURE__ */ x.jsx(
                    hi,
                    {
                      id: "phone",
                      value: u.phone,
                      onChange: (C) => c({ ...u, phone: C.target.value })
                    }
                  )
                  ]
                }),
              /* @__PURE__ */ x.jsxs("div", {
                  className: "space-y-2", children: [
                /* @__PURE__ */ x.jsx(vo, { htmlFor: "postal_code", children: "CEP" }),
                /* @__PURE__ */ x.jsx(
                    hi,
                    {
                      id: "postal_code",
                      value: u.postal_code,
                      onChange: (C) => c({ ...u, postal_code: C.target.value })
                    }
                  )
                  ]
                }),
              /* @__PURE__ */ x.jsxs("div", {
                  className: "space-y-2 col-span-2", children: [
                /* @__PURE__ */ x.jsx(vo, { htmlFor: "address", children: "Endereo" }),
                /* @__PURE__ */ x.jsx(
                    hi,
                    {
                      id: "address",
                      value: u.address,
                      onChange: (C) => c({ ...u, address: C.target.value })
                    }
                  )
                  ]
                }),
              /* @__PURE__ */ x.jsxs("div", {
                  className: "space-y-2", children: [
                /* @__PURE__ */ x.jsx(vo, { htmlFor: "city", children: "Cidade" }),
                /* @__PURE__ */ x.jsx(
                    hi,
                    {
                      id: "city",
                      value: u.city,
                      onChange: (C) => c({ ...u, city: C.target.value })
                    }
                  )
                  ]
                }),
              /* @__PURE__ */ x.jsxs("div", {
                  className: "space-y-2", children: [
                /* @__PURE__ */ x.jsx(vo, { htmlFor: "state", children: "Estado" }),
                /* @__PURE__ */ x.jsx(
                    hi,
                    {
                      id: "state",
                      value: u.state,
                      onChange: (C) => c({ ...u, state: C.target.value })
                    }
                  )
                  ]
                })
                ]
              }),
            /* @__PURE__ */ x.jsxs("div", {
                className: "flex justify-end gap-2", children: [
              /* @__PURE__ */ x.jsx(Jn, { type: "button", variant: "outline", onClick: () => o(!1), children: "Cancelar" }),
              /* @__PURE__ */ x.jsx(Jn, { type: "submit", children: "Cadastrar" })
                ]
              })
              ]
            })
            ]
          })
          ]
        })
        ]
      }),
    /* @__PURE__ */ x.jsxs(Wo, {
        children: [
      /* @__PURE__ */ x.jsx(Hf, {
          children: /* @__PURE__ */ x.jsx("div", {
            className: "flex items-center gap-4", children: /* @__PURE__ */ x.jsxs("div", {
              className: "relative flex-1", children: [
        /* @__PURE__ */ x.jsx(V1, { className: "absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-muted-foreground" }),
        /* @__PURE__ */ x.jsx(
                hi,
                {
                  placeholder: "Buscar clientes...",
                  value: n,
                  onChange: (C) => e(C.target.value),
                  className: "pl-10"
                }
              )
              ]
            })
          })
        }),
      /* @__PURE__ */ x.jsx(qo, {
          children: y ? /* @__PURE__ */ x.jsx("p", { className: "text-center py-8 text-muted-foreground", children: "Carregando clientes..." }) : T && T.length > 0 ? /* @__PURE__ */ x.jsxs(Mx, {
            children: [
        /* @__PURE__ */ x.jsx(Lx, {
              children: /* @__PURE__ */ x.jsxs(qf, {
                children: [
          /* @__PURE__ */ x.jsx(Ta, { children: "Nome" }),
          /* @__PURE__ */ x.jsx(Ta, { children: "Email" }),
          /* @__PURE__ */ x.jsx(Ta, { children: "Telefone" }),
          /* @__PURE__ */ x.jsx(Ta, { children: "Cidade" }),
          /* @__PURE__ */ x.jsx(Ta, { children: "Cadastro" }),
          /* @__PURE__ */ x.jsx(Ta, { className: "text-right", children: "Aes" })
                ]
              })
            }),
        /* @__PURE__ */ x.jsx(Ix, {
              children: T.map((C) => /* @__PURE__ */ x.jsxs(qf, {
                children: [
          /* @__PURE__ */ x.jsx(Ra, { className: "font-medium", children: C.full_name }),
          /* @__PURE__ */ x.jsx(Ra, { children: C.email }),
          /* @__PURE__ */ x.jsx(Ra, { children: C.phone || "-" }),
          /* @__PURE__ */ x.jsx(Ra, { children: C.city || "-" }),
          /* @__PURE__ */ x.jsx(Ra, { children: V2(new Date(C.created_at), "dd/MM/yyyy", { locale: H2 }) }),
          /* @__PURE__ */ x.jsx(Ra, {
                  className: "text-right", children: /* @__PURE__ */ x.jsxs("div", {
                    className: "flex justify-end gap-2", children: [
            /* @__PURE__ */ x.jsx(Jn, { variant: "ghost", size: "sm", children: /* @__PURE__ */ x.jsx(u3, { className: "h-4 w-4" }) }),
            /* @__PURE__ */ x.jsx(
                      Jn,
                      {
                        variant: "ghost",
                        size: "sm",
                        onClick: () => _.mutate(C.id),
                        children: /* @__PURE__ */ x.jsx(mD, { className: "h-4 w-4 text-destructive" })
                      }
                    )
                    ]
                  })
                })
                ]
              }, C.id))
            })
            ]
          }) : /* @__PURE__ */ x.jsx("p", { className: "text-center py-8 text-muted-foreground", children: "Nenhum cliente encontrado" })
        })
        ]
      })
      ]
    })
  });
}
const qY = () => {
  const n = ku();
  return D.useEffect(() => {
    console.error("404 Error: User attempted to access non-existent route:", n.pathname);
  }, [n.pathname]), /* @__PURE__ */ x.jsx("div", {
    className: "flex min-h-screen items-center justify-center bg-gray-100", children: /* @__PURE__ */ x.jsxs("div", {
      className: "text-center", children: [
    /* @__PURE__ */ x.jsx("h1", { className: "mb-4 text-4xl font-bold", children: "404" }),
    /* @__PURE__ */ x.jsx("p", { className: "mb-4 text-xl text-gray-600", children: "Oops! Page not found" }),
    /* @__PURE__ */ x.jsx("a", { href: "/", className: "text-blue-500 underline hover:text-blue-700", children: "Return to Home" })
      ]
    })
  });
}, Iw = ({ children: n }) => {
  const { loading: e, isAdmin: r, user: o } = kT();
  return e ? /* @__PURE__ */ x.jsx("div", { className: "min-h-screen flex items-center justify-center", children: /* @__PURE__ */ x.jsx(Ff, { className: "h-8 w-8 animate-spin text-accent" }) }) : o ? r ? /* @__PURE__ */ x.jsx(x.Fragment, { children: n }) : /* @__PURE__ */ x.jsx("div", {
    className: "min-h-screen flex items-center justify-center", children: /* @__PURE__ */ x.jsxs("div", {
      className: "text-center", children: [
    /* @__PURE__ */ x.jsx("h1", { className: "text-2xl font-bold mb-2", children: "Acesso Negado" }),
    /* @__PURE__ */ x.jsx("p", { className: "text-muted-foreground", children: "Voc no tem permisso para acessar esta rea." })
      ]
    })
  }) : /* @__PURE__ */ x.jsx(MH, { to: "/auth", replace: !0 });
}, YY = new O5(), KY = () => /* @__PURE__ */ x.jsx(P5, {
  client: YY, children: /* @__PURE__ */ x.jsxs(f5, {
    children: [
  /* @__PURE__ */ x.jsx(Y3, {}),
  /* @__PURE__ */ x.jsx(CB, {}),
  /* @__PURE__ */ x.jsx(ZH, {
      children: /* @__PURE__ */ x.jsxs(IH, {
        children: [
    /* @__PURE__ */ x.jsx(Cs, { path: "/", element: /* @__PURE__ */ x.jsx(e9, {}) }),
    /* @__PURE__ */ x.jsx(Cs, { path: "/categoria/:categoria", element: /* @__PURE__ */ x.jsx(n9, {}) }),
    /* @__PURE__ */ x.jsx(Cs, { path: "/produto/:handle", element: /* @__PURE__ */ x.jsx(a9, {}) }),
    /* @__PURE__ */ x.jsx(Cs, { path: "/sobre", element: /* @__PURE__ */ x.jsx(i9, {}) }),
    /* @__PURE__ */ x.jsx(Cs, { path: "/auth", element: /* @__PURE__ */ x.jsx(Z9, {}) }),
    /* @__PURE__ */ x.jsx(Cs, { path: "/admin", element: /* @__PURE__ */ x.jsx(Iw, { children: /* @__PURE__ */ x.jsx(e7, {}) }) }),
    /* @__PURE__ */ x.jsx(Cs, { path: "/admin/produtos", element: /* @__PURE__ */ x.jsx(Iw, { children: /* @__PURE__ */ x.jsx(r7, {}) }) }),
    /* @__PURE__ */ x.jsx(Cs, { path: "/admin/pedidos", element: /* @__PURE__ */ x.jsx(Iw, { children: /* @__PURE__ */ x.jsx($Y, {}) }) }),
    /* @__PURE__ */ x.jsx(Cs, { path: "/admin/clientes", element: /* @__PURE__ */ x.jsx(Iw, { children: /* @__PURE__ */ x.jsx(WY, {}) }) }),
    /* @__PURE__ */ x.jsx(Cs, { path: "*", element: /* @__PURE__ */ x.jsx(qY, {}) })
        ]
      })
    })
    ]
  })
});
zC(document.getElementById("root")).render(/* @__PURE__ */ x.jsx(KY, {}));
